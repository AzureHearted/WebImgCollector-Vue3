<template> <div> <teleport :to="teleport" v-if="modalEnable" > <transition @after-leave="handleClosed"> <div v-show="modalShow" ref="modalDom" class="drag-modal-container" :style="[modalSizeStyle, modalDragStyle, modalStyle]" :class="[modalClass]" > <div ref="titleDom" class="drag-modal-title" :style="[titleSizeStyle, titleStyle]" :class="[titleClass]" > <slot name="title"> 可拖拽modal </slot> </div> <div class="drag-modal-body" :style="[bodySizeStyle, bodyStyle]" :class="[bodyClass]" > <slot></slot> </div> <div class="drag-modal-footer"> <slot name="footer"> <div style=" width: 100%; display: flex; justify-content: flex-end; padding: 4px 4px 0px 4px; gap: 4px; " > <button type="button">确认</button> <button type="button" @click="$emit('update:modelValue', false)" > 关闭 </button> </div> </slot> </div> <div class="drag-modal-size-control"> <div class="drag-modal-border drag-modal-border-left" @mousedown="dragLeftBorder" ></div> <div class="drag-modal-border drag-modal-border-top" @mousedown="dragTopBorder" ></div> <div class="drag-modal-border drag-modal-border-right" @mousedown="dragRightBorder" ></div> <div class="drag-modal-border drag-modal-border-bottom" @mousedown="dragBottomBorder" ></div> <div class="drag-modal-corner drag-modal-corner-lt" @mousedown="dragLTCorner" ></div> <div class="drag-modal-corner drag-modal-corner-rt" @mousedown="dragRTCorner" ></div> <div class="drag-modal-corner drag-modal-corner-rb" @mousedown="dragRBCorner" ></div> <div class="drag-modal-corner drag-modal-corner-lb" @mousedown="dragLBCorner" ></div> </div> </div> </transition> </teleport> <teleport to="body"> <div ref="dragZoneDom" class="modal-default-drag-zone" ></div> </teleport> </div></template><script setup lang="ts"> import {StyleValue} from "vue"; import {Property} from "csstype"; interface IProps { modelValue: boolean; teleport?: string; defaultDragZoneMargin?: Property.Margin; modalInitWidth?: number; modalInitHeight?: number; modalMinWidth?: number; modalMinHeight?: number; modalZIndex?: Property.ZIndex; modalStyle?: StyleValue; modalClass?: string; modalAspectRatio?: Property.AspectRatio; modalOverflow?: Property.Overflow; modalPadding?: Property.Padding; titleStyle?: StyleValue; titleClass?: string; titleHeight?: Property.Height; titleLineHeight?: Property.LineHeight; titleMargin?: Property.Margin; titlePadding?: Property.Padding; titleTextAlign?: Property.TextAlign; bodyStyle?: StyleValue; bodyClass?: string; bodyOverflow?: Property.Overflow; } const props = withDefaults(defineProps<IProps>(), { modelValue: false, teleport: "body", defaultDragZoneMargin: "10px", modalInitWidth: 350, modalInitHeight: 250, modalMinWidth: 200, modalMinHeight: 200, modalZIndex: 2050, modalPadding: "4px", modalAspectRatio: "none", modalOverflow: "auto", bodyOverflow: "auto", modalStyle: "", titleStyle: "", titleHeight: "30px", titleTextAlign: "center", titleMargin: "2px", bodyStyle: "", }); const emits = defineEmits(["update:modelValue"]); const dragZoneDom = ref<HTMLElement>(); const modalDom = ref<HTMLElement>(); const titleDom = ref<HTMLElement>(); const window = useWindowSize(); const dragZoneBounding = useElementBounding(dragZoneDom); const modalBounding = useElementBounding(modalDom); const modalEnable = ref(false); const modalShow = ref(false); watch( () => props.modelValue, (newVal) => { if (newVal) { console.log("打开"); modalEnable.value = newVal; setTimeout(() => { modalShow.value = newVal; }); } else { console.log("关闭"); modalShow.value = newVal; } } ); function handleClosed() { modalEnable.value = false; } onMounted(() => { console.log("挂载", props.modelValue); if (props.modelValue) { emits("update:modelValue", false); setTimeout(() => { emits("update:modelValue", true); }); } }); const modalSize = ref({ width: props.modalInitWidth, height: props.modalInitHeight, }); const initPosition = ref({ x: ref((window.width.value - props.modalInitWidth) / 2), y: ref((window.height.value - props.modalInitHeight) / 2), }); const {style: modalDragStyle, position: modalPosition} = useDraggable(modalDom, { handle: titleDom, preventDefault: true, stopPropagation: true, pointerTypes: ["mouse", "touch", "pen"], initialValue: initPosition, onStart(position, event) { }, onMove(position, event) { dragZoneBounding.update(); modalBounding.update(); if (modalBounding.width.value <= dragZoneBounding.width.value) { if (position.x < dragZoneBounding.left.value) { position.x = dragZoneBounding.left.value; } if (position.x + modalBounding.width.value > dragZoneBounding.right.value) { position.x = dragZoneBounding.right.value - modalBounding.width.value; } } else { if (position.x < dragZoneBounding.left.value) { position.x = dragZoneBounding.left.value; } } if (modalBounding.height.value <= dragZoneBounding.height.value) { if (position.y < dragZoneBounding.top.value) { position.y = dragZoneBounding.top.value; } if (position.y + modalBounding.height.value > dragZoneBounding.bottom.value) { position.y = dragZoneBounding.bottom.value - modalBounding.height.value; } } else { if (position.y < dragZoneBounding.top.value) { position.y = dragZoneBounding.top.value; } } }, onEnd(position, event) { }, }); watch([dragZoneBounding.width, dragZoneBounding.height], (newVal, oldVal) => { if (modalBounding.right.value > dragZoneBounding.right.value) { let newX = dragZoneBounding.right.value - modalBounding.width.value; if (newX >= dragZoneBounding.left.value) { modalPosition.value.x = newX; } else { modalPosition.value.x = dragZoneBounding.left.value; } } if (modalBounding.bottom.value > dragZoneBounding.bottom.value) { let newY = dragZoneBounding.bottom.value - modalBounding.height.value; if (newY >= dragZoneBounding.top.value) { modalPosition.value.y = newY; } else { modalPosition.value.y = dragZoneBounding.top.value; } } }); const modalSizeStyle = computed((): StyleValue => { const {modalPadding, modalAspectRatio, modalOverflow, modalZIndex} = props; return { padding: modalPadding, aspectRatio: modalAspectRatio, overflow: modalOverflow, zIndex: modalZIndex, }; }); const titleSizeStyle = computed((): StyleValue => { const {titleHeight, titleMargin, titlePadding, titleTextAlign, titleLineHeight} = props; return { height: titleHeight, margin: titleMargin, padding: titlePadding, textAlign: titleTextAlign, lineHeight: titleLineHeight, }; }); const bodySizeStyle = computed((): StyleValue => { const {bodyOverflow} = props; return { overflow: bodyOverflow, }; }); function dragLeftBorder(e: MouseEvent) { dragZoneBounding.update(); modalBounding.update(); const startModalWidth = modalBounding.width.value; const startModalLeft = modalBounding.left.value; const {clientX: startX} = e; document.addEventListener("mousemove", handleMove); function handleMove(e: MouseEvent) { const {clientX: nowX} = e; const deltaX = nowX - startX; if ( startModalLeft + deltaX >= dragZoneBounding.left.value && startModalWidth - deltaX > props.modalMinWidth ) { modalPosition.value.x = startModalLeft + deltaX; modalSize.value.width = startModalWidth - deltaX; } } document.addEventListener("mouseup", handleDrop); function handleDrop(e: MouseEvent) { document.removeEventListener("mousemove", handleMove); document.removeEventListener("mouseup", handleDrop); } } function dragTopBorder(e: MouseEvent) { dragZoneBounding.update(); modalBounding.update(); const startModalHeight = modalBounding.height.value; const startModalTop = modalBounding.top.value; const {clientY: startY} = e; document.addEventListener("mousemove", handleMove); function handleMove(e: MouseEvent) { const {clientY: nowY} = e; const deltaY = nowY - startY; if ( startModalTop + deltaY >= dragZoneBounding.left.value && startModalHeight - deltaY > props.modalMinHeight ) { modalPosition.value.y = startModalTop + deltaY; modalSize.value.height = startModalHeight - deltaY; } } document.addEventListener("mouseup", handleDrop); function handleDrop(e: MouseEvent) { document.removeEventListener("mousemove", handleMove); document.removeEventListener("mouseup", handleDrop); } } function dragRightBorder(e: MouseEvent) { dragZoneBounding.update(); modalBounding.update(); const startModalWidth = modalBounding.width.value; const startModalRight = modalBounding.right.value; const {clientX: startX} = e; document.addEventListener("mousemove", handleMove); function handleMove(e: MouseEvent) { const {clientX: nowX} = e; const deltaX = nowX - startX; if ( startModalRight + deltaX <= dragZoneBounding.right.value && startModalWidth + deltaX > props.modalMinWidth ) { modalSize.value.width = startModalWidth + deltaX; } } document.addEventListener("mouseup", handleDrop); function handleDrop(e: MouseEvent) { document.removeEventListener("mousemove", handleMove); document.removeEventListener("mouseup", handleDrop); } } function dragBottomBorder(e: MouseEvent) { dragZoneBounding.update(); modalBounding.update(); const startModalHeight = modalBounding.height.value; const startModalBottom = modalBounding.bottom.value; const {clientY: startY} = e; document.addEventListener("mousemove", handleMove); function handleMove(e: MouseEvent) { const {clientY: nowY} = e; const deltaY = nowY - startY; if ( startModalBottom + deltaY <= dragZoneBounding.bottom.value && startModalHeight + deltaY > props.modalMinHeight ) { modalSize.value.height = startModalHeight + deltaY; } } document.addEventListener("mouseup", handleDrop); function handleDrop(e: MouseEvent) { document.removeEventListener("mousemove", handleMove); document.removeEventListener("mouseup", handleDrop); } } function dragLTCorner(e: MouseEvent) { dragZoneBounding.update(); modalBounding.update(); const startModalWidth = modalBounding.width.value; const startModalHeight = modalBounding.height.value; const startModalLeft = modalBounding.left.value; const startModalTop = modalBounding.top.value; const {clientX: startX, clientY: startY} = e; document.addEventListener("mousemove", handleMove); function handleMove(e: MouseEvent) { const {clientX: nowX, clientY: nowY} = e; const deltaX = nowX - startX; const deltaY = nowY - startY; if ( startModalLeft + deltaX >= dragZoneBounding.left.value && startModalWidth - deltaX > props.modalMinWidth ) { modalPosition.value.x = startModalLeft + deltaX; modalSize.value.width = startModalWidth - deltaX; } if ( startModalTop + deltaY >= dragZoneBounding.top.value && startModalHeight - deltaY > props.modalMinHeight ) { modalPosition.value.y = startModalTop + deltaY; modalSize.value.height = startModalHeight - deltaY; } } document.addEventListener("mouseup", handleDrop); function handleDrop(e: MouseEvent) { document.removeEventListener("mousemove", handleMove); document.removeEventListener("mouseup", handleDrop); } } function dragRTCorner(e: MouseEvent) { dragZoneBounding.update(); modalBounding.update(); const startModalWidth = modalBounding.width.value; const startModalHeight = modalBounding.height.value; const startModalRight = modalBounding.right.value; const startModalTop = modalBounding.top.value; const {clientX: startX, clientY: startY} = e; document.addEventListener("mousemove", handleMove); function handleMove(e: MouseEvent) { const {clientX: nowX, clientY: nowY} = e; const deltaX = nowX - startX; const deltaY = nowY - startY; if ( startModalRight + deltaX <= dragZoneBounding.right.value && startModalWidth + deltaX > props.modalMinWidth ) { modalSize.value.width = startModalWidth + deltaX; } if ( startModalTop + deltaY >= dragZoneBounding.top.value && startModalHeight - deltaY > props.modalMinHeight ) { modalPosition.value.y = startModalTop + deltaY; modalSize.value.height = startModalHeight - deltaY; } } document.addEventListener("mouseup", handleDrop); function handleDrop(e: MouseEvent) { document.removeEventListener("mousemove", handleMove); document.removeEventListener("mouseup", handleDrop); } } function dragRBCorner(e: MouseEvent) { dragZoneBounding.update(); modalBounding.update(); const startModalWidth = modalBounding.width.value; const startModalHeight = modalBounding.height.value; const startModalRight = modalBounding.right.value; const startModalBottom = modalBounding.bottom.value; const {clientX: startX, clientY: startY} = e; document.addEventListener("mousemove", handleMove); function handleMove(e: MouseEvent) { const {clientX: nowX, clientY: nowY} = e; const deltaX = nowX - startX; const deltaY = nowY - startY; if ( startModalRight + deltaX <= dragZoneBounding.right.value && startModalWidth + deltaX > props.modalMinWidth ) { modalSize.value.width = startModalWidth + deltaX; } if ( startModalBottom + deltaY <= dragZoneBounding.bottom.value && startModalHeight + deltaY > props.modalMinHeight ) { modalSize.value.height = startModalHeight + deltaY; } } document.addEventListener("mouseup", handleDrop); function handleDrop(e: MouseEvent) { document.removeEventListener("mousemove", handleMove); document.removeEventListener("mouseup", handleDrop); } } function dragLBCorner(e: MouseEvent) { dragZoneBounding.update(); modalBounding.update(); const startModalWidth = modalBounding.width.value; const startModalHeight = modalBounding.height.value; const startModalLeft = modalBounding.left.value; const startModalBottom = modalBounding.bottom.value; const {clientX: startX, clientY: startY} = e; document.addEventListener("mousemove", handleMove); function handleMove(e: MouseEvent) { const {clientX: nowX, clientY: nowY} = e; const deltaX = nowX - startX; const deltaY = nowY - startY; if ( startModalLeft + deltaX >= dragZoneBounding.left.value && startModalWidth - deltaX > props.modalMinWidth ) { modalPosition.value.x = startModalLeft + deltaX; modalSize.value.width = startModalWidth - deltaX; } if ( startModalBottom + deltaY <= dragZoneBounding.bottom.value && startModalHeight + deltaY > props.modalMinHeight ) { modalSize.value.height = startModalHeight + deltaY; } } document.addEventListener("mouseup", handleDrop); function handleDrop(e: MouseEvent) { document.removeEventListener("mousemove", handleMove); document.removeEventListener("mouseup", handleDrop); } }</script><style lang="scss" scoped> * { margin: 0; padding: 0; border: 0; box-sizing: border-box; } .drag-modal-container { position: fixed; width: v-bind("modalSize.width+'px'"); height: v-bind("modalSize.height+'px'"); border-radius: 6px; background-color: white; box-shadow: 0 0 5px 0 black; display: flex; flex-flow: column nowrap; align-items: stretch; justify-content: stretch; pointer-events: all; .drag-modal-title { touch-action: none; text-align: center; pointer-events: all; user-select: none; -webkit-user-drag: none; } .drag-modal-body { flex: 1; height: calc(100% - v-bind("titleHeight")) !important; position: relative; box-shadow: inset 0 0 10px 0 black; padding: 10px; border-radius: 4px; } .drag-modal-size-control { $weight: 4px; $length: 100%; user-select: none !important; -webkit-user-drag: none !important; overflow: hidden !important; .drag-modal-border { position: absolute !important; margin: auto !important; &.drag-modal-border-left { position: relative; left: 0 !important; top: 0 !important; bottom: 0 !important; width: $weight !important; height: $length !important; cursor: ew-resize !important; } &.drag-modal-border-right { right: 0 !important; top: 0 !important; bottom: 0 !important; width: $weight !important; height: $length !important; cursor: ew-resize !important; } &.drag-modal-border-top { top: 0 !important; left: 0 !important; right: 0 !important; width: $length !important; height: $weight !important; cursor: ns-resize !important; } &.drag-modal-border-bottom { bottom: 0 !important; left: 0 !important; right: 0 !important; width: $length !important; height: $weight !important; cursor: ns-resize !important; } } .drag-modal-corner { position: absolute !important; $width: calc(2 * $weight); $height: calc(2 * $weight); width: $width !important; height: $height !important; &.drag-modal-corner-lt { left: 0 !important; top: 0 !important; cursor: se-resize !important; } &.drag-modal-corner-rt { right: 0 !important; top: 0 !important; cursor: sw-resize !important; } &.drag-modal-corner-rb { right: 0 !important; bottom: 0 !important; cursor: se-resize !important; } &.drag-modal-corner-lb { left: 0 !important; bottom: 0 !important; cursor: sw-resize !important; } } } } .modal-default-drag-zone { position: fixed; margin: auto; left: 0; top: 0; right: 0; bottom: 0; margin: v-bind("defaultDragZoneMargin"); pointer-events: none; } * { &::-webkit-scrollbar { width: 10px !important; height: 10px !important; background: transparent !important; color: transparent !important; transition: all 0.5s; } &::-webkit-scrollbar-track { border-radius: 10px !important; background: transparent !important; color: transparent !important; } &::-webkit-scrollbar-thumb { background: #0d7ac39c !important; border-radius: 10px !important; } }</style><style lang="scss"> .v-enter-active, .v-leave-active { transition: 0.5s ease !important; } .v-enter-from, .v-leave-to { opacity: 0; }</style>