<template><div class="onlineGallery-toolBar"><el-space size="large" spacer="|" :wrap="true"><el-statistic class="statistic" :value="filterCards.length"><template #title><div style="display: flex; justify-content: center">选中 / 可见 / 总数</div></template><template #prefix>{{ selectedCards.length }} / </template><template #suffix>/ {{ data.cardList.length }} </template></el-statistic><div class="filter"><div class="size"><el-row :gutter="0" align="middle"><el-col :span="4">宽度</el-col><el-col :span="20"><el-sliderlabel="宽度"size="small"v-model="filter.size.width.value"range:min="0":max="filter.size.width.max"placement="bottom"></el-slider></el-col></el-row><el-row :gutter="0" align="middle"><el-col :span="4">高度</el-col><el-col :span="20"><el-sliderlabel="高度"size="small"v-model="filter.size.height.value"range:min="0":max="filter.size.height.max"placement="bottom"></el-slider></el-col></el-row></div><el-select-v2class="format"size="small"v-model="filter.formats.value"filterableclearableallow-createcollapse-tags:options="filter.formats.options":max-collapse-tags="3"placeholder="格式过滤"style="width: 240px"multiple /></div><div class="zoom-slider"><span>最大显示行数</span><el-sliderlabel="最大显示行数"v-model="info.nowColumn":min="1":max="8":step="1"size="small"placement="bottom"show-stops></el-slider></div><el-button-group><el-buttontype="primary"@click="refresh"size="small"round:loading="loading.value":icon="RefreshRight">刷新</el-button><el-buttontype="primary"@click="allSelectSwitch"size="small"round:loading="loading.value":icon="info.allSelected ? CheckboxAll : CheckboxNone">{{ info.allSelected ? "取消全选" : "选择全部" }}</el-button><el-buttontype="primary"@click="downloadSelected"size="small"round:loading="loading.value":icon="Download">下载选中项</el-button><el-dropdown size="small"><el-button type="primary" size="small" :icon="MoreFilled"></el-button><template #dropdown><el-dropdown-menu><AppRuleEditor /></el-dropdown-menu></template></el-dropdown></el-button-group></el-space></div></template><script setup>import AppSettingMenu from "./App_SettingMenu.vue";import AppRuleEditor from "./App_RuleEditor.vue";import {getBlobByUrl, getOriginByUrl, getNameByUrl, buildUUID} from "../js/public.js";import {RefreshRight, Download, MoreFilled} from "@element-plus/icons-vue"; import CheckboxNone from "/src/svg/checkbox-blank-line.svg"; import CheckboxIndeterminate from "/src/svg/checkbox-indeterminate-fill.svg"; import CheckboxAll from "/src/svg/checkbox-fill.svg"; const props = defineProps({data: Object,info: Object,loading: Object,});const filter = reactive({size: {width: {value: [350, 3840], max: 3840},height: {value: [350, 3840], max: 3840},},formats: {options: [{value: "png", label: "png"},{value: "jpg", label: "jpg"},{value: "jpeg", label: "jpeg"},{value: "gif", label: "gif"},{value: "bmp", label: "bmp"},{value: "webp", label: "webp"},{value: "svg", label: "svg"},],value: ["png", "jpg", "jpeg", "gif"],},});const filterCards = computed(() => {let regex = filter.formats.value.length? new RegExp(`\\.(${filter.formats.value.join("|")})$`): new RegExp("");const result = props.data.cardList.filter((card) =>card.width >= filter.size.width.value[0] &&card.width <= filter.size.width.value[1] &&card.height >= filter.size.height.value[0] &&card.height <= filter.size.height.value[1] &&regex.test(card.url));props.data.filterCards = result;return result;});const refresh = async () => {await getCards();};const selectedCards = computed(() => {return props.data.cardList.filter((card) => card.selected);});const allSelectSwitch = async () => {props.info.allSelected = !props.info.allSelected; props.loading.value = true;filterCards.value.forEach((card) => (card.selected = props.info.allSelected));props.loading.value = false;};const downloadSelected = async () => {const downloadCards = selectedCards.value;if (!downloadCards.length) {ElMessage({message: "请选择要下载的数据",type: "info",showClose: true,grouping: true,offset: 80,});return;}const taskQueue = new TaskQueue({showMessage: false, max: 5});props.loading.init();let finallyCount = 0;for (const card of downloadCards) {if (card.blob == null) {const task = async () => {const url = card.url;let blob = await getBlobByUrl(url, "Fetch");if (!blob) {blob = await getBlobByUrl(url, "GM");}if (!blob) {blob = await getBlobByUrl(url, "GM", location.origin);}card.blob = blob;if (card.blob != null) {return [card.name, "处理成功!"];} else {return [card.name, "处理失败"];}};taskQueue.addTask(task);}}taskQueue.singleCallback = () => {finallyCount++;props.loading.percentage = (finallyCount / downloadCards.length) * 100;};taskQueue.finallyCallback = async () => {ElMessage({message: "下载成功! (正在生成压缩包)",type: "success",showClose: true,grouping: true,offset: 80,});const zipContainer = new JSZip();for (const card of downloadCards) {if (card.name != null && card.blob != null) {zipContainer.file(card.name, card.blob);}}const zip = await zipContainer.generateAsync({type: "blob",compression: "DEFLATE",level: 9,});saveAs(zip, `${document.querySelector("title").innerText}.zip`);props.loading.percentage = 100;props.loading.reset();};taskQueue.run();};const getCards = async () => {let cardDomList = await getImgOrVideoDom(); if (!cardDomList.length) {ElMessage({message: "没有匹配到相应数据",type: "info",showClose: true,grouping: true,offset: 80,});return;}const taskQueue = new TaskQueue({showMessage: false, max: 10});props.loading.init();let finallyCount = 0;let oldUrlList = new Set(props.data.cardList.map((card) => card.url)); const taskList = cardDomList.map((dom) => {return async () => {let temp = {name: "",url: "",originUrls: [],width: 0,height: 0,aspectRatio: 0,match: false, selected: false, dom: dom,};if (dom.tagName == "META") {temp.originUrls = [getTagInfo(dom, 3, "content")].filter((url) => !isEmpty(url, true));if (temp.originUrls.length > 0) {temp.url = temp.originUrls[0];const blob = await fetch(temp.url).then((res) => res.blob()).catch((err) => {return {type: "none",};});if (/^image/.test(blob.type)) {const meta = await new Promise((resolve, reject) => {let reader = new FileReader();reader.readAsDataURL(blob);reader.onload = function (theFile) {let image = new Image();image.src = theFile.target.result;image.onload = function () {resolve({isOk: true,width: this.width,height: this.height,});};image.onerror = function () {reject({isOk: false,width: 0,height: 0,});};};});if (meta.isOk) {temp.name = getNameByUrl(temp.url);temp.width = meta.width;temp.height = meta.height;temp.aspectRatio = meta.width / meta.height;temp.match = true;}}}} else if (dom.tagName == "IMG" || dom.tagName == "VIDEO") {if (dom.naturalWidth > 0 && dom.naturalHeight > 0) {temp.originUrls = [getTagInfo(dom, 2, "srcset"),getTagInfo(dom, 2, "data-src"),getTagInfo(dom, 3, "src"),].filter((url) => !isEmpty(url, true));if (temp.originUrls.length > 0) {temp.url = temp.originUrls[0];temp.name = getNameByUrl(temp.url);temp.width = dom.naturalWidth;temp.height = dom.naturalHeight;temp.aspectRatio = dom.naturalWidth / dom.naturalHeight;temp.match = true;} else {temp.match = false;}} else {temp.originUrls = [getTagInfo(dom, 2, "srcset"),getTagInfo(dom, 2, "data-src"),getTagInfo(dom, 3, "src"),].filter((url) => !isEmpty(url, true));if (temp.originUrls.length > 0) {temp.url = temp.originUrls[0];const blob = await fetch(temp.url).then((res) => res.blob()).catch((err) => {return {type: "none",};});if (/^image/.test(blob.type)) {const meta = await new Promise((resolve, reject) => {let reader = new FileReader();reader.readAsDataURL(blob);reader.onload = function (theFile) {let image = new Image();image.src = theFile.target.result;image.onload = function () {resolve({isOk: true,width: this.width,height: this.height,});};image.onerror = function () {reject({isOk: false,width: 0,height: 0,});};};});if (meta.isOk) {temp.name = getNameByUrl(temp.url);temp.width = meta.width;temp.height = meta.height;temp.aspectRatio = meta.width / meta.height;temp.match = true;}}}}} else if (dom.tagName == "A") {temp.originUrls = [getTagInfo(dom, 3, "href")].filter((url) => !isEmpty(url, true));if (temp.originUrls.length > 0) {temp.url = temp.originUrls[0];const blob = await fetch(temp.url).then((res) => res.blob()).catch((err) => {return {type: "none",};});if (/^image/.test(blob.type)) {const meta = await new Promise((resolve, reject) => {let reader = new FileReader();reader.readAsDataURL(blob);reader.onload = function (theFile) {let image = new Image();image.src = theFile.target.result;image.onload = function () {resolve({isOk: true,width: this.width,height: this.height,});};image.onerror = function () {reject({isOk: false,width: 0,height: 0,});};};});if (meta.isOk) {temp.name = getNameByUrl(temp.url);temp.width = meta.width;temp.height = meta.height;temp.aspectRatio = meta.width / meta.height;temp.match = true;}}}}if (temp.match && !oldUrlList.has(temp.url)) {filter.size.width.max = Math.max(filter.size.width.max, temp.width);filter.size.height.max = Math.max(filter.size.height.max, temp.height);let card = temp;delete card.match; card.id = buildUUID(); props.data.cardList.push(card);return ["符合条件（添加）", card.dom];} else {return ["不符合条件（排除）"];}};});taskQueue.taskList = taskList;taskQueue.singleCallback = () => {finallyCount++;props.loading.percentage = (finallyCount / cardDomList.length) * 100;};taskQueue.finallyCallback = () => {console.log("更新成功");ElMessage({message: "数据更新成功!",type: "success",showClose: true,grouping: true,offset: 80,});props.loading.percentage = 100;props.loading.reset();};taskQueue.run();};const getImgOrVideoDom = async () => {let imgDoms = [];if (filter.formats.value.length) {const formatList = filter.formats.value;for (const format of formatList) {imgDoms.push(...Array.from(document.querySelectorAll(`meta[property="og:image"][content $= '\.${format}']`)));imgDoms.push(...Array.from(document.querySelectorAll(`img[src $= '\.${format}']`)));imgDoms.push(...Array.from(document.querySelectorAll(`[href $= '\.${format}']`)));}} else {imgDoms.push(...Array.from(document.querySelectorAll(`meta[property="og:image"][content]`)));imgDoms.push(...Array.from(document.querySelectorAll(`img[src]`)));}return imgDoms;};const getMetaInfo = async (url) => {};const getTagInfo = (domTag, type, attr) => {let attrList = [];if (/\|/.test(attr)) {attrList = attr.split("|");} else {attrList = [attr];}if (domTag == null) {return null;}let result;if (type == 1) {result = domTag.value;} else if (type == 2) {result = "";for (let i = 0; i < attrList.length; i++) {const attr = attrList[i];let temp = domTag.getAttribute(attr);if (!isEmpty(temp)) {if (attr == "srcset") {temp = getSrcsetMaximumValue(temp);}result = temp;break;}}} else if (type == 3) {result = "";for (let i = 0; i < attrList.length; i++) {const attr = attrList[i];let temp = domTag[attr];if (!isEmpty(temp)) {if (attr == "srcset") {temp = getSrcsetMaximumValue(temp);}result = temp;break;}}} else if (type == 4) {result = domTag.innerText;} else if (type == 5) {result = domTag.innerHTML;} else if (type == 6) {result = domTag.outerHTML;}if (isUrl(result)) {result = urlCompletion(result);}return String(result);};const isEmpty = (str = "", includeSpace = false) => {return includeSpace? str == null || str == undefined || str == "" || /^ +?$/.test(str): str == null || str == undefined || str == "";};const urlCompletion = (url) => {const v1 = /^\/[^\/].*$/i;const v2 = /^\/\/.*$/i;if (v1.test(url)) {return window.document.location.origin + url;}if (v2.test(url)) {return window.document.location.protocol + url;}};const isUrl = (str) => {var v = /^(\/|(.\/)).+?$/i;return v.test(str);};const getSrcsetMaximumValue = (srcsetString) => {let result = srcsetString;if (/\d+w/.test(srcsetString)) {let dataList = srcsetString.split(/\, */).filter((item) => !isEmpty(item, true)).map((item) => {const itemDataInfos = item.split(" ");if (itemDataInfos.length == 2) {return {url: itemDataInfos[0],resolution: Number(itemDataInfos[1].split(/w|W/)[0]),};} else {return {url: itemDataInfos[0],resolution: 0,};}});let maxItem = dataList[0];dataList.forEach((item) => {if (maxItem.resolution < item.resolution) {maxItem = item;}}); result = maxItem.url;}return result;};defineExpose({getCards,});</script><style lang="scss" scoped>* {font-family: win-bug-omega, system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell,"Noto Sans", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif !important;}.statistic {font-size: 14px !important;}.zoom-slider {width: 160px;font-size: 14px !important;}.filter {width: 400px;display: flex;flex-flow: row;justify-content: space-around;align-items: center;gap: 20px;.size {flex: 1 1 50%;font-size: 14px !important;}.format {flex: 1 1 50%;font-size: 14px !important;}}</style>