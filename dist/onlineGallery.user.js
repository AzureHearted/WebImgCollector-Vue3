<<<<<<< HEAD
// ==UserScript==
// @name       onlineGallery
// @namespace  npm/vite-plugin-monkey
// @version    1.0.0
// @author     Lxs
// @license    MIT
// @icon       https://vitejs.dev/logo.svg
// @match      *://www.pixiv.net/*
// @match      http*://*
// @match      http*://*/*
// @exclude    *://element-plus.org/*
// @require    https://cdn.bootcdn.net/ajax/libs/jszip/3.7.1/jszip.min.js
// @connect    *
// @grant      GM_getValue
// @grant      GM_setValue
// @grant      GM_xmlhttpRequest
// @run-at     document-start
// @noframes
// ==/UserScript==

(o=>{const e=document.createElement("style");e.dataset.source="vite-plugin-monkey",e.textContent=o,document.head.append(e)})(` @charset "UTF-8";.el-popper,.el-message,.el-notification,.is-message-box{z-index:9147483647!important}.el-checkbox__inner{z-index:0!important}.el-statistic__content{font-size:large!important}:root[data-show-scrollbar=false]{overflow:hidden}:root[data-show-scrollbar=false]>::-webkit-scrollbar{width:0px!important;height:0px!important;transition:all .5s}[class*=el-input]{border:0!important}.onlineGallery-container svg,.onlineGallery-child-window-container svg{width:auto!important;height:auto!important}:root{--f-spinner-width: 36px;--f-spinner-height: 36px;--f-spinner-color-1: rgba(0, 0, 0, .1);--f-spinner-color-2: rgba(17, 24, 28, .8);--f-spinner-stroke: 2.75}.f-spinner{margin:auto;padding:0;width:var(--f-spinner-width);height:var(--f-spinner-height)}.f-spinner svg{width:100%;height:100%;vertical-align:top;animation:f-spinner-rotate 2s linear infinite}.f-spinner svg *{stroke-width:var(--f-spinner-stroke);fill:none}.f-spinner svg *:first-child{stroke:var(--f-spinner-color-1)}.f-spinner svg *:last-child{stroke:var(--f-spinner-color-2);animation:f-spinner-dash 2s ease-in-out infinite}@keyframes f-spinner-rotate{to{transform:rotate(360deg)}}@keyframes f-spinner-dash{0%{stroke-dasharray:1,150;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-35}to{stroke-dasharray:90,150;stroke-dashoffset:-124}}.f-throwOutUp{animation:.175s ease-out both f-throwOutUp}.f-throwOutDown{animation:.175s ease-out both f-throwOutDown}@keyframes f-throwOutUp{to{transform:translate3d(0,-150px,0);opacity:0}}@keyframes f-throwOutDown{to{transform:translate3d(0,150px,0);opacity:0}}.f-zoomInUp{animation:var(--f-transition-duration, .2s) ease-out .1s both f-zoomInUp}.f-zoomOutDown{animation:var(--f-transition-duration, .2s) ease-out both f-zoomOutDown}@keyframes f-zoomInUp{0%{transform:scale(.975) translate3d(0,16px,0);opacity:0}to{transform:scale(1) translateZ(0);opacity:1}}@keyframes f-zoomOutDown{to{transform:scale(.975) translate3d(0,16px,0);opacity:0}}.f-fadeIn{animation:var(--f-transition-duration, .2s) ease both f-fadeIn;z-index:2}.f-fadeOut{animation:var(--f-transition-duration, .2s) ease both f-fadeOut;z-index:1}@keyframes f-fadeIn{0%{opacity:0}to{opacity:1}}@keyframes f-fadeOut{to{opacity:0}}.f-fadeSlowIn{animation:var(--f-transition-duration, .5s) ease both f-fadeSlowIn;z-index:2}.f-fadeSlowOut{animation:var(--f-transition-duration, .5s) ease both f-fadeSlowOut;z-index:1}@keyframes f-fadeSlowIn{0%{opacity:0}to{opacity:1}}@keyframes f-fadeSlowOut{to{opacity:0}}.f-fadeFastIn{animation:var(--f-transition-duration, .2s) ease-out both f-fadeFastIn;z-index:2}.f-fadeFastOut{animation:var(--f-transition-duration, .2s) ease-out both f-fadeFastOut;z-index:2}@keyframes f-fadeFastIn{0%{opacity:.75}to{opacity:1}}@keyframes f-fadeFastOut{to{opacity:0}}.f-crossfadeIn{animation:var(--f-transition-duration, .2s) ease-out both f-crossfadeIn;z-index:2}.f-crossfadeOut{animation:calc(var(--f-transition-duration, .2s)*.5) linear .1s both f-crossfadeOut;z-index:1}@keyframes f-crossfadeIn{0%{opacity:0}to{opacity:1}}@keyframes f-crossfadeOut{to{opacity:0}}.f-slideIn.from-next{animation:var(--f-transition-duration, .85s) cubic-bezier(.16,1,.3,1) f-slideInNext}.f-slideIn.from-prev{animation:var(--f-transition-duration, .85s) cubic-bezier(.16,1,.3,1) f-slideInPrev}.f-slideOut.to-next{animation:var(--f-transition-duration, .85s) cubic-bezier(.16,1,.3,1) f-slideOutNext}.f-slideOut.to-prev{animation:var(--f-transition-duration, .85s) cubic-bezier(.16,1,.3,1) f-slideOutPrev}@keyframes f-slideInPrev{0%{transform:translate(100%)}to{transform:translateZ(0)}}@keyframes f-slideInNext{0%{transform:translate(-100%)}to{transform:translateZ(0)}}@keyframes f-slideOutNext{to{transform:translate(-100%)}}@keyframes f-slideOutPrev{to{transform:translate(100%)}}.f-classicIn.from-next{animation:var(--f-transition-duration, .85s) cubic-bezier(.16,1,.3,1) f-classicInNext;z-index:2}.f-classicIn.from-prev{animation:var(--f-transition-duration, .85s) cubic-bezier(.16,1,.3,1) f-classicInPrev;z-index:2}.f-classicOut.to-next{animation:var(--f-transition-duration, .85s) cubic-bezier(.16,1,.3,1) f-classicOutNext;z-index:1}.f-classicOut.to-prev{animation:var(--f-transition-duration, .85s) cubic-bezier(.16,1,.3,1) f-classicOutPrev;z-index:1}@keyframes f-classicInNext{0%{transform:translate(-75px);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes f-classicInPrev{0%{transform:translate(75px);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes f-classicOutNext{to{transform:translate(-75px);opacity:0}}@keyframes f-classicOutPrev{to{transform:translate(75px);opacity:0}}:root{--f-button-width: 40px;--f-button-height: 40px;--f-button-border: 0;--f-button-border-radius: 0;--f-button-color: #374151;--f-button-bg: #f8f8f8;--f-button-hover-bg: #e0e0e0;--f-button-active-bg: #d0d0d0;--f-button-shadow: none;--f-button-transition: all .15s ease;--f-button-transform: none;--f-button-svg-width: 20px;--f-button-svg-height: 20px;--f-button-svg-stroke-width: 1.5;--f-button-svg-fill: none;--f-button-svg-filter: none;--f-button-svg-disabled-opacity: .65}.f-button{display:flex;justify-content:center;align-items:center;box-sizing:content-box;position:relative;margin:0;padding:0;width:var(--f-button-width);height:var(--f-button-height);border:var(--f-button-border);border-radius:var(--f-button-border-radius);color:var(--f-button-color);background:var(--f-button-bg);box-shadow:var(--f-button-shadow);pointer-events:all;cursor:pointer;transition:var(--f-button-transition)}@media (hover: hover){.f-button:hover:not([disabled]){color:var(--f-button-hover-color);background-color:var(--f-button-hover-bg)}}.f-button:active:not([disabled]){background-color:var(--f-button-active-bg)}.f-button:focus:not(:focus-visible){outline:none}.f-button:focus-visible{outline:none;box-shadow:inset 0 0 0 var(--f-button-outline, 2px) var(--f-button-outline-color, var(--f-button-color))}.f-button svg{width:var(--f-button-svg-width);height:var(--f-button-svg-height);fill:var(--f-button-svg-fill);stroke:currentColor;stroke-width:var(--f-button-svg-stroke-width);stroke-linecap:round;stroke-linejoin:round;transition:opacity .15s ease;transform:var(--f-button-transform);filter:var(--f-button-svg-filter);pointer-events:none}.f-button[disabled]{cursor:default}.f-button[disabled] svg{opacity:var(--f-button-svg-disabled-opacity)}.f-carousel__nav .f-button.is-prev,.f-carousel__nav .f-button.is-next,.fancybox__nav .f-button.is-prev,.fancybox__nav .f-button.is-next{position:absolute;z-index:1}.is-horizontal .f-carousel__nav .f-button.is-prev,.is-horizontal .f-carousel__nav .f-button.is-next,.is-horizontal .fancybox__nav .f-button.is-prev,.is-horizontal .fancybox__nav .f-button.is-next{top:50%;transform:translateY(-50%)}.is-horizontal .f-carousel__nav .f-button.is-prev,.is-horizontal .fancybox__nav .f-button.is-prev{left:var(--f-button-prev-pos)}.is-horizontal .f-carousel__nav .f-button.is-next,.is-horizontal .fancybox__nav .f-button.is-next{right:var(--f-button-next-pos)}.is-horizontal.is-rtl .f-carousel__nav .f-button.is-prev,.is-horizontal.is-rtl .fancybox__nav .f-button.is-prev{left:auto;right:var(--f-button-next-pos)}.is-horizontal.is-rtl .f-carousel__nav .f-button.is-next,.is-horizontal.is-rtl .fancybox__nav .f-button.is-next{right:auto;left:var(--f-button-prev-pos)}.is-vertical .f-carousel__nav .f-button.is-prev,.is-vertical .f-carousel__nav .f-button.is-next,.is-vertical .fancybox__nav .f-button.is-prev,.is-vertical .fancybox__nav .f-button.is-next{top:auto;left:50%;transform:translate(-50%)}.is-vertical .f-carousel__nav .f-button.is-prev,.is-vertical .fancybox__nav .f-button.is-prev{top:var(--f-button-next-pos)}.is-vertical .f-carousel__nav .f-button.is-next,.is-vertical .fancybox__nav .f-button.is-next{bottom:var(--f-button-next-pos)}.is-vertical .f-carousel__nav .f-button.is-prev svg,.is-vertical .f-carousel__nav .f-button.is-next svg,.is-vertical .fancybox__nav .f-button.is-prev svg,.is-vertical .fancybox__nav .f-button.is-next svg{transform:rotate(90deg)}html.with-fancybox{width:auto;overflow:visible;scroll-behavior:auto}html.with-fancybox body{touch-action:none}html.with-fancybox body.hide-scrollbar{width:auto;margin-right:calc(var(--fancybox-body-margin, 0px) + var(--fancybox-scrollbar-compensate, 0px));overflow:hidden!important;overscroll-behavior-y:none}.fancybox__container{--fancybox-color: #dbdbdb;--fancybox-hover-color: #fff;--fancybox-bg: rgba(24, 24, 27, .98);--fancybox-slide-gap: 10px;--f-spinner-width: 50px;--f-spinner-height: 50px;--f-spinner-color-1: rgba(255, 255, 255, .1);--f-spinner-color-2: #bbb;--f-spinner-stroke: 3.65;position:fixed;top:0;left:0;bottom:0;right:0;direction:ltr;display:flex;flex-direction:column;box-sizing:border-box;margin:0;padding:0;color:#f8f8f8;-webkit-tap-highlight-color:rgba(0,0,0,0);overflow:visible;z-index:1050;outline:none;transform-origin:top left;-webkit-text-size-adjust:100%;-moz-text-size-adjust:none;-ms-text-size-adjust:100%;text-size-adjust:100%;overscroll-behavior-y:contain}.fancybox__container *,.fancybox__container *:before,.fancybox__container *:after{box-sizing:inherit}.fancybox__backdrop{position:fixed;top:0;left:0;bottom:0;right:0;z-index:-1;background:var(--fancybox-bg);opacity:var(--fancybox-opacity, 1);will-change:opacity}.fancybox__carousel{position:relative;box-sizing:border-box;flex:1;min-height:0;z-index:10;overflow-y:visible;overflow-x:clip}.fancybox__viewport{width:100%;height:100%}.fancybox__track{display:flex;margin:0 auto;height:100%}.fancybox__slide{flex:0 0 auto;position:relative;display:flex;flex-direction:column;align-items:center;width:100%;height:100%;margin:0 var(--fancybox-slide-gap) 0 0;padding:4px;overflow:auto;transform:translateZ(0);backface-visibility:hidden}.fancybox__container:not(.is-compact) .fancybox__slide.has-close-btn{padding-top:40px}.fancybox__slide.has-iframe,.fancybox__slide.has-video,.fancybox__slide.has-html5video,.fancybox__slide.has-image{overflow:hidden}.fancybox__slide.has-image.is-animating,.fancybox__slide.has-image.is-selected{overflow:visible}.fancybox__slide:before,.fancybox__slide:after{content:"";flex:0 0 0;margin:auto}.fancybox__content{align-self:center;display:flex;flex-direction:column;position:relative;margin:0;padding:2rem;max-width:100%;color:var(--fancybox-content-color, #374151);background:var(--fancybox-content-bg, #fff);cursor:default;border-radius:0;z-index:20}.is-loading .fancybox__content{opacity:0}.is-draggable .fancybox__content{cursor:move;cursor:grab}.can-zoom_in .fancybox__content{cursor:zoom-in}.can-zoom_out .fancybox__content{cursor:zoom-out}.is-dragging .fancybox__content{cursor:move;cursor:grabbing}.fancybox__content [data-selectable],.fancybox__content [contenteditable]{cursor:auto}.fancybox__slide.has-image>.fancybox__content{padding:0;background:rgba(0,0,0,0);min-height:1px;background-repeat:no-repeat;background-size:contain;background-position:center center;transition:none;transform:translateZ(0);backface-visibility:hidden}.fancybox__slide.has-image>.fancybox__content>picture>img{width:100%;height:auto;max-height:100%}.is-zooming-in .fancybox__viewport:not(.is-dragging) .fancybox__slide:not(.is-selected) .fancybox__content,.is-zooming-out .fancybox__slide:not(.is-selected) .fancybox__content{visibility:hidden}.is-animating .fancybox__content,.is-dragging .fancybox__content{filter:blur(0px);will-change:transform,width,height}.fancybox-image{margin:auto;display:block;width:100%;height:100%;min-height:0;object-fit:contain;-webkit-user-select:none;user-select:none}.fancybox__caption{align-self:center;max-width:100%;flex-shrink:0;margin:0;padding:14px 0 4px;overflow-wrap:anywhere;line-height:1.375;color:var(--fancybox-color, currentColor);opacity:var(--fancybox-opacity, 1);cursor:auto;visibility:visible}.is-loading .fancybox__caption,.is-closing .fancybox__caption{opacity:0;visibility:hidden}.is-compact .fancybox__caption{padding-bottom:0}.f-button.is-close-btn{--f-button-svg-stroke-width: 2;position:absolute;top:0;right:8px;z-index:40}.fancybox__content>.f-button.is-close-btn{--f-button-width: 34px;--f-button-height: 34px;--f-button-border-radius: 4px;--f-button-color: var(--fancybox-color, #fff);--f-button-hover-color: var(--fancybox-color, #fff);--f-button-bg: transparent;--f-button-hover-bg: transparent;--f-button-active-bg: transparent;--f-button-svg-width: 22px;--f-button-svg-height: 22px;position:absolute;top:-38px;right:0;opacity:.75}.is-loading .fancybox__content>.f-button.is-close-btn{visibility:hidden}.is-zooming-out .fancybox__content>.f-button.is-close-btn{visibility:hidden}.fancybox__content>.f-button.is-close-btn:hover{opacity:1}.fancybox__footer{padding:0;margin:0;position:relative}.fancybox__footer .fancybox__caption{width:100%;padding:24px;opacity:var(--fancybox-opacity, 1);transition:all .25s ease}.is-compact .fancybox__footer{position:absolute;bottom:0;left:0;right:0;z-index:20;background:rgba(24,24,27,.5)}.is-compact .fancybox__footer .fancybox__caption{padding:12px}.is-compact .fancybox__content>.f-button.is-close-btn{--f-button-border-radius: 50%;--f-button-color: #fff;--f-button-hover-color: #fff;--f-button-outline-color: #000;--f-button-bg: rgba(0, 0, 0, .6);--f-button-active-bg: rgba(0, 0, 0, .6);--f-button-hover-bg: rgba(0, 0, 0, .6);--f-button-svg-width: 18px;--f-button-svg-height: 18px;--f-button-svg-filter: none;top:5px;right:5px}.fancybox__nav{--f-button-width: 50px;--f-button-height: 50px;--f-button-border: 0;--f-button-border-radius: 50%;--f-button-color: var(--fancybox-color);--f-button-hover-color: var(--fancybox-hover-color);--f-button-bg: transparent;--f-button-hover-bg: rgba(24, 24, 27, .3);--f-button-active-bg: rgba(24, 24, 27, .5);--f-button-shadow: none;--f-button-transition: all .15s ease;--f-button-transform: none;--f-button-svg-width: 26px;--f-button-svg-height: 26px;--f-button-svg-stroke-width: 2.5;--f-button-svg-fill: none;--f-button-svg-filter: drop-shadow(1px 1px 1px rgba(24, 24, 27, .5));--f-button-svg-disabled-opacity: .65;--f-button-next-pos: 1rem;--f-button-prev-pos: 1rem;opacity:var(--fancybox-opacity, 1)}.fancybox__nav .f-button:before{position:absolute;content:"";top:-30px;right:-20px;left:-20px;bottom:-30px;z-index:1}.is-idle .fancybox__nav{animation:.15s ease-out both f-fadeOut}.is-idle.is-compact .fancybox__footer{pointer-events:none;animation:.15s ease-out both f-fadeOut}.fancybox__slide>.f-spinner{position:absolute;top:50%;left:50%;margin:var(--f-spinner-top, calc(var(--f-spinner-width) * -.5)) 0 0 var(--f-spinner-left, calc(var(--f-spinner-height) * -.5));z-index:30;cursor:pointer}.fancybox-protected{position:absolute;top:0;left:0;right:0;bottom:0;z-index:40;-webkit-user-select:none;user-select:none}.fancybox-ghost{position:absolute;top:0;left:0;width:100%;height:100%;min-height:0;object-fit:contain;z-index:40;-webkit-user-select:none;user-select:none;pointer-events:none}.fancybox-focus-guard{outline:none;opacity:0;position:fixed;pointer-events:none}.fancybox__container:not([aria-hidden]){opacity:0}.fancybox__container.is-animated[aria-hidden=false]>*:not(.fancybox__backdrop,.fancybox__carousel),.fancybox__container.is-animated[aria-hidden=false] .fancybox__carousel>*:not(.fancybox__viewport),.fancybox__container.is-animated[aria-hidden=false] .fancybox__slide>*:not(.fancybox__content){animation:.25s ease .1s backwards f-fadeIn}.fancybox__container.is-animated[aria-hidden=false] .fancybox__backdrop{animation:.35s ease backwards f-fadeIn}.fancybox__container.is-animated[aria-hidden=true]>*:not(.fancybox__backdrop,.fancybox__carousel),.fancybox__container.is-animated[aria-hidden=true] .fancybox__carousel>*:not(.fancybox__viewport),.fancybox__container.is-animated[aria-hidden=true] .fancybox__slide>*:not(.fancybox__content){animation:.15s ease forwards f-fadeOut}.fancybox__container.is-animated[aria-hidden=true] .fancybox__backdrop{animation:.35s ease forwards f-fadeOut}.has-iframe .fancybox__content,.has-map .fancybox__content,.has-pdf .fancybox__content,.has-youtube .fancybox__content,.has-vimeo .fancybox__content,.has-html5video .fancybox__content{max-width:100%;flex-shrink:1;min-height:1px;overflow:visible}.has-iframe .fancybox__content,.has-map .fancybox__content,.has-pdf .fancybox__content{width:100%;height:100%}.fancybox__container:not(.is-compact) .has-iframe .fancybox__content,.fancybox__container:not(.is-compact) .has-map .fancybox__content,.fancybox__container:not(.is-compact) .has-pdf .fancybox__content{width:calc(100% - 120px);height:90%}.has-youtube .fancybox__content,.has-vimeo .fancybox__content,.has-html5video .fancybox__content{width:960px;height:540px;max-width:100%;max-height:100%}.has-map .fancybox__content,.has-pdf .fancybox__content,.has-youtube .fancybox__content,.has-vimeo .fancybox__content,.has-html5video .fancybox__content{padding:0;background:rgba(24,24,27,.9);color:#fff}.has-map .fancybox__content{background:#e5e3df}.fancybox__html5video,.fancybox__iframe{border:0;display:block;height:100%;width:100%;background:rgba(0,0,0,0)}.fancybox-placeholder{border:0!important;clip:rect(1px,1px,1px,1px)!important;-webkit-clip-path:inset(50%)!important;clip-path:inset(50%)!important;height:1px!important;margin:-1px!important;overflow:hidden!important;padding:0!important;position:absolute!important;width:1px!important;white-space:nowrap!important}.f-carousel__thumbs{--f-thumb-width: 96px;--f-thumb-height: 72px;--f-thumb-outline: 0;--f-thumb-outline-color: #5eb0ef;--f-thumb-opacity: 1;--f-thumb-hover-opacity: 1;--f-thumb-selected-opacity: 1;--f-thumb-border-radius: 2px;--f-thumb-offset: 0px;--f-button-next-pos: 0;--f-button-prev-pos: 0}.f-carousel__thumbs.is-classic{--f-thumb-gap: 8px;--f-thumb-opacity: .5;--f-thumb-hover-opacity: 1;--f-thumb-selected-opacity: 1}.f-carousel__thumbs.is-modern{--f-thumb-gap: 4px;--f-thumb-extra-gap: 20px;--f-thumb-clip-width: 46px}.f-thumbs{position:relative;flex:0 0 auto;margin:0;overflow:hidden;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;user-select:none;perspective:1000px;transform:translateZ(0)}.f-thumbs .f-spinner{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:2px;background-image:linear-gradient(#ebeff2,#e2e8f0);z-index:-1}.f-thumbs .f-spinner svg{display:none}.f-thumbs.is-vertical{height:100%}.f-thumbs__viewport{width:100%;height:auto;overflow:hidden}.f-thumbs__track{display:flex;will-change:transform}.f-thumbs__slide{position:relative;flex:0 0 auto;box-sizing:content-box;display:flex;align-items:center;justify-content:center;padding:0;margin:0;width:var(--f-thumb-width);min-width:var(--f-thumb-width);height:var(--f-thumb-height);overflow:visible;cursor:pointer}.f-thumbs__slide.is-loading img{opacity:0}.is-classic .f-thumbs__viewport{height:100%}.is-modern .f-thumbs__track{width:max-content}.is-modern .f-thumbs__track:before{content:"";position:absolute;top:0;bottom:0;left:calc(var(--left, 0)*1px);width:calc(100% - var(--width, 0)*1px);cursor:pointer}.is-modern .f-thumbs__slide{--clip-path: inset( 0 calc( (var(--f-thumb-width, 0) - var(--f-thumb-clip-width, 0)) * .5 * (1 - var(--progress, 0)) ) round var(--f-thumb-border-radius, 0) );transform:translate3d(calc(var(--shift, 0) * -1px),0,0);transition:none;pointer-events:none}.is-modern .f-thumbs__slide:focus-within:not(.is-selected){filter:drop-shadow(-1px 0px 0px var(--f-thumb-outline-color)) drop-shadow(2px 0px 0px var(--f-thumb-outline-color)) drop-shadow(0px -1px 0px var(--f-thumb-outline-color)) drop-shadow(0px 2px 0px var(--f-thumb-outline-color))}.is-modern .f-thumbs__slide>*{clip-path:var(--clip-path)}.is-modern.in-touch .f-thumbs__slide{filter:none}.is-modern.is-resting .f-thumbs__slide{transition:all .33s ease}.is-modern.is-resting .f-thumbs__slide>*{transition:all .33s ease}.f-thumbs__slide__button{-webkit-appearance:none;-moz-appearance:none;appearance:none;width:100%;height:100%;margin:0;padding:0;border:0;position:relative;border-radius:var(--f-thumb-border-radius);overflow:hidden;background:rgba(0,0,0,0);outline:none;cursor:pointer;pointer-events:auto;touch-action:manipulation;opacity:var(--f-thumb-opacity);transition:opacity .2s ease}.f-thumbs__slide__button:hover{opacity:var(--f-thumb-hover-opacity)}.f-thumbs__slide__button:focus:not(:focus-visible){outline:none}.f-thumbs__slide__button:focus-visible{outline:none;opacity:var(--f-thumb-selected-opacity)}.is-nav-selected .f-thumbs__slide__button{opacity:var(--f-thumb-selected-opacity)}.is-nav-selected .f-thumbs__slide__button:after{content:"";position:absolute;top:0;left:0;right:0;height:auto;bottom:0;border:var(--f-thumb-outline, 0) solid var(--f-thumb-outline-color, transparent);border-radius:var(--f-thumb-border-radius);animation:f-fadeIn .2s ease-out;z-index:10}.f-thumbs__slide__img{position:absolute;overflow:hidden;top:0;right:0;bottom:0;left:0;width:100%;height:100%;padding:var(--f-thumb-offset);box-sizing:border-box;pointer-events:none;object-fit:cover}.f-thumbs.is-horizontal .f-thumbs__track{margin:0 auto;padding:8px 0 12px}.f-thumbs.is-horizontal .f-thumbs__slide{margin:0 var(--f-thumb-gap) 0 0}.f-thumbs.is-vertical .f-thumbs__track{flex-wrap:wrap;margin:auto 0;padding:0 8px}.f-thumbs.is-vertical .f-thumbs__slide{margin:0 0 var(--f-thumb-gap) 0}.fancybox__thumbs{--f-thumb-width: 96px;--f-thumb-height: 72px;--f-thumb-border-radius: 2px;--f-thumb-outline: 2px;--f-thumb-outline-color: #ededed;position:relative;opacity:var(--fancybox-opacity, 1);transition:max-height .35s cubic-bezier(.23,1,.32,1)}.fancybox__thumbs.is-classic{--f-thumb-gap: 8px;--f-thumb-opacity: .5;--f-thumb-hover-opacity: 1}.fancybox__thumbs.is-classic .f-spinner{background-image:linear-gradient(rgba(255,255,255,.1),rgba(255,255,255,.05))}.fancybox__thumbs.is-modern{--f-thumb-gap: 4px;--f-thumb-extra-gap: 20px;--f-thumb-clip-width: 46px;--f-thumb-opacity: 1;--f-thumb-hover-opacity: 1}.fancybox__thumbs.is-modern .f-spinner{background-image:linear-gradient(rgba(255,255,255,.1),rgba(255,255,255,.05))}.fancybox__thumbs.is-horizontal{padding:0 var(--f-thumb-gap)}.fancybox__thumbs.is-vertical{padding:var(--f-thumb-gap) 0}.is-compact .fancybox__thumbs{--f-thumb-width: 64px;--f-thumb-clip-width: 32px;--f-thumb-height: 48px;--f-thumb-extra-gap: 10px}.fancybox__thumbs.is-masked{max-height:0px!important}.is-closing .fancybox__thumbs{transition:none!important}.fancybox__toolbar{--f-progress-color: var(--fancybox-color, rgba(255, 255, 255, .94));--f-button-width: 46px;--f-button-height: 46px;--f-button-color: var(--fancybox-color);--f-button-hover-color: var(--fancybox-hover-color);--f-button-bg: rgba(24, 24, 27, .65);--f-button-hover-bg: rgba(70, 70, 73, .65);--f-button-active-bg: rgba(90, 90, 93, .65);--f-button-border-radius: 0;--f-button-svg-width: 24px;--f-button-svg-height: 24px;--f-button-svg-stroke-width: 1.5;--f-button-svg-filter: drop-shadow(1px 1px 1px rgba(24, 24, 27, .15));--f-button-svg-fill: none;--f-button-svg-disabled-opacity: .65;display:flex;flex-direction:row;justify-content:space-between;margin:0;padding:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI Adjusted,Segoe UI,Liberation Sans,sans-serif;color:var(--fancybox-color, currentColor);opacity:var(--fancybox-opacity, 1);text-shadow:var(--fancybox-toolbar-text-shadow, 1px 1px 1px rgba(0, 0, 0, .5));pointer-events:none;z-index:20}.fancybox__toolbar :focus-visible{z-index:1}.fancybox__toolbar.is-absolute,.is-compact .fancybox__toolbar{position:absolute;top:0;left:0;right:0}.is-idle .fancybox__toolbar{pointer-events:none;animation:.15s ease-out both f-fadeOut}.fancybox__toolbar__column{display:flex;flex-direction:row;flex-wrap:wrap;align-content:flex-start}.fancybox__toolbar__column.is-left,.fancybox__toolbar__column.is-right{flex-grow:1;flex-basis:0}.fancybox__toolbar__column.is-right{display:flex;justify-content:flex-end;flex-wrap:nowrap}.fancybox__infobar{padding:0 5px;line-height:var(--f-button-height);text-align:center;font-size:17px;font-variant-numeric:tabular-nums;-webkit-font-smoothing:subpixel-antialiased;cursor:default;-webkit-user-select:none;user-select:none}.fancybox__infobar span{padding:0 5px}.fancybox__infobar:not(:first-child):not(:last-child){background:var(--f-button-bg)}[data-fancybox-toggle-slideshow]{position:relative}[data-fancybox-toggle-slideshow] .f-progress{height:100%;opacity:.3}[data-fancybox-toggle-slideshow] svg g:first-child{display:flex}[data-fancybox-toggle-slideshow] svg g:last-child{display:none}.has-slideshow [data-fancybox-toggle-slideshow] svg g:first-child{display:none}.has-slideshow [data-fancybox-toggle-slideshow] svg g:last-child{display:flex}[data-fancybox-toggle-fullscreen] svg g:first-child{display:flex}[data-fancybox-toggle-fullscreen] svg g:last-child{display:none}:fullscreen [data-fancybox-toggle-fullscreen] svg g:first-child{display:none}:fullscreen [data-fancybox-toggle-fullscreen] svg g:last-child{display:flex}.f-progress{position:absolute;top:0;left:0;right:0;height:3px;transform:scaleX(0);transform-origin:0;transition-property:transform;transition-timing-function:linear;background:var(--f-progress-color, var(--f-carousel-theme-color, #0091ff));z-index:30;-webkit-user-select:none;user-select:none;pointer-events:none}.var--box,.var--box *{box-sizing:border-box}.var--relative{position:relative}.var--absolute{position:absolute}.var--hidden{overflow:hidden}.var--lock{overflow:hidden!important}.var--block{display:block}.var--ellipsis{overflow-x:hidden;text-overflow:ellipsis;white-space:nowrap}.var--inline-block{display:inline-block}.var--flex{display:flex}.var--inline-flex{display:inline-flex}:root{--font-size-xs: 10px;--font-size-sm: 12px;--font-size-md: 14px;--font-size-lg: 16px;--icon-size-xs: 16px;--icon-size-sm: 18px;--icon-size-md: 20px;--icon-size-lg: 22px;--color-body: #fff;--color-text: #333;--color-primary: #3a7afe;--color-info: #00afef;--color-success: #00c48f;--color-warning: #ff9f00;--color-danger: #f44336;--color-disabled: #e0e0e0;--color-text-disabled: #aaa;--opacity-disabled: .6;--cubic-bezier: cubic-bezier(.25, .8, .5, 1);--shadow-key-umbra-opacity: rgba(0, 0, 0, .2);--shadow-key-penumbra-opacity: rgba(0, 0, 0, .14);--shadow-key-ambient-opacity: rgba(0, 0, 0, .12)}.var-elevation--0{box-shadow:0 0 0 0 var(--shadow-key-umbra-opacity),0 0 0 0 var(--shadow-key-penumbra-opacity),0 0 0 0 var(--shadow-key-ambient-opacity)}.var-elevation--1{box-shadow:0 2px 1px -1px var(--shadow-key-umbra-opacity),0 1px 1px 0 var(--shadow-key-penumbra-opacity),0 1px 3px 0 var(--shadow-key-ambient-opacity)}.var-elevation--2{box-shadow:0 3px 1px -2px var(--shadow-key-umbra-opacity),0 2px 2px 0 var(--shadow-key-penumbra-opacity),0 1px 5px 0 var(--shadow-key-ambient-opacity)}.var-elevation--3{box-shadow:0 3px 3px -2px var(--shadow-key-umbra-opacity),0 3px 4px 0 var(--shadow-key-penumbra-opacity),0 1px 8px 0 var(--shadow-key-ambient-opacity)}.var-elevation--4{box-shadow:0 2px 4px -1px var(--shadow-key-umbra-opacity),0 4px 5px 0 var(--shadow-key-penumbra-opacity),0 1px 10px 0 var(--shadow-key-ambient-opacity)}.var-elevation--5{box-shadow:0 3px 5px -1px var(--shadow-key-umbra-opacity),0 5px 8px 0 var(--shadow-key-penumbra-opacity),0 1px 14px 0 var(--shadow-key-ambient-opacity)}.var-elevation--6{box-shadow:0 3px 5px -1px var(--shadow-key-umbra-opacity),0 6px 10px 0 var(--shadow-key-penumbra-opacity),0 1px 18px 0 var(--shadow-key-ambient-opacity)}.var-elevation--7{box-shadow:0 4px 5px -2px var(--shadow-key-umbra-opacity),0 7px 10px 1px var(--shadow-key-penumbra-opacity),0 2px 16px 1px var(--shadow-key-ambient-opacity)}.var-elevation--8{box-shadow:0 5px 5px -3px var(--shadow-key-umbra-opacity),0 8px 10px 1px var(--shadow-key-penumbra-opacity),0 3px 14px 2px var(--shadow-key-ambient-opacity)}.var-elevation--9{box-shadow:0 5px 6px -3px var(--shadow-key-umbra-opacity),0 9px 12px 1px var(--shadow-key-penumbra-opacity),0 3px 16px 2px var(--shadow-key-ambient-opacity)}.var-elevation--10{box-shadow:0 6px 6px -3px var(--shadow-key-umbra-opacity),0 10px 14px 1px var(--shadow-key-penumbra-opacity),0 4px 18px 3px var(--shadow-key-ambient-opacity)}.var-elevation--11{box-shadow:0 6px 7px -4px var(--shadow-key-umbra-opacity),0 11px 15px 1px var(--shadow-key-penumbra-opacity),0 4px 20px 3px var(--shadow-key-ambient-opacity)}.var-elevation--12{box-shadow:0 7px 8px -4px var(--shadow-key-umbra-opacity),0 12px 17px 2px var(--shadow-key-penumbra-opacity),0 5px 22px 4px var(--shadow-key-ambient-opacity)}.var-elevation--13{box-shadow:0 7px 8px -4px var(--shadow-key-umbra-opacity),0 13px 19px 2px var(--shadow-key-penumbra-opacity),0 5px 24px 4px var(--shadow-key-ambient-opacity)}.var-elevation--14{box-shadow:0 7px 9px -4px var(--shadow-key-umbra-opacity),0 14px 21px 2px var(--shadow-key-penumbra-opacity),0 5px 26px 4px var(--shadow-key-ambient-opacity)}.var-elevation--15{box-shadow:0 8px 9px -5px var(--shadow-key-umbra-opacity),0 15px 22px 2px var(--shadow-key-penumbra-opacity),0 6px 28px 5px var(--shadow-key-ambient-opacity)}.var-elevation--16{box-shadow:0 8px 10px -5px var(--shadow-key-umbra-opacity),0 16px 24px 2px var(--shadow-key-penumbra-opacity),0 6px 30px 5px var(--shadow-key-ambient-opacity)}.var-elevation--17{box-shadow:0 8px 11px -5px var(--shadow-key-umbra-opacity),0 17px 26px 2px var(--shadow-key-penumbra-opacity),0 6px 32px 5px var(--shadow-key-ambient-opacity)}.var-elevation--18{box-shadow:0 9px 11px -5px var(--shadow-key-umbra-opacity),0 18px 28px 2px var(--shadow-key-penumbra-opacity),0 7px 34px 6px var(--shadow-key-ambient-opacity)}.var-elevation--19{box-shadow:0 9px 12px -6px var(--shadow-key-umbra-opacity),0 19px 29px 2px var(--shadow-key-penumbra-opacity),0 7px 36px 6px var(--shadow-key-ambient-opacity)}.var-elevation--20{box-shadow:0 10px 13px -6px var(--shadow-key-umbra-opacity),0 20px 31px 3px var(--shadow-key-penumbra-opacity),0 8px 38px 7px var(--shadow-key-ambient-opacity)}.var-elevation--21{box-shadow:0 10px 13px -6px var(--shadow-key-umbra-opacity),0 21px 33px 3px var(--shadow-key-penumbra-opacity),0 8px 40px 7px var(--shadow-key-ambient-opacity)}.var-elevation--22{box-shadow:0 10px 14px -6px var(--shadow-key-umbra-opacity),0 22px 35px 3px var(--shadow-key-penumbra-opacity),0 8px 42px 7px var(--shadow-key-ambient-opacity)}.var-elevation--23{box-shadow:0 11px 14px -7px var(--shadow-key-umbra-opacity),0 23px 36px 3px var(--shadow-key-penumbra-opacity),0 9px 44px 8px var(--shadow-key-ambient-opacity)}.var-elevation--24{box-shadow:0 11px 15px -7px var(--shadow-key-umbra-opacity),0 24px 38px 3px var(--shadow-key-penumbra-opacity),0 9px 46px 8px var(--shadow-key-ambient-opacity)}:root{--ripple-cubic-bezier: cubic-bezier(.68, .01, .62, .6);--ripple-color: currentColor}.var-ripple{position:absolute;transition:transform .2s var(--ripple-cubic-bezier),opacity .14s linear;top:0;left:0;border-radius:50%;opacity:0;will-change:transform,opacity;pointer-events:none;z-index:100;background-color:var(--ripple-color)}@font-face{font-family:varlet-icons;src:url(data:font/truetype;charset=utf-8;base64,AAEAAAALAIAAAwAwR1NVQiCLJXoAAAE4AAAAVE9TLzI/skzlAAABjAAAAFZjbWFw3xlfhgAAA8gAAAhKZ2x5ZmCMs/EAAA0IAAAzkGhlYWRhIEB+AAAA4AAAADZoaGVhA8QCOQAAALwAAAAkaG10ePAAAAAAAAHkAAAB5GxvY2HiUO8MAAAMFAAAAPRtYXhwAZIAfgAAARgAAAAgbmFtZQyVRWAAAECYAAACRnBvc3SAvcdqAABC4AAAB00AAQAAAcD/wAAAAgAAAP//AgEAAQAAAAAAAAAAAAAAAAAAAHkAAQAAAAEAAJJH3PZfDzz1AAsCAAAAAAAAAAAAAAAAAAAAAAAAAP/AAgEBwQAAAAgAAgAAAAAAAAABAAAAeQByAA8AAAAAAAIAAAAKAAoAAAD/AAAAAAAAAAEAAAAKADAAPgACREZMVAAObGF0bgAaAAQAAAAAAAAAAQAAAAQAAAAAAAAAAQAAAAFsaWdhAAgAAAABAAAAAQAEAAQAAAABAAgAAQAGAAAAAQAAAAEB/AGQAAUAAAFEAWYAAABHAUQBZgAAAPUAGQCEAAACAAUDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBmRWQAQPAA8RkBwP/AAC4BwQBAAAAAAQAAAAAAAAAAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAAAAAAFAAAAAwAAACwAAAAEAAACmgABAAAAAAGUAAMAAQAAACwAAwAKAAACmgAEAWgAAAAaABAAAwAK8AnwGfAp8DnwSfBZ8GnwefCJ8JnxCfEZ//8AAPAA8BDwIPAw8EDwUPBg8HDwgPCQ8QDxEP//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAGgAsAD4AUABiAHQAhgCYAKoAvADOAOAAAAABAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAAAAQYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAFsAAAAAAAAAB4AADwAAAA8AAAAAABAADwAQAA8AEAAAACAADwAgAA8AIAAAADAADwAwAA8AMAAAAEAADwBAAA8AQAAAAFAADwBQAA8AUAAAAGAADwBgAA8AYAAAAHAADwBwAA8AcAAAAIAADwCAAA8AgAAAAJAADwCQAA8AkAAAAKAADwEAAA8BAAAAALAADwEQAA8BEAAAAMAADwEgAA8BIAAAANAADwEwAA8BMAAAAOAADwFAAA8BQAAAAPAADwFQAA8BUAAAAQAADwFgAA8BYAAAARAADwFwAA8BcAAAASAADwGAAA8BgAAAATAADwGQAA8BkAAAAUAADwIAAA8CAAAAAVAADwIQAA8CEAAAAWAADwIgAA8CIAAAAXAADwIwAA8CMAAAAYAADwJAAA8CQAAAAZAADwJQAA8CUAAAAaAADwJgAA8CYAAAAbAADwJwAA8CcAAAAcAADwKAAA8CgAAAAdAADwKQAA8CkAAAAeAADwMAAA8DAAAAAfAADwMQAA8DEAAAAgAADwMgAA8DIAAAAhAADwMwAA8DMAAAAiAADwNAAA8DQAAAAjAADwNQAA8DUAAAAkAADwNgAA8DYAAAAlAADwNwAA8DcAAAAmAADwOAAA8DgAAAAnAADwOQAA8DkAAAAoAADwQAAA8EAAAAApAADwQQAA8EEAAAAqAADwQgAA8EIAAAArAADwQwAA8EMAAAAsAADwRAAA8EQAAAAtAADwRQAA8EUAAAAuAADwRgAA8EYAAAAvAADwRwAA8EcAAAAwAADwSAAA8EgAAAAxAADwSQAA8EkAAAAyAADwUAAA8FAAAAAzAADwUQAA8FEAAAA0AADwUgAA8FIAAAA1AADwUwAA8FMAAAA2AADwVAAA8FQAAAA3AADwVQAA8FUAAAA4AADwVgAA8FYAAAA5AADwVwAA8FcAAAA6AADwWAAA8FgAAAA7AADwWQAA8FkAAAA8AADwYAAA8GAAAAA9AADwYQAA8GEAAAA+AADwYgAA8GIAAAA/AADwYwAA8GMAAABAAADwZAAA8GQAAABBAADwZQAA8GUAAABCAADwZgAA8GYAAABDAADwZwAA8GcAAABEAADwaAAA8GgAAABFAADwaQAA8GkAAABGAADwcAAA8HAAAABHAADwcQAA8HEAAABIAADwcgAA8HIAAABJAADwcwAA8HMAAABKAADwdAAA8HQAAABLAADwdQAA8HUAAABMAADwdgAA8HYAAABNAADwdwAA8HcAAABOAADweAAA8HgAAABPAADweQAA8HkAAABQAADwgAAA8IAAAABRAADwgQAA8IEAAABSAADwggAA8IIAAABTAADwgwAA8IMAAABUAADwhAAA8IQAAABVAADwhQAA8IUAAABWAADwhgAA8IYAAABXAADwhwAA8IcAAABYAADwiAAA8IgAAABZAADwiQAA8IkAAABaAADwkAAA8JAAAABbAADwkQAA8JEAAABcAADwkgAA8JIAAABdAADwkwAA8JMAAABeAADwlAAA8JQAAABfAADwlQAA8JUAAABgAADwlgAA8JYAAABhAADwlwAA8JcAAABiAADwmAAA8JgAAABjAADwmQAA8JkAAABkAADxAAAA8QAAAABlAADxAQAA8QEAAABmAADxAgAA8QIAAABnAADxAwAA8QMAAABoAADxBAAA8QQAAABpAADxBQAA8QUAAABqAADxBgAA8QYAAABrAADxBwAA8QcAAABsAADxCAAA8QgAAABtAADxCQAA8QkAAABuAADxEAAA8RAAAABvAADxEQAA8REAAABwAADxEgAA8RIAAABxAADxEwAA8RMAAAByAADxFAAA8RQAAABzAADxFQAA8RUAAAB0AADxFgAA8RYAAAB1AADxFwAA8RcAAAB2AADxGAAA8RgAAAB3AADxGQAA8RkAAAB4AAAAAAAAACgAYACIAMQA3AD8ASQBWgGAAaoBzgISAkYCdgKkAuQDFgNOA24DoAO4A9gEAAQuBGwEwATiBQoFOAVaBYQFxAYcBpAHPgeWB/4IPgiKCNIJIglUCZ4JxAnwChoKTgpiCoIKtAsCCzQLcgucC9IL8AwiDGAMuAzkDR4NMA1MDWANbg1+DZANog2yDb4Nyg3YDeQN+g4QDnIOjA6wDtwPCg8+D4wPyhAgEK4RNhGsEeYSGBKOEr4S1BMGEzQTqBPcFAYUYhSgFMIVIBVCFXAV+BZUFpgW5Bc0F4wXphfMF+4YHBiSGMYY/hk2GWIZmhnIAAIAAP/qAdYBlgAFABYAADcnNxc3FyciDgIUHgIyPgI0LgLVah5Moh6VKk88ICA8T1RPPCAgPE9Vax5Moh+AIDxPVE88ICA8T1RPPCAAAAAAAwAA/+oB1gGWAAwAGQAfAAABIg4BFB4BMj4BNC4BAyIuATQ+ATIeARQOARMHJwcXNwEAOmI5OWJ0Yjk5YjouTy4uT1xPLi5PNI03HlWrAZU5YnRiOTlidGI5/oAuT1xPLi5PXE8uAQmMNx5WqwAAAAMAAP/qAdYBlgADAAcAGAAAASM1MxUjNTMnIg4CFB4CMj4CNC4CARUqKioqFSpPPCAgPE9UTzwgIDxPAQAr1oDAIDxPVE88ICA8T1RPPCAABAAA/+oB1gGWAAMAEAAhACUAABMzNSMTIi4BND4BMh4BFA4BAyIOAhQeAjI+AjQuAgMzNSPrKioVLk8uLk9cTy4uTy4qTzwgIDxPVE88ICA8Tz8qKgEAK/7qLk9cTy4uT1xPLgGAIDxPVE88ICA8T1RPPCD+wIAAAwAAAAAB6wGWAAMABwAKAAAlIzUzFSM1MwUhAwEVKioqKv8AAdbrlWvAK2sBlQAABAAAAAAB6wGWAAIABQAJAA0AAAEDIQMTITcVMzUHFTM1AQDrAdbrof6+jCoqKgGV/msBQP7rwFZWgCsrAAAAAAMAAP/qAdYBlgADAAcAGAAAJSM1MxUjNTMDIg4CFB4CMj4CNC4CARUqKioqFSpPPCAgPE9UTzwgIDxPq4DWKwEVIDxPVE88ICA8T1RPPCAABAAA/+oB1gGWAAMABwAUACEAADczFSM1MxUjNyIOARQeATI+ATQuAQMiLgE0PgEyHgEUDgHrKioqKhU6Yjk5YnRiOTliOi5PLi5PXE8uLk+AK9aA6jlidGI5OWJ0Yjn+gC5PXE8uLk9cTy4AAgAAAAABwQGBAAUAFQAANyc3FzcXNSEiBhURFBYzITI2NRE0JtVqHkyiHv7WEhkZEgEqEhkZVWseTKIfaxkS/tYSGRkSASoSGQAAAAIAAAAAAcABgQASABgAACUhETM1IyIGFREUFjMhMjY9ASMnBxc3JwcBlf7W1dUSGRkSASoSGSvsHmDVHrcrASorGRL+1hIZGRKqFB5g1R63AAAAAAIAAAAAAcEBgQAPABMAAAEhIgYVERQWMyEyNjURNCYHESERAZX+1hIZGRIBKhIZGRL+1gGAGRL+1hIZGRIBKhIZK/7WASoAAAMAAP/qAdYBlgAMAB0AKgAAJSIuATQ+ATIeARQOAQMiDgIUHgIyPgI0LgIHIg4BFB4BMj4BNC4BAQAuTy4uT1xPLi5PLipPPCAgPE9UTzwgIDxPKh0xHR0xOjEdHTEVLk9cTy4uT1xPLgGAIDxPVE88ICA8T1RPPCBqHTE6MR0dMToxHQAAAAACAAD/6gHWAZYAGQAfAAAlFA4BIi4BND4BMzIXNyYjIg4BFB4BMj4BNSUHFzcnBwGrLk9cTy4uTy4YFyEmKjpiOTlidGI5/tQeYNUet8AuTy4uT1xPLgciDzlidGI5OWI6KR5g1R63AAIAAP/qAdYBlgAMAB0AACUiLgE0PgEyHgEUDgEDIg4CFB4CMj4CNC4CAQAuTy4uT1xPLi5PLipPPCAgPE9UTzwgIDxPFS5PXE8uLk9cTy4BgCA8T1RPPCAgPE9UTzwgAAIAAP/qAdYBlgAMABgAAAEyHgEUDgEiLgE0PgEXBycHFwcXNxc3JzcBADpiOTlidGI5OWKHTU0eTU0eTU0eTU0BlTlidGI5OWJ0YjlqTU0eTU0eTU0eTU0AAAAAAwAA/+oB1gGWAAwAGQAlAAAlIi4BND4BMh4BFA4BAyIOARQeATI+ATQuAQ8BJwcXBxc3FzcnNwEALk8uLk9cTy4uTy46Yjk5YnRiOTliAzc3Hjc3Hjc3Hjc3FS5PXE8uLk9cTy4BgDlidGI5OWJ0YjmANzceNzceNzceNzcAAAACAAAAAAHAAYEAEAAcAAABKwEiBhURFBYzITI2NRE0JgMnByc3JzcXNxcHFwGVOfESGRkSASoSGRlaTU0eTU0eTU0eTU0BgBkS/tYSGRkSASoSGf7VTU0eTU0eTU0eTU0AAAAAAwAAAAABwAGBAA8AEwAfAAABISIGFREUFjMhMjY1ETQmAyERIQ8BFwcnByc3JzcXNwGV/tYSGRkSASoSGRkS/tYBKipNTR5NTR5NTR5NTQGAGRL+1hIZGRIBKhIZ/qsBKkhNTR5NTR5NTR5NTQAAAAIAAP/qAdYBlgADABAAACUjNTMnIg4BFB4BMj4BNC4BAWvW1ms6Yjk5YnRiOTliqyrAOWJ0Yjk5YnRiOQAAAAADAAD/6gHWAZYADAAZAB0AACUiLgE0PgEyHgEUDgEDIg4BFB4BMj4BNC4BBzM1IwEALk8uLk9cTy4uTy46Yjk5YnRiOTlipdbWFS5PXE8uLk9cTy4BgDlidGI5OWJ0YjnqKgAAAQAAAAAB1gGWAAkAACUXJzcvAQ8BFwcBAIQjdJk8PJl0I1BQlmUNjY0NZZYAAAAAAgAAAAAB1gGWAAUADwAAJTUfAQcXNy8BDwEXBzcXJwEAJF5HFYWZPDyZdCOEhCN3x1YIPlu0DY2NDWWWUFCWAAIAAAAAAdYBlgAJABMAACUHNyc/AR8BBxc3LwEPARcHNxcnAQBQFUdeJCReRxWFmTw8mXQjhIQjeDFcPQhWVgg9XLQNjY0NZZZQUJYAAAAAAQAA//gB1gGBABsAAAUnJicmJyY1ND4BMzIWFz4BMzIeARUUBwYHBgcBAB9FGysUFx82IBwyEhIyHCA2HxcUKxtFBxw+HCwiJycgNh8YFBQYHzYgJyciLBw+AAACAAD/+AHWAYEACgAmAAABIgYHFTY3NjU0JicyHgEVFAcGBwYPAScmJyYnJjU0PgEzMhYXPgEBYBgpClAdKSsgIDYfFxQrG0UfH0UbKxQXHzYgHDISEjIBVRoV4EgjMiggKisfNiAnJyIsHD4cHD4cLCInJyA2HxgUFBgAAgAA//gB1gGBABoANgAAJQcnJicmJyY1NDYzMhYXMz4BMzIWFRQHBgcGEyIGBy4BIyIOARUUFxYXFh8BNzY3Njc2NTQuAQECAgJAGSgTFSsgGSsIKAgrGSArFRMoGR4cMhISMhwgNh8XFCsbRR8fRRsrFBcfNjQCAjoZKB0hHiAqHBYWHCogHiEdKBkBEhgUFBgfNiAnJyIsHD4cHD4cLCInJyA2HwAAAgAAAAABlgGAAAcAEQAAASMnIwcjFSEBFBY7ATI2NREhAZVKFmoWSgEq/usZEqoSGf8AAWsVFSv+6xIZGRIBAAAAAAADAAAAAAGrAYAAEQAVABkAABMVIxUzERQWOwEyNjURMzUjNQczFSM3MxUjwGsWGRHWERkWa4ArK1UrKwGAFSv+6xIZGRIBFSsVa8DAwAAAAAQAAAAAAasBgAARABUAGQAdAAATFSMVMxEUFjsBMjY1ETM1IzUHMxEjNxUzNTMVMzXAaxYZEdYRGRZrq9bWKysqKwGAFSv+6xIZGRIBFSsVQP7r6sDAwMAAAAAAAgAAAAABwAGBAAMAEwAAJSM1MzchIgYVERQWMyEyNjURNCYBa9bWKv7WEhkZEgEqEhkZqyqrGRL+1hIZGRIBKhIZAAADAAAAAAHBAYEAAwATABcAACURIREBMhYVERQGIyEiJjURNDYzBRUjNQGV/tYBKhIZGRL+1hIZGRIBANYrASr+1gFVGRL+1hIZGRIBKhIZqyoqAAADAAD/6gHWAZYAEAAZACYAACUiJic0NzY3NjIXFhcWFQ4BAzIWFAYiJjQ2NyIOARQeATI+ATQuAQEAJ0QVGBQgHS4dIBQYFUQnGyUlNiUlGzpiOTlidGI5OWImJSATEQ4ICAgIDhETICUBLyU1JiY1JUA5YnRiOTlidGI5AAAAAAUAAP/qAdYBlgAMABQAJgAvADgAAAEiDgEUHgEyPgE0LgEDPgEyFhcGIjcmJyYiBwYHJjU0PgEyHgEVFCciBhQWMjY0JgciJjQ2MhYUBgEAOmI5OWJ0Yjk5YqMHQz5DBy52wxUvJT4lLxUjLk9cTy6rHywsPiwsHw0TExoTEwGVOWJ0Yjk5YnRiOf6lDhgYDiVEGQ4LCw4ZLjkuTy4uTy45uSw+Kys+LGsTGxISGxMAAgAA/+oB0QGWAAgATAAAJSImNDYyFhQGNzY0Jzc+AS8BLgEPASYvATQmKwEiBhUHBgcnJgYPAQYWHwEGFBcHDgEfAR4BPwEWHwEUFjsBMjY1NzY3FxY2PwE2JicBAB8sLD4sLIABAS0DAQIrAQgENRISCAYEVgQGCBISNQQIASsCAQMtAQEtAwECKwEIBDUSEggGBFYEBggTETUECAErAgEDdSw+LCw+LDYMEgwjAwcESgMDAhUOBzgEBQUEOAcOFQIDA0oEBwMjDBIMIwMHBEoDAwIVDgc4BAUFBDgIDRUCAwNKBAcDAAQAAP/qAdEBlgAIABEAUwBxAAABMhYUBiImNDYXIgYUFjI2NCYDIiY1JyYnBwYmLwEmNj8BJzcnLgE/AT4BHwE2PwE0NjsBMhYVFxYXNzYWHwEWBg8BFwcXHgEPAQ4BLwEGDwEUBiMDBwYHJwcXBhcHFzcWHwEzNzY3FzcnNic3JwcmLwEBACMyMkYyMiMSGRkkGRk9BAYIEhI1BAgBKwIBAy0BAS0DAQIrAQgENRISCAYEVgQGCBISNQQIASsCAQMtAQEtAwECKwEIBDUSEggGBDsIJxozEC0NDS0QNBomCCAIJho0EC0NDS0QMxonCAEVMkYyMkYyKhkkGRkkGf8ABQQ4Bw4VAgMDSgQHAyMVFSMDBwRKAwMCFQ4HOAQFBQQ4Bw4VAgMDSgQHAyMVFSMDBwRKAwMCFQ4HOAQFAYA4CB4WHCEmJiIbFh4IODgIHhYbIScmIRwWHgg4AAMAAP/VAasBlgATABwAOAAAATIeARQHBgcGDwEnJicmJyY0PgEXIgYUFjI2NCYTFA4BIi4BNTQ2NxcOARUUHgEyPgE1NCYnNx4BAQAjOyIUEBwUGBQUGBQcEBQiOyMSGRkkGRmZLk9cTy4kHw0RFCI7RjsiFBENHyQBlSI6Qy0jKR4dFxcdHikjLUM6IlUZIxkZIxn+6xgnFxcnGBQjDBMHFAsOGQ4OGQ4LFAcTDCMABAAA/9UBqwGWAA0AIQAqAEQAAAEyFhUUBwYHJicmNTQ2NyIOARUUFxYXMTc2NzY3NjU0LgEHIgYUFjI2NCYTFA4BIi4BNTQ2NxcGFRQeATI+ATU0JzceAQEAIzIbFyMkFhsyIyM6I0AgIBQYFBwQFCM6IxIZGSQZGZkuT1xPLiMfDSQiO0Y7IiYMISQBazIkHzMqLC8oMx4kMioiOyM8XS8iFx0eKSMsICM7IlUZIxkZIxn+6xcoFxcoFxQjDRMSFQ4ZDg4ZDhUSEw0jAAAAAAMAAAAAAdYBlgATACAAKQAAEzM3MxczMhYVERQGIyEiJjURNDYXIg4BFB4BMj4BNC4BBzIWFAYiJjQ2VUArgCtAERkZEf6qERkZvB0xHR0xOjEdHTEdGyUlNiUlAWsqKhkS/wASGRkSAQASGUAdMToxHR0xOjEdKyU2JSU2JQAABAAAAAAB1gGWABMAGwAoADEAAAEjJyMHIyIGFREUFjMhMjY1ETQmAyERMzczFzMHIg4BFB4BMj4BNC4BByImNDYyFhQGAatEJ4AnRBEZGREBVhEZGRH+qlcnWidXqx0xHR0xOjEdHTEdGyUlNiUlAWsqKhkS/wASGRkSAQASGf7VAQArKxUdMToxHR0xOjEdqyU2JSU2JQADAAD/6gHBAZYACAAmAC8AACUiBhQWMjY0JgEVMxcHBhUUFjMhNSMiJjQ/ATMyNj8BNjU0JiMhJxMiBhQWMjY0JgFrEhkZIxkZ/pkrTR0FGREBAPcCAwETnwwUBUwDDQj+xBQ6ERkZIxkZQBkjGRkjGQFVKqI1CQsSGSsDBAEjDAqKBgQJDSr+qxkjGRkjGQAEAAD/6gHBAZYACAAmAC8AMwAAJTIWFAYiJjQ2ATMXITIWFRQPAQ4BKwEPARQWOwEVISImNTQ/AScjEzIWFAYiJjQ2PwEhFwFrERkZIxkZ/rxGFAE8CA0DTAUUDJ8TAQMC9/8AERkFHU0rgBIZGSMZGdE8/vIyQBkjGRkjGQFVKg0JBAaKCgwjAwIDKxkSCwk1ov7VGSMZGSMZlWtrAAAAAQAAAAABwQGBACAAADceARc3NhcWMzIWHQEUBiMiJyYnJjU0NjsBMhYVFBcWB40XSS0vCQ0kKAgNDQhjVFIwMg0ISwkMDAQJ2i1JFy8JBAwMCUsIDTIwUlRjCA0NCCgkDQkAAAMAAAAAAcABgQAiACgALgAAJSInIyIPAS4BJzc+AScmNTQmKwEiBhUUFxYXFjMyNj0BNCYlMxYXByYBJic3FjMBqyojBwgGLy5JFi8FAgMLDQhLCA0xMFNUYwgNDf64IAIIGQ4BJyYrGiIVdQ0GLxhJLC8EDAUnJggNDQhjVFMwMQ0ISwgN4BcgGiv+/AMOGQgAAAACAAAAAAHAAYEABAAUAAA3FzcXIQURNCYjISIGFREUFjMhMja1Nkpg/tYBVRkS/tYSGRkSASoSGaBAYIAVASoSGRkS/tYSGRkAAAAAAwAAAAABwAGBAAMAEwAYAAAlIREhNSEiBhURFBYzITI2NRE0Jg8BJwczAZX+1gEq/tYSGRkSASoSGRl9Oyo66isBKisZEv7WEhkZEgEqEhnGTDNMAAAAAAIAAP/VAcABlgATABkAACUVITU3NTQ2NzU0NjIWHQEeAR0BBxQGIiY1AcD+gCs7LxkkGS87ahkkGSsWFiqAMk8OBxEZGREHDk8ygFUSGRkSAAAAAAMAAP/qAasBlgAHABsAIgAAJSM1NDYyFhUXNTQmJzU0JiIGHQEOAR0BBxUhNQcyNjUjFBYBVcA4UDgrPC8SGxMuPCsBa7YSGVUZVYsoODgodXUxSwsODhISDg4LSzF1KxUVVRkRERkAAQAAAAAB1gGAAAoAADc1MxUzNTMnBzMV1VZqQNXVQBWAgKvAwKsAAAIAAAAAAdYBgAAIABMAAAEXFSM1IxUjNTcHMxUzNTMVMzUzAQBrK4Ara9VAgCqAQAFHYKeAgKeZwKuAgKsAAAACAAD/6gGWAZYACAAcAAAlIiY0NjIWFAYnIg4BFBcWFxYfATc2NzY3NjQuAQEAFh8fLB8fFilEKBcTIBgcFxccGCATFyhEyx8sHx8sH8ooRE81KTEiIxsbIyIxKTRQRCgAAAAAAwAA/+oBlgGWAAgAHQAxAAABMhYUBiImNDY3Mh4BFRQHBgcGBzEnJicmJyY0PgEXIg4BFRQXFhcWFzY3Njc2NTQuAQEAFh8fLB8fFilEKCYcLBYRFxwYIBMXKEQpHTEdBAcVGjExGhUHBB0xATUfLB8fLB9gKEQpMkgzOR0SGyMiMSk0UEQoKh0xHREOGyUvQUEvJRsOER0xHQAAAgAA/+oB1gGWABUAIQAAEzIeARUUBxczFwcnNScGIyIuATQ+ARcVIxUzFTM1MzUjNcApRCgdEQyAKoASJzIpRCgoRBRAQCpAQAGVKEQpMicSgCqADBEdKERSRChAQCpAQCpAAAMAAAAAAbYBgAAUAB0AKQAAJRcHJzUnBiMiLgE0PgEyHgEVFAcXIzI2NCYiBhQWNyMVIzUjNTM1MxUzAUtqIGoGJzMmQCUlQEtAJSEGbyg4OFA4OF0rFSsrFSuVaiBqEQYhJUBLQCUlQCYzJwY4UDg4UDhWKysVKysAAAACAAD/6gHWAZYAFQAZAAATMh4BFRQHFzMXByc1JwYjIi4BND4BBxUzNcApRCgdEQyAKoASJzIpRCgoRCyqAZUoRCkyJxKAKoAMER0oRFJEKIAqKgADAAAAAAG2AYAAFAAdACEAACUjJzY1NC4BIg4BFB4BMzI3FxUXNyciJjQ2MhYUBiczFSMBSxEGISVAS0AlJUAmMycGaiDqKDg4UDg4XmtrlQYnMyZAJSVAS0AlIQYRaiBqOFA4OFA4axUAAAACAAD/6gHWAZYAAgAPAAA3NRcnIg4BFB4BMj4BNC4B1YBVOmI5OWJ0Yjk5YmDAYNU5YnRiOTlidGI5AAADAAD/6gHWAZYADAAZABwAACUiLgE0PgEyHgEUDgEDIg4BFB4BMj4BNC4BAzcnAQAuTy4uT1xPLi5PLjpiOTlidGI5OWJlgIAVLk9cTy4uT1xPLgGAOWJ0Yjk5YnRiOf7LYGAAAwAA/+oB1gGWABcAGwAoAAAlBwYHBhUjNTQ/ATY0JiIGFSM0NjIWFRQHIzUzAyIOARQeATI+ATQuAQFBEw0FByoZGg0ZJBkqMkYyQCoqFTpiOTlidGI5OWLQFA0LDhYLIxkbDCQZGRIjMjIjHLkqAUA5YnRiOTlidGI5AAQAAP/qAdYBlgADABAAHQA5AAA3MzUjEyIOARQeATI+ATQuAQMiLgE0PgEyHgEUDgEDIgYVMzQ2MhYVFAcGBwYHBhUzNDc+ATc2NTQm6yoqFTpiOTlidGI5OWI6Lk8uLk9cTy4uTy4jMioZJBkIBQ4SBwwqCgYgBgoyQCsBKjlidGI5OWJ0Yjn+gC5PXE8uLk9cTy4BKzIjERkZEQ0KBgoOCxEaEA0IHAkOEyMyAAAAAgAA/+oB1gGWAAsAHAAAJSMVIzUjNTM1MxUzJyIOAhQeAjI+AjQuAgFrVipWVipWaypPPCAgPE9UTzwgIDxPq1ZWKlZWwCA8T1RPPCAgPE9UTzwgAAAAAAMAAP/qAdYBlgAMABkAJQAAJSIuATQ+ATIeARQOAQMiDgEUHgEyPgE0LgEHIxUjFTMVMzUzNSMBAC5PLi5PXE8uLk8uOmI5OWJ0Yjk5YiUqVlYqVlYVLk9cTy4uT1xPLgGAOWJ0Yjk5YnRiOWpWKlZWKgAAAQAAAAABwAFJAAUAAAkBJzcXNwHA/wB1HlfiASv/AHUeV+IAAQAAAAABlgFWAA8AACUXFSMnByM1Nyc1Mxc3MxUBH3YfdnYfdnYfdnYfwHYfdnYfdnYfdnYfAAABAAAAAAGWAVYACwAAJSMVIzUjNTM1MxUzAZWAKoCAKoCrgIAqgIAAAQAAAAABlgDWAAMAACUhNSEBlf7WASqrKgAAAAEAAAAAAYABFgAFAAA/ARc3JweeYmIegIB3YmIegIAAAQAAAAABgAEJAAUAABMXNxcHJ55iYh6AgAEJYmIegIAAAAAAAQAAAAABSQFAAAUAACUnNycHFwFJYmIegIBeYmIegIAAAAAAAQAAAAABVgFAAAUAAD8BJzcXB7diYh6AgF5iYh6AgAABAAAAAAFrAOsAAgAAPwEXlWtrgGtrAAABAAAAAAFrAOsAAgAANxc3lWtr62trAAABAAAAAAErASsAAgAAAQcXAStrawEra2sAAAAAAQAAAAABQAErAAIAAD8BJ9Vra1VrawAAAgAAAAABlgGAAAYACgAANzUjNxcjFQc1IRXAVZWVVdUBKmuAlZWAVisrAAACAAAAAAGWAYAAAwAKAAA3ITUhJSM1IxUjF2sBKv7WASpVgFWVFSvAgICVAAkAAAAAAcABawADAAcACwAPAB8AIwAzADcARwAAJTUhFSU1IRU1ITUhIxUzNSM0NjsBMhYdARQGKwEiJjUXFTM1IzQ2OwEyFh0BFAYrASImNRcVMzUjNDY7ATIWHQEUBisBIiY1AcD+6wEV/usBFf7rVitADQgrCQwMCSsIDRUrQA0IKwkMDAkrCA0VK0ANCCsJDAwJKwgNKyoqgCoqgCoqKgkNDQkqCQ0NCVYqKgkNDQkqCQ0NCVYqKgkNDQkqCQ0NCQADAAAAAAHAAUAAAwAHAAsAABMhFSEVIRUhFSEVIUABgP6AAYD+gAGA/oABQCtAKkArAAAABAAAAAABwAFAAAUACQANABEAACUHJzcXByUhFSEVNTMVBzUhFQHAHmtrHkz+zAEV/uvV1QEVcx5rax5NgCtqKiprKysAAAAAAwAAAAABKwFrAAgAEQAaAAAlMhYUBiImNDY3MhYUBiImNDY3MhYUBiImNDYBABIZGSQZGRISGRkkGRkSEhkZJBkZaxkkGRkkGYAZJBkZJBmAGSQZGSQZAAQAAP/qAdYBlgANABIAFgAaAAABMhYVERQGIyEHETQ2MxURNyERBSEVIRUzFSMBqxEZGRH+1VUZERkBPf7VAQD/AMDAAZUZEf8AEhlVAYARGSr+5xkBAEArKyoABQAA/+oB1gGWAA0AEgAWABoAHgAAASEiBhURNyEyNjURNCYDIQcRIQcjNTMHIzUzByM1MwGr/qoRGVUBKxEZGRH+xBoBVkArK1YqKlUrKwGVGRH+gFUZEgEAERn+1hoBGpYrKysrKwAJAAD/4QHrAbUAAwAIABUAGQAdACEAJQApAC0AADcXNycXMjM1IxMiDgEUHgEyPgE0LgEXMzUjBxc3JxMnBxcnIxUzByMVMzcnBxdMHiYeeRUVKhUjOyIiO0Y7IiI7iEBAOyYeJiYeJh55KirAQEA7Jh4mNB4nHno/ASsjO0U7IiI7RTsjliujJx4nAQYeJh96P5UrpCYeJwAAAAACAAAAAAHrAVYAFAAqAAA3Ii4BND4BMz4BMzIeARczMhYUBiM1IzU0LgEjIgYHJiMiBhQWMyEyNjQmgB0xHR0xHRBFKyQ+JgMKJDIyJCodMR0oOwYMCxslJRsBFRIZGSscMToxHSYvIjsjMkYygBUdMR0zJwQlNSYZJBkAAgAA/+oB6wGWADYAPQAANyIuATQ+ATM+ATMyHgEXMzIWFAYrASImNDY7ATI2NCYrATU0LgEjIgYHJiMiBhQWOwEyFhQGIzczBzMHNyOAHTEdHTEdEEUrJD4mAwokMjIkFQkMDAkVEhkZEiodMR0oOwYMCxslJRsVCQ0NCWtAKytQEDVrHDE6MR0mLyI7IzJGMgwSDBkkGRUdMR0zJwQlNSYMEgxqVZVqAAAAAAQAAP/vAesBlgAMABkAJgBfAAA3HgEPAQ4BLgE/AT4BFx4BDwEOAS4BPwE+ARceAQ8BDgEuAT8BPgE3NTQuASMiBgcmIyIGFRQWFzEeAQ4BJzEuATQ+ATM+ATMyHgEXMzIWFRQGBzEGLgE2NzE+ATU0JiPACAkCHAIPEQkDGwIPXgkJAywCDxEJAiwDD14ICQIcAg8SCAIcAg8JHTEdKDsGDAsbJREPCAQJEAgZHR0xHRBFKyQ+JgMKJDIXFAgRCQUICQwZEsACEAhnCQgEDwlnCAkCAhAIpQkIBBAIpQgJAgIQCGcJCAQPCWcICSkVHTEdMycEJRsRHggEEg8EBA4xOjEdJi8iOyMyIxgnCwQEEBEEBhMMEhkAAAAAAgAA/9YB6wGWADQAXgAANzIWFAYjIi4BND4BMz4BMzIeARczMhYUBisBIiY0NjsBMjY0JisBNTQuASMiBgcmIyIGFBYXNycmNDYyHwE3PgEeAQ8BNzYeAQYPARcWFAYiLwEHDgEuAT8BBwYuATaACQwMCR0xHR0xHRBFKyQ+JgMKJDIyJBUJDAwJFRIZGRIqHTEdKDsGDAsbJSVDLyMGDRIGIgwDDxEJAg0vCBAECQgvIwYNEgYiDAMPEQkCDS8IEAQJlQwSDBwxOjEdJi8iOyMyRjIMEgwZJBkVHTEdMycEJTUmVgwiBhINBiMvCAkEEAgvDQIJEQ8DDCIGEg0GIy8ICQQQCC8NAgkRDwAAAAADAAD/6gHrAZUANABAAFQAADcyFhQGIyIuATQ+ATM+ATMyHgEXNzIWFAYrASImNDY7ATI2NCYrATU0LgEjIgYHJiMiBhQWFxYXFhUUBiImNTQ/AQ8BBgcGBwYVFBYyNjU0Jy4BJzGACQwMCR0xHR0xHRBFKyQ+JgMKJDIyJBUJDAwJFRIZGRIqHTEdKDsGCwwbJSWbBQcfGSQZHwwLCw4LEggMMkYyDAgkEpUNEQ0dMToxHCcvIzokATJHMg0RDRkjGRUdMR0zJgQmNSUDBworFhIZGRIWK1QMDhERGRIZFSMyMiMVGRI0FQAAAAMAAP/qAesBlgAYACAAIwAAJSc3NjczNSM1IxUjFTMGByYnIxYXBxc3FzcjAzM3MxczJzcXARM3ATcYP5Yqlu8XLR0UKxgobR5rQokrYCsYZRgrmCIjfzUBPU4rKiorQDIgJzUsax5qQpj/AEBAal1dAAAAAgAAAAABtgGAABUAHgAAEzIeARUUBxczFwcnNScGIyIuATQ+ARciBhQWMjY0JsslQCUhBhFqIGoGJzMmQCUlQCYoODhQODgBgCVAJjMnBmogahEGISVAS0AlKzhQODhQOAAAAAEAAP/0AdYBlgBRAAABIg4BFRQWFxY2PQEGJyYnMSYnJi8BJjQzNxYXFhcxFhcWNzY3JicmNTQ3JjUmNzMyFxYXNjIXNjc2FzEWBxQHFhUUBwYHFh0BFBY3PgE1NC4BAQA6YjlRQQcHJRULAwQHBAUECAUFDQsGAg0VDRACCywWHxYEAggGCAsQEhk4GRoTCgQIAgQWHxcrDgcIQFE5YgGVOWI6Rm8WAQcFJAgSCAsLCAYDAwYGAQELBQUVAgEGEwoFExo3IRgJCxITBAYMBwcRBAIBExILCRghOBkTBQ0bOgUHARZvRjpiOQAAAQAAAAABqwFrAB4AAAEuASMiDgEUHgEzMjY3Iw4BIyIuATQ+ATMyFhcHMzUBeRg+Iy5PLi5PLjtbDywOQikjOyIiOyMaLhJFlgE5FxsuT1xPLkg4JTAiO0Y7IhQSRZYAAQAAAAABqQFrAAgAABMzETcXByc3F+sqdh6pqR52AWv/AHUeqakedQAAAAACAAAAAAGrAYAAGQAdAAABBx4BFA4BIi4BNDY3Jw4BFRQeATI+ATU0JicjFTMBYR8dISI7RjsiIRweIiguT1xPLihuKioBTB8ROkU7IiI7RToRHxhJKy5PLi5PLitJTNUAAAAABAAA/+oBqwGWAA0AEwAXABsAABMiBhURFBYzITI2NREnBzMVMxUhNxUzNQcVMzWAEhkZEgEAEhmAq5Vr/wArqqpqAZUZEf6qERkZEQEAgCpr66srK1UrKwAAAAACAAD//QGbAYEALQBHAAAlJi8BJicmJy4BNwYHDgEXFhUUBicmJy4BNw4BFxYXFhceARcWNzY3PgEvASYnBwYHBicmJz4BNzYvASY3HgIXFhcWFRYGBwF5BAoDBg4QCBgKEBocKR0TAg8GAgESBgwaHAICBAQLETkgJCEjGR4SDwMEDEQLDBESDwwSFwQDBgMECAcMGgUIAwEBCwrRBQoDBQoNBxdFHgYWImoyBAMIBgYBAhc8GxZEIxULERQbJQQFCAgXG00lBQoRhgoDBgYFDAUYDwwWDhgUEA4XBwoNBAUNGwgAAAAAAwAAAAAB5wGBAAQAEQAcAAAhNyYiBxMiBgcXPgEyFhc3LgEHIgYHFzYyFzcuAQEATSJWIk1AdTEmKWJqYikmMXVAKk8hJzOAMychT2YaGgEaKCUzHyEhHzMlKIAbGDMmJjMYGwAAAAABAAD/1QHrAa4AFgAAJSc2LgIHFwcnBhYXHgE3FxYyPwE+AQHkwg8RPVgnXEBeEw8gHlAlwgcRBjEIASvCJVA9DxJcQFwnVyAeEQ/CBwcxBhMAAAADAAD/6gHBAcAACwAjAD8AAAEyNjU0LwEHBhUUFhcnBwYiLwEHBiMiJxUUFjMhMjY9AQYjIjcjNSMVIyIGHQEUFjI/ARcWMj8BFxYyNj0BNCYBABIZByQkBxl0FxcVPhUXFxYeFxMNCAFWCA0TFx4IayprGyUZIwsuLQwkCy4uCyMZJQFAGRIMCj8/CgwSGdUXFxUVFxcWDWIJDAwJYg2rKyslGyERGQwuLgsLLi4MGREhGyUAAAAABAAA/+oBwQGWACAAJAAoACwAABM1MzU0NjsBFTcXNTMyFhURFAYjISImPQEjNTM1IzUzNRcjFTM9ASMVEzUjFUArGRGANjUVERoaEf8AEBorKysrKioqKioqASsqFhEZlSAglRoQ/qoQGhoQFipWKlZWKoAqKv8AKioAAAIAAP/VAZYBqwADABMAACUjETM1IyIGFREUFjsBMjY1ETQmAWvW1tYRGRkR1hEZGSsBKlYZEv6AEhkZEgGAEhkAAAAABAAA/+MBxgGrAAkAEwArADcAAAEHFycHNyc/AR8BBxcnBzcnPwEXBzYeAQcGBw4BLgI2NzY3Nh4BBwYeAhcuAycOAR4CNgF7NhM4OBM2RBcXjiMNJCUNIywPDgQIEQUFCwwpbm5SHBwpDQ4IFA0BBB9FWgwuV0QmAh4TGD9UVgFpKkEnJ0EqAkBAlhorGRkrGgEqKmoBDhMIEAspHR1Sbm4pDQoFBhAJLlpFICYCJkRWLiFVVD8YEwAAAAADAAAAAAHfAYAAAwAJAA8AAAEXAyc3JzUXBzUlNxUHFxUBEypQKt9NiYn+zYlNTQGACf6JCbdNPImJPUyJPE1MPQAAAAMAAP/VAcEBqwADABMAHAAAISMRMzUjIgYVERQWOwEyNjURNCYnISIGFREzESEBlerq6hIZGRLqEhkZUv8AERkqAQABKyoZEf7VEhkZEgErERlWGRL+1QErAAAADwAA/8ACAQHBAAMABwAfACMAJwArAC8AMwA3AD0AQQBKAFMAXABlAAATMxUjJRUjNRUzNSM1MxUzNTMVIxUzFSMVIzUjFSM1MzcVMzUFNTMVAxUzNTMVMzUFFTM1JzMVIzczFSM1IzczFSMnFSM1NDY7ARUlMhYdASM1IzUBFTMVIyImPQEFNTMVFAYrATVVgIABVoAqKiorKysrKytAKkAqK/7VgFUrqiv/ACtWKytrVSorKyoqwCsZElUBVRIZK1X+q1VVEhkB1SsZElUBa4CAgIDrKyoqKiorQCsrK1YVQEBrgIABKysrKyvVKytqKipVK5VVqlVVEhkrKxkSVVUr/oBVKxkSVVVVVRIZKwAKAAD/6gIBAZYAAwAHAAsADwATABcAIAApADIAOwAAEzMRIxMzESMTMxEjEzMRIxMzESMTMxEjARUjNTQ2OwEVJTIWHQEjNSM1ARUzFSMiJj0BBTUzFRQGKwE1VSsrQBYWK0BAVRYWQCsrQBYW/pYrGRJVAVUSGStV/qtVVRIZAdUrGRJVAUD/AAEA/wABAP8AAQD/AAEA/wABAP8AAStWVhEZKioZEVZWKv7WVioZEVZWVlYRGSoAAwAA/+oBwQGrAA8AFgAuAAAlIi4CNTMUFjI2NTMUDgEnMhYVIzQ2FyM0LgEiDgEVIyIGFREUFjMhMjY1ETQmAQAVJx4RKyU2JSsdMR0bJYAlsCodMToxHSoSGRkSASoSGRmrEB4nFRomJhodMRzVJRsbJUAdMR0dMR0ZEv8AERkZEQEAEhkAAAQAAP/qAcABqwAXAB4AIgAxAAABIzQuASIOARUjIgYVERQWMyEyNjURNCYnMhYVIzQ2EyERIQciJjUjFB4BMj4BNSMUBgGVKh0xOjEdKhIZGRIBKhIZGacbJYAlsP7WASqVGyUrHTE6MR0rJQFAHTEdHTEdGRL/ABEZGREBABIZQCUbGyX+lQEAVSUbHTEdHTEdGyUAAAAABgAAAAACAQGBAA8AEwAXABsAKgAzAAATITIWFREUBiMhIiY1ETQ2BRUzNQcVMzUHFTM1BSIHBgcGHQEhNTQnJicmJyIGFBYyNjQmKwGqERoaEf5WERoaARGqqqqqlf7rGBwhFBcBABgUIB0XGyUlNSYmAYAaEf7WERoaEQEqERpAFRUrFRUqFhZUBwkOEBQVFRQQDgkHqSU2JSU2JQAAAAcAAAAAAgABgAAPABMAIQAqAC4AMgA2AAABIQ4BBxEeARchPgE3ES4BAyERIQM1NCcmJyYiBwYHBh0BNyIGFBYyNjQmMxUzNQcVMzUHFTM1AdX+VhIYAQEYEgGqEhgBARgS/lYBqqoUERsXKBcbERRrFh8fLB8fVYCAgIBVAYABGBL+1hIYAQEYEgEqEhj+rAEq/wAbEA4LBgYGBgsOEBvWICwfHywgFhYrFRUrFRUAAQAA/+oBgAGWAA8AACU1MzUjFTMVBxUzFTM1MzUBVRbWFitvIm/AqyoqqysqgIAqAAAAAAIAAP/qAasBlgALABYAABM3AQcnFSM1IzU3NR8BFSMnNSM1MxUjKxsBZRt/Im8rqisE0RbWFgFQG/6bG35+gCorEBArKtEvKioAAAACAAD/6gGAAZYADwAVAAAlNTM1IxUzFQcVMxUzNTM1Izc1MxUXAVUW1hYrbyJvxBlWGcCrKiqrKyqAgCoavLwaAAAAAAMAAP/qAasBlgAOABoAHQAAEzUjNTMVIxUXFSMnNSMVEwcnFSM1IzU3NSc3FzMnqxbWFisEUVbWHH4ibyuAG3YmEwE8LyoqqysqUa9a/vUbfn6AKisPgBzWFAAABQAAAAACAAGBAB8APgBHAFAAWQAAEzMVIxUUBiMyFh0BMxUjJicmPQE0JisBNTMyNj0BNDYhMhYdARQWOwEVIyIGHQEUBisBNTM1NDYzIiY9ASM1AzIWFAYiJjQ2IzIWFAYiJjQ2MzIWFAYiJjQ2ayoqGRISGSoqEwsNGRIVFRIZGQE8EhkZEhUVEhkZEioqGRISGSprCQwMEgwMTAkMDBINDbMJDQ0SDAwBgCtqEhkZEmorBQoLEVUSGSoZElUSGRkSVRIZKhkSVRIZK2oSGRkSaiv/AAwSDQ0SDAwSDQ0SDAwSDQ0SDAAAAAADAAAAAAHrAWAACAATAB0AAAEyFhQGIiY0NjcyFhcOASImJz4BBx4BMjY3LgEiBgEAGyUlNiUlG0+AHByAnoAcHIBtGmZ4ZhoaZnhmAQAlNiUlNiVgWUdHWVlHR1mgNj8/NjY/PwAAAAMAAAAAAesBYQAIABUAIAAAASIGFBYyNjQmByIuATQ+ATIeARQOAQMiBgceATI2Ny4BAQAbJSU2JSUbHTEdHTE6MR0dMR1PgBwcgJ6AHByAAQAlNiUlNiWrHTE6MR0dMToxHQELWUdHWVlHR1kAAAADAAD/1QHrAYEAAwAbACIAACURMxEDMhYdARQPAScmPQE3IyImPQE0PwE+ATMXIwcVMwc3AZVWqxIZDYwXCRWHEhkDQQUVDcDBP7sYXYABAP8AAQAZEtUSDI0XCQ4GYhkRKwgIlgwOK5UrcV0AAAAAAgAA/9UB6wGBAAMAHAAAJTMRKwIiBg8BBh0BFBY7AQcUFRQfATc2PQE0JgGVVlZVwA0VBUEDGRKHFQkXjA0ZgAEADgyWCAgrERliAwMOCReNDBLVEhkAAAMAAAAAAesBqwADABsAIgAAExEjERMiJj0BND8BFxYdAQczMhYdARQPAQ4BIyczNzUjNwdrVqsSGQ2MFwkVhxIZA0EFFQ3AwT+8GV0BAP8AAQD/ABkS1RIMjRcJDQdiGRErCAiWDA4rlStxXQAAAAACAAAAAAHrAasAGAAcAAAlNCYrATc0NTQvAQcGHQEUFjsBMjY/ATY1BTMRIwHrGRKHFQkXjA0ZEsANFQVBA/4qVlbrERliAwQNCReNDBLVEhkODJYICMABAAAAAAAAEADGAAEAAAAAAAEADAAAAAEAAAAAAAIABwAMAAEAAAAAAAMADAATAAEAAAAAAAQADAAfAAEAAAAAAAUACwArAAEAAAAAAAYADAA2AAEAAAAAAAoAKwBCAAEAAAAAAAsAEwBtAAMAAQQJAAEAGACAAAMAAQQJAAIADgCYAAMAAQQJAAMAGACmAAMAAQQJAAQAGAC+AAMAAQQJAAUAFgDWAAMAAQQJAAYAGADsAAMAAQQJAAoAVgEEAAMAAQQJAAsAJgFadmFybGV0LWljb25zUmVndWxhcnZhcmxldC1pY29uc3ZhcmxldC1pY29uc1ZlcnNpb24gMS4wdmFybGV0LWljb25zR2VuZXJhdGVkIGJ5IHN2ZzJ0dGYgZnJvbSBGb250ZWxsbyBwcm9qZWN0Lmh0dHA6Ly9mb250ZWxsby5jb20AdgBhAHIAbABlAHQALQBpAGMAbwBuAHMAUgBlAGcAdQBsAGEAcgB2AGEAcgBsAGUAdAAtAGkAYwBvAG4AcwB2AGEAcgBsAGUAdAAtAGkAYwBvAG4AcwBWAGUAcgBzAGkAbwBuACAAMQAuADAAdgBhAHIAbABlAHQALQBpAGMAbwBuAHMARwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABzAHYAZwAyAHQAdABmACAAZgByAG8AbQAgAEYAbwBuAHQAZQBsAGwAbwAgAHAAcgBvAGoAZQBjAHQALgBoAHQAdABwADoALwAvAGYAbwBuAHQAZQBsAGwAbwAuAGMAbwBtAAAAAgAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB5AQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiASMBJAElASYBJwEoASkBKgErASwBLQEuAS8BMAExATIBMwE0ATUBNgE3ATgBOQE6ATsBPAE9AT4BPwFAAUEBQgFDAUQBRQFGAUcBSAFJAUoBSwFMAU0BTgFPAVABUQFSAVMBVAFVAVYBVwFYAVkBWgFbAVwBXQFeAV8BYAFhAWIBYwFkAWUBZgFnAWgBaQFqAWsBbAFtAW4BbwFwAXEBcgFzAXQBdQF2AXcBeAF5AXoAFmNoZWNrYm94LW1hcmtlZC1jaXJjbGUUY2hlY2stY2lyY2xlLW91dGxpbmULaW5mb3JtYXRpb24TaW5mb3JtYXRpb24tb3V0bGluZQd3YXJuaW5nDWFsZXJ0LW91dGxpbmUFZXJyb3IUYWxlcnQtY2lyY2xlLW91dGxpbmUPY2hlY2tib3gtbWFya2VkF2NoZWNrYm94LW1hcmtlZC1vdXRsaW5lFmNoZWNrYm94LWJsYW5rLW91dGxpbmUMcmFkaW8tbWFya2VkHmNoZWNrYm94LW1hcmtlZC1jaXJjbGUtb3V0bGluZQtyYWRpby1ibGFuawxjbG9zZS1jaXJjbGUUY2xvc2UtY2lyY2xlLW91dGxpbmUJY2xvc2UtYm94EWNsb3NlLWJveC1vdXRsaW5lDG1pbnVzLWNpcmNsZRRtaW51cy1jaXJjbGUtb3V0bGluZQRzdGFyDnN0YXItaGFsZi1mdWxsDHN0YXItb3V0bGluZQVoZWFydA9oZWFydC1oYWxmLWZ1bGwNaGVhcnQtb3V0bGluZQZkZWxldGUJdHJhc2gtY2FuEXRyYXNoLWNhbi1vdXRsaW5lCW1pbnVzLWJveBFtaW51cy1ib3gtb3V0bGluZQ5hY2NvdW50LWNpcmNsZRZhY2NvdW50LWNpcmNsZS1vdXRsaW5lA2NvZwtjb2ctb3V0bGluZRFtYXAtbWFya2VyLXJhZGl1cxltYXAtbWFya2VyLXJhZGl1cy1vdXRsaW5lBmNhbWVyYQ5jYW1lcmEtb3V0bGluZQRjYXJ0DGNhcnQtb3V0bGluZQVwaG9uZQ1waG9uZS1vdXRsaW5lBWltYWdlDWltYWdlLW91dGxpbmUEYmVsbAxiZWxsLW91dGxpbmUEaG9tZQxob21lLW91dGxpbmUKbWFwLW1hcmtlchJtYXAtbWFya2VyLW91dGxpbmUMbWFnbmlmeS1wbHVzFG1hZ25pZnktcGx1cy1vdXRsaW5lDW1hZ25pZnktbWludXMVbWFnbmlmeS1taW51cy1vdXRsaW5lC3BsYXktY2lyY2xlE3BsYXktY2lyY2xlLW91dGxpbmULaGVscC1jaXJjbGUTaGVscC1jaXJjbGUtb3V0bGluZQtwbHVzLWNpcmNsZRNwbHVzLWNpcmNsZS1vdXRsaW5lBWNoZWNrDHdpbmRvdy1jbG9zZQRwbHVzBW1pbnVzCmNoZXZyb24tdXAMY2hldnJvbi1kb3duDGNoZXZyb24tbGVmdA1jaGV2cm9uLXJpZ2h0B21lbnUtdXAJbWVudS1kb3duCW1lbnUtbGVmdAptZW51LXJpZ2h0BnVwbG9hZAhkb3dubG9hZBRmb3JtYXQtbGlzdC1jaGVja2JveARtZW51CW1lbnUtb3Blbg1kb3RzLXZlcnRpY2FsFG1lc3NhZ2UtdGV4dC1vdXRsaW5lGm1lc3NhZ2UtcHJvY2Vzc2luZy1vdXRsaW5lE3doaXRlLWJhbGFuY2Utc3VubnkOd2VhdGhlci1jbG91ZHkRd2VhdGhlci1saWdodG5pbmcPd2VhdGhlci1wb3VyaW5nDXdlYXRoZXItc25vd3kNd2VhdGhlci1yYWlueQl0cmFuc2xhdGUHbWFnbmlmeQZnaXRodWIHcmVmcmVzaAphcnJvdy1kb3duBXBvd2VyFWZpbGUtZG9jdW1lbnQtb3V0bGluZQRmaXJlBHdpZmkGd3JlbmNoDGNha2UtdmFyaWFudAhub3RlYm9vawljZWxscGhvbmUNd2VhdGhlci1uaWdodAN4bWwMY29udGVudC1jb3B5C3FyY29kZS1zY2FuDGJhcmNvZGUtc2NhbghzaG9wcGluZxBzaG9wcGluZy1vdXRsaW5lFGNhcmQtYWNjb3VudC1kZXRhaWxzHGNhcmQtYWNjb3VudC1kZXRhaWxzLW91dGxpbmUDcGluB3Bpbi1vZmYLcGluLW91dGxpbmUPcGluLW9mZi1vdXRsaW5lCWNvZGUtanNvbgx2aWV3LW91dGxpbmUEdmlldxJ0aHVtYi1kb3duLW91dGxpbmUKdGh1bWItZG93bhB0aHVtYi11cC1vdXRsaW5lCHRodW1iLXVwAAAAAAA=) format("truetype");font-weight:400;font-style:normal}.var-icon--set{font-family:varlet-icons}.var-icon-checkbox-marked-circle:before{content:"\uF000"}.var-icon-check-circle-outline:before{content:"\uF001"}.var-icon-information:before{content:"\uF002"}.var-icon-information-outline:before{content:"\uF003"}.var-icon-warning:before{content:"\uF004"}.var-icon-alert-outline:before{content:"\uF005"}.var-icon-error:before{content:"\uF006"}.var-icon-alert-circle-outline:before{content:"\uF007"}.var-icon-checkbox-marked:before{content:"\uF008"}.var-icon-checkbox-marked-outline:before{content:"\uF009"}.var-icon-checkbox-blank-outline:before{content:"\uF010"}.var-icon-radio-marked:before{content:"\uF011"}.var-icon-checkbox-marked-circle-outline:before{content:"\uF012"}.var-icon-radio-blank:before{content:"\uF013"}.var-icon-close-circle:before{content:"\uF014"}.var-icon-close-circle-outline:before{content:"\uF015"}.var-icon-close-box:before{content:"\uF016"}.var-icon-close-box-outline:before{content:"\uF017"}.var-icon-minus-circle:before{content:"\uF018"}.var-icon-minus-circle-outline:before{content:"\uF019"}.var-icon-star:before{content:"\uF020"}.var-icon-star-half-full:before{content:"\uF021"}.var-icon-star-outline:before{content:"\uF022"}.var-icon-heart:before{content:"\uF023"}.var-icon-heart-half-full:before{content:"\uF024"}.var-icon-heart-outline:before{content:"\uF025"}.var-icon-delete:before{content:"\uF026"}.var-icon-trash-can:before{content:"\uF027"}.var-icon-trash-can-outline:before{content:"\uF028"}.var-icon-minus-box:before{content:"\uF029"}.var-icon-minus-box-outline:before{content:"\uF030"}.var-icon-account-circle:before{content:"\uF031"}.var-icon-account-circle-outline:before{content:"\uF032"}.var-icon-cog:before{content:"\uF033"}.var-icon-cog-outline:before{content:"\uF034"}.var-icon-map-marker-radius:before{content:"\uF035"}.var-icon-map-marker-radius-outline:before{content:"\uF036"}.var-icon-camera:before{content:"\uF037"}.var-icon-camera-outline:before{content:"\uF038"}.var-icon-cart:before{content:"\uF039"}.var-icon-cart-outline:before{content:"\uF040"}.var-icon-phone:before{content:"\uF041"}.var-icon-phone-outline:before{content:"\uF042"}.var-icon-image:before{content:"\uF043"}.var-icon-image-outline:before{content:"\uF044"}.var-icon-bell:before{content:"\uF045"}.var-icon-bell-outline:before{content:"\uF046"}.var-icon-home:before{content:"\uF047"}.var-icon-home-outline:before{content:"\uF048"}.var-icon-map-marker:before{content:"\uF049"}.var-icon-map-marker-outline:before{content:"\uF050"}.var-icon-magnify-plus:before{content:"\uF051"}.var-icon-magnify-plus-outline:before{content:"\uF052"}.var-icon-magnify-minus:before{content:"\uF053"}.var-icon-magnify-minus-outline:before{content:"\uF054"}.var-icon-play-circle:before{content:"\uF055"}.var-icon-play-circle-outline:before{content:"\uF056"}.var-icon-help-circle:before{content:"\uF057"}.var-icon-help-circle-outline:before{content:"\uF058"}.var-icon-plus-circle:before{content:"\uF059"}.var-icon-plus-circle-outline:before{content:"\uF060"}.var-icon-check:before{content:"\uF061"}.var-icon-window-close:before{content:"\uF062"}.var-icon-plus:before{content:"\uF063"}.var-icon-minus:before{content:"\uF064"}.var-icon-chevron-up:before{content:"\uF065"}.var-icon-chevron-down:before{content:"\uF066"}.var-icon-chevron-left:before{content:"\uF067"}.var-icon-chevron-right:before{content:"\uF068"}.var-icon-menu-up:before{content:"\uF069"}.var-icon-menu-down:before{content:"\uF070"}.var-icon-menu-left:before{content:"\uF071"}.var-icon-menu-right:before{content:"\uF072"}.var-icon-upload:before{content:"\uF073"}.var-icon-download:before{content:"\uF074"}.var-icon-format-list-checkbox:before{content:"\uF075"}.var-icon-menu:before{content:"\uF076"}.var-icon-menu-open:before{content:"\uF077"}.var-icon-dots-vertical:before{content:"\uF078"}.var-icon-message-text-outline:before{content:"\uF079"}.var-icon-message-processing-outline:before{content:"\uF080"}.var-icon-white-balance-sunny:before{content:"\uF081"}.var-icon-weather-cloudy:before{content:"\uF082"}.var-icon-weather-lightning:before{content:"\uF083"}.var-icon-weather-pouring:before{content:"\uF084"}.var-icon-weather-snowy:before{content:"\uF085"}.var-icon-weather-rainy:before{content:"\uF086"}.var-icon-translate:before{content:"\uF087"}.var-icon-magnify:before{content:"\uF088"}.var-icon-github:before{content:"\uF089"}.var-icon-refresh:before{content:"\uF090"}.var-icon-arrow-down:before{content:"\uF091"}.var-icon-power:before{content:"\uF092"}.var-icon-file-document-outline:before{content:"\uF093"}.var-icon-fire:before{content:"\uF094"}.var-icon-wifi:before{content:"\uF095"}.var-icon-wrench:before{content:"\uF096"}.var-icon-cake-variant:before{content:"\uF097"}.var-icon-notebook:before{content:"\uF098"}.var-icon-cellphone:before{content:"\uF099"}.var-icon-weather-night:before{content:"\uF100"}.var-icon-xml:before{content:"\uF101"}.var-icon-content-copy:before{content:"\uF102"}.var-icon-qrcode-scan:before{content:"\uF103"}.var-icon-barcode-scan:before{content:"\uF104"}.var-icon-shopping:before{content:"\uF105"}.var-icon-shopping-outline:before{content:"\uF106"}.var-icon-card-account-details:before{content:"\uF107"}.var-icon-card-account-details-outline:before{content:"\uF108"}.var-icon-pin:before{content:"\uF109"}.var-icon-pin-off:before{content:"\uF110"}.var-icon-pin-outline:before{content:"\uF111"}.var-icon-pin-off-outline:before{content:"\uF112"}.var-icon-code-json:before{content:"\uF113"}.var-icon-view-outline:before{content:"\uF114"}.var-icon-view:before{content:"\uF115"}.var-icon-thumb-down-outline:before{content:"\uF116"}.var-icon-thumb-down:before{content:"\uF117"}.var-icon-thumb-up-outline:before{content:"\uF118"}.var-icon-thumb-up:before{content:"\uF119"}:root{--icon-size: 20px}.var-icon{position:relative;display:inline-flex;justify-content:center;align-items:center;vertical-align:bottom;color:inherit;font-size:var(--icon-size)}.var-icon:before{position:relative;display:inline-block;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;font-weight:400;font-style:normal;line-height:1}.var-icon--shrinking{transform:scale(0);transition-property:transform}.var-icon__image{width:var(--icon-size);height:var(--icon-size);object-fit:cover}:root{--loading-opacity: .38;--loading-desc-margin: 8px 0 0}.var-loading{--loading-normal-width: 50px;--loading-normal-height: calc(var(--font-size-md) + 2px);--loading-large-width: 64px;--loading-large-height: calc(var(--font-size-lg) + 2px);--loading-small-width: 36px;--loading-small-height: calc(var(--font-size-sm) + 2px);--loading-mini-width: 22px;--loading-mini-height: calc(var(--font-size-xs) + 2px);position:relative}.var-loading__content{position:relative;transition:opacity .3s;opacity:1}.var-loading__content--active{opacity:var(--loading-opacity)}.var-loading__content-mask{position:absolute;left:0;right:0;top:0;bottom:0}.var-loading__body{display:flex;justify-content:center;align-items:center;height:100%;flex-direction:column}.var-loading__inside{position:absolute;left:50%;top:0;transform:translate(-50%);max-height:50vh;z-index:1}.var-loading__description{color:var(--color-primary);margin:var(--loading-desc-margin)}.var-loading__description--large{font-size:var(--font-size-lg)}.var-loading__description--normal{font-size:var(--font-size-md)}.var-loading__description--small{font-size:var(--font-size-sm)}.var-loading__description--mini{font-size:var(--font-size-xs)}.var-loading__circle{display:flex}.var-loading__circle-block{display:inline-block;color:var(--color-primary);animation:circle 1.8s linear infinite}.var-loading__circle-block--large{width:36px;height:36px}.var-loading__circle-block--normal{width:30px;height:30px}.var-loading__circle-block--small{width:24px;height:24px}.var-loading__circle-block--mini{width:18px;height:18px}.var-loading__circle-block svg{display:block;width:100%;height:100%}.var-loading__circle-block svg circle{animation:circular 1.5s ease-in-out infinite;stroke:currentColor;stroke-width:3;stroke-linecap:round}@keyframes circle{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes circular{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-40}to{stroke-dasharray:90,150;stroke-dashoffset:-120}}.var-loading__wave{--loading-wave-size-item-width: 5px;--loading-wave-size-item-margin: 5px;display:flex;align-items:center;justify-content:center;flex-shrink:0}.var-loading__wave--large{width:var(--loading-large-width);height:var(--loading-large-height)}.var-loading__wave--normal{width:var(--loading-normal-width);height:var(--loading-normal-height)}.var-loading__wave--small{width:var(--loading-small-width);height:var(--loading-small-height)}.var-loading__wave--mini{width:var(--loading-mini-width);height:var(--loading-mini-height)}.var-loading__wave-item{height:100%;display:inline-block;animation:1.2s ease-in-out infinite wave;background-color:var(--color-primary)}.var-loading__wave-item:nth-child(1){animation-delay:-1.2s;margin-left:0}.var-loading__wave-item:nth-child(2){animation-delay:-1.1s}.var-loading__wave-item:nth-child(3){animation-delay:-1s}.var-loading__wave-item:nth-child(4){animation-delay:-.9s}.var-loading__wave-item:nth-child(5){animation-delay:-.8s}.var-loading__wave-item--large{width:var(--loading-wave-size-item-width);margin-left:var(--loading-wave-size-item-margin)}.var-loading__wave-item--normal{width:calc(var(--loading-wave-size-item-width) - 1px);margin-left:calc(var(--loading-wave-size-item-margin) - 1px)}.var-loading__wave-item--small{width:calc(var(--loading-wave-size-item-width) - 2px);margin-left:calc(var(--loading-wave-size-item-margin) - 2px)}.var-loading__wave-item--mini{width:calc(var(--loading-wave-size-item-width) - 3px);margin-left:calc(var(--loading-wave-size-item-margin) - 3px)}@keyframes wave{0%,40%,to{transform:scaleY(.4)}20%{transform:scaleY(1)}}.var-loading__cube{--loading-cube-size-item-width: 10px;--loading-cube-size-item-height: 10px;--loading-cube-size-item-margin: 5px;display:flex;align-items:center;flex-shrink:0}.var-loading__cube--large{width:var(--loading-large-width);height:var(--loading-large-height)}.var-loading__cube--normal{width:var(--loading-normal-width);height:var(--loading-normal-height)}.var-loading__cube--small{width:var(--loading-small-width);height:var(--loading-small-height)}.var-loading__cube--mini{width:var(--loading-mini-width);height:var(--loading-mini-height)}.var-loading__cube-item{display:inline-block;transform-origin:right bottom;animation:1.5s ease infinite cube;background-color:var(--color-primary)}.var-loading__cube-item:nth-child(1){animation-delay:.2s;margin-left:0}.var-loading__cube-item:nth-child(2){animation-delay:.4s}.var-loading__cube-item:nth-child(3){animation-delay:.6s}.var-loading__cube-item:nth-child(4){animation-delay:.8s}.var-loading__cube-item--large{height:var(--loading-cube-size-item-height);width:var(--loading-cube-size-item-width);margin-left:var(--loading-cube-size-item-margin)}.var-loading__cube-item--normal{height:calc(var(--loading-cube-size-item-height) - 2px);width:calc(var(--loading-cube-size-item-width) - 2px);margin-left:calc(var(--loading-cube-size-item-margin) - 1px)}.var-loading__cube-item--small{height:calc(var(--loading-cube-size-item-height) - 4px);width:calc(var(--loading-cube-size-item-width) - 4px);margin-left:calc(var(--loading-cube-size-item-margin) - 2px)}.var-loading__cube-item--mini{height:calc(var(--loading-cube-size-item-height) - 6px);width:calc(var(--loading-cube-size-item-width) - 6px);margin-left:calc(var(--loading-cube-size-item-margin) - 3px)}@keyframes cube{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:rotate(90deg) scale(.3)}}.var-loading__rect{--loading-rect-size-item-width: 8px;--loading-rect-size-item-height: 100%;display:flex;flex-wrap:nowrap;justify-content:center;align-items:center;flex-shrink:0}.var-loading__rect--large{width:var(--loading-large-width);height:var(--loading-large-height)}.var-loading__rect--normal{width:var(--loading-normal-width);height:var(--loading-normal-height)}.var-loading__rect--small{width:var(--loading-small-width);height:var(--loading-small-height)}.var-loading__rect--mini{width:var(--loading-mini-width);height:var(--loading-mini-height)}.var-loading__rect-item{animation:2s ease-in-out infinite rect;background-color:var(--color-primary)}.var-loading__rect-item:nth-child(1){animation-delay:1.75s}.var-loading__rect-item:nth-child(2){animation-delay:1.5s}.var-loading__rect-item:nth-child(3){animation-delay:1.25s}.var-loading__rect-item:nth-child(4){animation-delay:1s}.var-loading__rect-item:nth-child(5){animation-delay:.75s}.var-loading__rect-item:nth-child(6){animation-delay:.5s}.var-loading__rect-item:nth-child(7){animation-delay:.25s}.var-loading__rect-item:nth-child(8){animation-delay:0s}.var-loading__rect-item--large{height:var(--loading-rect-size-item-height);width:var(--loading-rect-size-item-width)}.var-loading__rect-item--normal{height:calc(var(--loading-rect-size-item-height) * .9);width:calc(var(--loading-rect-size-item-width) * .8)}.var-loading__rect-item--small{height:calc(var(--loading-rect-size-item-height) * .8);width:calc(var(--loading-rect-size-item-width) * .6)}.var-loading__rect-item--mini{height:calc(var(--loading-rect-size-item-height) * .7);width:calc(var(--loading-rect-size-item-width) * .4)}@keyframes rect{0%{opacity:.3}25%{opacity:1}50%{opacity:.3}65%{opacity:1}to{opacity:.3}}.var-loading__disappear{--loading-disappear-size-item-width: 15px;--loading-disappear-size-item-height: 15px;display:flex;justify-content:space-around;align-items:center;flex-flow:nowrap;flex-shrink:0}.var-loading__disappear--large{width:var(--loading-large-width);height:var(--loading-large-height)}.var-loading__disappear--normal{width:var(--loading-normal-width);height:var(--loading-normal-height)}.var-loading__disappear--small{width:var(--loading-small-width);height:var(--loading-small-height)}.var-loading__disappear--mini{width:var(--loading-mini-width);height:var(--loading-mini-height)}.var-loading__disappear-item{border-radius:50%;animation:.5s ease-in-out infinite alternate disappear;background-color:var(--color-primary)}.var-loading__disappear-item:nth-child(1){animation-delay:-.4s}.var-loading__disappear-item:nth-child(2){animation-delay:-.2s}.var-loading__disappear-item:nth-child(3){animation-delay:0s}.var-loading__disappear-item--large{height:var(--loading-disappear-size-item-height);width:var(--loading-disappear-size-item-width)}.var-loading__disappear-item--normal{height:calc(var(--loading-disappear-size-item-height) * .8);width:calc(var(--loading-disappear-size-item-width) * .8)}.var-loading__disappear-item--small{height:calc(var(--loading-disappear-size-item-height) * .6);width:calc(var(--loading-disappear-size-item-width) * .6)}.var-loading__disappear-item--mini{height:calc(var(--loading-disappear-size-item-height) * .4);width:calc(var(--loading-disappear-size-item-width) * .4)}@keyframes disappear{0%{opacity:1}to{opacity:0}}:root{--button-default-color: #f5f5f5;--button-default-text-color: #555;--button-primary-color: var(--color-primary);--button-danger-color: var(--color-danger);--button-success-color: var(--color-success);--button-warning-color: var(--color-warning);--button-info-color: var(--color-info);--button-disabled-color: var(--color-disabled);--button-disabled-text-color: var(--color-text-disabled);--button-border-radius: 4px;--button-mini-padding: 0 9px;--button-small-padding: 0 11px;--button-normal-padding: 0 15px;--button-large-padding: 0 22px;--button-round-padding: 6px;--button-mini-height: 20px;--button-small-height: 28px;--button-normal-height: 36px;--button-large-height: 44px;--button-mini-font-size: var(--font-size-xs);--button-small-font-size: var(--font-size-sm);--button-normal-font-size: var(--font-size-md);--button-large-font-size: var(--font-size-lg)}.var-button{position:relative;justify-content:center;align-items:center;outline:none;border:none;border-radius:var(--button-border-radius);-webkit-user-select:none;user-select:none;cursor:pointer;font-family:inherit;transition:box-shadow .2s,background-color .25s;will-change:box-shadow;-webkit-tap-highlight-color:rgba(0,0,0,0);white-space:nowrap}.var-button:active{box-shadow:0 3px 5px -1px var(--shadow-key-umbra-opacity),0 5px 8px 0 var(--shadow-key-penumbra-opacity),0 1px 14px 0 var(--shadow-key-ambient-opacity)}.var-button__content{display:flex;align-items:center;flex-wrap:wrap}.var-button__loading[var-button-cover]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}.var-button--default{color:var(--button-default-text-color);background-color:var(--button-default-color)}.var-button--primary{color:#fff;background-color:var(--button-primary-color)}.var-button--info{color:#fff;background-color:var(--button-info-color)}.var-button--success{color:#fff;background-color:var(--button-success-color)}.var-button--warning{color:#fff;background-color:var(--button-warning-color)}.var-button--danger{color:#fff;background-color:var(--button-danger-color)}.var-button--disabled{background-color:var(--button-disabled-color);color:var(--button-disabled-text-color);cursor:not-allowed;box-shadow:none!important}.var-button--block{width:100%}.var-button--text{background-color:transparent}.var-button--text:active{box-shadow:none}.var-button--text-default{color:inherit}.var-button--text-primary{color:var(--button-primary-color)}.var-button--text-info{color:var(--button-info-color)}.var-button--text-success{color:var(--button-success-color)}.var-button--text-warning{color:var(--button-warning-color)}.var-button--text-danger{color:var(--button-danger-color)}.var-button--text-disabled{color:var(--button-disabled-text-color)}.var-button--normal{height:var(--button-normal-height);padding:var(--button-normal-padding);font-size:var(--button-normal-font-size)}.var-button--large{height:var(--button-large-height);padding:var(--button-large-padding);font-size:var(--button-large-font-size)}.var-button--small{height:var(--button-small-height);padding:var(--button-small-padding);font-size:var(--button-small-font-size)}.var-button--mini{height:var(--button-mini-height);padding:var(--button-mini-padding);font-size:var(--button-mini-font-size)}.var-button--round{padding:var(--button-round-padding);border-radius:50%;height:auto}.var-button--outline{border:thin solid currentColor}.var-button--hidden{opacity:0}.var-drag{position:fixed;display:inline-flex}.var-drag--transition{transition:transform .2s linear}:root{--fab-top: 70px;--fab-bottom: 16px;--fab-left: 16px;--fab-right: 16px;--fab-trigger-size: 56px;--fab-trigger-inactive-icon-size: 26px;--fab-trigger-active-icon-size: 22px;--fab-actions-padding: 10px 0;--fab-action-margin: 6px;--fab-transition-standard-easing: cubic-bezier(.4, 0, .2, 1)}.var-fab-transition-default-enter-active,.var-fab-transition-default-leave-active{transition:.3s var(--fab-transition-standard-easing)!important}.var-fab__trigger[var-fab-cover]{width:var(--fab-trigger-size);height:var(--fab-trigger-size)}.var-fab__trigger-inactive-icon[var-fab-cover]{font-size:var(--fab-trigger-inactive-icon-size)}.var-fab__trigger-active-icon[var-fab-cover]{font-size:var(--fab-trigger-active-icon-size)}.var-fab__actions{position:absolute;display:flex;justify-content:center;align-items:center;padding:var(--fab-actions-padding)}.var-fab__action{margin:var(--fab-action-margin)}.var-fab--position-left-top{top:var(--fab-top);left:var(--fab-left)}.var-fab--position-right-top{top:var(--fab-top);right:var(--fab-right)}.var-fab--position-left-bottom{bottom:var(--fab-bottom);left:var(--fab-left)}.var-fab--position-right-bottom{bottom:var(--fab-bottom);right:var(--fab-right)}.var-fab--direction-left .var-fab__actions,.var-fab--direction-right .var-fab__actions{height:100%;top:0;padding:0 var(--fab-actions-padding)}.var-fab--direction-left .var-fab__actions{flex-direction:row-reverse;right:100%}.var-fab--direction-right .var-fab__actions{flex-direction:row;left:100%}.var-fab--direction-top .var-fab__actions,.var-fab--direction-bottom .var-fab__actions{width:100%;left:0}.var-fab--direction-top .var-fab__actions{flex-direction:column-reverse;bottom:100%}.var-fab--direction-bottom .var-fab__actions{flex-direction:column;top:100%}.var-fab--fixed{position:fixed}.var-fab--absolute{position:absolute}.var-fab--active-transition-enter-active,.var-fab--active-transition-leave-active{transition:.3s var(--fab-transition-standard-easing)!important}.var-fab--active-transition-enter-from,.var-fab--active-transition-leave-to{transform:scale(0)}.var-fab--actions-transition-top-enter-active,.var-fab--actions-transition-top-leave-active{transition:.3s var(--fab-transition-standard-easing)!important}.var-fab--actions-transition-top-enter-from,.var-fab--actions-transition-top-leave-to{opacity:0;transform:translateY(40px)}.var-fab--actions-transition-bottom-enter-active,.var-fab--actions-transition-bottom-leave-active{transition:.3s var(--fab-transition-standard-easing)!important}.var-fab--actions-transition-bottom-enter-from,.var-fab--actions-transition-bottom-leave-to{opacity:0;transform:translateY(-40px)}.var-fab--actions-transition-left-enter-active,.var-fab--actions-transition-left-leave-active{transition:.3s var(--fab-transition-standard-easing)!important}.var-fab--actions-transition-left-enter-from,.var-fab--actions-transition-left-leave-to{opacity:0;transform:translate(40px)}.var-fab--actions-transition-right-enter-active,.var-fab--actions-transition-right-leave-active{transition:.3s var(--fab-transition-standard-easing)!important}.var-fab--actions-transition-right-enter-from,.var-fab--actions-transition-right-leave-to{opacity:0;transform:translate(-40px)}.var-fab--trigger-icon-animation{transform:scale(.4);opacity:0;transition-property:transform,opacity}.var-fab--safe-area{margin-bottom:constant(safe-area-inset-bottom);margin-bottom:env(safe-area-inset-bottom)}:root{--badge-content-padding: 2px 6px;--badge-icon-size: 12px;--badge-default-color: #e0e0e0;--badge-primary-color: var(--color-primary);--badge-danger-color: var(--color-danger);--badge-success-color: var(--color-success);--badge-warning-color: var(--color-warning);--badge-info-color: var(--color-info)}.var-badge{display:inline-block;position:relative;transition:background-color .25s}.var-badge__content{color:#fff;border-radius:100px;font-size:12px;padding:2px 6px;vertical-align:middle;text-align:center;display:inline-block}.var-badge__icon[var-badge-cover]{font-size:var(--badge-icon-size)}.var-badge--icon{padding:2px 4px}.var-badge--dot{box-sizing:content-box;width:8px;height:8px;border-radius:8px;padding:0}.var-badge--default{background:var(--badge-default-color)}.var-badge--primary{background:var(--badge-primary-color)}.var-badge--info{background:var(--badge-info-color)}.var-badge--warning{background:var(--badge-warning-color)}.var-badge--success{background:var(--badge-success-color)}.var-badge--danger{background:var(--badge-danger-color)}.var-badge--right-top{position:absolute;top:0;right:0;transform:translateY(-50%) translate(50%)}.var-badge--left-top{position:absolute;top:0;left:0;transform:translateY(-50%) translate(-50%)}.var-badge--right-bottom{position:absolute;bottom:0;right:0;transform:translateY(50%) translate(50%)}.var-badge--left-bottom{position:absolute;bottom:0;left:0;transform:translateY(50%) translate(-50%)}.var-badge-fade-enter-active,.var-badge-fade-leave-active{transition:opacity .15s var(--cubic-bezier)}.var-badge-fade-enter-from,.var-badge-fade-leave-to{opacity:0}.var-hover-overlay{position:absolute;top:0;left:0;right:0;bottom:0;border-radius:inherit;background-color:currentColor;opacity:0;transition:opacity .15s;will-change:opacity;pointer-events:none}.var-hover-overlay--hovering{opacity:.15}:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","\u5FAE\u8F6F\u96C5\u9ED1",Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:.3s;--el-transition-duration-fast:.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(.645, .045, .355, 1);--el-transition-function-fast-bezier:cubic-bezier(.23, 1, .32, 1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px}:root{color-scheme:light;--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary:#409eff;--el-color-primary-light-3:#79bbff;--el-color-primary-light-5:#a0cfff;--el-color-primary-light-7:#c6e2ff;--el-color-primary-light-8:#d9ecff;--el-color-primary-light-9:#ecf5ff;--el-color-primary-dark-2:#337ecc;--el-color-success:#67c23a;--el-color-success-light-3:#95d475;--el-color-success-light-5:#b3e19d;--el-color-success-light-7:#d1edc4;--el-color-success-light-8:#e1f3d8;--el-color-success-light-9:#f0f9eb;--el-color-success-dark-2:#529b2e;--el-color-warning:#e6a23c;--el-color-warning-light-3:#eebe77;--el-color-warning-light-5:#f3d19e;--el-color-warning-light-7:#f8e3c5;--el-color-warning-light-8:#faecd8;--el-color-warning-light-9:#fdf6ec;--el-color-warning-dark-2:#b88230;--el-color-danger:#f56c6c;--el-color-danger-light-3:#f89898;--el-color-danger-light-5:#fab6b6;--el-color-danger-light-7:#fcd3d3;--el-color-danger-light-8:#fde2e2;--el-color-danger-light-9:#fef0f0;--el-color-danger-dark-2:#c45656;--el-color-error:#f56c6c;--el-color-error-light-3:#f89898;--el-color-error-light-5:#fab6b6;--el-color-error-light-7:#fcd3d3;--el-color-error-light-8:#fde2e2;--el-color-error-light-9:#fef0f0;--el-color-error-dark-2:#c45656;--el-color-info:#909399;--el-color-info-light-3:#b1b3b8;--el-color-info-light-5:#c8c9cc;--el-color-info-light-7:#dedfe0;--el-color-info-light-8:#e9e9eb;--el-color-info-light-9:#f4f4f5;--el-color-info-dark-2:#73767a;--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0, 0, 0, .04),0px 8px 20px rgba(0, 0, 0, .08);--el-box-shadow-light:0px 0px 12px rgba(0, 0, 0, .12);--el-box-shadow-lighter:0px 0px 6px rgba(0, 0, 0, .12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0, 0, 0, .08),0px 12px 32px rgba(0, 0, 0, .12),0px 8px 16px -8px rgba(0, 0, 0, .16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0, 0, 0, .8);--el-overlay-color-light:rgba(0, 0, 0, .7);--el-overlay-color-lighter:rgba(0, 0, 0, .5);--el-mask-color:rgba(255, 255, 255, .9);--el-mask-color-extra-light:rgba(255, 255, 255, .3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:20px;--el-dialog-border-radius:var(--el-border-radius-small);position:relative;margin:var(--el-dialog-margin-top,15vh) auto 50px;background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:0!important}.el-dialog.is-align-center{margin:auto}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;margin-bottom:0;height:100%;overflow:auto}.el-dialog__wrapper{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto;margin:0}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-dialog__header{padding:var(--el-dialog-padding-primary);padding-bottom:10px;margin-right:16px}.el-dialog__headerbtn{position:absolute;top:6px;right:0;padding:0;width:54px;height:54px;background:0 0;border:none;outline:0;cursor:pointer;font-size:var(--el-message-close-size,16px)}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{line-height:var(--el-dialog-font-line-height);font-size:var(--el-dialog-title-font-size);color:var(--el-text-color-primary)}.el-dialog__body{padding:calc(var(--el-dialog-padding-primary) + 10px) var(--el-dialog-padding-primary);color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size)}.el-dialog__footer{padding:var(--el-dialog-padding-primary);padding-top:10px;text-align:right;box-sizing:border-box}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial;padding:25px calc(var(--el-dialog-padding-primary) + 5px) 30px}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-overlay-dialog{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto}.dialog-fade-enter-active{-webkit-animation:modal-fade-in var(--el-transition-duration);animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{-webkit-animation:dialog-fade-in var(--el-transition-duration);animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{-webkit-animation:modal-fade-out var(--el-transition-duration);animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{-webkit-animation:dialog-fade-out var(--el-transition-duration);animation:dialog-fade-out var(--el-transition-duration)}@-webkit-keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@-webkit-keyframes dialog-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}@keyframes dialog-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}@-webkit-keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@-webkit-keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}@keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}.el-overlay{position:fixed;top:0;right:0;bottom:0;left:0;z-index:2000;height:100%;background-color:var(--el-overlay-color-lighter);overflow:auto}.el-overlay .el-overlay-root{height:0}.el-container{display:flex;flex-direction:row;flex:1;flex-basis:auto;box-sizing:border-box;min-width:0}.el-container.is-vertical{flex-direction:column}.el-aside{overflow:auto;box-sizing:border-box;flex-shrink:0;width:var(--el-aside-width,300px)}.el-footer{--el-footer-padding:0 20px;--el-footer-height:60px;padding:var(--el-footer-padding);box-sizing:border-box;flex-shrink:0;height:var(--el-footer-height)}.el-header{--el-header-padding:0 20px;--el-header-height:60px;padding:var(--el-header-padding);box-sizing:border-box;flex-shrink:0;height:var(--el-header-height)}.el-main{--el-main-padding:20px;display:block;flex:1;flex-basis:auto;overflow:auto;box-sizing:border-box;padding:var(--el-main-padding)}.el-tabs{--el-tabs-header-height:40px}.el-tabs__header{padding:0;position:relative;margin:0 0 15px}.el-tabs__active-bar{position:absolute;bottom:0;left:0;height:2px;background-color:var(--el-color-primary);z-index:1;transition:width var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),transform var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);list-style:none}.el-tabs__new-tab{display:flex;align-items:center;justify-content:center;float:right;border:1px solid var(--el-border-color);height:20px;width:20px;line-height:20px;margin:10px 0 10px 10px;border-radius:3px;text-align:center;font-size:12px;color:var(--el-text-color-primary);cursor:pointer;transition:all .15s}.el-tabs__new-tab .is-icon-plus{height:inherit;width:inherit;transform:scale(.8)}.el-tabs__new-tab .is-icon-plus svg{vertical-align:middle}.el-tabs__new-tab:hover{color:var(--el-color-primary)}.el-tabs__nav-wrap{overflow:hidden;margin-bottom:-1px;position:relative}.el-tabs__nav-wrap:after{content:"";position:absolute;left:0;bottom:0;width:100%;height:2px;background-color:var(--el-border-color-light);z-index:var(--el-index-normal)}.el-tabs__nav-wrap.is-scrollable{padding:0 20px;box-sizing:border-box}.el-tabs__nav-scroll{overflow:hidden}.el-tabs__nav-next,.el-tabs__nav-prev{position:absolute;cursor:pointer;line-height:44px;font-size:12px;color:var(--el-text-color-secondary);width:20px;text-align:center}.el-tabs__nav-next{right:0}.el-tabs__nav-prev{left:0}.el-tabs__nav{display:flex;white-space:nowrap;position:relative;transition:transform var(--el-transition-duration);float:left;z-index:calc(var(--el-index-normal) + 1)}.el-tabs__nav.is-stretch{min-width:100%;display:flex}.el-tabs__nav.is-stretch>*{flex:1;text-align:center}.el-tabs__item{padding:0 20px;height:var(--el-tabs-header-height);box-sizing:border-box;display:flex;align-items:center;justify-content:center;list-style:none;font-size:var(--el-font-size-base);font-weight:500;color:var(--el-text-color-primary);position:relative}.el-tabs__item:focus,.el-tabs__item:focus:active{outline:0}.el-tabs__item:focus-visible{box-shadow:0 0 2px 2px var(--el-color-primary) inset;border-radius:3px}.el-tabs__item .is-icon-close{border-radius:50%;text-align:center;transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);margin-left:5px}.el-tabs__item .is-icon-close:before{transform:scale(.9);display:inline-block}.el-tabs__item .is-icon-close:hover{background-color:var(--el-text-color-placeholder);color:#fff}.el-tabs__item.is-active{color:var(--el-color-primary)}.el-tabs__item:hover{color:var(--el-color-primary);cursor:pointer}.el-tabs__item.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-tabs__content{overflow:hidden;position:relative}.el-tabs--card>.el-tabs__header{border-bottom:1px solid var(--el-border-color-light);height:var(--el-tabs-header-height)}.el-tabs--card>.el-tabs__header .el-tabs__nav-wrap:after{content:none}.el-tabs--card>.el-tabs__header .el-tabs__nav{border:1px solid var(--el-border-color-light);border-bottom:none;border-radius:4px 4px 0 0;box-sizing:border-box}.el-tabs--card>.el-tabs__header .el-tabs__active-bar{display:none}.el-tabs--card>.el-tabs__header .el-tabs__item .is-icon-close{position:relative;font-size:12px;width:0;height:14px;overflow:hidden;right:-2px;transform-origin:100% 50%}.el-tabs--card>.el-tabs__header .el-tabs__item{border-bottom:1px solid transparent;border-left:1px solid var(--el-border-color-light);transition:color var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),padding var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs--card>.el-tabs__header .el-tabs__item:first-child{border-left:none}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover{padding-left:13px;padding-right:13px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover .is-icon-close{width:14px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active{border-bottom-color:var(--el-bg-color)}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable{padding-left:20px;padding-right:20px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable .is-icon-close{width:14px}.el-tabs--border-card{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color)}.el-tabs--border-card>.el-tabs__content{padding:15px}.el-tabs--border-card>.el-tabs__header{background-color:var(--el-fill-color-light);border-bottom:1px solid var(--el-border-color-light);margin:0}.el-tabs--border-card>.el-tabs__header .el-tabs__nav-wrap:after{content:none}.el-tabs--border-card>.el-tabs__header .el-tabs__item{transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);border:1px solid transparent;margin-top:-1px;color:var(--el-text-color-secondary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item:first-child{margin-left:-1px}.el-tabs--border-card>.el-tabs__header .el-tabs__item+.el-tabs__item{margin-left:-1px}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-active{color:var(--el-color-primary);background-color:var(--el-bg-color-overlay);border-right-color:var(--el-border-color);border-left-color:var(--el-border-color)}.el-tabs--border-card>.el-tabs__header .el-tabs__item:not(.is-disabled):hover{color:var(--el-color-primary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-disabled{color:var(--el-disabled-text-color)}.el-tabs--border-card>.el-tabs__header .is-scrollable .el-tabs__item:first-child{margin-left:0}.el-tabs--bottom .el-tabs__item.is-bottom:nth-child(2),.el-tabs--bottom .el-tabs__item.is-top:nth-child(2),.el-tabs--top .el-tabs__item.is-bottom:nth-child(2),.el-tabs--top .el-tabs__item.is-top:nth-child(2){padding-left:0}.el-tabs--bottom .el-tabs__item.is-bottom:last-child,.el-tabs--bottom .el-tabs__item.is-top:last-child,.el-tabs--top .el-tabs__item.is-bottom:last-child,.el-tabs--top .el-tabs__item.is-top:last-child{padding-right:0}.el-tabs--bottom .el-tabs--left>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom .el-tabs--right>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top .el-tabs--left>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top .el-tabs--right>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2){padding-left:20px}.el-tabs--bottom .el-tabs--left>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--bottom .el-tabs--right>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--top .el-tabs--left>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--top .el-tabs--right>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover{padding-left:13px}.el-tabs--bottom .el-tabs--left>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom .el-tabs--right>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top .el-tabs--left>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top .el-tabs--right>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:last-child{padding-right:20px}.el-tabs--bottom .el-tabs--left>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--bottom .el-tabs--right>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--top .el-tabs--left>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--top .el-tabs--right>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover{padding-right:13px}.el-tabs--bottom .el-tabs__header.is-bottom{margin-bottom:0;margin-top:10px}.el-tabs--bottom.el-tabs--border-card .el-tabs__header.is-bottom{border-bottom:0;border-top:1px solid var(--el-border-color)}.el-tabs--bottom.el-tabs--border-card .el-tabs__nav-wrap.is-bottom{margin-top:-1px;margin-bottom:0}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom:not(.is-active){border:1px solid transparent}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom{margin:0 -1px -1px}.el-tabs--left,.el-tabs--right{overflow:hidden}.el-tabs--left .el-tabs__header.is-left,.el-tabs--left .el-tabs__header.is-right,.el-tabs--left .el-tabs__nav-scroll,.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__header.is-left,.el-tabs--right .el-tabs__header.is-right,.el-tabs--right .el-tabs__nav-scroll,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{height:100%}.el-tabs--left .el-tabs__active-bar.is-left,.el-tabs--left .el-tabs__active-bar.is-right,.el-tabs--right .el-tabs__active-bar.is-left,.el-tabs--right .el-tabs__active-bar.is-right{top:0;bottom:auto;width:2px;height:auto}.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{margin-bottom:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{height:30px;line-height:30px;width:100%;text-align:center;cursor:pointer}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i{transform:rotate(90deg)}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{left:auto;top:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next{right:auto;bottom:0}.el-tabs--left .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--left .el-tabs__nav-wrap.is-right.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-right.is-scrollable{padding:30px 0}.el-tabs--left .el-tabs__nav-wrap.is-left:after,.el-tabs--left .el-tabs__nav-wrap.is-right:after,.el-tabs--right .el-tabs__nav-wrap.is-left:after,.el-tabs--right .el-tabs__nav-wrap.is-right:after{height:100%;width:2px;bottom:auto;top:0}.el-tabs--left .el-tabs__nav.is-left,.el-tabs--left .el-tabs__nav.is-right,.el-tabs--right .el-tabs__nav.is-left,.el-tabs--right .el-tabs__nav.is-right{flex-direction:column}.el-tabs--left .el-tabs__item.is-left,.el-tabs--right .el-tabs__item.is-left{justify-content:flex-end}.el-tabs--left .el-tabs__item.is-right,.el-tabs--right .el-tabs__item.is-right{justify-content:flex-start}.el-tabs--left .el-tabs__header.is-left{float:left;margin-bottom:0;margin-right:10px}.el-tabs--left .el-tabs__nav-wrap.is-left{margin-right:-1px}.el-tabs--left .el-tabs__nav-wrap.is-left:after{left:auto;right:0}.el-tabs--left .el-tabs__active-bar.is-left{right:0;left:auto}.el-tabs--left .el-tabs__item.is-left{text-align:right}.el-tabs--left.el-tabs--card .el-tabs__active-bar.is-left{display:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left{border-left:none;border-right:1px solid var(--el-border-color-light);border-bottom:none;border-top:1px solid var(--el-border-color-light);text-align:left}.el-tabs--left.el-tabs--card .el-tabs__item.is-left:first-child{border-right:1px solid var(--el-border-color-light);border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active{border:1px solid var(--el-border-color-light);border-right-color:#fff;border-left:none;border-bottom:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:first-child{border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:last-child{border-bottom:none}.el-tabs--left.el-tabs--card .el-tabs__nav{border-radius:4px 0 0 4px;border-bottom:1px solid var(--el-border-color-light);border-right:none}.el-tabs--left.el-tabs--card .el-tabs__new-tab{float:none}.el-tabs--left.el-tabs--border-card .el-tabs__header.is-left{border-right:1px solid var(--el-border-color)}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left{border:1px solid transparent;margin:-1px 0 -1px -1px}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left.is-active{border-color:transparent;border-top-color:#d1dbe5;border-bottom-color:#d1dbe5}.el-tabs--right .el-tabs__header.is-right{float:right;margin-bottom:0;margin-left:10px}.el-tabs--right .el-tabs__nav-wrap.is-right{margin-left:-1px}.el-tabs--right .el-tabs__nav-wrap.is-right:after{left:0;right:auto}.el-tabs--right .el-tabs__active-bar.is-right{left:0}.el-tabs--right.el-tabs--card .el-tabs__active-bar.is-right{display:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right{border-bottom:none;border-top:1px solid var(--el-border-color-light)}.el-tabs--right.el-tabs--card .el-tabs__item.is-right:first-child{border-left:1px solid var(--el-border-color-light);border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active{border:1px solid var(--el-border-color-light);border-left-color:#fff;border-right:none;border-bottom:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:first-child{border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:last-child{border-bottom:none}.el-tabs--right.el-tabs--card .el-tabs__nav{border-radius:0 4px 4px 0;border-bottom:1px solid var(--el-border-color-light);border-left:none}.el-tabs--right.el-tabs--border-card .el-tabs__header.is-right{border-left:1px solid var(--el-border-color)}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right{border:1px solid transparent;margin:-1px -1px -1px 0}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right.is-active{border-color:transparent;border-top-color:#d1dbe5;border-bottom-color:#d1dbe5}.slideInLeft-transition,.slideInRight-transition{display:inline-block}.slideInRight-enter{-webkit-animation:slideInRight-enter var(--el-transition-duration);animation:slideInRight-enter var(--el-transition-duration)}.slideInRight-leave{position:absolute;left:0;right:0;-webkit-animation:slideInRight-leave var(--el-transition-duration);animation:slideInRight-leave var(--el-transition-duration)}.slideInLeft-enter{-webkit-animation:slideInLeft-enter var(--el-transition-duration);animation:slideInLeft-enter var(--el-transition-duration)}.slideInLeft-leave{position:absolute;left:0;right:0;-webkit-animation:slideInLeft-leave var(--el-transition-duration);animation:slideInLeft-leave var(--el-transition-duration)}@-webkit-keyframes slideInRight-enter{0%{opacity:0;transform-origin:0 0;transform:translate(100%)}to{opacity:1;transform-origin:0 0;transform:translate(0)}}@keyframes slideInRight-enter{0%{opacity:0;transform-origin:0 0;transform:translate(100%)}to{opacity:1;transform-origin:0 0;transform:translate(0)}}@-webkit-keyframes slideInRight-leave{0%{transform-origin:0 0;transform:translate(0);opacity:1}to{transform-origin:0 0;transform:translate(100%);opacity:0}}@keyframes slideInRight-leave{0%{transform-origin:0 0;transform:translate(0);opacity:1}to{transform-origin:0 0;transform:translate(100%);opacity:0}}@-webkit-keyframes slideInLeft-enter{0%{opacity:0;transform-origin:0 0;transform:translate(-100%)}to{opacity:1;transform-origin:0 0;transform:translate(0)}}@keyframes slideInLeft-enter{0%{opacity:0;transform-origin:0 0;transform:translate(-100%)}to{opacity:1;transform-origin:0 0;transform:translate(0)}}@-webkit-keyframes slideInLeft-leave{0%{transform-origin:0 0;transform:translate(0);opacity:1}to{transform-origin:0 0;transform:translate(-100%);opacity:0}}@keyframes slideInLeft-leave{0%{transform-origin:0 0;transform:translate(0);opacity:1}to{transform-origin:0 0;transform:translate(-100%);opacity:0}}.el-icon-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@-webkit-keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.el-icon{--color:inherit;height:1em;width:1em;line-height:1em;display:inline-flex;justify-content:center;align-items:center;position:relative;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}.hover-button-container[data-v-8b0631ff]{position:relative!important;width:24px;aspect-ratio:1;display:flex;justify-content:center;align-items:center;cursor:pointer}.hover-button-container>*[data-v-8b0631ff]{position:absolute;display:flex;justify-content:center;align-items:center}.hover-button-container-enter-active[data-v-8b0631ff],.hover-button-container-leave-active[data-v-8b0631ff]{transition:opacity .5s ease}.hover-button-container-enter-from[data-v-8b0631ff],.hover-button-container-leave-to[data-v-8b0631ff]{opacity:0}.el-checkbox{--el-checkbox-font-size:14px;--el-checkbox-font-weight:var(--el-font-weight-primary);--el-checkbox-text-color:var(--el-text-color-regular);--el-checkbox-input-height:14px;--el-checkbox-input-width:14px;--el-checkbox-border-radius:var(--el-border-radius-small);--el-checkbox-bg-color:var(--el-fill-color-blank);--el-checkbox-input-border:var(--el-border);--el-checkbox-disabled-border-color:var(--el-border-color);--el-checkbox-disabled-input-fill:var(--el-fill-color-light);--el-checkbox-disabled-icon-color:var(--el-text-color-placeholder);--el-checkbox-disabled-checked-input-fill:var(--el-border-color-extra-light);--el-checkbox-disabled-checked-input-border-color:var(--el-border-color);--el-checkbox-disabled-checked-icon-color:var(--el-text-color-placeholder);--el-checkbox-checked-text-color:var(--el-color-primary);--el-checkbox-checked-input-border-color:var(--el-color-primary);--el-checkbox-checked-bg-color:var(--el-color-primary);--el-checkbox-checked-icon-color:var(--el-color-white);--el-checkbox-input-border-color-hover:var(--el-color-primary)}.el-checkbox{color:var(--el-checkbox-text-color);font-weight:var(--el-checkbox-font-weight);font-size:var(--el-font-size-base);position:relative;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin-right:30px;height:var(--el-checkbox-height,32px)}.el-checkbox.is-disabled{cursor:not-allowed}.el-checkbox.is-bordered{padding:0 15px 0 9px;border-radius:var(--el-border-radius-base);border:var(--el-border);box-sizing:border-box}.el-checkbox.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-checkbox.is-bordered.is-disabled{border-color:var(--el-border-color-lighter)}.el-checkbox.is-bordered.el-checkbox--large{padding:0 19px 0 11px;border-radius:var(--el-border-radius-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__label{font-size:var(--el-font-size-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.is-bordered.el-checkbox--small{padding:0 11px 0 7px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox input:focus-visible+.el-checkbox__inner{outline:2px solid var(--el-checkbox-input-border-color-hover);outline-offset:1px;border-radius:var(--el-checkbox-border-radius)}.el-checkbox__input{white-space:nowrap;cursor:pointer;outline:0;display:inline-flex;position:relative}.el-checkbox__input.is-disabled .el-checkbox__inner{background-color:var(--el-checkbox-disabled-input-fill);border-color:var(--el-checkbox-disabled-border-color);cursor:not-allowed}.el-checkbox__input.is-disabled .el-checkbox__inner:after{cursor:not-allowed;border-color:var(--el-checkbox-disabled-icon-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-disabled-checked-icon-color);border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled+span.el-checkbox__label{color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox__input.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-checked .el-checkbox__inner:after{transform:rotate(45deg) scaleY(1);border-color:var(--el-checkbox-checked-icon-color)}.el-checkbox__input.is-checked+.el-checkbox__label{color:var(--el-checkbox-checked-text-color)}.el-checkbox__input.is-focus:not(.is-checked) .el-checkbox__original:not(:focus-visible){border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__input.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:before{content:"";position:absolute;display:block;background-color:var(--el-checkbox-checked-icon-color);height:2px;transform:scale(.5);left:0;right:0;top:5px}.el-checkbox__input.is-indeterminate .el-checkbox__inner:after{display:none}.el-checkbox__inner{display:inline-block;position:relative;border:var(--el-checkbox-input-border);border-radius:var(--el-checkbox-border-radius);box-sizing:border-box;width:var(--el-checkbox-input-width);height:var(--el-checkbox-input-height);background-color:var(--el-checkbox-bg-color);z-index:var(--el-index-normal);transition:border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46),outline .25s cubic-bezier(.71,-.46,.29,1.46)}.el-checkbox__inner:hover{border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__inner:after{box-sizing:content-box;content:"";border:1px solid transparent;border-left:0;border-top:0;height:7px;left:4px;position:absolute;top:1px;transform:rotate(45deg) scaleY(0);width:3px;transition:transform .15s ease-in 50ms;transform-origin:center}.el-checkbox__original{opacity:0;outline:0;position:absolute;margin:0;width:0;height:0;z-index:-1}.el-checkbox__label{display:inline-block;padding-left:8px;line-height:1;font-size:var(--el-checkbox-font-size)}.el-checkbox.el-checkbox--large{height:40px}.el-checkbox.el-checkbox--large .el-checkbox__label{font-size:14px}.el-checkbox.el-checkbox--large .el-checkbox__inner{width:14px;height:14px}.el-checkbox.el-checkbox--small{height:24px}.el-checkbox.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.el-checkbox--small .el-checkbox__inner{width:12px;height:12px}.el-checkbox.el-checkbox--small .el-checkbox__input.is-indeterminate .el-checkbox__inner:before{top:4px}.el-checkbox.el-checkbox--small .el-checkbox__inner:after{width:2px;height:6px}.el-checkbox:last-of-type{margin-right:0}.el-form{--el-form-label-font-size:var(--el-font-size-base);--el-form-inline-content-width:220px}.el-form--label-left .el-form-item__label{justify-content:flex-start}.el-form--label-top .el-form-item{display:block}.el-form--label-top .el-form-item .el-form-item__label{display:block;height:auto;text-align:left;margin-bottom:8px;line-height:22px}.el-form--inline .el-form-item{display:inline-flex;vertical-align:middle;margin-right:32px}.el-form--inline.el-form--label-top{display:flex;flex-wrap:wrap}.el-form--inline.el-form--label-top .el-form-item{display:block}.el-form--large.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:12px;line-height:22px}.el-form--default.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:8px;line-height:22px}.el-form--small.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:4px;line-height:20px}.el-form-item{display:flex;--font-size:14px;margin-bottom:18px}.el-form-item .el-form-item{margin-bottom:0}.el-form-item .el-input__validateIcon{display:none}.el-form-item--large{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:22px}.el-form-item--large .el-form-item__label{height:40px;line-height:40px}.el-form-item--large .el-form-item__content{line-height:40px}.el-form-item--large .el-form-item__error{padding-top:4px}.el-form-item--default{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--default .el-form-item__label{height:32px;line-height:32px}.el-form-item--default .el-form-item__content{line-height:32px}.el-form-item--default .el-form-item__error{padding-top:2px}.el-form-item--small{--font-size:12px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--small .el-form-item__label{height:24px;line-height:24px}.el-form-item--small .el-form-item__content{line-height:24px}.el-form-item--small .el-form-item__error{padding-top:2px}.el-form-item__label-wrap{display:flex}.el-form-item__label{display:inline-flex;justify-content:flex-end;align-items:flex-start;flex:0 0 auto;font-size:var(--el-form-label-font-size);color:var(--el-text-color-regular);height:32px;line-height:32px;padding:0 12px 0 0;box-sizing:border-box}.el-form-item__content{display:flex;flex-wrap:wrap;align-items:center;flex:1;line-height:32px;position:relative;font-size:var(--font-size);min-width:0}.el-form-item__content .el-input-group{vertical-align:top}.el-form-item__error{color:var(--el-color-danger);font-size:12px;line-height:1;padding-top:2px;position:absolute;top:100%;left:0}.el-form-item__error--inline{position:relative;top:auto;left:auto;display:inline-block;margin-left:10px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label-wrap>.el-form-item__label:before,.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label:before{content:"*";color:var(--el-color-danger);margin-right:4px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label-wrap>.el-form-item__label:after,.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label:after{content:"*";color:var(--el-color-danger);margin-left:4px}.el-form-item.is-error .el-select-v2__wrapper.is-focused{border-color:transparent}.el-form-item.is-error .el-select-v2__wrapper,.el-form-item.is-error .el-select-v2__wrapper:focus,.el-form-item.is-error .el-textarea__inner,.el-form-item.is-error .el-textarea__inner:focus{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input-group__append .el-input__wrapper,.el-form-item.is-error .el-input-group__prepend .el-input__wrapper{box-shadow:0 0 0 1px transparent inset}.el-form-item.is-error .el-input__validateIcon{color:var(--el-color-danger)}.el-form-item--feedback .el-input__validateIcon{display:inline-flex}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%}.el-textarea{position:relative;display:inline-block;width:100%;vertical-align:bottom;font-size:var(--el-font-size-base)}.el-textarea__inner{position:relative;display:block;resize:vertical;padding:5px 11px;line-height:1.5;box-sizing:border-box;width:100%;font-size:inherit;font-family:inherit;color:var(--el-input-text-color,var(--el-text-color-regular));background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;-webkit-appearance:none;box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));transition:var(--el-transition-box-shadow);border:none}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{outline:0;box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-textarea .el-input__count{color:var(--el-color-info);background:var(--el-fill-color-blank);position:absolute;font-size:12px;line-height:14px;bottom:5px;right:10px}.el-textarea.is-disabled .el-textarea__inner{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%}.el-input{--el-input-height:var(--el-component-size);position:relative;font-size:var(--el-font-size-base);display:inline-flex;width:var(--el-input-width);line-height:var(--el-input-height);box-sizing:border-box;vertical-align:middle}.el-input::-webkit-scrollbar{z-index:11;width:6px}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{border-radius:5px;width:6px;background:var(--el-text-color-disabled)}.el-input::-webkit-scrollbar-corner{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);font-size:14px;cursor:pointer}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{height:100%;display:inline-flex;align-items:center;color:var(--el-color-info);font-size:12px}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);line-height:initial;display:inline-block;padding-left:8px}.el-input__wrapper{display:inline-flex;flex-grow:1;align-items:center;justify-content:center;padding:1px 11px;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));cursor:text;transition:var(--el-transition-box-shadow);transform:translateZ(0);box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px);width:100%;flex-grow:1;-webkit-appearance:none;color:var(--el-input-text-color,var(--el-text-color-regular));font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);padding:0;outline:0;border:none;background:0 0;box-sizing:border-box}.el-input__inner:focus{outline:0}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__prefix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__prefix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__suffix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{height:inherit;line-height:inherit;display:flex;justify-content:center;align-items:center;transition:all var(--el-transition-duration);margin-left:8px}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color,) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{display:inline-flex;width:100%;align-items:stretch}.el-input-group__append,.el-input-group__prepend{background-color:var(--el-fill-color-light);color:var(--el-color-info);position:relative;display:inline-flex;align-items:center;justify-content:center;min-height:100%;border-radius:var(--el-input-border-radius);padding:0 20px;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:0}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-input__wrapper,.el-input-group__append div.el-select:hover .el-input__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-input__wrapper,.el-input-group__prepend div.el-select:hover .el-input__wrapper{border-color:transparent;background-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-right:0;border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-left:0;border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-input .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select .el-input .el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__wrapper{box-shadow:1px 0 0 0 var(--el-input-focus-border-color) inset,1px 0 0 0 var(--el-input-focus-border-color),0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important;z-index:2}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__wrapper:focus{outline:0;z-index:2;box-shadow:1px 0 0 0 var(--el-input-focus-border-color) inset,1px 0 0 0 var(--el-input-focus-border-color),0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important}.el-input-group--prepend .el-input-group__prepend .el-select:hover .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select:hover .el-input__wrapper{z-index:1;box-shadow:1px 0 0 0 var(--el-input-hover-border-color) inset,1px 0 0 0 var(--el-input-hover-border-color),0 1px 0 0 var(--el-input-hover-border-color) inset,0 -1px 0 0 var(--el-input-hover-border-color) inset!important}.el-input-group--append>.el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-input .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select .el-input .el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--append .el-input-group__append .el-select .el-input.is-focus .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select .el-input.is-focus .el-input__wrapper{z-index:2;box-shadow:-1px 0 0 0 var(--el-input-focus-border-color),-1px 0 0 0 var(--el-input-focus-border-color) inset,0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important}.el-input-group--append .el-input-group__append .el-select:hover .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select:hover .el-input__wrapper{z-index:1;box-shadow:-1px 0 0 0 var(--el-input-hover-border-color),-1px 0 0 0 var(--el-input-hover-border-color) inset,0 1px 0 0 var(--el-input-hover-border-color) inset,0 -1px 0 0 var(--el-input-hover-border-color) inset!important}.el-tag{--el-tag-font-size:12px;--el-tag-border-radius:4px;--el-tag-border-radius-rounded:9999px}.el-tag{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary);--el-tag-text-color:var(--el-color-primary);background-color:var(--el-tag-bg-color);border-color:var(--el-tag-border-color);color:var(--el-tag-text-color);display:inline-flex;justify-content:center;align-items:center;vertical-align:middle;height:24px;padding:0 9px;font-size:var(--el-tag-font-size);line-height:1;border-width:1px;border-style:solid;border-radius:var(--el-tag-border-radius);box-sizing:border-box;white-space:nowrap;--el-icon-size:14px}.el-tag.el-tag--primary{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-bg-color:var(--el-color-success-light-9);--el-tag-border-color:var(--el-color-success-light-8);--el-tag-hover-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-bg-color:var(--el-color-warning-light-9);--el-tag-border-color:var(--el-color-warning-light-8);--el-tag-hover-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-bg-color:var(--el-color-danger-light-9);--el-tag-border-color:var(--el-color-danger-light-8);--el-tag-hover-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-bg-color:var(--el-color-error-light-9);--el-tag-border-color:var(--el-color-error-light-8);--el-tag-hover-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-bg-color:var(--el-color-info-light-9);--el-tag-border-color:var(--el-color-info-light-8);--el-tag-hover-color:var(--el-color-info)}.el-tag.el-tag--primary{--el-tag-text-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-text-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-text-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-text-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-text-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-text-color:var(--el-color-info)}.el-tag.is-hit{border-color:var(--el-color-primary)}.el-tag.is-round{border-radius:var(--el-tag-border-radius-rounded)}.el-tag .el-tag__close{color:var(--el-tag-text-color)}.el-tag .el-tag__close:hover{color:var(--el-color-white);background-color:var(--el-tag-hover-color)}.el-tag .el-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--el-icon-size) - 2px);height:var(--el-icon-size);width:var(--el-icon-size)}.el-tag .el-tag__close{margin-left:6px}.el-tag--dark{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3);--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--primary{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3)}.el-tag--dark.el-tag--success{--el-tag-bg-color:var(--el-color-success);--el-tag-border-color:var(--el-color-success);--el-tag-hover-color:var(--el-color-success-light-3)}.el-tag--dark.el-tag--warning{--el-tag-bg-color:var(--el-color-warning);--el-tag-border-color:var(--el-color-warning);--el-tag-hover-color:var(--el-color-warning-light-3)}.el-tag--dark.el-tag--danger{--el-tag-bg-color:var(--el-color-danger);--el-tag-border-color:var(--el-color-danger);--el-tag-hover-color:var(--el-color-danger-light-3)}.el-tag--dark.el-tag--error{--el-tag-bg-color:var(--el-color-error);--el-tag-border-color:var(--el-color-error);--el-tag-hover-color:var(--el-color-error-light-3)}.el-tag--dark.el-tag--info{--el-tag-bg-color:var(--el-color-info);--el-tag-border-color:var(--el-color-info);--el-tag-hover-color:var(--el-color-info-light-3)}.el-tag--dark.el-tag--primary,.el-tag--dark.el-tag--success,.el-tag--dark.el-tag--warning,.el-tag--dark.el-tag--danger,.el-tag--dark.el-tag--error,.el-tag--dark.el-tag--info{--el-tag-text-color:var(--el-color-white)}.el-tag--plain{--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary);--el-tag-bg-color:var(--el-fill-color-blank)}.el-tag--plain.el-tag--primary{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary)}.el-tag--plain.el-tag--success{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-success-light-5);--el-tag-hover-color:var(--el-color-success)}.el-tag--plain.el-tag--warning{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-warning-light-5);--el-tag-hover-color:var(--el-color-warning)}.el-tag--plain.el-tag--danger{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-danger-light-5);--el-tag-hover-color:var(--el-color-danger)}.el-tag--plain.el-tag--error{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-error-light-5);--el-tag-hover-color:var(--el-color-error)}.el-tag--plain.el-tag--info{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-info-light-5);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-closable{padding-right:5px}.el-tag--large{padding:0 11px;height:32px;--el-icon-size:16px}.el-tag--large .el-tag__close{margin-left:8px}.el-tag--large.is-closable{padding-right:7px}.el-tag--small{padding:0 7px;height:20px;--el-icon-size:12px}.el-tag--small .el-tag__close{margin-left:4px}.el-tag--small.is-closable{padding-right:3px}.el-tag--small .el-icon-close{transform:scale(.8)}.el-tag.el-tag--primary.is-hit{border-color:var(--el-color-primary)}.el-tag.el-tag--success.is-hit{border-color:var(--el-color-success)}.el-tag.el-tag--warning.is-hit{border-color:var(--el-color-warning)}.el-tag.el-tag--danger.is-hit{border-color:var(--el-color-danger)}.el-tag.el-tag--error.is-hit{border-color:var(--el-color-error)}.el-tag.el-tag--info.is-hit{border-color:var(--el-color-info)}.el-select-dropdown__item{font-size:var(--el-font-size-base);padding:0 32px 0 20px;position:relative;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--el-text-color-regular);height:34px;line-height:34px;box-sizing:border-box;cursor:pointer}.el-select-dropdown__item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select-dropdown__item.hover,.el-select-dropdown__item:hover{background-color:var(--el-fill-color-light)}.el-select-dropdown__item.selected{color:var(--el-color-primary);font-weight:700}.el-scrollbar{--el-scrollbar-opacity:.3;--el-scrollbar-bg-color:var(--el-text-color-secondary);--el-scrollbar-hover-opacity:.5;--el-scrollbar-hover-bg-color:var(--el-text-color-secondary)}.el-scrollbar{overflow:hidden;position:relative;height:100%}.el-scrollbar__wrap{overflow:auto;height:100%}.el-scrollbar__wrap--hidden-default{scrollbar-width:none}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.el-scrollbar__thumb{position:relative;display:block;width:0;height:0;cursor:pointer;border-radius:inherit;background-color:var(--el-scrollbar-bg-color,var(--el-text-color-secondary));transition:var(--el-transition-duration) background-color;opacity:var(--el-scrollbar-opacity,.3)}.el-scrollbar__thumb:hover{background-color:var(--el-scrollbar-hover-bg-color,var(--el-text-color-secondary));opacity:var(--el-scrollbar-hover-opacity,.5)}.el-scrollbar__bar{position:absolute;right:2px;bottom:2px;z-index:1;border-radius:4px}.el-scrollbar__bar.is-vertical{width:6px;top:2px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar-fade-enter-active{transition:opacity .34s ease-out}.el-scrollbar-fade-leave-active{transition:opacity .12s ease-out}.el-scrollbar-fade-enter-from,.el-scrollbar-fade-leave-active{opacity:0}.el-popper{--el-popper-border-radius:var(--el-popover-border-radius, 4px)}.el-popper{position:absolute;border-radius:var(--el-popper-border-radius);padding:5px 11px;z-index:2000;font-size:12px;line-height:20px;min-width:10px;word-wrap:break-word;visibility:visible}.el-popper.is-dark{color:var(--el-bg-color);background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary)}.el-popper.is-dark .el-popper__arrow:before{border:1px solid var(--el-text-color-primary);background:var(--el-text-color-primary);right:0}.el-popper.is-light{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light .el-popper__arrow:before{border:1px solid var(--el-border-color-light);background:var(--el-bg-color-overlay);right:0}.el-popper.is-pure{padding:0}.el-popper__arrow{position:absolute;width:10px;height:10px;z-index:-1}.el-popper__arrow:before{position:absolute;width:10px;height:10px;z-index:-1;content:" ";transform:rotate(45deg);background:var(--el-text-color-primary);box-sizing:border-box}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent!important;border-bottom-color:transparent!important}.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent!important;border-top-color:transparent!important}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected{color:var(--el-color-primary);background-color:var(--el-bg-color-overlay)}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected.hover{background-color:var(--el-fill-color-light)}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected:after{content:"";position:absolute;top:50%;right:20px;border-top:none;border-right:none;background-repeat:no-repeat;background-position:center;background-color:var(--el-color-primary);-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;transform:translateY(-50%);width:12px;height:12px}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected.is-disabled:after{background-color:var(--el-text-color-disabled)}.el-select-dropdown .el-select-dropdown__option-item.is-selected:after{content:"";position:absolute;top:50%;right:20px;border-top:none;border-right:none;background-repeat:no-repeat;background-position:center;background-color:var(--el-color-primary);-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;transform:translateY(-50%);width:12px;height:12px}.el-select-dropdown .el-select-dropdown__item.is-disabled:hover{background-color:unset}.el-select-dropdown .el-select-dropdown__item.is-disabled.selected{color:var(--el-text-color-disabled)}.el-select-dropdown__list{list-style:none;padding:6px 0;margin:0;box-sizing:border-box}.el-select{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px}.el-select{display:inline-block;position:relative;vertical-align:middle;line-height:32px}.el-select__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-select__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-select__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent;border-left-color:transparent}.el-select__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-select__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent;border-bottom-color:transparent}.el-select__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-select .el-select-tags-wrapper.has-prefix{margin-left:6px}.el-select--large{line-height:40px}.el-select--large .el-select-tags-wrapper.has-prefix{margin-left:8px}.el-select--small{line-height:24px}.el-select--small .el-select-tags-wrapper.has-prefix{margin-left:4px}.el-select .el-select__tags>span{display:inline-block}.el-select:hover:not(.el-select--disabled) .el-input__wrapper{box-shadow:0 0 0 1px var(--el-select-border-color-hover) inset}.el-select .el-select__tags-text{display:inline-block;line-height:normal;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select .el-input__wrapper{cursor:pointer}.el-select .el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-select-input-focus-border-color) inset!important}.el-select .el-input__inner{cursor:pointer}.el-select .el-input{display:flex}.el-select .el-input .el-select__caret{color:var(--el-select-input-color);font-size:var(--el-select-input-font-size);transition:transform var(--el-transition-duration);transform:rotate(0);cursor:pointer}.el-select .el-input .el-select__caret.is-reverse{transform:rotate(-180deg)}.el-select .el-input .el-select__caret.is-show-close{font-size:var(--el-select-font-size);text-align:center;transform:rotate(0);border-radius:var(--el-border-radius-circle);color:var(--el-select-input-color);transition:var(--el-transition-color)}.el-select .el-input .el-select__caret.is-show-close:hover{color:var(--el-select-close-hover-color)}.el-select .el-input .el-select__caret.el-icon{position:relative;height:inherit;z-index:2}.el-select .el-input.is-disabled .el-input__wrapper{cursor:not-allowed}.el-select .el-input.is-disabled .el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select .el-input.is-disabled .el-input__inner,.el-select .el-input.is-disabled .el-select__caret{cursor:not-allowed}.el-select .el-input.is-focus .el-input__wrapper{box-shadow:0 0 0 1px var(--el-select-input-focus-border-color) inset!important}.el-select__input{border:none;outline:0;padding:0;margin-left:15px;color:var(--el-select-multiple-input-color);font-size:var(--el-select-font-size);-webkit-appearance:none;-moz-appearance:none;appearance:none;height:28px;background-color:transparent}.el-select__input.is-disabled{cursor:not-allowed}.el-select__input--iOS{position:absolute;left:0;top:0;z-index:6}.el-select__input.is-small{height:14px}.el-select__close{cursor:pointer;position:absolute;top:8px;z-index:var(--el-index-top);right:25px;color:var(--el-select-input-color);line-height:18px;font-size:var(--el-select-input-font-size)}.el-select__close:hover{color:var(--el-select-close-hover-color)}.el-select__tags{position:absolute;line-height:normal;top:50%;transform:translateY(-50%);white-space:normal;z-index:var(--el-index-normal);display:flex;align-items:center;flex-wrap:wrap;cursor:pointer}.el-select__tags .el-tag{box-sizing:border-box;border-color:transparent;margin:2px 6px 2px 0}.el-select__tags .el-tag:last-child{margin-right:0}.el-select__tags .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);right:-7px;top:0;color:#fff}.el-select__tags .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-select__tags .el-tag .el-icon-close:before{display:block;transform:translateY(.5px)}.el-select__tags .el-tag--info{background-color:var(--el-fill-color)}.el-select__tags.is-disabled{cursor:not-allowed}.el-select__collapse-tags{white-space:normal;z-index:var(--el-index-normal);display:flex;align-items:center;flex-wrap:wrap;cursor:pointer}.el-select__collapse-tags .el-tag{box-sizing:border-box;border-color:transparent;margin:2px 6px 2px 0}.el-select__collapse-tags .el-tag:last-child{margin-right:0}.el-select__collapse-tags .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);right:-7px;top:0;color:#fff}.el-select__collapse-tags .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-select__collapse-tags .el-tag .el-icon-close:before{display:block;transform:translateY(.5px)}.el-select__collapse-tags .el-tag--info{background-color:var(--el-fill-color)}.el-select__collapse-tag{line-height:inherit;height:inherit;display:flex}.side-button[data-v-d0fd7022]{position:relative;width:24px;aspect-ratio:1;display:flex;justify-content:center;align-items:center;font-size:18px}.side-button.add-match-item[data-v-d0fd7022]{color:green}.side-button.remove-match-item[data-v-d0fd7022]{color:red}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center top}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center bottom}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transition:var(--el-transition-md-fade);transform-origin:top left}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-tree{--el-tree-node-content-height:26px;--el-tree-node-hover-bg-color:var(--el-fill-color-light);--el-tree-text-color:var(--el-text-color-regular);--el-tree-expand-icon-color:var(--el-text-color-placeholder)}.el-tree{position:relative;cursor:default;background:var(--el-fill-color-blank);color:var(--el-tree-text-color);font-size:var(--el-font-size-base)}.el-tree__empty-block{position:relative;min-height:60px;text-align:center;width:100%;height:100%}.el-tree__empty-text{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:var(--el-text-color-secondary);font-size:var(--el-font-size-base)}.el-tree__drop-indicator{position:absolute;left:0;right:0;height:1px;background-color:var(--el-color-primary)}.el-tree-node{white-space:nowrap;outline:0}.el-tree-node:focus>.el-tree-node__content{background-color:var(--el-tree-node-hover-bg-color)}.el-tree-node.is-drop-inner>.el-tree-node__content .el-tree-node__label{background-color:var(--el-color-primary);color:#fff}.el-tree-node__content{--el-checkbox-height:var(--el-tree-node-content-height);display:flex;align-items:center;height:var(--el-tree-node-content-height);cursor:pointer}.el-tree-node__content>.el-tree-node__expand-icon{padding:6px;box-sizing:content-box}.el-tree-node__content>label.el-checkbox{margin-right:8px}.el-tree-node__content:hover{background-color:var(--el-tree-node-hover-bg-color)}.el-tree.is-dragging .el-tree-node__content{cursor:move}.el-tree.is-dragging .el-tree-node__content *{pointer-events:none}.el-tree.is-dragging.is-drop-not-allow .el-tree-node__content{cursor:not-allowed}.el-tree-node__expand-icon{cursor:pointer;color:var(--el-tree-expand-icon-color);font-size:12px;transform:rotate(0);transition:transform var(--el-transition-duration) ease-in-out}.el-tree-node__expand-icon.expanded{transform:rotate(90deg)}.el-tree-node__expand-icon.is-leaf{color:transparent;cursor:default}.el-tree-node__expand-icon.is-hidden{visibility:hidden}.el-tree-node__loading-icon{margin-right:8px;font-size:var(--el-font-size-base);color:var(--el-tree-expand-icon-color)}.el-tree-node>.el-tree-node__children{overflow:hidden;background-color:transparent}.el-tree-node.is-expanded>.el-tree-node__children{display:block}.el-tree--highlight-current .el-tree-node.is-current>.el-tree-node__content{background-color:var(--el-color-primary-light-9)}.el-vl__wrapper{position:relative}.el-vl__wrapper:hover .el-virtual-scrollbar,.el-vl__wrapper.always-on .el-virtual-scrollbar{opacity:1}.el-vl__window{scrollbar-width:none}.el-vl__window::-webkit-scrollbar{display:none}.el-virtual-scrollbar{opacity:0;transition:opacity .34s ease-out}.el-virtual-scrollbar.always-on{opacity:1}.el-vg__wrapper{position:relative}.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255, 255, 255, .5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-color-info);--el-button-active-color:var(--el-text-color-primary)}.el-button{display:inline-flex;justify-content:center;align-items:center;line-height:1;height:32px;white-space:nowrap;cursor:pointer;color:var(--el-button-text-color);text-align:center;box-sizing:border-box;outline:0;transition:.1s;font-weight:var(--el-button-font-weight);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);padding:8px 15px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button:focus,.el-button:hover{color:var(--el-button-hover-text-color);border-color:var(--el-button-hover-border-color);background-color:var(--el-button-hover-bg-color);outline:0}.el-button:active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button>span{display:inline-flex;align-items:center}.el-button+.el-button{margin-left:12px}.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button.is-disabled,.el-button.is-disabled:focus,.el-button.is-disabled:hover{color:var(--el-button-disabled-text-color);cursor:not-allowed;background-image:none;background-color:var(--el-button-disabled-bg-color);border-color:var(--el-button-disabled-border-color)}.el-button.is-loading{position:relative;pointer-events:none}.el-button.is-loading:before{z-index:1;pointer-events:none;content:"";position:absolute;left:-1px;top:-1px;right:-1px;bottom:-1px;border-radius:inherit;background-color:var(--el-mask-color-extra-light)}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{border-radius:50%;padding:8px}.el-button.is-text{color:var(--el-button-text-color);border:0 solid transparent;background-color:transparent}.el-button.is-text.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important}.el-button.is-text:not(.is-disabled):focus,.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:focus,.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{border-color:transparent;color:var(--el-button-text-color);background:0 0;padding:2px;height:auto}.el-button.is-link:focus,.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.el-button.is-link:not(.is-disabled):focus,.el-button.is-link:not(.is-disabled):hover{border-color:transparent;background-color:transparent}.el-button.is-link:not(.is-disabled):active{color:var(--el-button-active-color);border-color:transparent;background-color:transparent}.el-button--text{border-color:transparent;background:0 0;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.el-button--text:not(.is-disabled):focus,.el-button--text:not(.is-disabled):hover{color:var(--el-color-primary-light-3);border-color:transparent;background-color:transparent}.el-button--text:not(.is-disabled):active{color:var(--el-color-primary-dark-2);border-color:transparent;background-color:transparent}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{color:var(--el-color-primary-light-5);background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{color:var(--el-color-success-light-5);background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{color:var(--el-color-warning-light-5);background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{color:var(--el-color-danger-light-5);background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{color:var(--el-color-info-light-5);background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8)}.el-button--large{--el-button-size:40px;height:var(--el-button-size);padding:12px 19px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{width:var(--el-button-size);padding:12px}.el-button--small{--el-button-size:24px;height:var(--el-button-size);padding:5px 11px;font-size:12px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{width:var(--el-button-size);padding:5px}.el-image__error,.el-image__inner,.el-image__placeholder,.el-image__wrapper{width:100%;height:100%}.el-image{position:relative;display:inline-block;overflow:hidden}.el-image__inner{vertical-align:top;opacity:1}.el-image__inner.is-loading{opacity:0}.el-image__wrapper{position:absolute;top:0;left:0}.el-image__placeholder{background:var(--el-fill-color-light)}.el-image__error{display:flex;justify-content:center;align-items:center;font-size:14px;background:var(--el-fill-color-light);color:var(--el-text-color-placeholder);vertical-align:middle}.el-image__preview{cursor:pointer}.el-image-viewer__wrapper{position:fixed;top:0;right:0;bottom:0;left:0}.el-image-viewer__btn{position:absolute;z-index:1;display:flex;align-items:center;justify-content:center;border-radius:50%;opacity:.8;cursor:pointer;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-image-viewer__btn .el-icon{font-size:inherit;cursor:pointer}.el-image-viewer__close{top:40px;right:40px;width:40px;height:40px;font-size:40px}.el-image-viewer__canvas{position:static;width:100%;height:100%;display:flex;justify-content:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-image-viewer__actions{left:50%;bottom:30px;transform:translate(-50%);width:282px;height:44px;padding:0 23px;background-color:var(--el-text-color-regular);border-color:#fff;border-radius:22px}.el-image-viewer__actions__inner{width:100%;height:100%;text-align:justify;cursor:default;font-size:23px;color:#fff;display:flex;align-items:center;justify-content:space-around}.el-image-viewer__prev{top:50%;transform:translateY(-50%);left:40px;width:44px;height:44px;font-size:24px;color:#fff;background-color:var(--el-text-color-regular);border-color:#fff}.el-image-viewer__next{top:50%;transform:translateY(-50%);right:40px;text-indent:2px;width:44px;height:44px;font-size:24px;color:#fff;background-color:var(--el-text-color-regular);border-color:#fff}.el-image-viewer__close{width:44px;height:44px;font-size:24px;color:#fff;background-color:var(--el-text-color-regular);border-color:#fff}.el-image-viewer__mask{position:absolute;width:100%;height:100%;top:0;left:0;opacity:.5;background:#000}.viewer-fade-enter-active{-webkit-animation:viewer-fade-in var(--el-transition-duration);animation:viewer-fade-in var(--el-transition-duration)}.viewer-fade-leave-active{-webkit-animation:viewer-fade-out var(--el-transition-duration);animation:viewer-fade-out var(--el-transition-duration)}@-webkit-keyframes viewer-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes viewer-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@-webkit-keyframes viewer-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}@keyframes viewer-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}.el-badge{--el-badge-bg-color:var(--el-color-danger);--el-badge-radius:10px;--el-badge-font-size:12px;--el-badge-padding:6px;--el-badge-size:18px;position:relative;vertical-align:middle;display:inline-block;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content}.el-badge__content{background-color:var(--el-badge-bg-color);border-radius:var(--el-badge-radius);color:var(--el-color-white);display:inline-flex;justify-content:center;align-items:center;font-size:var(--el-badge-font-size);height:var(--el-badge-size);padding:0 var(--el-badge-padding);white-space:nowrap;border:1px solid var(--el-bg-color)}.el-badge__content.is-fixed{position:absolute;top:0;right:calc(1px + var(--el-badge-size)/ 2);transform:translateY(-50%) translate(100%);z-index:var(--el-index-normal)}.el-badge__content.is-fixed.is-dot{right:5px}.el-badge__content.is-dot{height:8px;width:8px;padding:0;right:0;border-radius:50%}.el-badge__content--primary{background-color:var(--el-color-primary)}.el-badge__content--success{background-color:var(--el-color-success)}.el-badge__content--warning{background-color:var(--el-color-warning)}.el-badge__content--info{background-color:var(--el-color-info)}.el-badge__content--danger{background-color:var(--el-color-danger)}.el-message{--el-message-bg-color:var(--el-color-info-light-9);--el-message-border-color:var(--el-border-color-lighter);--el-message-padding:15px 19px;--el-message-close-size:16px;--el-message-close-icon-color:var(--el-text-color-placeholder);--el-message-close-hover-color:var(--el-text-color-secondary)}.el-message{width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;max-width:calc(100% - 32px);box-sizing:border-box;border-radius:var(--el-border-radius-base);border-width:var(--el-border-width);border-style:var(--el-border-style);border-color:var(--el-message-border-color);position:fixed;left:50%;top:20px;transform:translate(-50%);background-color:var(--el-message-bg-color);transition:opacity var(--el-transition-duration),transform .4s,top .4s;padding:var(--el-message-padding);display:flex;align-items:center}.el-message.is-center{justify-content:center}.el-message.is-closable .el-message__content{padding-right:31px}.el-message p{margin:0}.el-message--success{--el-message-bg-color:var(--el-color-success-light-9);--el-message-border-color:var(--el-color-success-light-8);--el-message-text-color:var(--el-color-success)}.el-message--success .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--success{color:var(--el-message-text-color)}.el-message--info{--el-message-bg-color:var(--el-color-info-light-9);--el-message-border-color:var(--el-color-info-light-8);--el-message-text-color:var(--el-color-info)}.el-message--info .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--info{color:var(--el-message-text-color)}.el-message--warning{--el-message-bg-color:var(--el-color-warning-light-9);--el-message-border-color:var(--el-color-warning-light-8);--el-message-text-color:var(--el-color-warning)}.el-message--warning .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--warning{color:var(--el-message-text-color)}.el-message--error{--el-message-bg-color:var(--el-color-error-light-9);--el-message-border-color:var(--el-color-error-light-8);--el-message-text-color:var(--el-color-error)}.el-message--error .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--error{color:var(--el-message-text-color)}.el-message__icon{margin-right:10px}.el-message .el-message__badge{position:absolute;top:-8px;right:-8px}.el-message__content{padding:0;font-size:14px;line-height:1}.el-message__content:focus{outline-width:0}.el-message .el-message__closeBtn{position:absolute;top:50%;right:19px;transform:translateY(-50%);cursor:pointer;color:var(--el-message-close-icon-color);font-size:var(--el-message-close-size)}.el-message .el-message__closeBtn:focus{outline-width:0}.el-message .el-message__closeBtn:hover{color:var(--el-message-close-hover-color)}.el-message-fade-enter-from,.el-message-fade-leave-to{opacity:0;transform:translate(-50%,-100%)}:root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:.5}.v-modal-enter{-webkit-animation:v-modal-in var(--el-transition-duration-fast) ease;animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{-webkit-animation:v-modal-out var(--el-transition-duration-fast) ease forwards;animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@-webkit-keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-in{0%{opacity:0}}@-webkit-keyframes v-modal-out{to{opacity:0}}@keyframes v-modal-out{to{opacity:0}}.v-modal{position:fixed;left:0;top:0;width:100%;height:100%;opacity:var(--el-popup-modal-opacity);background:var(--el-popup-modal-bg-color)}.el-popup-parent--hidden{overflow:hidden}.el-message-box{--el-messagebox-title-color:var(--el-text-color-primary);--el-messagebox-width:420px;--el-messagebox-border-radius:4px;--el-messagebox-font-size:var(--el-font-size-large);--el-messagebox-content-font-size:var(--el-font-size-base);--el-messagebox-content-color:var(--el-text-color-regular);--el-messagebox-error-font-size:12px;--el-messagebox-padding-primary:15px}.el-message-box{display:inline-block;max-width:var(--el-messagebox-width);width:100%;padding-bottom:10px;vertical-align:middle;background-color:var(--el-bg-color);border-radius:var(--el-messagebox-border-radius);border:1px solid var(--el-border-color-lighter);font-size:var(--el-messagebox-font-size);box-shadow:var(--el-box-shadow-light);text-align:left;overflow:hidden;-webkit-backface-visibility:hidden;backface-visibility:hidden;box-sizing:border-box}.el-message-box:focus{outline:0!important}.el-overlay.is-message-box .el-overlay-message-box{text-align:center;position:fixed;top:0;right:0;bottom:0;left:0;padding:16px;overflow:auto}.el-overlay.is-message-box .el-overlay-message-box:after{content:"";display:inline-block;height:100%;width:0;vertical-align:middle}.el-message-box.is-draggable .el-message-box__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-message-box__header{position:relative;padding:var(--el-messagebox-padding-primary);padding-bottom:10px}.el-message-box__title{padding-left:0;margin-bottom:0;font-size:var(--el-messagebox-font-size);line-height:1;color:var(--el-messagebox-title-color)}.el-message-box__headerbtn{position:absolute;top:var(--el-messagebox-padding-primary);right:var(--el-messagebox-padding-primary);padding:0;border:none;outline:0;background:0 0;font-size:var(--el-message-close-size,16px);cursor:pointer}.el-message-box__headerbtn .el-message-box__close{color:var(--el-color-info);font-size:inherit}.el-message-box__headerbtn:focus .el-message-box__close,.el-message-box__headerbtn:hover .el-message-box__close{color:var(--el-color-primary)}.el-message-box__content{padding:10px var(--el-messagebox-padding-primary);color:var(--el-messagebox-content-color);font-size:var(--el-messagebox-content-font-size)}.el-message-box__container{position:relative}.el-message-box__input{padding-top:15px}.el-message-box__input div.invalid>input{border-color:var(--el-color-error)}.el-message-box__input div.invalid>input:focus{border-color:var(--el-color-error)}.el-message-box__status{position:absolute;top:50%;transform:translateY(-50%);font-size:24px!important}.el-message-box__status:before{padding-left:1px}.el-message-box__status.el-icon{position:absolute}.el-message-box__status+.el-message-box__message{padding-left:36px;padding-right:12px;word-break:break-word}.el-message-box__status.el-message-box-icon--success{--el-messagebox-color:var(--el-color-success);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--info{--el-messagebox-color:var(--el-color-info);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--warning{--el-messagebox-color:var(--el-color-warning);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--error{--el-messagebox-color:var(--el-color-error);color:var(--el-messagebox-color)}.el-message-box__message{margin:0}.el-message-box__message p{margin:0;line-height:24px}.el-message-box__errormsg{color:var(--el-color-error);font-size:var(--el-messagebox-error-font-size);min-height:18px;margin-top:2px}.el-message-box__btns{padding:5px 15px 0;display:flex;flex-wrap:wrap;justify-content:flex-end;align-items:center}.el-message-box__btns button:nth-child(2){margin-left:10px}.el-message-box__btns-reverse{flex-direction:row-reverse}.el-message-box--center .el-message-box__title{position:relative;display:flex;align-items:center;justify-content:center}.el-message-box--center .el-message-box__status{position:relative;top:auto;padding-right:5px;text-align:center;transform:translateY(-1px)}.el-message-box--center .el-message-box__message{margin-left:0}.el-message-box--center .el-message-box__btns{justify-content:center}.el-message-box--center .el-message-box__content{padding-left:calc(var(--el-messagebox-padding-primary) + 12px);padding-right:calc(var(--el-messagebox-padding-primary) + 12px);text-align:center}.fade-in-linear-enter-active .el-overlay-message-box{-webkit-animation:msgbox-fade-in var(--el-transition-duration);animation:msgbox-fade-in var(--el-transition-duration)}.fade-in-linear-leave-active .el-overlay-message-box{animation:msgbox-fade-in var(--el-transition-duration) reverse}@-webkit-keyframes msgbox-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes msgbox-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@-webkit-keyframes msgbox-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}@keyframes msgbox-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}.onlineGallery-RuleEditor-modal{pointer-events:none!important}.onlineGallery-RuleEditor-modal .el-dialog__header{padding:15px 10px 5px 20px}.onlineGallery-RuleEditor-modal .el-dialog__header .el-dialog__headerbtn{top:0;right:0;width:50px;height:50px}.onlineGallery-RuleEditor-modal .el-dialog__body{padding:10px}.onlineGallery-RuleEditor-modal .el-dialog__body .el-container{position:relative;height:max-content;min-height:300px}.onlineGallery-RuleEditor-modal .el-dialog__body .el-container .el-tabs{height:90%}.onlineGallery-RuleEditor-modal .el-dialog__body .tree-item{display:flex;align-items:center;justify-content:space-between;overflow:hidden}.onlineGallery-RuleEditor-modal .el-dialog__body .tree-item.tree-item-normal{position:relative!important;flex-grow:1}.onlineGallery-RuleEditor-modal .el-dialog__body .tree-item.tree-item-normal>.label-ruleName{flex-grow:1;padding-left:4px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.onlineGallery-RuleEditor-modal .el-dialog__body .tree-item.tree-item-normal>.icon-button-deleteRule{position:relative;right:2px;width:24px;height:auto;display:flex;justify-content:center;align-items:center;color:red;font-size:medium}.onlineGallery-RuleEditor-modal .el-dialog__body .tree-item.tree-item-add-button>button{width:100%}.onlineGallery-RuleEditor-modal .el-dialog__footer{padding:10px}*[data-v-b78ae3cf]{margin:0!important;padding:0!important;border:0!important;box-sizing:border-box!important;z-index:0!important}[data-show=true][data-v-b78ae3cf]{opacity:1;filter:blur(0px);transition:1s}[data-show=false][data-v-b78ae3cf]{opacity:0;filter:blur(10px);transition:1s}*[data-v-33e8a5f9]{border:0;margin:0;box-sizing:border-box}.card[data-v-33e8a5f9]{border:0!important;margin:0!important;padding:0!important;scroll-snap-align:start;position:relative;border-radius:4px;box-shadow:var(--el-box-shadow-dark);aspect-ratio:var(--aspect-ratio);max-width:100%;max-height:var(--cardMaxHeight);width:calc(var(--cardMaxHeight) * var(--aspect-ratio))!important;background-color:transparent;overflow:hidden;cursor:pointer;transition:.5s}.card[data-v-33e8a5f9]:hover{box-shadow:1px 2px 12px 6px #00000080}.card .content[data-v-33e8a5f9]{border:0!important;margin:0!important;padding:0!important;width:100%;height:auto;object-position:center;-webkit-user-drag:none;background-position:center;background-repeat:repeat;background-size:contain}.card .button-group[data-v-33e8a5f9]{position:absolute;margin:4px;top:0;right:0;width:24px;height:24px;border-radius:12px;transition:.15s}.card .button-group .button[data-v-33e8a5f9]{position:absolute;margin:auto;padding:0;left:0;top:0;right:0;width:100%!important;height:auto!important;aspect-ratio:1!important;font-size:medium;box-shadow:var(--el-box-shadow-light);transition:.15s}.card .button-group[data-v-33e8a5f9]:hover{height:50px}.card .button-group:hover .button.download[data-v-33e8a5f9]{transform:translateY(26px)}.card .checkbox[data-v-33e8a5f9]{position:absolute!important;height:fit-content;top:4px!important;left:4px!important;box-shadow:var(--el-box-shadow-light)}.card .tag-group[data-v-33e8a5f9]{position:absolute;width:100%!important;bottom:0px;left:0px;padding:4px;display:flex;flex-flow:row wrap;gap:2px}.card .tag-group .el-tag[data-v-33e8a5f9]{max-width:100%;justify-content:start;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}*[data-v-f25bdb68]{border:0;margin:0;box-sizing:border-box}.onlineGallery-listBody[data-v-f25bdb68]{width:100%;padding:10px;display:flex;flex-flow:row wrap;justify-content:center;align-items:stretch;align-content:start;gap:8px;transition:1s;-webkit-user-select:none;user-select:none;-webkit-user-drag:none}.onlineGallery-backTop[data-v-f25bdb68]{--el-backtop-bg-color: var(--el-bg-color-overlay);--el-backtop-text-color: var(--el-color-primary);--el-backtop-hover-bg-color: var(--el-border-color-extra-light);position:absolute;width:40px;height:40px;right:40px;bottom:40px;border-radius:50%;background-color:var(--el-bg-color-overlay);color:var(--el-color-primary);display:flex;align-items:center;justify-content:center;font-size:20px;box-shadow:var(--el-box-shadow-lighter);cursor:pointer;z-index:5;transition:.5s}.onlineGallery-backTop[data-v-f25bdb68]:hover{background-color:var(--el-border-color-extra-light)}.backTop-enter-active[data-v-f25bdb68],.backTop-leave-active[data-v-f25bdb68]{transition:opacity .5s ease}.backTop-enter-from[data-v-f25bdb68],.backTop-leave-to[data-v-f25bdb68]{opacity:0}.list-move[data-v-f25bdb68],.list-enter-active[data-v-f25bdb68],.list-leave-active[data-v-f25bdb68]{transition:all .5s ease}.list-enter-from[data-v-f25bdb68],.list-leave-to[data-v-f25bdb68]{opacity:0;transform:translate(30px)}.list-leave-active[data-v-f25bdb68]{position:absolute}.el-button-group{display:inline-block;vertical-align:middle}.el-button-group:after,.el-button-group:before{display:table;content:""}.el-button-group:after{clear:both}.el-button-group>.el-button{float:left;position:relative}.el-button-group>.el-button+.el-button{margin-left:0}.el-button-group>.el-button:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.el-button-group>.el-button:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.el-button-group>.el-button:first-child:last-child{border-top-right-radius:var(--el-border-radius-base);border-bottom-right-radius:var(--el-border-radius-base);border-top-left-radius:var(--el-border-radius-base);border-bottom-left-radius:var(--el-border-radius-base)}.el-button-group>.el-button:first-child:last-child.is-round{border-radius:var(--el-border-radius-round)}.el-button-group>.el-button:first-child:last-child.is-circle{border-radius:50%}.el-button-group>.el-button:not(:first-child):not(:last-child){border-radius:0}.el-button-group>.el-button:not(:last-child){margin-right:-1px}.el-button-group>.el-button:active,.el-button-group>.el-button:focus,.el-button-group>.el-button:hover{z-index:1}.el-button-group>.el-button.is-active{z-index:1}.el-button-group>.el-dropdown>.el-button{border-top-left-radius:0;border-bottom-left-radius:0;border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-dropdown{--el-dropdown-menu-box-shadow:var(--el-box-shadow-light);--el-dropdown-menuItem-hover-fill:var(--el-color-primary-light-9);--el-dropdown-menuItem-hover-color:var(--el-color-primary);--el-dropdown-menu-index:10;display:inline-flex;position:relative;color:var(--el-text-color-regular);font-size:var(--el-font-size-base);line-height:1;vertical-align:top}.el-dropdown.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-dropdown__popper{--el-dropdown-menu-box-shadow:var(--el-box-shadow-light);--el-dropdown-menuItem-hover-fill:var(--el-color-primary-light-9);--el-dropdown-menuItem-hover-color:var(--el-color-primary);--el-dropdown-menu-index:10}.el-dropdown__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-dropdown-menu-box-shadow)}.el-dropdown__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-dropdown__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent;border-left-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent;border-bottom-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-dropdown__popper .el-dropdown-menu{border:none}.el-dropdown__popper .el-dropdown__popper-selfdefine{outline:0}.el-dropdown__popper .el-scrollbar__bar{z-index:calc(var(--el-dropdown-menu-index) + 1)}.el-dropdown__popper .el-dropdown__list{list-style:none;padding:0;margin:0;box-sizing:border-box}.el-dropdown .el-dropdown__caret-button{padding-left:0;padding-right:0;display:inline-flex;justify-content:center;align-items:center;width:32px;border-left:none}.el-dropdown .el-dropdown__caret-button>span{display:inline-flex}.el-dropdown .el-dropdown__caret-button:before{content:"";position:absolute;display:block;width:1px;top:-1px;bottom:-1px;left:0;background:var(--el-overlay-color-lighter)}.el-dropdown .el-dropdown__caret-button.el-button:before{background:var(--el-border-color);opacity:.5}.el-dropdown .el-dropdown__caret-button .el-dropdown__icon{font-size:inherit;padding-left:0}.el-dropdown .el-dropdown-selfdefine{outline:0}.el-dropdown--large .el-dropdown__caret-button{width:40px}.el-dropdown--small .el-dropdown__caret-button{width:24px}.el-dropdown-menu{position:relative;top:0;left:0;z-index:var(--el-dropdown-menu-index);padding:5px 0;margin:0;background-color:var(--el-bg-color-overlay);border:none;border-radius:var(--el-border-radius-base);box-shadow:none;list-style:none}.el-dropdown-menu__item{display:flex;align-items:center;white-space:nowrap;list-style:none;line-height:22px;padding:5px 16px;margin:0;font-size:var(--el-font-size-base);color:var(--el-text-color-regular);cursor:pointer;outline:0}.el-dropdown-menu__item:not(.is-disabled):focus{background-color:var(--el-dropdown-menuItem-hover-fill);color:var(--el-dropdown-menuItem-hover-color)}.el-dropdown-menu__item i{margin-right:5px}.el-dropdown-menu__item--divided{margin:6px 0;border-top:1px solid var(--el-border-color-lighter)}.el-dropdown-menu__item.is-disabled{cursor:not-allowed;color:var(--el-text-color-disabled)}.el-dropdown-menu--large{padding:7px 0}.el-dropdown-menu--large .el-dropdown-menu__item{padding:7px 20px;line-height:22px;font-size:14px}.el-dropdown-menu--large .el-dropdown-menu__item--divided{margin:8px 0}.el-dropdown-menu--small{padding:3px 0}.el-dropdown-menu--small .el-dropdown-menu__item{padding:2px 12px;line-height:20px;font-size:12px}.el-dropdown-menu--small .el-dropdown-menu__item--divided{margin:4px 0}.el-input-number{position:relative;display:inline-flex;width:150px;line-height:30px}.el-input-number .el-input__wrapper{padding-left:42px;padding-right:42px}.el-input-number .el-input__inner{-webkit-appearance:none;-moz-appearance:textfield;text-align:center;line-height:1}.el-input-number .el-input__inner::-webkit-inner-spin-button,.el-input-number .el-input__inner::-webkit-outer-spin-button{margin:0;-webkit-appearance:none}.el-input-number__decrease,.el-input-number__increase{display:flex;justify-content:center;align-items:center;height:auto;position:absolute;z-index:1;top:1px;bottom:1px;width:32px;background:var(--el-fill-color-light);color:var(--el-text-color-regular);cursor:pointer;font-size:13px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-input-number__decrease:hover,.el-input-number__increase:hover{color:var(--el-color-primary)}.el-input-number__decrease:hover~.el-input:not(.is-disabled) .el-input__wrapper,.el-input-number__increase:hover~.el-input:not(.is-disabled) .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-input-number__decrease.is-disabled,.el-input-number__increase.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-input-number__increase{right:1px;border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0;border-left:var(--el-border)}.el-input-number__decrease{left:1px;border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);border-right:var(--el-border)}.el-input-number.is-disabled .el-input-number__decrease,.el-input-number.is-disabled .el-input-number__increase{border-color:var(--el-disabled-border-color);color:var(--el-disabled-border-color)}.el-input-number.is-disabled .el-input-number__decrease:hover,.el-input-number.is-disabled .el-input-number__increase:hover{color:var(--el-disabled-border-color);cursor:not-allowed}.el-input-number--large{width:180px;line-height:38px}.el-input-number--large .el-input-number__decrease,.el-input-number--large .el-input-number__increase{width:40px;font-size:14px}.el-input-number--large .el-input__wrapper{padding-left:47px;padding-right:47px}.el-input-number--small{width:120px;line-height:22px}.el-input-number--small .el-input-number__decrease,.el-input-number--small .el-input-number__increase{width:24px;font-size:12px}.el-input-number--small .el-input__wrapper{padding-left:31px;padding-right:31px}.el-input-number--small .el-input-number__decrease [class*=el-icon],.el-input-number--small .el-input-number__increase [class*=el-icon]{transform:scale(.9)}.el-input-number.is-without-controls .el-input__wrapper{padding-left:15px;padding-right:15px}.el-input-number.is-controls-right .el-input__wrapper{padding-left:15px;padding-right:42px}.el-input-number.is-controls-right .el-input-number__decrease,.el-input-number.is-controls-right .el-input-number__increase{--el-input-number-controls-height:15px;height:var(--el-input-number-controls-height);line-height:var(--el-input-number-controls-height)}.el-input-number.is-controls-right .el-input-number__decrease [class*=el-icon],.el-input-number.is-controls-right .el-input-number__increase [class*=el-icon]{transform:scale(.8)}.el-input-number.is-controls-right .el-input-number__increase{bottom:auto;left:auto;border-radius:0 var(--el-border-radius-base) 0 0;border-bottom:var(--el-border)}.el-input-number.is-controls-right .el-input-number__decrease{right:1px;top:auto;left:auto;border-right:none;border-left:var(--el-border);border-radius:0 0 var(--el-border-radius-base) 0}.el-input-number.is-controls-right[class*=large] [class*=decrease],.el-input-number.is-controls-right[class*=large] [class*=increase]{--el-input-number-controls-height:19px}.el-input-number.is-controls-right[class*=small] [class*=decrease],.el-input-number.is-controls-right[class*=small] [class*=increase]{--el-input-number-controls-height:11px}.el-select-dropdown{z-index:calc(var(--el-index-top) + 1);border-radius:var(--el-border-radius-base);box-sizing:border-box}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown__option-item.is-selected:not(.is-multiple).is-disabled{color:var(--el-text-color-disabled)}.el-select-dropdown__option-item.is-selected:not(.is-multiple).is-disabled:after{background-color:var(--el-text-color-disabled)}.el-select-dropdown__option-item:hover:not(.hover){background-color:transparent}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-disabled.is-selected{color:var(--el-text-color-disabled)}.el-select-dropdown__empty{padding:10px 0;margin:0;text-align:center;color:var(--el-text-color-secondary);font-size:var(--el-select-font-size)}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{list-style:none;margin:6px 0!important;padding:0!important;box-sizing:border-box}.el-select-dropdown__option-item{font-size:var(--el-select-font-size);padding:0 32px 0 20px;position:relative;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--el-text-color-regular);height:34px;line-height:34px;box-sizing:border-box;cursor:pointer}.el-select-dropdown__option-item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select-dropdown__option-item.is-disabled:hover{background-color:var(--el-bg-color)}.el-select-dropdown__option-item.is-selected{background-color:var(--el-fill-color-light);font-weight:700}.el-select-dropdown__option-item.is-selected:not(.is-multiple){color:var(--el-color-primary)}.el-select-dropdown__option-item.hover{background-color:var(--el-fill-color-light)!important}.el-select-dropdown__option-item:hover{background-color:var(--el-fill-color-light)}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-selected{color:var(--el-color-primary);background-color:var(--el-bg-color-overlay)}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-selected .el-icon{position:absolute;right:20px;top:0;height:inherit;font-size:12px}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-selected .el-icon svg{height:inherit;vertical-align:middle}.el-select-group{margin:0;padding:0}.el-select-group__wrap{position:relative;list-style:none;margin:0;padding:0}.el-select-group__wrap:not(:last-of-type){padding-bottom:24px}.el-select-group__wrap:not(:last-of-type):after{content:"";position:absolute;display:block;left:20px;right:20px;bottom:12px;height:1px;background:var(--el-border-color-light)}.el-select-group__split-dash{position:absolute;left:20px;right:20px;height:1px;background:var(--el-border-color-light)}.el-select-group__title{padding-left:20px;font-size:12px;color:var(--el-color-info);line-height:30px}.el-select-group .el-select-dropdown__item{padding-left:20px}.el-select-v2{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px}.el-select-v2{display:inline-block;position:relative;vertical-align:middle;font-size:14px}.el-select-v2__wrapper{display:flex;align-items:center;flex-wrap:wrap;position:relative;box-sizing:border-box;cursor:pointer;padding:1px 30px 1px 0;border:1px solid var(--el-border-color);border-radius:var(--el-border-radius-base);background-color:var(--el-fill-color-blank);transition:var(--el-transition-duration)}.el-select-v2__wrapper:hover{border-color:var(--el-text-color-placeholder)}.el-select-v2__wrapper.is-filterable{cursor:text}.el-select-v2__wrapper.is-focused{border-color:var(--el-color-primary)}.el-select-v2__wrapper.is-hovering:not(.is-focused){border-color:var(--el-border-color-hover)}.el-select-v2__wrapper.is-disabled{cursor:not-allowed;background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);border-color:var(--el-select-disabled-border)}.el-select-v2__wrapper.is-disabled:hover{border-color:var(--el-select-disabled-border)}.el-select-v2__wrapper.is-disabled.is-focus{border-color:var(--el-input-focus-border-color)}.el-select-v2__wrapper.is-disabled .is-transparent{opacity:1;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-select-v2__wrapper.is-disabled .el-select-v2__caret,.el-select-v2__wrapper.is-disabled .el-select-v2__combobox-input{cursor:not-allowed}.el-select-v2__wrapper .el-select-v2__input-wrapper{box-sizing:border-box;position:relative;-webkit-margin-start:12px;margin-inline-start:12px;max-width:100%;overflow:hidden}.el-select-v2__wrapper,.el-select-v2__wrapper .el-select-v2__input-wrapper{line-height:32px}.el-select-v2__wrapper .el-select-v2__input-wrapper input{--el-input-inner-height:calc(var(--el-component-size, 32px) - 8px);height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);min-width:4px;width:100%;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none;background:0 0;border:none;margin:2px 0;outline:0;padding:0}.el-select-v2 .el-select-v2__tags-text{display:inline-block;line-height:normal;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select-v2__empty{padding:10px 0;margin:0;text-align:center;color:var(--el-text-color-secondary);font-size:14px}.el-select-v2__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-select-v2__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-select-v2__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent;border-left-color:transparent}.el-select-v2__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-select-v2__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent;border-bottom-color:transparent}.el-select-v2__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-select-v2--large .el-select-v2__wrapper .el-select-v2__combobox-input{height:32px}.el-select-v2--large .el-select-v2__caret,.el-select-v2--large .el-select-v2__suffix{height:40px}.el-select-v2--large .el-select-v2__placeholder{font-size:14px;line-height:40px}.el-select-v2--small .el-select-v2__wrapper .el-select-v2__combobox-input{height:16px}.el-select-v2--small .el-select-v2__caret,.el-select-v2--small .el-select-v2__suffix{height:24px}.el-select-v2--small .el-select-v2__placeholder{font-size:12px;line-height:24px}.el-select-v2 .el-select-v2__selection>span{display:inline-block}.el-select-v2:hover .el-select-v2__combobox-input{border-color:var(--el-select-border-color-hover)}.el-select-v2 .el-select__selection-text{text-overflow:ellipsis;display:inline-block;overflow-x:hidden;vertical-align:bottom}.el-select-v2 .el-select-v2__combobox-input{padding-right:35px;display:block;color:var(--el-text-color-regular)}.el-select-v2 .el-select-v2__combobox-input:focus{border-color:var(--el-select-input-focus-border-color)}.el-select-v2__input{border:none;outline:0;padding:0;margin-left:15px;color:var(--el-select-multiple-input-color);font-size:var(--el-select-font-size);-webkit-appearance:none;-moz-appearance:none;appearance:none;height:28px}.el-select-v2__input.is-small{height:14px}.el-select-v2__close{cursor:pointer;position:absolute;top:8px;z-index:var(--el-index-top);right:25px;color:var(--el-select-input-color);line-height:18px;font-size:var(--el-select-input-font-size)}.el-select-v2__close:hover{color:var(--el-select-close-hover-color)}.el-select-v2__suffix{display:inline-flex;position:absolute;right:12px;height:32px;top:50%;transform:translateY(-50%);color:var(--el-input-icon-color,var(--el-text-color-placeholder))}.el-select-v2__suffix .el-input__icon{height:inherit}.el-select-v2__suffix .el-input__icon:not(:first-child){margin-left:8px}.el-select-v2__caret{color:var(--el-select-input-color);font-size:var(--el-select-input-font-size);transition:var(--el-transition-duration);transform:rotate(180deg);cursor:pointer}.el-select-v2__caret.is-reverse{transform:rotate(0)}.el-select-v2__caret.is-show-close{font-size:var(--el-select-font-size);text-align:center;transform:rotate(180deg);border-radius:var(--el-border-radius-circle);color:var(--el-select-input-color);transition:var(--el-transition-color)}.el-select-v2__caret.is-show-close:hover{color:var(--el-select-close-hover-color)}.el-select-v2__caret.el-icon{height:inherit}.el-select-v2__caret.el-icon svg{vertical-align:middle}.el-select-v2__selection{white-space:normal;z-index:var(--el-index-normal);display:flex;align-items:center;flex-wrap:wrap;width:100%}.el-select-v2__input-calculator{left:0;position:absolute;top:0;visibility:hidden;white-space:pre;z-index:999}.el-select-v2__selected-item{line-height:inherit;height:inherit;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-wrap:wrap}.el-select-v2__placeholder{position:absolute;top:50%;transform:translateY(-50%);-webkit-margin-start:12px;margin-inline-start:12px;width:calc(100% - 52px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--el-input-text-color,var(--el-text-color-regular))}.el-select-v2__placeholder.is-transparent{color:var(--el-text-color-placeholder)}.el-select-v2 .el-select-v2__selection .el-tag{box-sizing:border-box;border-color:transparent;margin:2px 0 2px 6px;background-color:var(--el-fill-color)}.el-select-v2 .el-select-v2__selection .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);right:-7px;color:var(--el-color-white)}.el-select-v2 .el-select-v2__selection .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-select-v2 .el-select-v2__selection .el-tag .el-icon-close:before{display:block;transform:translateY(.5px)}.el-select-v2.el-select-v2--small .el-select-v2__selection .el-tag{margin:1px 0 1px 6px;height:18px}.el-slider{--el-slider-main-bg-color:var(--el-color-primary);--el-slider-runway-bg-color:var(--el-border-color-light);--el-slider-stop-bg-color:var(--el-color-white);--el-slider-disabled-color:var(--el-text-color-placeholder);--el-slider-border-radius:3px;--el-slider-height:6px;--el-slider-button-size:20px;--el-slider-button-wrapper-size:36px;--el-slider-button-wrapper-offset:-15px}.el-slider{width:100%;height:32px;display:flex;align-items:center}.el-slider__runway{flex:1;height:var(--el-slider-height);background-color:var(--el-slider-runway-bg-color);border-radius:var(--el-slider-border-radius);position:relative;cursor:pointer}.el-slider__runway.show-input{margin-right:30px;width:auto}.el-slider__runway.is-disabled{cursor:default}.el-slider__runway.is-disabled .el-slider__bar{background-color:var(--el-slider-disabled-color)}.el-slider__runway.is-disabled .el-slider__button{border-color:var(--el-slider-disabled-color)}.el-slider__runway.is-disabled .el-slider__button-wrapper.hover,.el-slider__runway.is-disabled .el-slider__button-wrapper:hover,.el-slider__runway.is-disabled .el-slider__button-wrapper.dragging{cursor:not-allowed}.el-slider__runway.is-disabled .el-slider__button.dragging,.el-slider__runway.is-disabled .el-slider__button.hover,.el-slider__runway.is-disabled .el-slider__button:hover{transform:scale(1)}.el-slider__runway.is-disabled .el-slider__button.hover,.el-slider__runway.is-disabled .el-slider__button:hover,.el-slider__runway.is-disabled .el-slider__button.dragging{cursor:not-allowed}.el-slider__input{flex-shrink:0;width:130px}.el-slider__bar{height:var(--el-slider-height);background-color:var(--el-slider-main-bg-color);border-top-left-radius:var(--el-slider-border-radius);border-bottom-left-radius:var(--el-slider-border-radius);position:absolute}.el-slider__button-wrapper{height:var(--el-slider-button-wrapper-size);width:var(--el-slider-button-wrapper-size);position:absolute;z-index:1;top:var(--el-slider-button-wrapper-offset);transform:translate(-50%);background-color:transparent;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;line-height:normal;outline:0}.el-slider__button-wrapper:after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-slider__button-wrapper.hover,.el-slider__button-wrapper:hover{cursor:-webkit-grab;cursor:grab}.el-slider__button-wrapper.dragging{cursor:-webkit-grabbing;cursor:grabbing}.el-slider__button{display:inline-block;width:var(--el-slider-button-size);height:var(--el-slider-button-size);vertical-align:middle;border:solid 2px var(--el-slider-main-bg-color);background-color:var(--el-color-white);border-radius:50%;box-sizing:border-box;transition:var(--el-transition-duration-fast);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-slider__button.dragging,.el-slider__button.hover,.el-slider__button:hover{transform:scale(1.2)}.el-slider__button.hover,.el-slider__button:hover{cursor:-webkit-grab;cursor:grab}.el-slider__button.dragging{cursor:-webkit-grabbing;cursor:grabbing}.el-slider__stop{position:absolute;height:var(--el-slider-height);width:var(--el-slider-height);border-radius:var(--el-border-radius-circle);background-color:var(--el-slider-stop-bg-color);transform:translate(-50%)}.el-slider__marks{top:0;left:12px;width:18px;height:100%}.el-slider__marks-text{position:absolute;transform:translate(-50%);font-size:14px;color:var(--el-color-info);margin-top:15px;white-space:pre}.el-slider.is-vertical{position:relative;display:inline-flex;width:auto;height:100%;flex:0}.el-slider.is-vertical .el-slider__runway{width:var(--el-slider-height);height:100%;margin:0 16px}.el-slider.is-vertical .el-slider__bar{width:var(--el-slider-height);height:auto;border-radius:0 0 3px 3px}.el-slider.is-vertical .el-slider__button-wrapper{top:auto;left:var(--el-slider-button-wrapper-offset);transform:translateY(50%)}.el-slider.is-vertical .el-slider__stop{transform:translateY(50%)}.el-slider.is-vertical .el-slider__marks-text{margin-top:0;left:15px;transform:translateY(50%)}.el-slider--large{height:40px}.el-slider--small{height:24px}.el-statistic{--el-statistic-title-font-weight:400;--el-statistic-title-font-size:var(--el-font-size-extra-small);--el-statistic-title-color:var(--el-text-color-regular);--el-statistic-content-font-weight:400;--el-statistic-content-font-size:var(--el-font-size-extra-large);--el-statistic-content-color:var(--el-text-color-primary)}.el-statistic__head{font-weight:var(--el-statistic-title-font-weight);font-size:var(--el-statistic-title-font-size);color:var(--el-statistic-title-color);line-height:20px;margin-bottom:4px}.el-statistic__content{font-weight:var(--el-statistic-content-font-weight);font-size:var(--el-statistic-content-font-size);color:var(--el-statistic-content-color)}.el-statistic__value{display:inline-block}.el-statistic__prefix{margin-right:4px;display:inline-block}.el-statistic__suffix{margin-left:4px;display:inline-block}*[data-v-0fb243fe]{font-family:win-bug-omega,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Hiragino Kaku Gothic ProN,Meiryo,sans-serif!important}.onlineGallery-toolBar[data-v-0fb243fe]{position:relative;margin-top:10px;margin-bottom:10px;display:flex;flex-flow:row wrap;justify-content:start;align-items:center;gap:10px;color:#000;-webkit-user-select:none;user-select:none;-webkit-user-drag:none}@media (max-width: 500px){.onlineGallery-toolBar[data-v-0fb243fe]{gap:4px;margin-top:4px;margin-bottom:8px;padding-left:10px;padding-right:10px}}.onlineGallery-toolBar .statistic-container[data-v-0fb243fe]{flex-shrink:0;width:140px;font-size:14px!important;display:flex;flex-flow:column;justify-content:center;align-items:center}@media (max-width: 500px){.onlineGallery-toolBar .statistic-container[data-v-0fb243fe]{width:100%;align-items:start}}.onlineGallery-toolBar .filter-container[data-v-0fb243fe]{width:fit-content;width:220px;display:flex;flex-flow:column;justify-content:center;align-items:center}@media (max-width: 500px){.onlineGallery-toolBar .filter-container[data-v-0fb243fe]{align-items:start;gap:2px}}.onlineGallery-toolBar .filter-container .filter-size[data-v-0fb243fe]{position:relative;width:100%;display:flex;flex-flow:column nowrap;justify-content:center;align-items:center}@media (max-width: 500px){.onlineGallery-toolBar .filter-container .filter-size[data-v-0fb243fe]{gap:2px}}.onlineGallery-toolBar .filter-container .filter-size .filter-size-row[data-v-0fb243fe]{width:100%;display:flex;flex-flow:row nowrap;gap:8px;justify-content:start;align-items:center}.onlineGallery-toolBar .filter-container .filter-size .filter-size-row .filter-size-slider[data-v-0fb243fe]{flex-grow:1;padding-right:10px}.onlineGallery-toolBar .filter-container .filter-size .filter-size-row .filter-size-label[data-v-0fb243fe]{margin:0;white-space:nowrap;font-size:16px!important;color:#000!important}.onlineGallery-toolBar .filter-container .filter-format[data-v-0fb243fe]{position:relative;width:100%;display:flex;flex-flow:row;justify-content:center;align-items:center;gap:8px}.onlineGallery-toolBar .filter-container .filter-format .format-select[data-v-0fb243fe]{flex-grow:1}.onlineGallery-toolBar .filter-container .filter-format .format-label[data-v-0fb243fe]{margin:0;text-align:center;white-space:nowrap;font-size:16px!important}.onlineGallery-toolBar .list-control-container[data-v-0fb243fe]{position:relative;width:fit-content;display:flex;flex-flow:column;justify-content:center;align-items:start;gap:8px}@media (max-width: 500px){.onlineGallery-toolBar .list-control-container[data-v-0fb243fe]{flex-flow:row}}.onlineGallery-toolBar .list-control-container .list-control-column[data-v-0fb243fe]{position:relative;width:fit-content;display:flex;flex-flow:row;justify-content:center;align-items:center;gap:8px}.onlineGallery-toolBar .list-control-container .list-control-column .list-control-column-input-number[data-v-0fb243fe]{width:80px}.onlineGallery-toolBar .list-control-container .list-control-column .list-control-column-label[data-v-0fb243fe]{margin:0;text-align:center;white-space:nowrap;font-size:16px!important}.onlineGallery-toolBar .list-control-container .list-control-sort-method[data-v-0fb243fe]{position:relative;width:fit-content;display:flex;flex-flow:row;justify-content:center;align-items:center;gap:8px}.onlineGallery-toolBar .list-control-container .list-control-sort-method .list-control-sort-method-select[data-v-0fb243fe]{width:120px}.onlineGallery-toolBar .list-control-container .list-control-sort-method .list-control-sort-method-label[data-v-0fb243fe]{margin:0;text-align:center;white-space:nowrap;font-size:16px!important}.onlineGallery-toolBar .button-group-container[data-v-0fb243fe]{width:fit-content}.onlineGallery-toolBar .rule-selector-container[data-v-0fb243fe]{position:relative;width:fit-content;display:flex;flex-flow:row;justify-content:center;align-items:center;gap:8px}.onlineGallery-toolBar .rule-selector-container .rule-selector-select[data-v-0fb243fe]{width:160px}.onlineGallery-toolBar .rule-selector-container .rule-selector-label[data-v-0fb243fe]{margin:0;text-align:center;white-space:nowrap;font-size:16px!important}.rule-item[data-v-0fb243fe]{height:100%!important;display:flex;justify-content:start;align-items:center;gap:8px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.rule-icon[data-v-0fb243fe]{flex-shrink:0;width:16px!important;aspect-ratio:1;display:flex;justify-content:center;align-items:center}.el-progress{position:relative;line-height:1;display:flex;align-items:center}.el-progress__text{font-size:14px;color:var(--el-text-color-regular);margin-left:5px;min-width:50px;line-height:1}.el-progress__text i{vertical-align:middle;display:block}.el-progress--circle,.el-progress--dashboard{display:inline-block}.el-progress--circle .el-progress__text,.el-progress--dashboard .el-progress__text{position:absolute;top:50%;left:0;width:100%;text-align:center;margin:0;transform:translateY(-50%)}.el-progress--circle .el-progress__text i,.el-progress--dashboard .el-progress__text i{vertical-align:middle;display:inline-block}.el-progress--without-text .el-progress__text{display:none}.el-progress--without-text .el-progress-bar{padding-right:0;margin-right:0;display:block}.el-progress--text-inside .el-progress-bar{padding-right:0;margin-right:0}.el-progress.is-success .el-progress-bar__inner{background-color:var(--el-color-success)}.el-progress.is-success .el-progress__text{color:var(--el-color-success)}.el-progress.is-warning .el-progress-bar__inner{background-color:var(--el-color-warning)}.el-progress.is-warning .el-progress__text{color:var(--el-color-warning)}.el-progress.is-exception .el-progress-bar__inner{background-color:var(--el-color-danger)}.el-progress.is-exception .el-progress__text{color:var(--el-color-danger)}.el-progress-bar{flex-grow:1;box-sizing:border-box}.el-progress-bar__outer{height:6px;border-radius:100px;background-color:var(--el-border-color-lighter);overflow:hidden;position:relative;vertical-align:middle}.el-progress-bar__inner{position:absolute;left:0;top:0;height:100%;background-color:var(--el-color-primary);text-align:right;border-radius:100px;line-height:1;white-space:nowrap;transition:width .6s ease}.el-progress-bar__inner:after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-progress-bar__inner--indeterminate{transform:translateZ(0);-webkit-animation:indeterminate 3s infinite;animation:indeterminate 3s infinite}.el-progress-bar__inner--striped{background-image:linear-gradient(45deg,rgba(0,0,0,.1) 25%,transparent 25%,transparent 50%,rgba(0,0,0,.1) 50%,rgba(0,0,0,.1) 75%,transparent 75%,transparent);background-size:1.25em 1.25em}.el-progress-bar__inner--striped.el-progress-bar__inner--striped-flow{-webkit-animation:striped-flow 3s linear infinite;animation:striped-flow 3s linear infinite}.el-progress-bar__innerText{display:inline-block;vertical-align:middle;color:#fff;font-size:12px;margin:0 5px}@-webkit-keyframes progress{0%{background-position:0 0}to{background-position:32px 0}}@keyframes progress{0%{background-position:0 0}to{background-position:32px 0}}@-webkit-keyframes indeterminate{0%{left:-100%}to{left:100%}}@keyframes indeterminate{0%{left:-100%}to{left:100%}}@-webkit-keyframes striped-flow{0%{background-position:-100%}to{background-position:100%}}@keyframes striped-flow{0%{background-position:-100%}to{background-position:100%}}*[data-v-889d9413]{border:0;margin:0;box-sizing:border-box}.onlineGallery-body[data-v-889d9413]{position:relative;width:100%;height:100%;display:flex;flex-flow:column;justify-content:stretch;align-items:center;--header-height: 80px}.onlineGallery-body .onlineGallery-toolBar[data-v-889d9413]{flex-shrink:0;position:relative;max-width:100%;width:100%;height:max-content}.onlineGallery-body .listContainer[data-v-889d9413]{flex-grow:1;position:relative;width:100%;border-radius:6px;box-shadow:var(--el-box-shadow-light);overflow:hidden}.onlineGallery-body .loadingBar[data-v-889d9413]{position:absolute;margin:0 auto;top:2px;left:0;right:0;width:50%}@media (max-width: 500px){.onlineGallery-body .loadingBar[data-v-889d9413]{width:80%}}.el-notification{--el-notification-width:330px;--el-notification-padding:14px 26px 14px 13px;--el-notification-radius:8px;--el-notification-shadow:var(--el-box-shadow-light);--el-notification-border-color:var(--el-border-color-lighter);--el-notification-icon-size:24px;--el-notification-close-font-size:var(--el-message-close-size, 16px);--el-notification-group-margin-left:13px;--el-notification-group-margin-right:8px;--el-notification-content-font-size:var(--el-font-size-base);--el-notification-content-color:var(--el-text-color-regular);--el-notification-title-font-size:16px;--el-notification-title-color:var(--el-text-color-primary);--el-notification-close-color:var(--el-text-color-secondary);--el-notification-close-hover-color:var(--el-text-color-regular)}.el-notification{display:flex;width:var(--el-notification-width);padding:var(--el-notification-padding);border-radius:var(--el-notification-radius);box-sizing:border-box;border:1px solid var(--el-notification-border-color);position:fixed;background-color:var(--el-bg-color-overlay);box-shadow:var(--el-notification-shadow);transition:opacity var(--el-transition-duration),transform var(--el-transition-duration),left var(--el-transition-duration),right var(--el-transition-duration),top .4s,bottom var(--el-transition-duration);overflow-wrap:anywhere;overflow:hidden;z-index:9999}.el-notification.right{right:16px}.el-notification.left{left:16px}.el-notification__group{margin-left:var(--el-notification-group-margin-left);margin-right:var(--el-notification-group-margin-right)}.el-notification__title{font-weight:700;font-size:var(--el-notification-title-font-size);line-height:var(--el-notification-icon-size);color:var(--el-notification-title-color);margin:0}.el-notification__content{font-size:var(--el-notification-content-font-size);line-height:24px;margin:6px 0 0;color:var(--el-notification-content-color);text-align:justify}.el-notification__content p{margin:0}.el-notification .el-notification__icon{height:var(--el-notification-icon-size);width:var(--el-notification-icon-size);font-size:var(--el-notification-icon-size)}.el-notification .el-notification__closeBtn{position:absolute;top:18px;right:15px;cursor:pointer;color:var(--el-notification-close-color);font-size:var(--el-notification-close-font-size)}.el-notification .el-notification__closeBtn:hover{color:var(--el-notification-close-hover-color)}.el-notification .el-notification--success{--el-notification-icon-color:var(--el-color-success);color:var(--el-notification-icon-color)}.el-notification .el-notification--info{--el-notification-icon-color:var(--el-color-info);color:var(--el-notification-icon-color)}.el-notification .el-notification--warning{--el-notification-icon-color:var(--el-color-warning);color:var(--el-notification-icon-color)}.el-notification .el-notification--error{--el-notification-icon-color:var(--el-color-error);color:var(--el-notification-icon-color)}.el-notification-fade-enter-from.right{right:0;transform:translate(100%)}.el-notification-fade-enter-from.left{left:0;transform:translate(-100%)}.el-notification-fade-leave-to{opacity:0}*[data-v-1b52a8bb]{box-sizing:border-box;border:0;pointer-events:auto}.onlineGallery-container[data-v-1b52a8bb]{box-sizing:border-box;position:fixed;z-index:2147483646;padding:0 30px 20px;margin:0;left:calc(0px - var(--width));top:0!important;bottom:0;width:var(--width);max-width:100vw!important;background-color:#fffc;box-shadow:var(--el-box-shadow-dark);-webkit-backdrop-filter:blur(2px);backdrop-filter:blur(2px);display:flex;flex-flow:column;justify-content:start;align-items:center;transition:.5s ease}.onlineGallery-container[data-open=true][data-v-1b52a8bb]{left:0px!important}.onlineGallery-container[data-v-1b52a8bb]:focus{outline:none}@media (max-width: 500px){.onlineGallery-container[data-v-1b52a8bb]{padding:4px}}.onlineGallery-button-close[data-v-1b52a8bb]{position:absolute;right:10px;top:10px;width:fit-content;height:fit-content;box-shadow:var(--el-box-shadow-light)}.onlineGallery-child-window-container[data-v-1b52a8bb]{position:fixed;z-index:2147483646}.onlineGallery-float-button[data-v-1b52a8bb]{position:relative;width:46px;height:46px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:xx-large!important}.onlineGallery-float-button svg[data-v-1b52a8bb]{scale:1.3} `);

(function (JSZip$1) {
  'use strict';

  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var require_main_001 = __commonJS({
    "main-a9a1c7e3.js"(exports, module) {
      function makeMap(str, expectsLowerCase) {
        const map = /* @__PURE__ */ Object.create(null);
        const list = str.split(",");
        for (let i2 = 0; i2 < list.length; i2++) {
          map[list[i2]] = true;
        }
        return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
      }
      const EMPTY_OBJ = {};
      const EMPTY_ARR = [];
      const NOOP = () => {
      };
      const NO = () => false;
      const onRE = /^on[^a-z]/;
      const isOn = (key) => onRE.test(key);
      const isModelListener = (key) => key.startsWith("onUpdate:");
      const extend = Object.assign;
      const remove = (arr, el) => {
        const i2 = arr.indexOf(el);
        if (i2 > -1) {
          arr.splice(i2, 1);
        }
      };
      const hasOwnProperty$d = Object.prototype.hasOwnProperty;
      const hasOwn = (val, key) => hasOwnProperty$d.call(val, key);
      const isArray$3 = Array.isArray;
      const isMap$2 = (val) => toTypeString(val) === "[object Map]";
      const isSet$2 = (val) => toTypeString(val) === "[object Set]";
      const isDate = (val) => toTypeString(val) === "[object Date]";
      const isFunction$2 = (val) => typeof val === "function";
      const isString$2 = (val) => typeof val === "string";
      const isSymbol$1 = (val) => typeof val === "symbol";
      const isObject$1 = (val) => val !== null && typeof val === "object";
      const isPromise = (val) => {
        return isObject$1(val) && isFunction$2(val.then) && isFunction$2(val.catch);
      };
      const objectToString$1 = Object.prototype.toString;
      const toTypeString = (value) => objectToString$1.call(value);
      const toRawType = (value) => {
        return toTypeString(value).slice(8, -1);
      };
      const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
      const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
      const isReservedProp = /* @__PURE__ */ makeMap(
        // the leading comma is intentional so empty string "" is also included
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
      );
      const cacheStringFunction = (fn2) => {
        const cache2 = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache2[str];
          return hit || (cache2[str] = fn2(str));
        };
      };
      const camelizeRE = /-(\w)/g;
      const camelize$1 = cacheStringFunction((str) => {
        return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
      });
      const hyphenateRE = /\B([A-Z])/g;
      const hyphenate = cacheStringFunction(
        (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
      );
      const capitalize$1 = cacheStringFunction(
        (str) => str.charAt(0).toUpperCase() + str.slice(1)
      );
      const toHandlerKey = cacheStringFunction(
        (str) => str ? `on${capitalize$1(str)}` : ``
      );
      const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
      const invokeArrayFns = (fns, arg) => {
        for (let i2 = 0; i2 < fns.length; i2++) {
          fns[i2](arg);
        }
      };
      const def = (obj, key, value) => {
        Object.defineProperty(obj, key, {
          configurable: true,
          enumerable: false,
          value
        });
      };
      const looseToNumber = (val) => {
        const n2 = parseFloat(val);
        return isNaN(n2) ? val : n2;
      };
      const toNumber$2 = (val) => {
        const n2 = isString$2(val) ? Number(val) : NaN;
        return isNaN(n2) ? val : n2;
      };
      let _globalThis;
      const getGlobalThis = () => {
        return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
      };
      function normalizeStyle(value) {
        if (isArray$3(value)) {
          const res = {};
          for (let i2 = 0; i2 < value.length; i2++) {
            const item = value[i2];
            const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) {
              for (const key in normalized) {
                res[key] = normalized[key];
              }
            }
          }
          return res;
        } else if (isString$2(value)) {
          return value;
        } else if (isObject$1(value)) {
          return value;
        }
      }
      const listDelimiterRE = /;(?![^(]*\))/g;
      const propertyDelimiterRE = /:([^]+)/;
      const styleCommentRE = /\/\*[^]*?\*\//g;
      function parseStringStyle(cssText) {
        const ret = {};
        cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
          if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
          }
        });
        return ret;
      }
      function normalizeClass(value) {
        let res = "";
        if (isString$2(value)) {
          res = value;
        } else if (isArray$3(value)) {
          for (let i2 = 0; i2 < value.length; i2++) {
            const normalized = normalizeClass(value[i2]);
            if (normalized) {
              res += normalized + " ";
            }
          }
        } else if (isObject$1(value)) {
          for (const name in value) {
            if (value[name]) {
              res += name + " ";
            }
          }
        }
        return res.trim();
      }
      function normalizeProps(props2) {
        if (!props2)
          return null;
        let { class: klass, style } = props2;
        if (klass && !isString$2(klass)) {
          props2.class = normalizeClass(klass);
        }
        if (style) {
          props2.style = normalizeStyle(style);
        }
        return props2;
      }
      const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
      const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
      function includeBooleanAttr(value) {
        return !!value || value === "";
      }
      function looseCompareArrays(a2, b2) {
        if (a2.length !== b2.length)
          return false;
        let equal = true;
        for (let i2 = 0; equal && i2 < a2.length; i2++) {
          equal = looseEqual(a2[i2], b2[i2]);
        }
        return equal;
      }
      function looseEqual(a2, b2) {
        if (a2 === b2)
          return true;
        let aValidType = isDate(a2);
        let bValidType = isDate(b2);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
        }
        aValidType = isSymbol$1(a2);
        bValidType = isSymbol$1(b2);
        if (aValidType || bValidType) {
          return a2 === b2;
        }
        aValidType = isArray$3(a2);
        bValidType = isArray$3(b2);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
        }
        aValidType = isObject$1(a2);
        bValidType = isObject$1(b2);
        if (aValidType || bValidType) {
          if (!aValidType || !bValidType) {
            return false;
          }
          const aKeysCount = Object.keys(a2).length;
          const bKeysCount = Object.keys(b2).length;
          if (aKeysCount !== bKeysCount) {
            return false;
          }
          for (const key in a2) {
            const aHasKey = a2.hasOwnProperty(key);
            const bHasKey = b2.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b2[key])) {
              return false;
            }
          }
        }
        return String(a2) === String(b2);
      }
      function looseIndexOf(arr, val) {
        return arr.findIndex((item) => looseEqual(item, val));
      }
      const toDisplayString = (val) => {
        return isString$2(val) ? val : val == null ? "" : isArray$3(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
      };
      const replacer = (_key, val) => {
        if (val && val.__v_isRef) {
          return replacer(_key, val.value);
        } else if (isMap$2(val)) {
          return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
              entries[`${key} =>`] = val2;
              return entries;
            }, {})
          };
        } else if (isSet$2(val)) {
          return {
            [`Set(${val.size})`]: [...val.values()]
          };
        } else if (isObject$1(val) && !isArray$3(val) && !isPlainObject$1(val)) {
          return String(val);
        }
        return val;
      };
      let activeEffectScope;
      class EffectScope {
        constructor(detached = false) {
          this.detached = detached;
          this._active = true;
          this.effects = [];
          this.cleanups = [];
          this.parent = activeEffectScope;
          if (!detached && activeEffectScope) {
            this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
              this
            ) - 1;
          }
        }
        get active() {
          return this._active;
        }
        run(fn2) {
          if (this._active) {
            const currentEffectScope = activeEffectScope;
            try {
              activeEffectScope = this;
              return fn2();
            } finally {
              activeEffectScope = currentEffectScope;
            }
          }
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        on() {
          activeEffectScope = this;
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        off() {
          activeEffectScope = this.parent;
        }
        stop(fromParent) {
          if (this._active) {
            let i2, l2;
            for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
              this.effects[i2].stop();
            }
            for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
              this.cleanups[i2]();
            }
            if (this.scopes) {
              for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
                this.scopes[i2].stop(true);
              }
            }
            if (!this.detached && this.parent && !fromParent) {
              const last = this.parent.scopes.pop();
              if (last && last !== this) {
                this.parent.scopes[this.index] = last;
                last.index = this.index;
              }
            }
            this.parent = void 0;
            this._active = false;
          }
        }
      }
      function effectScope(detached) {
        return new EffectScope(detached);
      }
      function recordEffectScope(effect, scope = activeEffectScope) {
        if (scope && scope.active) {
          scope.effects.push(effect);
        }
      }
      function getCurrentScope() {
        return activeEffectScope;
      }
      function onScopeDispose(fn2) {
        if (activeEffectScope) {
          activeEffectScope.cleanups.push(fn2);
        }
      }
      const createDep = (effects) => {
        const dep = new Set(effects);
        dep.w = 0;
        dep.n = 0;
        return dep;
      };
      const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
      const newTracked = (dep) => (dep.n & trackOpBit) > 0;
      const initDepMarkers = ({ deps }) => {
        if (deps.length) {
          for (let i2 = 0; i2 < deps.length; i2++) {
            deps[i2].w |= trackOpBit;
          }
        }
      };
      const finalizeDepMarkers = (effect) => {
        const { deps } = effect;
        if (deps.length) {
          let ptr = 0;
          for (let i2 = 0; i2 < deps.length; i2++) {
            const dep = deps[i2];
            if (wasTracked(dep) && !newTracked(dep)) {
              dep.delete(effect);
            } else {
              deps[ptr++] = dep;
            }
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
          }
          deps.length = ptr;
        }
      };
      const targetMap = /* @__PURE__ */ new WeakMap();
      let effectTrackDepth = 0;
      let trackOpBit = 1;
      const maxMarkerBits = 30;
      let activeEffect;
      const ITERATE_KEY = Symbol("");
      const MAP_KEY_ITERATE_KEY = Symbol("");
      class ReactiveEffect {
        constructor(fn2, scheduler = null, scope) {
          this.fn = fn2;
          this.scheduler = scheduler;
          this.active = true;
          this.deps = [];
          this.parent = void 0;
          recordEffectScope(this, scope);
        }
        run() {
          if (!this.active) {
            return this.fn();
          }
          let parent = activeEffect;
          let lastShouldTrack = shouldTrack;
          while (parent) {
            if (parent === this) {
              return;
            }
            parent = parent.parent;
          }
          try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) {
              initDepMarkers(this);
            } else {
              cleanupEffect(this);
            }
            return this.fn();
          } finally {
            if (effectTrackDepth <= maxMarkerBits) {
              finalizeDepMarkers(this);
            }
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = void 0;
            if (this.deferStop) {
              this.stop();
            }
          }
        }
        stop() {
          if (activeEffect === this) {
            this.deferStop = true;
          } else if (this.active) {
            cleanupEffect(this);
            if (this.onStop) {
              this.onStop();
            }
            this.active = false;
          }
        }
      }
      function cleanupEffect(effect2) {
        const { deps } = effect2;
        if (deps.length) {
          for (let i2 = 0; i2 < deps.length; i2++) {
            deps[i2].delete(effect2);
          }
          deps.length = 0;
        }
      }
      let shouldTrack = true;
      const trackStack = [];
      function pauseTracking() {
        trackStack.push(shouldTrack);
        shouldTrack = false;
      }
      function resetTracking() {
        const last = trackStack.pop();
        shouldTrack = last === void 0 ? true : last;
      }
      function track(target, type2, key) {
        if (shouldTrack && activeEffect) {
          let depsMap = targetMap.get(target);
          if (!depsMap) {
            targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
          }
          let dep = depsMap.get(key);
          if (!dep) {
            depsMap.set(key, dep = createDep());
          }
          trackEffects(dep);
        }
      }
      function trackEffects(dep, debuggerEventExtraInfo) {
        let shouldTrack2 = false;
        if (effectTrackDepth <= maxMarkerBits) {
          if (!newTracked(dep)) {
            dep.n |= trackOpBit;
            shouldTrack2 = !wasTracked(dep);
          }
        } else {
          shouldTrack2 = !dep.has(activeEffect);
        }
        if (shouldTrack2) {
          dep.add(activeEffect);
          activeEffect.deps.push(dep);
        }
      }
      function trigger(target, type2, key, newValue, oldValue, oldTarget) {
        const depsMap = targetMap.get(target);
        if (!depsMap) {
          return;
        }
        let deps = [];
        if (type2 === "clear") {
          deps = [...depsMap.values()];
        } else if (key === "length" && isArray$3(target)) {
          const newLength = Number(newValue);
          depsMap.forEach((dep, key2) => {
            if (key2 === "length" || key2 >= newLength) {
              deps.push(dep);
            }
          });
        } else {
          if (key !== void 0) {
            deps.push(depsMap.get(key));
          }
          switch (type2) {
            case "add":
              if (!isArray$3(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
                if (isMap$2(target)) {
                  deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              } else if (isIntegerKey(key)) {
                deps.push(depsMap.get("length"));
              }
              break;
            case "delete":
              if (!isArray$3(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
                if (isMap$2(target)) {
                  deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              }
              break;
            case "set":
              if (isMap$2(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
              }
              break;
          }
        }
        if (deps.length === 1) {
          if (deps[0]) {
            {
              triggerEffects(deps[0]);
            }
          }
        } else {
          const effects = [];
          for (const dep of deps) {
            if (dep) {
              effects.push(...dep);
            }
          }
          {
            triggerEffects(createDep(effects));
          }
        }
      }
      function triggerEffects(dep, debuggerEventExtraInfo) {
        const effects = isArray$3(dep) ? dep : [...dep];
        for (const effect2 of effects) {
          if (effect2.computed) {
            triggerEffect(effect2);
          }
        }
        for (const effect2 of effects) {
          if (!effect2.computed) {
            triggerEffect(effect2);
          }
        }
      }
      function triggerEffect(effect2, debuggerEventExtraInfo) {
        if (effect2 !== activeEffect || effect2.allowRecurse) {
          if (effect2.scheduler) {
            effect2.scheduler();
          } else {
            effect2.run();
          }
        }
      }
      function getDepFromReactive(object2, key) {
        var _a2;
        return (_a2 = targetMap.get(object2)) == null ? void 0 : _a2.get(key);
      }
      const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
      const builtInSymbols = new Set(
        /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
      );
      const get$1 = /* @__PURE__ */ createGetter();
      const shallowGet = /* @__PURE__ */ createGetter(false, true);
      const readonlyGet = /* @__PURE__ */ createGetter(true);
      const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
      function createArrayInstrumentations() {
        const instrumentations = {};
        ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
          instrumentations[key] = function(...args) {
            const arr = toRaw(this);
            for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
              track(arr, "get", i2 + "");
            }
            const res = arr[key](...args);
            if (res === -1 || res === false) {
              return arr[key](...args.map(toRaw));
            } else {
              return res;
            }
          };
        });
        ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
          instrumentations[key] = function(...args) {
            pauseTracking();
            const res = toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
          };
        });
        return instrumentations;
      }
      function hasOwnProperty$c(key) {
        const obj = toRaw(this);
        track(obj, "has", key);
        return obj.hasOwnProperty(key);
      }
      function createGetter(isReadonly2 = false, shallow = false) {
        return function get2(target, key, receiver) {
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_isShallow") {
            return shallow;
          } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
            return target;
          }
          const targetIsArray = isArray$3(target);
          if (!isReadonly2) {
            if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
              return Reflect.get(arrayInstrumentations, key, receiver);
            }
            if (key === "hasOwnProperty") {
              return hasOwnProperty$c;
            }
          }
          const res = Reflect.get(target, key, receiver);
          if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
          }
          if (!isReadonly2) {
            track(target, "get", key);
          }
          if (shallow) {
            return res;
          }
          if (isRef(res)) {
            return targetIsArray && isIntegerKey(key) ? res : res.value;
          }
          if (isObject$1(res)) {
            return isReadonly2 ? readonly(res) : reactive(res);
          }
          return res;
        };
      }
      const set$1 = /* @__PURE__ */ createSetter();
      const shallowSet = /* @__PURE__ */ createSetter(true);
      function createSetter(shallow = false) {
        return function set2(target, key, value, receiver) {
          let oldValue = target[key];
          if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
            return false;
          }
          if (!shallow) {
            if (!isShallow(value) && !isReadonly(value)) {
              oldValue = toRaw(oldValue);
              value = toRaw(value);
            }
            if (!isArray$3(target) && isRef(oldValue) && !isRef(value)) {
              oldValue.value = value;
              return true;
            }
          }
          const hadKey = isArray$3(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
          const result = Reflect.set(target, key, value, receiver);
          if (target === toRaw(receiver)) {
            if (!hadKey) {
              trigger(target, "add", key, value);
            } else if (hasChanged(value, oldValue)) {
              trigger(target, "set", key, value);
            }
          }
          return result;
        };
      }
      function deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      }
      function has$1(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      function ownKeys(target) {
        track(target, "iterate", isArray$3(target) ? "length" : ITERATE_KEY);
        return Reflect.ownKeys(target);
      }
      const mutableHandlers = {
        get: get$1,
        set: set$1,
        deleteProperty,
        has: has$1,
        ownKeys
      };
      const readonlyHandlers = {
        get: readonlyGet,
        set(target, key) {
          return true;
        },
        deleteProperty(target, key) {
          return true;
        }
      };
      const shallowReactiveHandlers = /* @__PURE__ */ extend(
        {},
        mutableHandlers,
        {
          get: shallowGet,
          set: shallowSet
        }
      );
      const toShallow = (value) => value;
      const getProto = (v2) => Reflect.getPrototypeOf(v2);
      function get$2(target, key, isReadonly2 = false, isShallow2 = false) {
        target = target["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!isReadonly2) {
          if (key !== rawKey) {
            track(rawTarget, "get", key);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has: has2 } = getProto(rawTarget);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        if (has2.call(rawTarget, key)) {
          return wrap(target.get(key));
        } else if (has2.call(rawTarget, rawKey)) {
          return wrap(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key);
        }
      }
      function has(key, isReadonly2 = false) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!isReadonly2) {
          if (key !== rawKey) {
            track(rawTarget, "has", key);
          }
          track(rawTarget, "has", rawKey);
        }
        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
      }
      function size(target, isReadonly2 = false) {
        target = target["__v_raw"];
        !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return Reflect.get(target, "size", target);
      }
      function add(value) {
        value = toRaw(value);
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      }
      function set$2(key, value) {
        value = toRaw(value);
        const target = toRaw(this);
        const { has: has2, get: get2 } = getProto(target);
        let hadKey = has2.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target, key);
        }
        const oldValue = get2.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      }
      function deleteEntry(key) {
        const target = toRaw(this);
        const { has: has2, get: get2 } = getProto(target);
        let hadKey = has2.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target, key);
        }
        get2 ? get2.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      }
      function clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(target, "clear", void 0, void 0);
        }
        return result;
      }
      function createForEach(isReadonly2, isShallow2) {
        return function forEach(callback, thisArg) {
          const observed = this;
          const target = observed["__v_raw"];
          const rawTarget = toRaw(target);
          const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
          !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
          return target.forEach((value, key) => {
            return callback.call(thisArg, wrap(value), wrap(key), observed);
          });
        };
      }
      function createIterableMethod(method2, isReadonly2, isShallow2) {
        return function(...args) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const targetIsMap = isMap$2(rawTarget);
          const isPair = method2 === "entries" || method2 === Symbol.iterator && targetIsMap;
          const isKeyOnly = method2 === "keys" && targetIsMap;
          const innerIterator = target[method2](...args);
          const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
          !isReadonly2 && track(
            rawTarget,
            "iterate",
            isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
          );
          return {
            // iterator protocol
            next() {
              const { value, done } = innerIterator.next();
              return done ? { value, done } : {
                value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                done
              };
            },
            // iterable protocol
            [Symbol.iterator]() {
              return this;
            }
          };
        };
      }
      function createReadonlyMethod(type2) {
        return function(...args) {
          return type2 === "delete" ? false : this;
        };
      }
      function createInstrumentations() {
        const mutableInstrumentations2 = {
          get(key) {
            return get$2(this, key);
          },
          get size() {
            return size(this);
          },
          has,
          add,
          set: set$2,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, false)
        };
        const shallowInstrumentations2 = {
          get(key) {
            return get$2(this, key, false, true);
          },
          get size() {
            return size(this);
          },
          has,
          add,
          set: set$2,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, true)
        };
        const readonlyInstrumentations2 = {
          get(key) {
            return get$2(this, key, true);
          },
          get size() {
            return size(this, true);
          },
          has(key) {
            return has.call(this, key, true);
          },
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear"),
          forEach: createForEach(true, false)
        };
        const shallowReadonlyInstrumentations2 = {
          get(key) {
            return get$2(this, key, true, true);
          },
          get size() {
            return size(this, true);
          },
          has(key) {
            return has.call(this, key, true);
          },
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear"),
          forEach: createForEach(true, true)
        };
        const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
        iteratorMethods.forEach((method2) => {
          mutableInstrumentations2[method2] = createIterableMethod(
            method2,
            false,
            false
          );
          readonlyInstrumentations2[method2] = createIterableMethod(
            method2,
            true,
            false
          );
          shallowInstrumentations2[method2] = createIterableMethod(
            method2,
            false,
            true
          );
          shallowReadonlyInstrumentations2[method2] = createIterableMethod(
            method2,
            true,
            true
          );
        });
        return [
          mutableInstrumentations2,
          readonlyInstrumentations2,
          shallowInstrumentations2,
          shallowReadonlyInstrumentations2
        ];
      }
      const [
        mutableInstrumentations,
        readonlyInstrumentations,
        shallowInstrumentations,
        shallowReadonlyInstrumentations
      ] = /* @__PURE__ */ createInstrumentations();
      function createInstrumentationGetter(isReadonly2, shallow) {
        const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
        return (target, key, receiver) => {
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_raw") {
            return target;
          }
          return Reflect.get(
            hasOwn(instrumentations, key) && key in target ? instrumentations : target,
            key,
            receiver
          );
        };
      }
      const mutableCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, false)
      };
      const shallowCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, true)
      };
      const readonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, false)
      };
      const reactiveMap = /* @__PURE__ */ new WeakMap();
      const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
      const readonlyMap = /* @__PURE__ */ new WeakMap();
      const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
      function targetTypeMap(rawType) {
        switch (rawType) {
          case "Object":
          case "Array":
            return 1;
          case "Map":
          case "Set":
          case "WeakMap":
          case "WeakSet":
            return 2;
          default:
            return 0;
        }
      }
      function getTargetType(value) {
        return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
      }
      function reactive(target) {
        if (isReadonly(target)) {
          return target;
        }
        return createReactiveObject(
          target,
          false,
          mutableHandlers,
          mutableCollectionHandlers,
          reactiveMap
        );
      }
      function shallowReactive(target) {
        return createReactiveObject(
          target,
          false,
          shallowReactiveHandlers,
          shallowCollectionHandlers,
          shallowReactiveMap
        );
      }
      function readonly(target) {
        return createReactiveObject(
          target,
          true,
          readonlyHandlers,
          readonlyCollectionHandlers,
          readonlyMap
        );
      }
      function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
        if (!isObject$1(target)) {
          return target;
        }
        if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
          return target;
        }
        const existingProxy = proxyMap.get(target);
        if (existingProxy) {
          return existingProxy;
        }
        const targetType = getTargetType(target);
        if (targetType === 0) {
          return target;
        }
        const proxy = new Proxy(
          target,
          targetType === 2 ? collectionHandlers : baseHandlers
        );
        proxyMap.set(target, proxy);
        return proxy;
      }
      function isReactive(value) {
        if (isReadonly(value)) {
          return isReactive(value["__v_raw"]);
        }
        return !!(value && value["__v_isReactive"]);
      }
      function isReadonly(value) {
        return !!(value && value["__v_isReadonly"]);
      }
      function isShallow(value) {
        return !!(value && value["__v_isShallow"]);
      }
      function isProxy(value) {
        return isReactive(value) || isReadonly(value);
      }
      function toRaw(observed) {
        const raw = observed && observed["__v_raw"];
        return raw ? toRaw(raw) : observed;
      }
      function markRaw(value) {
        def(value, "__v_skip", true);
        return value;
      }
      const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
      const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
      function trackRefValue(ref2) {
        if (shouldTrack && activeEffect) {
          ref2 = toRaw(ref2);
          {
            trackEffects(ref2.dep || (ref2.dep = createDep()));
          }
        }
      }
      function triggerRefValue(ref2, newVal) {
        ref2 = toRaw(ref2);
        const dep = ref2.dep;
        if (dep) {
          {
            triggerEffects(dep);
          }
        }
      }
      function isRef(r2) {
        return !!(r2 && r2.__v_isRef === true);
      }
      function ref(value) {
        return createRef(value, false);
      }
      function shallowRef(value) {
        return createRef(value, true);
      }
      function createRef(rawValue, shallow) {
        if (isRef(rawValue)) {
          return rawValue;
        }
        return new RefImpl(rawValue, shallow);
      }
      class RefImpl {
        constructor(value, __v_isShallow) {
          this.__v_isShallow = __v_isShallow;
          this.dep = void 0;
          this.__v_isRef = true;
          this._rawValue = __v_isShallow ? value : toRaw(value);
          this._value = __v_isShallow ? value : toReactive(value);
        }
        get value() {
          trackRefValue(this);
          return this._value;
        }
        set value(newVal) {
          const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
          newVal = useDirectValue ? newVal : toRaw(newVal);
          if (hasChanged(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = useDirectValue ? newVal : toReactive(newVal);
            triggerRefValue(this);
          }
        }
      }
      function triggerRef(ref2) {
        triggerRefValue(ref2);
      }
      function unref(ref2) {
        return isRef(ref2) ? ref2.value : ref2;
      }
      const shallowUnwrapHandlers = {
        get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
        set: (target, key, value, receiver) => {
          const oldValue = target[key];
          if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          } else {
            return Reflect.set(target, key, value, receiver);
          }
        }
      };
      function proxyRefs(objectWithRefs) {
        return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
      }
      class CustomRefImpl {
        constructor(factory) {
          this.dep = void 0;
          this.__v_isRef = true;
          const { get: get2, set: set2 } = factory(
            () => trackRefValue(this),
            () => triggerRefValue(this)
          );
          this._get = get2;
          this._set = set2;
        }
        get value() {
          return this._get();
        }
        set value(newVal) {
          this._set(newVal);
        }
      }
      function customRef(factory) {
        return new CustomRefImpl(factory);
      }
      function toRefs$1(object2) {
        const ret = isArray$3(object2) ? new Array(object2.length) : {};
        for (const key in object2) {
          ret[key] = propertyToRef(object2, key);
        }
        return ret;
      }
      class ObjectRefImpl {
        constructor(_object, _key, _defaultValue) {
          this._object = _object;
          this._key = _key;
          this._defaultValue = _defaultValue;
          this.__v_isRef = true;
        }
        get value() {
          const val = this._object[this._key];
          return val === void 0 ? this._defaultValue : val;
        }
        set value(newVal) {
          this._object[this._key] = newVal;
        }
        get dep() {
          return getDepFromReactive(toRaw(this._object), this._key);
        }
      }
      class GetterRefImpl {
        constructor(_getter) {
          this._getter = _getter;
          this.__v_isRef = true;
          this.__v_isReadonly = true;
        }
        get value() {
          return this._getter();
        }
      }
      function toRef$1(source, key, defaultValue) {
        if (isRef(source)) {
          return source;
        } else if (isFunction$2(source)) {
          return new GetterRefImpl(source);
        } else if (isObject$1(source) && arguments.length > 1) {
          return propertyToRef(source, key, defaultValue);
        } else {
          return ref(source);
        }
      }
      function propertyToRef(source, key, defaultValue) {
        const val = source[key];
        return isRef(val) ? val : new ObjectRefImpl(
          source,
          key,
          defaultValue
        );
      }
      class ComputedRefImpl {
        constructor(getter, _setter, isReadonly2, isSSR) {
          this._setter = _setter;
          this.dep = void 0;
          this.__v_isRef = true;
          this["__v_isReadonly"] = false;
          this._dirty = true;
          this.effect = new ReactiveEffect(getter, () => {
            if (!this._dirty) {
              this._dirty = true;
              triggerRefValue(this);
            }
          });
          this.effect.computed = this;
          this.effect.active = this._cacheable = !isSSR;
          this["__v_isReadonly"] = isReadonly2;
        }
        get value() {
          const self2 = toRaw(this);
          trackRefValue(self2);
          if (self2._dirty || !self2._cacheable) {
            self2._dirty = false;
            self2._value = self2.effect.run();
          }
          return self2._value;
        }
        set value(newValue) {
          this._setter(newValue);
        }
      }
      function computed$1(getterOrOptions, debugOptions, isSSR = false) {
        let getter;
        let setter;
        const onlyGetter = isFunction$2(getterOrOptions);
        if (onlyGetter) {
          getter = getterOrOptions;
          setter = NOOP;
        } else {
          getter = getterOrOptions.get;
          setter = getterOrOptions.set;
        }
        const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
        return cRef;
      }
      function warn(msg, ...args) {
        return;
      }
      function callWithErrorHandling(fn2, instance, type2, args) {
        let res;
        try {
          res = args ? fn2(...args) : fn2();
        } catch (err) {
          handleError(err, instance, type2);
        }
        return res;
      }
      function callWithAsyncErrorHandling(fn2, instance, type2, args) {
        if (isFunction$2(fn2)) {
          const res = callWithErrorHandling(fn2, instance, type2, args);
          if (res && isPromise(res)) {
            res.catch((err) => {
              handleError(err, instance, type2);
            });
          }
          return res;
        }
        const values = [];
        for (let i2 = 0; i2 < fn2.length; i2++) {
          values.push(callWithAsyncErrorHandling(fn2[i2], instance, type2, args));
        }
        return values;
      }
      function handleError(err, instance, type2, throwInDev = true) {
        const contextVNode = instance ? instance.vnode : null;
        if (instance) {
          let cur = instance.parent;
          const exposedInstance = instance.proxy;
          const errorInfo = type2;
          while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
              for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
                if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
                  return;
                }
              }
            }
            cur = cur.parent;
          }
          const appErrorHandler = instance.appContext.config.errorHandler;
          if (appErrorHandler) {
            callWithErrorHandling(
              appErrorHandler,
              null,
              10,
              [err, exposedInstance, errorInfo]
            );
            return;
          }
        }
        logError(err, type2, contextVNode, throwInDev);
      }
      function logError(err, type2, contextVNode, throwInDev = true) {
        {
          console.error(err);
        }
      }
      let isFlushing = false;
      let isFlushPending = false;
      const queue = [];
      let flushIndex = 0;
      const pendingPostFlushCbs = [];
      let activePostFlushCbs = null;
      let postFlushIndex = 0;
      const resolvedPromise = /* @__PURE__ */ Promise.resolve();
      let currentFlushPromise = null;
      function nextTick(fn2) {
        const p2 = currentFlushPromise || resolvedPromise;
        return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
      }
      function findInsertionIndex(id2) {
        let start = flushIndex + 1;
        let end2 = queue.length;
        while (start < end2) {
          const middle = start + end2 >>> 1;
          const middleJobId = getId(queue[middle]);
          middleJobId < id2 ? start = middle + 1 : end2 = middle;
        }
        return start;
      }
      function queueJob(job) {
        if (!queue.length || !queue.includes(
          job,
          isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
        )) {
          if (job.id == null) {
            queue.push(job);
          } else {
            queue.splice(findInsertionIndex(job.id), 0, job);
          }
          queueFlush();
        }
      }
      function queueFlush() {
        if (!isFlushing && !isFlushPending) {
          isFlushPending = true;
          currentFlushPromise = resolvedPromise.then(flushJobs);
        }
      }
      function invalidateJob(job) {
        const i2 = queue.indexOf(job);
        if (i2 > flushIndex) {
          queue.splice(i2, 1);
        }
      }
      function queuePostFlushCb(cb) {
        if (!isArray$3(cb)) {
          if (!activePostFlushCbs || !activePostFlushCbs.includes(
            cb,
            cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
          )) {
            pendingPostFlushCbs.push(cb);
          }
        } else {
          pendingPostFlushCbs.push(...cb);
        }
        queueFlush();
      }
      function flushPreFlushCbs(seen, i2 = isFlushing ? flushIndex + 1 : 0) {
        for (; i2 < queue.length; i2++) {
          const cb = queue[i2];
          if (cb && cb.pre) {
            queue.splice(i2, 1);
            i2--;
            cb();
          }
        }
      }
      function flushPostFlushCbs(seen) {
        if (pendingPostFlushCbs.length) {
          const deduped = [...new Set(pendingPostFlushCbs)];
          pendingPostFlushCbs.length = 0;
          if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
          }
          activePostFlushCbs = deduped;
          activePostFlushCbs.sort((a2, b2) => getId(a2) - getId(b2));
          for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            activePostFlushCbs[postFlushIndex]();
          }
          activePostFlushCbs = null;
          postFlushIndex = 0;
        }
      }
      const getId = (job) => job.id == null ? Infinity : job.id;
      const comparator = (a2, b2) => {
        const diff = getId(a2) - getId(b2);
        if (diff === 0) {
          if (a2.pre && !b2.pre)
            return -1;
          if (b2.pre && !a2.pre)
            return 1;
        }
        return diff;
      };
      function flushJobs(seen) {
        isFlushPending = false;
        isFlushing = true;
        queue.sort(comparator);
        try {
          for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job && job.active !== false) {
              if (false)
                ;
              callWithErrorHandling(job, null, 14);
            }
          }
        } finally {
          flushIndex = 0;
          queue.length = 0;
          flushPostFlushCbs();
          isFlushing = false;
          currentFlushPromise = null;
          if (queue.length || pendingPostFlushCbs.length) {
            flushJobs();
          }
        }
      }
      function emit(instance, event, ...rawArgs) {
        if (instance.isUnmounted)
          return;
        const props2 = instance.vnode.props || EMPTY_OBJ;
        let args = rawArgs;
        const isModelListener2 = event.startsWith("update:");
        const modelArg = isModelListener2 && event.slice(7);
        if (modelArg && modelArg in props2) {
          const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
          const { number: number2, trim } = props2[modifiersKey] || EMPTY_OBJ;
          if (trim) {
            args = rawArgs.map((a2) => isString$2(a2) ? a2.trim() : a2);
          }
          if (number2) {
            args = rawArgs.map(looseToNumber);
          }
        }
        let handlerName;
        let handler = props2[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
        props2[handlerName = toHandlerKey(camelize$1(event))];
        if (!handler && isModelListener2) {
          handler = props2[handlerName = toHandlerKey(hyphenate(event))];
        }
        if (handler) {
          callWithAsyncErrorHandling(
            handler,
            instance,
            6,
            args
          );
        }
        const onceHandler = props2[handlerName + `Once`];
        if (onceHandler) {
          if (!instance.emitted) {
            instance.emitted = {};
          } else if (instance.emitted[handlerName]) {
            return;
          }
          instance.emitted[handlerName] = true;
          callWithAsyncErrorHandling(
            onceHandler,
            instance,
            6,
            args
          );
        }
      }
      function normalizeEmitsOptions(comp, appContext, asMixin = false) {
        const cache2 = appContext.emitsCache;
        const cached = cache2.get(comp);
        if (cached !== void 0) {
          return cached;
        }
        const raw = comp.emits;
        let normalized = {};
        let hasExtends = false;
        if (!isFunction$2(comp)) {
          const extendEmits = (raw2) => {
            const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
            if (normalizedFromExtend) {
              hasExtends = true;
              extend(normalized, normalizedFromExtend);
            }
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
          }
          if (comp.extends) {
            extendEmits(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
          }
        }
        if (!raw && !hasExtends) {
          if (isObject$1(comp)) {
            cache2.set(comp, null);
          }
          return null;
        }
        if (isArray$3(raw)) {
          raw.forEach((key) => normalized[key] = null);
        } else {
          extend(normalized, raw);
        }
        if (isObject$1(comp)) {
          cache2.set(comp, normalized);
        }
        return normalized;
      }
      function isEmitListener(options, key) {
        if (!options || !isOn(key)) {
          return false;
        }
        key = key.slice(2).replace(/Once$/, "");
        return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
      }
      let currentRenderingInstance = null;
      let currentScopeId = null;
      function setCurrentRenderingInstance(instance) {
        const prev = currentRenderingInstance;
        currentRenderingInstance = instance;
        currentScopeId = instance && instance.type.__scopeId || null;
        return prev;
      }
      function pushScopeId(id2) {
        currentScopeId = id2;
      }
      function popScopeId() {
        currentScopeId = null;
      }
      function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
        if (!ctx)
          return fn2;
        if (fn2._n) {
          return fn2;
        }
        const renderFnWithContext = (...args) => {
          if (renderFnWithContext._d) {
            setBlockTracking(-1);
          }
          const prevInstance = setCurrentRenderingInstance(ctx);
          let res;
          try {
            res = fn2(...args);
          } finally {
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) {
              setBlockTracking(1);
            }
          }
          return res;
        };
        renderFnWithContext._n = true;
        renderFnWithContext._c = true;
        renderFnWithContext._d = true;
        return renderFnWithContext;
      }
      function markAttrsAccessed() {
      }
      function renderComponentRoot(instance) {
        const {
          type: Component,
          vnode,
          proxy,
          withProxy,
          props: props2,
          propsOptions: [propsOptions],
          slots,
          attrs,
          emit: emit2,
          render: render2,
          renderCache,
          data,
          setupState,
          ctx,
          inheritAttrs
        } = instance;
        let result;
        let fallthroughAttrs;
        const prev = setCurrentRenderingInstance(instance);
        try {
          if (vnode.shapeFlag & 4) {
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(
              render2.call(
                proxyToUse,
                proxyToUse,
                renderCache,
                props2,
                setupState,
                data,
                ctx
              )
            );
            fallthroughAttrs = attrs;
          } else {
            const render22 = Component;
            if (false)
              ;
            result = normalizeVNode(
              render22.length > 1 ? render22(
                props2,
                false ? {
                  get attrs() {
                    markAttrsAccessed();
                    return attrs;
                  },
                  slots,
                  emit: emit2
                } : { attrs, slots, emit: emit2 }
              ) : render22(
                props2,
                null
                /* we know it doesn't need it */
              )
            );
            fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
          }
        } catch (err) {
          blockStack.length = 0;
          handleError(err, instance, 1);
          result = createVNode(Comment);
        }
        let root2 = result;
        if (fallthroughAttrs && inheritAttrs !== false) {
          const keys2 = Object.keys(fallthroughAttrs);
          const { shapeFlag } = root2;
          if (keys2.length) {
            if (shapeFlag & (1 | 6)) {
              if (propsOptions && keys2.some(isModelListener)) {
                fallthroughAttrs = filterModelListeners(
                  fallthroughAttrs,
                  propsOptions
                );
              }
              root2 = cloneVNode(root2, fallthroughAttrs);
            }
          }
        }
        if (vnode.dirs) {
          root2 = cloneVNode(root2);
          root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
        }
        if (vnode.transition) {
          root2.transition = vnode.transition;
        }
        {
          result = root2;
        }
        setCurrentRenderingInstance(prev);
        return result;
      }
      const getFunctionalFallthrough = (attrs) => {
        let res;
        for (const key in attrs) {
          if (key === "class" || key === "style" || isOn(key)) {
            (res || (res = {}))[key] = attrs[key];
          }
        }
        return res;
      };
      const filterModelListeners = (attrs, props2) => {
        const res = {};
        for (const key in attrs) {
          if (!isModelListener(key) || !(key.slice(9) in props2)) {
            res[key] = attrs[key];
          }
        }
        return res;
      };
      function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
        const { props: prevProps, children: prevChildren, component } = prevVNode;
        const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
        const emits = component.emitsOptions;
        if (nextVNode.dirs || nextVNode.transition) {
          return true;
        }
        if (optimized && patchFlag >= 0) {
          if (patchFlag & 1024) {
            return true;
          }
          if (patchFlag & 16) {
            if (!prevProps) {
              return !!nextProps;
            }
            return hasPropsChanged(prevProps, nextProps, emits);
          } else if (patchFlag & 8) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i2 = 0; i2 < dynamicProps.length; i2++) {
              const key = dynamicProps[i2];
              if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
                return true;
              }
            }
          }
        } else {
          if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
              return true;
            }
          }
          if (prevProps === nextProps) {
            return false;
          }
          if (!prevProps) {
            return !!nextProps;
          }
          if (!nextProps) {
            return true;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        }
        return false;
      }
      function hasPropsChanged(prevProps, nextProps, emitsOptions) {
        const nextKeys = Object.keys(nextProps);
        if (nextKeys.length !== Object.keys(prevProps).length) {
          return true;
        }
        for (let i2 = 0; i2 < nextKeys.length; i2++) {
          const key = nextKeys[i2];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
            return true;
          }
        }
        return false;
      }
      function updateHOCHostEl({ vnode, parent }, el) {
        while (parent && parent.subTree === vnode) {
          (vnode = parent.vnode).el = el;
          parent = parent.parent;
        }
      }
      const isSuspense = (type2) => type2.__isSuspense;
      function queueEffectWithSuspense(fn2, suspense) {
        if (suspense && suspense.pendingBranch) {
          if (isArray$3(fn2)) {
            suspense.effects.push(...fn2);
          } else {
            suspense.effects.push(fn2);
          }
        } else {
          queuePostFlushCb(fn2);
        }
      }
      function watchEffect(effect, options) {
        return doWatch(effect, null, options);
      }
      const INITIAL_WATCHER_VALUE = {};
      function watch(source, cb, options) {
        return doWatch(source, cb, options);
      }
      function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
        var _a2;
        const instance = getCurrentScope() === ((_a2 = currentInstance) == null ? void 0 : _a2.scope) ? currentInstance : null;
        let getter;
        let forceTrigger = false;
        let isMultiSource = false;
        if (isRef(source)) {
          getter = () => source.value;
          forceTrigger = isShallow(source);
        } else if (isReactive(source)) {
          getter = () => source;
          deep = true;
        } else if (isArray$3(source)) {
          isMultiSource = true;
          forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
          getter = () => source.map((s2) => {
            if (isRef(s2)) {
              return s2.value;
            } else if (isReactive(s2)) {
              return traverse(s2);
            } else if (isFunction$2(s2)) {
              return callWithErrorHandling(s2, instance, 2);
            } else
              ;
          });
        } else if (isFunction$2(source)) {
          if (cb) {
            getter = () => callWithErrorHandling(source, instance, 2);
          } else {
            getter = () => {
              if (instance && instance.isUnmounted) {
                return;
              }
              if (cleanup) {
                cleanup();
              }
              return callWithAsyncErrorHandling(
                source,
                instance,
                3,
                [onCleanup]
              );
            };
          }
        } else {
          getter = NOOP;
        }
        if (cb && deep) {
          const baseGetter = getter;
          getter = () => traverse(baseGetter());
        }
        let cleanup;
        let onCleanup = (fn2) => {
          cleanup = effect.onStop = () => {
            callWithErrorHandling(fn2, instance, 4);
          };
        };
        let ssrCleanup;
        if (isInSSRComponentSetup) {
          onCleanup = NOOP;
          if (!cb) {
            getter();
          } else if (immediate) {
            callWithAsyncErrorHandling(cb, instance, 3, [
              getter(),
              isMultiSource ? [] : void 0,
              onCleanup
            ]);
          }
          if (flush === "sync") {
            const ctx = useSSRContext();
            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
          } else {
            return NOOP;
          }
        }
        let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
        const job = () => {
          if (!effect.active) {
            return;
          }
          if (cb) {
            const newValue = effect.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some(
              (v2, i2) => hasChanged(v2, oldValue[i2])
            ) : hasChanged(newValue, oldValue)) || false) {
              if (cleanup) {
                cleanup();
              }
              callWithAsyncErrorHandling(cb, instance, 3, [
                newValue,
                // pass undefined as the old value when it's changed for the first time
                oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                onCleanup
              ]);
              oldValue = newValue;
            }
          } else {
            effect.run();
          }
        };
        job.allowRecurse = !!cb;
        let scheduler;
        if (flush === "sync") {
          scheduler = job;
        } else if (flush === "post") {
          scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
        } else {
          job.pre = true;
          if (instance)
            job.id = instance.uid;
          scheduler = () => queueJob(job);
        }
        const effect = new ReactiveEffect(getter, scheduler);
        if (cb) {
          if (immediate) {
            job();
          } else {
            oldValue = effect.run();
          }
        } else if (flush === "post") {
          queuePostRenderEffect(
            effect.run.bind(effect),
            instance && instance.suspense
          );
        } else {
          effect.run();
        }
        const unwatch = () => {
          effect.stop();
          if (instance && instance.scope) {
            remove(instance.scope.effects, effect);
          }
        };
        if (ssrCleanup)
          ssrCleanup.push(unwatch);
        return unwatch;
      }
      function instanceWatch(source, value, options) {
        const publicThis = this.proxy;
        const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
        let cb;
        if (isFunction$2(value)) {
          cb = value;
        } else {
          cb = value.handler;
          options = value;
        }
        const cur = currentInstance;
        setCurrentInstance(this);
        const res = doWatch(getter, cb.bind(publicThis), options);
        if (cur) {
          setCurrentInstance(cur);
        } else {
          unsetCurrentInstance();
        }
        return res;
      }
      function createPathGetter(ctx, path) {
        const segments = path.split(".");
        return () => {
          let cur = ctx;
          for (let i2 = 0; i2 < segments.length && cur; i2++) {
            cur = cur[segments[i2]];
          }
          return cur;
        };
      }
      function traverse(value, seen) {
        if (!isObject$1(value) || value["__v_skip"]) {
          return value;
        }
        seen = seen || /* @__PURE__ */ new Set();
        if (seen.has(value)) {
          return value;
        }
        seen.add(value);
        if (isRef(value)) {
          traverse(value.value, seen);
        } else if (isArray$3(value)) {
          for (let i2 = 0; i2 < value.length; i2++) {
            traverse(value[i2], seen);
          }
        } else if (isSet$2(value) || isMap$2(value)) {
          value.forEach((v2) => {
            traverse(v2, seen);
          });
        } else if (isPlainObject$1(value)) {
          for (const key in value) {
            traverse(value[key], seen);
          }
        }
        return value;
      }
      function withDirectives(vnode, directives) {
        const internalInstance = currentRenderingInstance;
        if (internalInstance === null) {
          return vnode;
        }
        const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
        const bindings = vnode.dirs || (vnode.dirs = []);
        for (let i2 = 0; i2 < directives.length; i2++) {
          let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
          if (dir) {
            if (isFunction$2(dir)) {
              dir = {
                mounted: dir,
                updated: dir
              };
            }
            if (dir.deep) {
              traverse(value);
            }
            bindings.push({
              dir,
              instance,
              value,
              oldValue: void 0,
              arg,
              modifiers
            });
          }
        }
        return vnode;
      }
      function invokeDirectiveHook(vnode, prevVNode, instance, name) {
        const bindings = vnode.dirs;
        const oldBindings = prevVNode && prevVNode.dirs;
        for (let i2 = 0; i2 < bindings.length; i2++) {
          const binding = bindings[i2];
          if (oldBindings) {
            binding.oldValue = oldBindings[i2].value;
          }
          let hook = binding.dir[name];
          if (hook) {
            pauseTracking();
            callWithAsyncErrorHandling(hook, instance, 8, [
              vnode.el,
              binding,
              vnode,
              prevVNode
            ]);
            resetTracking();
          }
        }
      }
      function useTransitionState() {
        const state = {
          isMounted: false,
          isLeaving: false,
          isUnmounting: false,
          leavingVNodes: /* @__PURE__ */ new Map()
        };
        onMounted(() => {
          state.isMounted = true;
        });
        onBeforeUnmount(() => {
          state.isUnmounting = true;
        });
        return state;
      }
      const TransitionHookValidator = [Function, Array];
      const BaseTransitionPropsValidators = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
      };
      const BaseTransitionImpl = {
        name: `BaseTransition`,
        props: BaseTransitionPropsValidators,
        setup(props2, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          let prevTransitionKey;
          return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
              return;
            }
            let child = children[0];
            if (children.length > 1) {
              for (const c2 of children) {
                if (c2.type !== Comment) {
                  child = c2;
                  break;
                }
              }
            }
            const rawProps = toRaw(props2);
            const { mode } = rawProps;
            if (state.isLeaving) {
              return emptyPlaceholder(child);
            }
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
              return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(
              innerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
              const key = getTransitionKey();
              if (prevTransitionKey === void 0) {
                prevTransitionKey = key;
              } else if (key !== prevTransitionKey) {
                prevTransitionKey = key;
                transitionKeyChanged = true;
              }
            }
            if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
              const leavingHooks = resolveTransitionHooks(
                oldInnerChild,
                rawProps,
                state,
                instance
              );
              setTransitionHooks(oldInnerChild, leavingHooks);
              if (mode === "out-in") {
                state.isLeaving = true;
                leavingHooks.afterLeave = () => {
                  state.isLeaving = false;
                  if (instance.update.active !== false) {
                    instance.update();
                  }
                };
                return emptyPlaceholder(child);
              } else if (mode === "in-out" && innerChild.type !== Comment) {
                leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                  const leavingVNodesCache = getLeavingNodesForType(
                    state,
                    oldInnerChild
                  );
                  leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                  el._leaveCb = () => {
                    earlyRemove();
                    el._leaveCb = void 0;
                    delete enterHooks.delayedLeave;
                  };
                  enterHooks.delayedLeave = delayedLeave;
                };
              }
            }
            return child;
          };
        }
      };
      const BaseTransition = BaseTransitionImpl;
      function getLeavingNodesForType(state, vnode) {
        const { leavingVNodes } = state;
        let leavingVNodesCache = leavingVNodes.get(vnode.type);
        if (!leavingVNodesCache) {
          leavingVNodesCache = /* @__PURE__ */ Object.create(null);
          leavingVNodes.set(vnode.type, leavingVNodesCache);
        }
        return leavingVNodesCache;
      }
      function resolveTransitionHooks(vnode, props2, state, instance) {
        const {
          appear,
          mode,
          persisted = false,
          onBeforeEnter,
          onEnter,
          onAfterEnter,
          onEnterCancelled,
          onBeforeLeave,
          onLeave,
          onAfterLeave,
          onLeaveCancelled,
          onBeforeAppear,
          onAppear,
          onAfterAppear,
          onAppearCancelled
        } = props2;
        const key = String(vnode.key);
        const leavingVNodesCache = getLeavingNodesForType(state, vnode);
        const callHook2 = (hook, args) => {
          hook && callWithAsyncErrorHandling(
            hook,
            instance,
            9,
            args
          );
        };
        const callAsyncHook = (hook, args) => {
          const done = args[1];
          callHook2(hook, args);
          if (isArray$3(hook)) {
            if (hook.every((hook2) => hook2.length <= 1))
              done();
          } else if (hook.length <= 1) {
            done();
          }
        };
        const hooks = {
          mode,
          persisted,
          beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
              if (appear) {
                hook = onBeforeAppear || onBeforeEnter;
              } else {
                return;
              }
            }
            if (el._leaveCb) {
              el._leaveCb(
                true
                /* cancelled */
              );
            }
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
              leavingVNode.el._leaveCb();
            }
            callHook2(hook, [el]);
          },
          enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
              if (appear) {
                hook = onAppear || onEnter;
                afterHook = onAfterAppear || onAfterEnter;
                cancelHook = onAppearCancelled || onEnterCancelled;
              } else {
                return;
              }
            }
            let called = false;
            const done = el._enterCb = (cancelled) => {
              if (called)
                return;
              called = true;
              if (cancelled) {
                callHook2(cancelHook, [el]);
              } else {
                callHook2(afterHook, [el]);
              }
              if (hooks.delayedLeave) {
                hooks.delayedLeave();
              }
              el._enterCb = void 0;
            };
            if (hook) {
              callAsyncHook(hook, [el, done]);
            } else {
              done();
            }
          },
          leave(el, remove2) {
            const key2 = String(vnode.key);
            if (el._enterCb) {
              el._enterCb(
                true
                /* cancelled */
              );
            }
            if (state.isUnmounting) {
              return remove2();
            }
            callHook2(onBeforeLeave, [el]);
            let called = false;
            const done = el._leaveCb = (cancelled) => {
              if (called)
                return;
              called = true;
              remove2();
              if (cancelled) {
                callHook2(onLeaveCancelled, [el]);
              } else {
                callHook2(onAfterLeave, [el]);
              }
              el._leaveCb = void 0;
              if (leavingVNodesCache[key2] === vnode) {
                delete leavingVNodesCache[key2];
              }
            };
            leavingVNodesCache[key2] = vnode;
            if (onLeave) {
              callAsyncHook(onLeave, [el, done]);
            } else {
              done();
            }
          },
          clone(vnode2) {
            return resolveTransitionHooks(vnode2, props2, state, instance);
          }
        };
        return hooks;
      }
      function emptyPlaceholder(vnode) {
        if (isKeepAlive(vnode)) {
          vnode = cloneVNode(vnode);
          vnode.children = null;
          return vnode;
        }
      }
      function getKeepAliveChild(vnode) {
        return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
      }
      function setTransitionHooks(vnode, hooks) {
        if (vnode.shapeFlag & 6 && vnode.component) {
          setTransitionHooks(vnode.component.subTree, hooks);
        } else if (vnode.shapeFlag & 128) {
          vnode.ssContent.transition = hooks.clone(vnode.ssContent);
          vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
        } else {
          vnode.transition = hooks;
        }
      }
      function getTransitionRawChildren(children, keepComment = false, parentKey) {
        let ret = [];
        let keyedFragmentCount = 0;
        for (let i2 = 0; i2 < children.length; i2++) {
          let child = children[i2];
          const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
          if (child.type === Fragment) {
            if (child.patchFlag & 128)
              keyedFragmentCount++;
            ret = ret.concat(
              getTransitionRawChildren(child.children, keepComment, key)
            );
          } else if (keepComment || child.type !== Comment) {
            ret.push(key != null ? cloneVNode(child, { key }) : child);
          }
        }
        if (keyedFragmentCount > 1) {
          for (let i2 = 0; i2 < ret.length; i2++) {
            ret[i2].patchFlag = -2;
          }
        }
        return ret;
      }
      function defineComponent(options, extraOptions) {
        return isFunction$2(options) ? (
          // #8326: extend call and options.name access are considered side-effects
          // by Rollup, so we have to wrap it in a pure-annotated IIFE.
          /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
        ) : options;
      }
      const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
      const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
      function onActivated(hook, target) {
        registerKeepAliveHook(hook, "a", target);
      }
      function onDeactivated(hook, target) {
        registerKeepAliveHook(hook, "da", target);
      }
      function registerKeepAliveHook(hook, type2, target = currentInstance) {
        const wrappedHook = hook.__wdc || (hook.__wdc = () => {
          let current = target;
          while (current) {
            if (current.isDeactivated) {
              return;
            }
            current = current.parent;
          }
          return hook();
        });
        injectHook(type2, wrappedHook, target);
        if (target) {
          let current = target.parent;
          while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
              injectToKeepAliveRoot(wrappedHook, type2, target, current);
            }
            current = current.parent;
          }
        }
      }
      function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
        const injected = injectHook(
          type2,
          hook,
          keepAliveRoot,
          true
          /* prepend */
        );
        onUnmounted(() => {
          remove(keepAliveRoot[type2], injected);
        }, target);
      }
      function injectHook(type2, hook, target = currentInstance, prepend = false) {
        if (target) {
          const hooks = target[type2] || (target[type2] = []);
          const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
            if (target.isUnmounted) {
              return;
            }
            pauseTracking();
            setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type2, args);
            unsetCurrentInstance();
            resetTracking();
            return res;
          });
          if (prepend) {
            hooks.unshift(wrappedHook);
          } else {
            hooks.push(wrappedHook);
          }
          return wrappedHook;
        }
      }
      const createHook = (lifecycle) => (hook, target = currentInstance) => (
        // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
        (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
      );
      const onBeforeMount = createHook("bm");
      const onMounted = createHook("m");
      const onBeforeUpdate = createHook("bu");
      const onUpdated = createHook("u");
      const onBeforeUnmount = createHook("bum");
      const onUnmounted = createHook("um");
      const onServerPrefetch = createHook("sp");
      const onRenderTriggered = createHook(
        "rtg"
      );
      const onRenderTracked = createHook(
        "rtc"
      );
      function onErrorCaptured(hook, target = currentInstance) {
        injectHook("ec", hook, target);
      }
      const COMPONENTS = "components";
      const DIRECTIVES = "directives";
      function resolveComponent(name, maybeSelfReference) {
        return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
      }
      const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
      function resolveDynamicComponent(component) {
        if (isString$2(component)) {
          return resolveAsset(COMPONENTS, component, false) || component;
        } else {
          return component || NULL_DYNAMIC_COMPONENT;
        }
      }
      function resolveDirective(name) {
        return resolveAsset(DIRECTIVES, name);
      }
      function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
        const instance = currentRenderingInstance || currentInstance;
        if (instance) {
          const Component = instance.type;
          if (type2 === COMPONENTS) {
            const selfName = getComponentName(
              Component,
              false
              /* do not include inferred name to avoid breaking existing code */
            );
            if (selfName && (selfName === name || selfName === camelize$1(name) || selfName === capitalize$1(camelize$1(name)))) {
              return Component;
            }
          }
          const res = (
            // local registration
            // check instance[type] first which is resolved for options API
            resolve(instance[type2] || Component[type2], name) || // global registration
            resolve(instance.appContext[type2], name)
          );
          if (!res && maybeSelfReference) {
            return Component;
          }
          return res;
        }
      }
      function resolve(registry, name) {
        return registry && (registry[name] || registry[camelize$1(name)] || registry[capitalize$1(camelize$1(name))]);
      }
      function renderList(source, renderItem, cache2, index) {
        let ret;
        const cached = cache2 && cache2[index];
        if (isArray$3(source) || isString$2(source)) {
          ret = new Array(source.length);
          for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
            ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
          }
        } else if (typeof source === "number") {
          ret = new Array(source);
          for (let i2 = 0; i2 < source; i2++) {
            ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
          }
        } else if (isObject$1(source)) {
          if (source[Symbol.iterator]) {
            ret = Array.from(
              source,
              (item, i2) => renderItem(item, i2, void 0, cached && cached[i2])
            );
          } else {
            const keys2 = Object.keys(source);
            ret = new Array(keys2.length);
            for (let i2 = 0, l2 = keys2.length; i2 < l2; i2++) {
              const key = keys2[i2];
              ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
            }
          }
        } else {
          ret = [];
        }
        if (cache2) {
          cache2[index] = ret;
        }
        return ret;
      }
      function createSlots(slots, dynamicSlots) {
        for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
          const slot = dynamicSlots[i2];
          if (isArray$3(slot)) {
            for (let j2 = 0; j2 < slot.length; j2++) {
              slots[slot[j2].name] = slot[j2].fn;
            }
          } else if (slot) {
            slots[slot.name] = slot.key ? (...args) => {
              const res = slot.fn(...args);
              if (res)
                res.key = slot.key;
              return res;
            } : slot.fn;
          }
        }
        return slots;
      }
      function renderSlot(slots, name, props2 = {}, fallback, noSlotted) {
        if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
          if (name !== "default")
            props2.name = name;
          return createVNode("slot", props2, fallback && fallback());
        }
        let slot = slots[name];
        if (slot && slot._c) {
          slot._d = false;
        }
        openBlock();
        const validSlotContent = slot && ensureValidVNode(slot(props2));
        const rendered = createBlock(
          Fragment,
          {
            key: props2.key || // slot content array of a dynamic conditional slot may have a branch
            // key attached in the `createSlots` helper, respect that
            validSlotContent && validSlotContent.key || `_${name}`
          },
          validSlotContent || (fallback ? fallback() : []),
          validSlotContent && slots._ === 1 ? 64 : -2
        );
        if (!noSlotted && rendered.scopeId) {
          rendered.slotScopeIds = [rendered.scopeId + "-s"];
        }
        if (slot && slot._c) {
          slot._d = true;
        }
        return rendered;
      }
      function ensureValidVNode(vnodes) {
        return vnodes.some((child) => {
          if (!isVNode(child))
            return true;
          if (child.type === Comment)
            return false;
          if (child.type === Fragment && !ensureValidVNode(child.children))
            return false;
          return true;
        }) ? vnodes : null;
      }
      const getPublicInstance = (i2) => {
        if (!i2)
          return null;
        if (isStatefulComponent(i2))
          return getExposeProxy(i2) || i2.proxy;
        return getPublicInstance(i2.parent);
      };
      const publicPropertiesMap = (
        // Move PURE marker to new line to workaround compiler discarding it
        // due to type annotation
        /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
          $: (i2) => i2,
          $el: (i2) => i2.vnode.el,
          $data: (i2) => i2.data,
          $props: (i2) => i2.props,
          $attrs: (i2) => i2.attrs,
          $slots: (i2) => i2.slots,
          $refs: (i2) => i2.refs,
          $parent: (i2) => getPublicInstance(i2.parent),
          $root: (i2) => getPublicInstance(i2.root),
          $emit: (i2) => i2.emit,
          $options: (i2) => resolveMergedOptions(i2),
          $forceUpdate: (i2) => i2.f || (i2.f = () => queueJob(i2.update)),
          $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
          $watch: (i2) => instanceWatch.bind(i2)
        })
      );
      const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
      const PublicInstanceProxyHandlers = {
        get({ _: instance }, key) {
          const { ctx, setupState, data, props: props2, accessCache, type: type2, appContext } = instance;
          let normalizedProps;
          if (key[0] !== "$") {
            const n2 = accessCache[key];
            if (n2 !== void 0) {
              switch (n2) {
                case 1:
                  return setupState[key];
                case 2:
                  return data[key];
                case 4:
                  return ctx[key];
                case 3:
                  return props2[key];
              }
            } else if (hasSetupBinding(setupState, key)) {
              accessCache[key] = 1;
              return setupState[key];
            } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
              accessCache[key] = 2;
              return data[key];
            } else if (
              // only cache other properties when instance has declared (thus stable)
              // props
              (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
            ) {
              accessCache[key] = 3;
              return props2[key];
            } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
              accessCache[key] = 4;
              return ctx[key];
            } else if (shouldCacheAccess) {
              accessCache[key] = 0;
            }
          }
          const publicGetter = publicPropertiesMap[key];
          let cssModule, globalProperties;
          if (publicGetter) {
            if (key === "$attrs") {
              track(instance, "get", key);
            }
            return publicGetter(instance);
          } else if (
            // css module (injected by vue-loader)
            (cssModule = type2.__cssModules) && (cssModule = cssModule[key])
          ) {
            return cssModule;
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (
            // global properties
            globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
          ) {
            {
              return globalProperties[key];
            }
          } else
            ;
        },
        set({ _: instance }, key, value) {
          const { data, setupState, ctx } = instance;
          if (hasSetupBinding(setupState, key)) {
            setupState[key] = value;
            return true;
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            data[key] = value;
            return true;
          } else if (hasOwn(instance.props, key)) {
            return false;
          }
          if (key[0] === "$" && key.slice(1) in instance) {
            return false;
          } else {
            {
              ctx[key] = value;
            }
          }
          return true;
        },
        has({
          _: { data, setupState, accessCache, ctx, appContext, propsOptions }
        }, key) {
          let normalizedProps;
          return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
        },
        defineProperty(target, key, descriptor) {
          if (descriptor.get != null) {
            target._.accessCache[key] = 0;
          } else if (hasOwn(descriptor, "value")) {
            this.set(target, key, descriptor.value, null);
          }
          return Reflect.defineProperty(target, key, descriptor);
        }
      };
      function useSlots() {
        return getContext().slots;
      }
      function useAttrs$1() {
        return getContext().attrs;
      }
      function getContext() {
        const i2 = getCurrentInstance();
        return i2.setupContext || (i2.setupContext = createSetupContext(i2));
      }
      function normalizePropsOrEmits(props2) {
        return isArray$3(props2) ? props2.reduce(
          (normalized, p2) => (normalized[p2] = null, normalized),
          {}
        ) : props2;
      }
      let shouldCacheAccess = true;
      function applyOptions(instance) {
        const options = resolveMergedOptions(instance);
        const publicThis = instance.proxy;
        const ctx = instance.ctx;
        shouldCacheAccess = false;
        if (options.beforeCreate) {
          callHook$1(options.beforeCreate, instance, "bc");
        }
        const {
          // state
          data: dataOptions,
          computed: computedOptions,
          methods,
          watch: watchOptions,
          provide: provideOptions,
          inject: injectOptions,
          // lifecycle
          created,
          beforeMount,
          mounted: mounted2,
          beforeUpdate: beforeUpdate2,
          updated: updated2,
          activated,
          deactivated,
          beforeDestroy,
          beforeUnmount,
          destroyed,
          unmounted: unmounted2,
          render: render2,
          renderTracked,
          renderTriggered,
          errorCaptured,
          serverPrefetch,
          // public API
          expose,
          inheritAttrs,
          // assets
          components,
          directives,
          filters
        } = options;
        const checkDuplicateProperties = null;
        if (injectOptions) {
          resolveInjections(injectOptions, ctx, checkDuplicateProperties);
        }
        if (methods) {
          for (const key in methods) {
            const methodHandler = methods[key];
            if (isFunction$2(methodHandler)) {
              {
                ctx[key] = methodHandler.bind(publicThis);
              }
            }
          }
        }
        if (dataOptions) {
          const data = dataOptions.call(publicThis, publicThis);
          if (!isObject$1(data))
            ;
          else {
            instance.data = reactive(data);
          }
        }
        shouldCacheAccess = true;
        if (computedOptions) {
          for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get2 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
            const set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
            const c2 = computed({
              get: get2,
              set: set2
            });
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => c2.value,
              set: (v2) => c2.value = v2
            });
          }
        }
        if (watchOptions) {
          for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
          }
        }
        if (provideOptions) {
          const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
          Reflect.ownKeys(provides).forEach((key) => {
            provide(key, provides[key]);
          });
        }
        if (created) {
          callHook$1(created, instance, "c");
        }
        function registerLifecycleHook(register, hook) {
          if (isArray$3(hook)) {
            hook.forEach((_hook) => register(_hook.bind(publicThis)));
          } else if (hook) {
            register(hook.bind(publicThis));
          }
        }
        registerLifecycleHook(onBeforeMount, beforeMount);
        registerLifecycleHook(onMounted, mounted2);
        registerLifecycleHook(onBeforeUpdate, beforeUpdate2);
        registerLifecycleHook(onUpdated, updated2);
        registerLifecycleHook(onActivated, activated);
        registerLifecycleHook(onDeactivated, deactivated);
        registerLifecycleHook(onErrorCaptured, errorCaptured);
        registerLifecycleHook(onRenderTracked, renderTracked);
        registerLifecycleHook(onRenderTriggered, renderTriggered);
        registerLifecycleHook(onBeforeUnmount, beforeUnmount);
        registerLifecycleHook(onUnmounted, unmounted2);
        registerLifecycleHook(onServerPrefetch, serverPrefetch);
        if (isArray$3(expose)) {
          if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach((key) => {
              Object.defineProperty(exposed, key, {
                get: () => publicThis[key],
                set: (val) => publicThis[key] = val
              });
            });
          } else if (!instance.exposed) {
            instance.exposed = {};
          }
        }
        if (render2 && instance.render === NOOP) {
          instance.render = render2;
        }
        if (inheritAttrs != null) {
          instance.inheritAttrs = inheritAttrs;
        }
        if (components)
          instance.components = components;
        if (directives)
          instance.directives = directives;
      }
      function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
        if (isArray$3(injectOptions)) {
          injectOptions = normalizeInject(injectOptions);
        }
        for (const key in injectOptions) {
          const opt = injectOptions[key];
          let injected;
          if (isObject$1(opt)) {
            if ("default" in opt) {
              injected = inject(
                opt.from || key,
                opt.default,
                true
                /* treat default function as factory */
              );
            } else {
              injected = inject(opt.from || key);
            }
          } else {
            injected = inject(opt);
          }
          if (isRef(injected)) {
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => injected.value,
              set: (v2) => injected.value = v2
            });
          } else {
            ctx[key] = injected;
          }
        }
      }
      function callHook$1(hook, instance, type2) {
        callWithAsyncErrorHandling(
          isArray$3(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
          instance,
          type2
        );
      }
      function createWatcher(raw, ctx, publicThis, key) {
        const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
        if (isString$2(raw)) {
          const handler = ctx[raw];
          if (isFunction$2(handler)) {
            watch(getter, handler);
          }
        } else if (isFunction$2(raw)) {
          watch(getter, raw.bind(publicThis));
        } else if (isObject$1(raw)) {
          if (isArray$3(raw)) {
            raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
          } else {
            const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if (isFunction$2(handler)) {
              watch(getter, handler, raw);
            }
          }
        } else
          ;
      }
      function resolveMergedOptions(instance) {
        const base2 = instance.type;
        const { mixins, extends: extendsOptions } = base2;
        const {
          mixins: globalMixins,
          optionsCache: cache2,
          config: { optionMergeStrategies }
        } = instance.appContext;
        const cached = cache2.get(base2);
        let resolved;
        if (cached) {
          resolved = cached;
        } else if (!globalMixins.length && !mixins && !extendsOptions) {
          {
            resolved = base2;
          }
        } else {
          resolved = {};
          if (globalMixins.length) {
            globalMixins.forEach(
              (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
            );
          }
          mergeOptions(resolved, base2, optionMergeStrategies);
        }
        if (isObject$1(base2)) {
          cache2.set(base2, resolved);
        }
        return resolved;
      }
      function mergeOptions(to, from, strats, asMixin = false) {
        const { mixins, extends: extendsOptions } = from;
        if (extendsOptions) {
          mergeOptions(to, extendsOptions, strats, true);
        }
        if (mixins) {
          mixins.forEach(
            (m2) => mergeOptions(to, m2, strats, true)
          );
        }
        for (const key in from) {
          if (asMixin && key === "expose")
            ;
          else {
            const strat = internalOptionMergeStrats[key] || strats && strats[key];
            to[key] = strat ? strat(to[key], from[key]) : from[key];
          }
        }
        return to;
      }
      const internalOptionMergeStrats = {
        data: mergeDataFn,
        props: mergeEmitsOrPropsOptions,
        emits: mergeEmitsOrPropsOptions,
        // objects
        methods: mergeObjectOptions,
        computed: mergeObjectOptions,
        // lifecycle
        beforeCreate: mergeAsArray,
        created: mergeAsArray,
        beforeMount: mergeAsArray,
        mounted: mergeAsArray,
        beforeUpdate: mergeAsArray,
        updated: mergeAsArray,
        beforeDestroy: mergeAsArray,
        beforeUnmount: mergeAsArray,
        destroyed: mergeAsArray,
        unmounted: mergeAsArray,
        activated: mergeAsArray,
        deactivated: mergeAsArray,
        errorCaptured: mergeAsArray,
        serverPrefetch: mergeAsArray,
        // assets
        components: mergeObjectOptions,
        directives: mergeObjectOptions,
        // watch
        watch: mergeWatchOptions,
        // provide / inject
        provide: mergeDataFn,
        inject: mergeInject
      };
      function mergeDataFn(to, from) {
        if (!from) {
          return to;
        }
        if (!to) {
          return from;
        }
        return function mergedDataFn() {
          return extend(
            isFunction$2(to) ? to.call(this, this) : to,
            isFunction$2(from) ? from.call(this, this) : from
          );
        };
      }
      function mergeInject(to, from) {
        return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
      }
      function normalizeInject(raw) {
        if (isArray$3(raw)) {
          const res = {};
          for (let i2 = 0; i2 < raw.length; i2++) {
            res[raw[i2]] = raw[i2];
          }
          return res;
        }
        return raw;
      }
      function mergeAsArray(to, from) {
        return to ? [...new Set([].concat(to, from))] : from;
      }
      function mergeObjectOptions(to, from) {
        return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
      }
      function mergeEmitsOrPropsOptions(to, from) {
        if (to) {
          if (isArray$3(to) && isArray$3(from)) {
            return [.../* @__PURE__ */ new Set([...to, ...from])];
          }
          return extend(
            /* @__PURE__ */ Object.create(null),
            normalizePropsOrEmits(to),
            normalizePropsOrEmits(from != null ? from : {})
          );
        } else {
          return from;
        }
      }
      function mergeWatchOptions(to, from) {
        if (!to)
          return from;
        if (!from)
          return to;
        const merged = extend(/* @__PURE__ */ Object.create(null), to);
        for (const key in from) {
          merged[key] = mergeAsArray(to[key], from[key]);
        }
        return merged;
      }
      function createAppContext() {
        return {
          app: null,
          config: {
            isNativeTag: NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
          },
          mixins: [],
          components: {},
          directives: {},
          provides: /* @__PURE__ */ Object.create(null),
          optionsCache: /* @__PURE__ */ new WeakMap(),
          propsCache: /* @__PURE__ */ new WeakMap(),
          emitsCache: /* @__PURE__ */ new WeakMap()
        };
      }
      let uid$1 = 0;
      function createAppAPI(render2, hydrate) {
        return function createApp2(rootComponent, rootProps = null) {
          if (!isFunction$2(rootComponent)) {
            rootComponent = extend({}, rootComponent);
          }
          if (rootProps != null && !isObject$1(rootProps)) {
            rootProps = null;
          }
          const context2 = createAppContext();
          const installedPlugins = /* @__PURE__ */ new Set();
          let isMounted = false;
          const app2 = context2.app = {
            _uid: uid$1++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context2,
            _instance: null,
            version,
            get config() {
              return context2.config;
            },
            set config(v2) {
            },
            use(plugin, ...options) {
              if (installedPlugins.has(plugin))
                ;
              else if (plugin && isFunction$2(plugin.install)) {
                installedPlugins.add(plugin);
                plugin.install(app2, ...options);
              } else if (isFunction$2(plugin)) {
                installedPlugins.add(plugin);
                plugin(app2, ...options);
              } else
                ;
              return app2;
            },
            mixin(mixin) {
              {
                if (!context2.mixins.includes(mixin)) {
                  context2.mixins.push(mixin);
                }
              }
              return app2;
            },
            component(name, component) {
              if (!component) {
                return context2.components[name];
              }
              context2.components[name] = component;
              return app2;
            },
            directive(name, directive) {
              if (!directive) {
                return context2.directives[name];
              }
              context2.directives[name] = directive;
              return app2;
            },
            mount(rootContainer, isHydrate, isSVG) {
              if (!isMounted) {
                const vnode = createVNode(
                  rootComponent,
                  rootProps
                );
                vnode.appContext = context2;
                if (isHydrate && hydrate) {
                  hydrate(vnode, rootContainer);
                } else {
                  render2(vnode, rootContainer, isSVG);
                }
                isMounted = true;
                app2._container = rootContainer;
                rootContainer.__vue_app__ = app2;
                return getExposeProxy(vnode.component) || vnode.component.proxy;
              }
            },
            unmount() {
              if (isMounted) {
                render2(null, app2._container);
                delete app2._container.__vue_app__;
              }
            },
            provide(key, value) {
              context2.provides[key] = value;
              return app2;
            },
            runWithContext(fn2) {
              currentApp = app2;
              try {
                return fn2();
              } finally {
                currentApp = null;
              }
            }
          };
          return app2;
        };
      }
      let currentApp = null;
      function provide(key, value) {
        if (!currentInstance)
          ;
        else {
          let provides = currentInstance.provides;
          const parentProvides = currentInstance.parent && currentInstance.parent.provides;
          if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
          }
          provides[key] = value;
        }
      }
      function inject(key, defaultValue, treatDefaultAsFactory = false) {
        const instance = currentInstance || currentRenderingInstance;
        if (instance || currentApp) {
          const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
          if (provides && key in provides) {
            return provides[key];
          } else if (arguments.length > 1) {
            return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
          } else
            ;
        }
      }
      function hasInjectionContext() {
        return !!(currentInstance || currentRenderingInstance || currentApp);
      }
      function initProps(instance, rawProps, isStateful, isSSR = false) {
        const props2 = {};
        const attrs = {};
        def(attrs, InternalObjectKey, 1);
        instance.propsDefaults = /* @__PURE__ */ Object.create(null);
        setFullProps(instance, rawProps, props2, attrs);
        for (const key in instance.propsOptions[0]) {
          if (!(key in props2)) {
            props2[key] = void 0;
          }
        }
        if (isStateful) {
          instance.props = isSSR ? props2 : shallowReactive(props2);
        } else {
          if (!instance.type.props) {
            instance.props = attrs;
          } else {
            instance.props = props2;
          }
        }
        instance.attrs = attrs;
      }
      function updateProps(instance, rawProps, rawPrevProps, optimized) {
        const {
          props: props2,
          attrs,
          vnode: { patchFlag }
        } = instance;
        const rawCurrentProps = toRaw(props2);
        const [options] = instance.propsOptions;
        let hasAttrsChanged = false;
        if (
          // always force full diff in dev
          // - #1942 if hmr is enabled with sfc component
          // - vite#872 non-sfc component used by sfc component
          (optimized || patchFlag > 0) && !(patchFlag & 16)
        ) {
          if (patchFlag & 8) {
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
              let key = propsToUpdate[i2];
              if (isEmitListener(instance.emitsOptions, key)) {
                continue;
              }
              const value = rawProps[key];
              if (options) {
                if (hasOwn(attrs, key)) {
                  if (value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                  }
                } else {
                  const camelizedKey = camelize$1(key);
                  props2[camelizedKey] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    camelizedKey,
                    value,
                    instance,
                    false
                    /* isAbsent */
                  );
                }
              } else {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              }
            }
          }
        } else {
          if (setFullProps(instance, rawProps, props2, attrs)) {
            hasAttrsChanged = true;
          }
          let kebabKey;
          for (const key in rawCurrentProps) {
            if (!rawProps || // for camelCase
            !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
            // and converted to camelCase (#955)
            ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
              if (options) {
                if (rawPrevProps && // for camelCase
                (rawPrevProps[key] !== void 0 || // for kebab-case
                rawPrevProps[kebabKey] !== void 0)) {
                  props2[key] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    key,
                    void 0,
                    instance,
                    true
                    /* isAbsent */
                  );
                }
              } else {
                delete props2[key];
              }
            }
          }
          if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
              if (!rawProps || !hasOwn(rawProps, key) && true) {
                delete attrs[key];
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (hasAttrsChanged) {
          trigger(instance, "set", "$attrs");
        }
      }
      function setFullProps(instance, rawProps, props2, attrs) {
        const [options, needCastKeys] = instance.propsOptions;
        let hasAttrsChanged = false;
        let rawCastValues;
        if (rawProps) {
          for (let key in rawProps) {
            if (isReservedProp(key)) {
              continue;
            }
            const value = rawProps[key];
            let camelKey;
            if (options && hasOwn(options, camelKey = camelize$1(key))) {
              if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                props2[camelKey] = value;
              } else {
                (rawCastValues || (rawCastValues = {}))[camelKey] = value;
              }
            } else if (!isEmitListener(instance.emitsOptions, key)) {
              if (!(key in attrs) || value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (needCastKeys) {
          const rawCurrentProps = toRaw(props2);
          const castValues = rawCastValues || EMPTY_OBJ;
          for (let i2 = 0; i2 < needCastKeys.length; i2++) {
            const key = needCastKeys[i2];
            props2[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              castValues[key],
              instance,
              !hasOwn(castValues, key)
            );
          }
        }
        return hasAttrsChanged;
      }
      function resolvePropValue(options, props2, key, value, instance, isAbsent) {
        const opt = options[key];
        if (opt != null) {
          const hasDefault = hasOwn(opt, "default");
          if (hasDefault && value === void 0) {
            const defaultValue = opt.default;
            if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
              const { propsDefaults } = instance;
              if (key in propsDefaults) {
                value = propsDefaults[key];
              } else {
                setCurrentInstance(instance);
                value = propsDefaults[key] = defaultValue.call(
                  null,
                  props2
                );
                unsetCurrentInstance();
              }
            } else {
              value = defaultValue;
            }
          }
          if (opt[
            0
            /* shouldCast */
          ]) {
            if (isAbsent && !hasDefault) {
              value = false;
            } else if (opt[
              1
              /* shouldCastTrue */
            ] && (value === "" || value === hyphenate(key))) {
              value = true;
            }
          }
        }
        return value;
      }
      function normalizePropsOptions(comp, appContext, asMixin = false) {
        const cache2 = appContext.propsCache;
        const cached = cache2.get(comp);
        if (cached) {
          return cached;
        }
        const raw = comp.props;
        const normalized = {};
        const needCastKeys = [];
        let hasExtends = false;
        if (!isFunction$2(comp)) {
          const extendProps = (raw2) => {
            hasExtends = true;
            const [props2, keys2] = normalizePropsOptions(raw2, appContext, true);
            extend(normalized, props2);
            if (keys2)
              needCastKeys.push(...keys2);
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
          }
          if (comp.extends) {
            extendProps(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendProps);
          }
        }
        if (!raw && !hasExtends) {
          if (isObject$1(comp)) {
            cache2.set(comp, EMPTY_ARR);
          }
          return EMPTY_ARR;
        }
        if (isArray$3(raw)) {
          for (let i2 = 0; i2 < raw.length; i2++) {
            const normalizedKey = camelize$1(raw[i2]);
            if (validatePropName(normalizedKey)) {
              normalized[normalizedKey] = EMPTY_OBJ;
            }
          }
        } else if (raw) {
          for (const key in raw) {
            const normalizedKey = camelize$1(key);
            if (validatePropName(normalizedKey)) {
              const opt = raw[key];
              const prop = normalized[normalizedKey] = isArray$3(opt) || isFunction$2(opt) ? { type: opt } : extend({}, opt);
              if (prop) {
                const booleanIndex = getTypeIndex(Boolean, prop.type);
                const stringIndex = getTypeIndex(String, prop.type);
                prop[
                  0
                  /* shouldCast */
                ] = booleanIndex > -1;
                prop[
                  1
                  /* shouldCastTrue */
                ] = stringIndex < 0 || booleanIndex < stringIndex;
                if (booleanIndex > -1 || hasOwn(prop, "default")) {
                  needCastKeys.push(normalizedKey);
                }
              }
            }
          }
        }
        const res = [normalized, needCastKeys];
        if (isObject$1(comp)) {
          cache2.set(comp, res);
        }
        return res;
      }
      function validatePropName(key) {
        if (key[0] !== "$") {
          return true;
        }
        return false;
      }
      function getType(ctor) {
        const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
        return match ? match[2] : ctor === null ? "null" : "";
      }
      function isSameType(a2, b2) {
        return getType(a2) === getType(b2);
      }
      function getTypeIndex(type2, expectedTypes) {
        if (isArray$3(expectedTypes)) {
          return expectedTypes.findIndex((t2) => isSameType(t2, type2));
        } else if (isFunction$2(expectedTypes)) {
          return isSameType(expectedTypes, type2) ? 0 : -1;
        }
        return -1;
      }
      const isInternalKey = (key) => key[0] === "_" || key === "$stable";
      const normalizeSlotValue = (value) => isArray$3(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
      const normalizeSlot = (key, rawSlot, ctx) => {
        if (rawSlot._n) {
          return rawSlot;
        }
        const normalized = withCtx((...args) => {
          if (false)
            ;
          return normalizeSlotValue(rawSlot(...args));
        }, ctx);
        normalized._c = false;
        return normalized;
      };
      const normalizeObjectSlots = (rawSlots, slots, instance) => {
        const ctx = rawSlots._ctx;
        for (const key in rawSlots) {
          if (isInternalKey(key))
            continue;
          const value = rawSlots[key];
          if (isFunction$2(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
          } else if (value != null) {
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
          }
        }
      };
      const normalizeVNodeSlots = (instance, children) => {
        const normalized = normalizeSlotValue(children);
        instance.slots.default = () => normalized;
      };
      const initSlots = (instance, children) => {
        if (instance.vnode.shapeFlag & 32) {
          const type2 = children._;
          if (type2) {
            instance.slots = toRaw(children);
            def(children, "_", type2);
          } else {
            normalizeObjectSlots(
              children,
              instance.slots = {}
            );
          }
        } else {
          instance.slots = {};
          if (children) {
            normalizeVNodeSlots(instance, children);
          }
        }
        def(instance.slots, InternalObjectKey, 1);
      };
      const updateSlots = (instance, children, optimized) => {
        const { vnode, slots } = instance;
        let needDeletionCheck = true;
        let deletionComparisonTarget = EMPTY_OBJ;
        if (vnode.shapeFlag & 32) {
          const type2 = children._;
          if (type2) {
            if (optimized && type2 === 1) {
              needDeletionCheck = false;
            } else {
              extend(slots, children);
              if (!optimized && type2 === 1) {
                delete slots._;
              }
            }
          } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
          }
          deletionComparisonTarget = children;
        } else if (children) {
          normalizeVNodeSlots(instance, children);
          deletionComparisonTarget = { default: 1 };
        }
        if (needDeletionCheck) {
          for (const key in slots) {
            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
              delete slots[key];
            }
          }
        }
      };
      function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
        if (isArray$3(rawRef)) {
          rawRef.forEach(
            (r2, i2) => setRef(
              r2,
              oldRawRef && (isArray$3(oldRawRef) ? oldRawRef[i2] : oldRawRef),
              parentSuspense,
              vnode,
              isUnmount
            )
          );
          return;
        }
        if (isAsyncWrapper(vnode) && !isUnmount) {
          return;
        }
        const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
        const value = isUnmount ? null : refValue;
        const { i: owner, r: ref2 } = rawRef;
        const oldRef = oldRawRef && oldRawRef.r;
        const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
        const setupState = owner.setupState;
        if (oldRef != null && oldRef !== ref2) {
          if (isString$2(oldRef)) {
            refs[oldRef] = null;
            if (hasOwn(setupState, oldRef)) {
              setupState[oldRef] = null;
            }
          } else if (isRef(oldRef)) {
            oldRef.value = null;
          }
        }
        if (isFunction$2(ref2)) {
          callWithErrorHandling(ref2, owner, 12, [value, refs]);
        } else {
          const _isString = isString$2(ref2);
          const _isRef = isRef(ref2);
          if (_isString || _isRef) {
            const doSet = () => {
              if (rawRef.f) {
                const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
                if (isUnmount) {
                  isArray$3(existing) && remove(existing, refValue);
                } else {
                  if (!isArray$3(existing)) {
                    if (_isString) {
                      refs[ref2] = [refValue];
                      if (hasOwn(setupState, ref2)) {
                        setupState[ref2] = refs[ref2];
                      }
                    } else {
                      ref2.value = [refValue];
                      if (rawRef.k)
                        refs[rawRef.k] = ref2.value;
                    }
                  } else if (!existing.includes(refValue)) {
                    existing.push(refValue);
                  }
                }
              } else if (_isString) {
                refs[ref2] = value;
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = value;
                }
              } else if (_isRef) {
                ref2.value = value;
                if (rawRef.k)
                  refs[rawRef.k] = value;
              } else
                ;
            };
            if (value) {
              doSet.id = -1;
              queuePostRenderEffect(doSet, parentSuspense);
            } else {
              doSet();
            }
          }
        }
      }
      const queuePostRenderEffect = queueEffectWithSuspense;
      function createRenderer(options) {
        return baseCreateRenderer(options);
      }
      function baseCreateRenderer(options, createHydrationFns) {
        const target = getGlobalThis();
        target.__VUE__ = true;
        const {
          insert: hostInsert,
          remove: hostRemove,
          patchProp: hostPatchProp,
          createElement: hostCreateElement,
          createText: hostCreateText,
          createComment: hostCreateComment,
          setText: hostSetText,
          setElementText: hostSetElementText,
          parentNode: hostParentNode,
          nextSibling: hostNextSibling,
          setScopeId: hostSetScopeId = NOOP,
          insertStaticContent: hostInsertStaticContent
        } = options;
        const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
          if (n1 === n2) {
            return;
          }
          if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
          }
          if (n2.patchFlag === -2) {
            optimized = false;
            n2.dynamicChildren = null;
          }
          const { type: type2, ref: ref2, shapeFlag } = n2;
          switch (type2) {
            case Text:
              processText(n1, n2, container, anchor);
              break;
            case Comment:
              processCommentNode(n1, n2, container, anchor);
              break;
            case Static:
              if (n1 == null) {
                mountStaticNode(n2, container, anchor, isSVG);
              }
              break;
            case Fragment:
              processFragment(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              break;
            default:
              if (shapeFlag & 1) {
                processElement(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else if (shapeFlag & 6) {
                processComponent(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else if (shapeFlag & 64) {
                type2.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized,
                  internals
                );
              } else if (shapeFlag & 128) {
                type2.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized,
                  internals
                );
              } else
                ;
          }
          if (ref2 != null && parentComponent) {
            setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
          }
        };
        const processText = (n1, n2, container, anchor) => {
          if (n1 == null) {
            hostInsert(
              n2.el = hostCreateText(n2.children),
              container,
              anchor
            );
          } else {
            const el = n2.el = n1.el;
            if (n2.children !== n1.children) {
              hostSetText(el, n2.children);
            }
          }
        };
        const processCommentNode = (n1, n2, container, anchor) => {
          if (n1 == null) {
            hostInsert(
              n2.el = hostCreateComment(n2.children || ""),
              container,
              anchor
            );
          } else {
            n2.el = n1.el;
          }
        };
        const mountStaticNode = (n2, container, anchor, isSVG) => {
          [n2.el, n2.anchor] = hostInsertStaticContent(
            n2.children,
            container,
            anchor,
            isSVG,
            n2.el,
            n2.anchor
          );
        };
        const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
          let next;
          while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
          }
          hostInsert(anchor, container, nextSibling);
        };
        const removeStaticNode = ({ el, anchor }) => {
          let next;
          while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
          }
          hostRemove(anchor);
        };
        const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          isSVG = isSVG || n2.type === "svg";
          if (n1 == null) {
            mountElement(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          } else {
            patchElement(
              n1,
              n2,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          }
        };
        const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          let el;
          let vnodeHook;
          const { type: type2, props: props2, shapeFlag, transition, dirs } = vnode;
          el = vnode.el = hostCreateElement(
            vnode.type,
            isSVG,
            props2 && props2.is,
            props2
          );
          if (shapeFlag & 8) {
            hostSetElementText(el, vnode.children);
          } else if (shapeFlag & 16) {
            mountChildren(
              vnode.children,
              el,
              null,
              parentComponent,
              parentSuspense,
              isSVG && type2 !== "foreignObject",
              slotScopeIds,
              optimized
            );
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "created");
          }
          setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
          if (props2) {
            for (const key in props2) {
              if (key !== "value" && !isReservedProp(key)) {
                hostPatchProp(
                  el,
                  key,
                  null,
                  props2[key],
                  isSVG,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
            if ("value" in props2) {
              hostPatchProp(el, "value", null, props2.value);
            }
            if (vnodeHook = props2.onVnodeBeforeMount) {
              invokeVNodeHook(vnodeHook, parentComponent, vnode);
            }
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
          }
          const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
          if (needCallTransitionHooks) {
            transition.beforeEnter(el);
          }
          hostInsert(el, container, anchor);
          if ((vnodeHook = props2 && props2.onVnodeMounted) || needCallTransitionHooks || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              needCallTransitionHooks && transition.enter(el);
              dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
          }
        };
        const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
          if (scopeId) {
            hostSetScopeId(el, scopeId);
          }
          if (slotScopeIds) {
            for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
              hostSetScopeId(el, slotScopeIds[i2]);
            }
          }
          if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (vnode === subTree) {
              const parentVNode = parentComponent.vnode;
              setScopeId(
                el,
                parentVNode,
                parentVNode.scopeId,
                parentVNode.slotScopeIds,
                parentComponent.parent
              );
            }
          }
        };
        const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
          for (let i2 = start; i2 < children.length; i2++) {
            const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
            patch(
              null,
              child,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          }
        };
        const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          const el = n2.el = n1.el;
          let { patchFlag, dynamicChildren, dirs } = n2;
          patchFlag |= n1.patchFlag & 16;
          const oldProps = n1.props || EMPTY_OBJ;
          const newProps = n2.props || EMPTY_OBJ;
          let vnodeHook;
          parentComponent && toggleRecurse(parentComponent, false);
          if (vnodeHook = newProps.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          }
          if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
          }
          parentComponent && toggleRecurse(parentComponent, true);
          const areChildrenSVG = isSVG && n2.type !== "foreignObject";
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              el,
              parentComponent,
              parentSuspense,
              areChildrenSVG,
              slotScopeIds
            );
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              el,
              null,
              parentComponent,
              parentSuspense,
              areChildrenSVG,
              slotScopeIds,
              false
            );
          }
          if (patchFlag > 0) {
            if (patchFlag & 16) {
              patchProps(
                el,
                n2,
                oldProps,
                newProps,
                parentComponent,
                parentSuspense,
                isSVG
              );
            } else {
              if (patchFlag & 2) {
                if (oldProps.class !== newProps.class) {
                  hostPatchProp(el, "class", null, newProps.class, isSVG);
                }
              }
              if (patchFlag & 4) {
                hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
              }
              if (patchFlag & 8) {
                const propsToUpdate = n2.dynamicProps;
                for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
                  const key = propsToUpdate[i2];
                  const prev = oldProps[key];
                  const next = newProps[key];
                  if (next !== prev || key === "value") {
                    hostPatchProp(
                      el,
                      key,
                      prev,
                      next,
                      isSVG,
                      n1.children,
                      parentComponent,
                      parentSuspense,
                      unmountChildren
                    );
                  }
                }
              }
            }
            if (patchFlag & 1) {
              if (n1.children !== n2.children) {
                hostSetElementText(el, n2.children);
              }
            }
          } else if (!optimized && dynamicChildren == null) {
            patchProps(
              el,
              n2,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              isSVG
            );
          }
          if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
              dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
            }, parentSuspense);
          }
        };
        const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
          for (let i2 = 0; i2 < newChildren.length; i2++) {
            const oldVNode = oldChildren[i2];
            const newVNode = newChildren[i2];
            const container = (
              // oldVNode may be an errored async setup() component inside Suspense
              // which will not have a mounted element
              oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
              // of the Fragment itself so it can move its children.
              (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
              // which also requires the correct parent container
              !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
              oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
                // In other cases, the parent container is not actually used so we
                // just pass the block element here to avoid a DOM parentNode call.
                fallbackContainer
              )
            );
            patch(
              oldVNode,
              newVNode,
              container,
              null,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              true
            );
          }
        };
        const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
          if (oldProps !== newProps) {
            if (oldProps !== EMPTY_OBJ) {
              for (const key in oldProps) {
                if (!isReservedProp(key) && !(key in newProps)) {
                  hostPatchProp(
                    el,
                    key,
                    oldProps[key],
                    null,
                    isSVG,
                    vnode.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
            }
            for (const key in newProps) {
              if (isReservedProp(key))
                continue;
              const next = newProps[key];
              const prev = oldProps[key];
              if (next !== prev && key !== "value") {
                hostPatchProp(
                  el,
                  key,
                  prev,
                  next,
                  isSVG,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
            if ("value" in newProps) {
              hostPatchProp(el, "value", oldProps.value, newProps.value);
            }
          }
        };
        const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
          const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
          let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
          if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
          }
          if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            mountChildren(
              n2.children,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          } else {
            if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
            // of renderSlot() with no valid children
            n1.dynamicChildren) {
              patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                container,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds
              );
              if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n2.key != null || parentComponent && n2 === parentComponent.subTree
              ) {
                traverseStaticChildren(
                  n1,
                  n2,
                  true
                  /* shallow */
                );
              }
            } else {
              patchChildren(
                n1,
                n2,
                container,
                fragmentEndAnchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            }
          }
        };
        const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          n2.slotScopeIds = slotScopeIds;
          if (n1 == null) {
            if (n2.shapeFlag & 512) {
              parentComponent.ctx.activate(
                n2,
                container,
                anchor,
                isSVG,
                optimized
              );
            } else {
              mountComponent(
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                optimized
              );
            }
          } else {
            updateComponent(n1, n2, optimized);
          }
        };
        const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
          const instance = initialVNode.component = createComponentInstance(
            initialVNode,
            parentComponent,
            parentSuspense
          );
          if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
          }
          {
            setupComponent(instance);
          }
          if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            if (!initialVNode.el) {
              const placeholder = instance.subTree = createVNode(Comment);
              processCommentNode(null, placeholder, container, anchor);
            }
            return;
          }
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            isSVG,
            optimized
          );
        };
        const updateComponent = (n1, n2, optimized) => {
          const instance = n2.component = n1.component;
          if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
              updateComponentPreRender(instance, n2, optimized);
              return;
            } else {
              instance.next = n2;
              invalidateJob(instance.update);
              instance.update();
            }
          } else {
            n2.el = n1.el;
            instance.vnode = n2;
          }
        };
        const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
          const componentUpdateFn = () => {
            if (!instance.isMounted) {
              let vnodeHook;
              const { el, props: props2 } = initialVNode;
              const { bm, m: m2, parent } = instance;
              const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
              toggleRecurse(instance, false);
              if (bm) {
                invokeArrayFns(bm);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHook, parent, initialVNode);
              }
              toggleRecurse(instance, true);
              if (el && hydrateNode) {
                const hydrateSubTree = () => {
                  instance.subTree = renderComponentRoot(instance);
                  hydrateNode(
                    el,
                    instance.subTree,
                    instance,
                    parentSuspense,
                    null
                  );
                };
                if (isAsyncWrapperVNode) {
                  initialVNode.type.__asyncLoader().then(
                    // note: we are moving the render call into an async callback,
                    // which means it won't track dependencies - but it's ok because
                    // a server-rendered async wrapper is already in resolved state
                    // and it will never need to change.
                    () => !instance.isUnmounted && hydrateSubTree()
                  );
                } else {
                  hydrateSubTree();
                }
              } else {
                const subTree = instance.subTree = renderComponentRoot(instance);
                patch(
                  null,
                  subTree,
                  container,
                  anchor,
                  instance,
                  parentSuspense,
                  isSVG
                );
                initialVNode.el = subTree.el;
              }
              if (m2) {
                queuePostRenderEffect(m2, parentSuspense);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeMounted)) {
                const scopedInitialVNode = initialVNode;
                queuePostRenderEffect(
                  () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                  parentSuspense
                );
              }
              if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
                instance.a && queuePostRenderEffect(instance.a, parentSuspense);
              }
              instance.isMounted = true;
              initialVNode = container = anchor = null;
            } else {
              let { next, bu, u: u2, parent, vnode } = instance;
              let originNext = next;
              let vnodeHook;
              toggleRecurse(instance, false);
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              } else {
                next = vnode;
              }
              if (bu) {
                invokeArrayFns(bu);
              }
              if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
                invokeVNodeHook(vnodeHook, parent, next, vnode);
              }
              toggleRecurse(instance, true);
              const nextTree = renderComponentRoot(instance);
              const prevTree = instance.subTree;
              instance.subTree = nextTree;
              patch(
                prevTree,
                nextTree,
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el),
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree),
                instance,
                parentSuspense,
                isSVG
              );
              next.el = nextTree.el;
              if (originNext === null) {
                updateHOCHostEl(instance, nextTree.el);
              }
              if (u2) {
                queuePostRenderEffect(u2, parentSuspense);
              }
              if (vnodeHook = next.props && next.props.onVnodeUpdated) {
                queuePostRenderEffect(
                  () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                  parentSuspense
                );
              }
            }
          };
          const effect = instance.effect = new ReactiveEffect(
            componentUpdateFn,
            () => queueJob(update),
            instance.scope
            // track it in component's effect scope
          );
          const update = instance.update = () => effect.run();
          update.id = instance.uid;
          toggleRecurse(instance, true);
          update();
        };
        const updateComponentPreRender = (instance, nextVNode, optimized) => {
          nextVNode.component = instance;
          const prevProps = instance.vnode.props;
          instance.vnode = nextVNode;
          instance.next = null;
          updateProps(instance, nextVNode.props, prevProps, optimized);
          updateSlots(instance, nextVNode.children, optimized);
          pauseTracking();
          flushPreFlushCbs();
          resetTracking();
        };
        const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
          const c1 = n1 && n1.children;
          const prevShapeFlag = n1 ? n1.shapeFlag : 0;
          const c2 = n2.children;
          const { patchFlag, shapeFlag } = n2;
          if (patchFlag > 0) {
            if (patchFlag & 128) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              return;
            } else if (patchFlag & 256) {
              patchUnkeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              return;
            }
          }
          if (shapeFlag & 8) {
            if (prevShapeFlag & 16) {
              unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
              hostSetElementText(container, c2);
            }
          } else {
            if (prevShapeFlag & 16) {
              if (shapeFlag & 16) {
                patchKeyedChildren(
                  c1,
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else {
                unmountChildren(c1, parentComponent, parentSuspense, true);
              }
            } else {
              if (prevShapeFlag & 8) {
                hostSetElementText(container, "");
              }
              if (shapeFlag & 16) {
                mountChildren(
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              }
            }
          }
        };
        const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          c1 = c1 || EMPTY_ARR;
          c2 = c2 || EMPTY_ARR;
          const oldLength = c1.length;
          const newLength = c2.length;
          const commonLength = Math.min(oldLength, newLength);
          let i2;
          for (i2 = 0; i2 < commonLength; i2++) {
            const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
            patch(
              c1[i2],
              nextChild,
              container,
              null,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          }
          if (oldLength > newLength) {
            unmountChildren(
              c1,
              parentComponent,
              parentSuspense,
              true,
              false,
              commonLength
            );
          } else {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized,
              commonLength
            );
          }
        };
        const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          let i2 = 0;
          const l2 = c2.length;
          let e1 = c1.length - 1;
          let e2 = l2 - 1;
          while (i2 <= e1 && i2 <= e2) {
            const n1 = c1[i2];
            const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
            if (isSameVNodeType(n1, n2)) {
              patch(
                n1,
                n2,
                container,
                null,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            } else {
              break;
            }
            i2++;
          }
          while (i2 <= e1 && i2 <= e2) {
            const n1 = c1[e1];
            const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
            if (isSameVNodeType(n1, n2)) {
              patch(
                n1,
                n2,
                container,
                null,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            } else {
              break;
            }
            e1--;
            e2--;
          }
          if (i2 > e1) {
            if (i2 <= e2) {
              const nextPos = e2 + 1;
              const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
              while (i2 <= e2) {
                patch(
                  null,
                  c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                i2++;
              }
            }
          } else if (i2 > e2) {
            while (i2 <= e1) {
              unmount(c1[i2], parentComponent, parentSuspense, true);
              i2++;
            }
          } else {
            const s1 = i2;
            const s2 = i2;
            const keyToNewIndexMap = /* @__PURE__ */ new Map();
            for (i2 = s2; i2 <= e2; i2++) {
              const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
              if (nextChild.key != null) {
                keyToNewIndexMap.set(nextChild.key, i2);
              }
            }
            let j2;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            let maxNewIndexSoFar = 0;
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i2 = 0; i2 < toBePatched; i2++)
              newIndexToOldIndexMap[i2] = 0;
            for (i2 = s1; i2 <= e1; i2++) {
              const prevChild = c1[i2];
              if (patched >= toBePatched) {
                unmount(prevChild, parentComponent, parentSuspense, true);
                continue;
              }
              let newIndex;
              if (prevChild.key != null) {
                newIndex = keyToNewIndexMap.get(prevChild.key);
              } else {
                for (j2 = s2; j2 <= e2; j2++) {
                  if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
                    newIndex = j2;
                    break;
                  }
                }
              }
              if (newIndex === void 0) {
                unmount(prevChild, parentComponent, parentSuspense, true);
              } else {
                newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
                if (newIndex >= maxNewIndexSoFar) {
                  maxNewIndexSoFar = newIndex;
                } else {
                  moved = true;
                }
                patch(
                  prevChild,
                  c2[newIndex],
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                patched++;
              }
            }
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
            j2 = increasingNewIndexSequence.length - 1;
            for (i2 = toBePatched - 1; i2 >= 0; i2--) {
              const nextIndex = s2 + i2;
              const nextChild = c2[nextIndex];
              const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
              if (newIndexToOldIndexMap[i2] === 0) {
                patch(
                  null,
                  nextChild,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else if (moved) {
                if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
                  move(nextChild, container, anchor, 2);
                } else {
                  j2--;
                }
              }
            }
          }
        };
        const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
          const { el, type: type2, transition, children, shapeFlag } = vnode;
          if (shapeFlag & 6) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
          }
          if (shapeFlag & 128) {
            vnode.suspense.move(container, anchor, moveType);
            return;
          }
          if (shapeFlag & 64) {
            type2.move(vnode, container, anchor, internals);
            return;
          }
          if (type2 === Fragment) {
            hostInsert(el, container, anchor);
            for (let i2 = 0; i2 < children.length; i2++) {
              move(children[i2], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
          }
          if (type2 === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
          }
          const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
          if (needTransition) {
            if (moveType === 0) {
              transition.beforeEnter(el);
              hostInsert(el, container, anchor);
              queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            } else {
              const { leave, delayLeave, afterLeave } = transition;
              const remove22 = () => hostInsert(el, container, anchor);
              const performLeave = () => {
                leave(el, () => {
                  remove22();
                  afterLeave && afterLeave();
                });
              };
              if (delayLeave) {
                delayLeave(el, remove22, performLeave);
              } else {
                performLeave();
              }
            }
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
          const {
            type: type2,
            props: props2,
            ref: ref2,
            children,
            dynamicChildren,
            shapeFlag,
            patchFlag,
            dirs
          } = vnode;
          if (ref2 != null) {
            setRef(ref2, null, parentSuspense, vnode, true);
          }
          if (shapeFlag & 256) {
            parentComponent.ctx.deactivate(vnode);
            return;
          }
          const shouldInvokeDirs = shapeFlag & 1 && dirs;
          const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
          let vnodeHook;
          if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
          if (shapeFlag & 6) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
          } else {
            if (shapeFlag & 128) {
              vnode.suspense.unmount(parentSuspense, doRemove);
              return;
            }
            if (shouldInvokeDirs) {
              invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
            }
            if (shapeFlag & 64) {
              vnode.type.remove(
                vnode,
                parentComponent,
                parentSuspense,
                optimized,
                internals,
                doRemove
              );
            } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
            (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
              unmountChildren(
                dynamicChildren,
                parentComponent,
                parentSuspense,
                false,
                true
              );
            } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
              unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
              remove2(vnode);
            }
          }
          if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeUnmounted) || shouldInvokeDirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
            }, parentSuspense);
          }
        };
        const remove2 = (vnode) => {
          const { type: type2, el, anchor, transition } = vnode;
          if (type2 === Fragment) {
            {
              removeFragment(el, anchor);
            }
            return;
          }
          if (type2 === Static) {
            removeStaticNode(vnode);
            return;
          }
          const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
              transition.afterLeave();
            }
          };
          if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
              delayLeave(vnode.el, performRemove, performLeave);
            } else {
              performLeave();
            }
          } else {
            performRemove();
          }
        };
        const removeFragment = (cur, end2) => {
          let next;
          while (cur !== end2) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
          }
          hostRemove(end2);
        };
        const unmountComponent = (instance, parentSuspense, doRemove) => {
          const { bum, scope, update, subTree, um } = instance;
          if (bum) {
            invokeArrayFns(bum);
          }
          scope.stop();
          if (update) {
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
          }
          if (um) {
            queuePostRenderEffect(um, parentSuspense);
          }
          queuePostRenderEffect(() => {
            instance.isUnmounted = true;
          }, parentSuspense);
          if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
              parentSuspense.resolve();
            }
          }
        };
        const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
          for (let i2 = start; i2 < children.length; i2++) {
            unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
          }
        };
        const getNextHostNode = (vnode) => {
          if (vnode.shapeFlag & 6) {
            return getNextHostNode(vnode.component.subTree);
          }
          if (vnode.shapeFlag & 128) {
            return vnode.suspense.next();
          }
          return hostNextSibling(vnode.anchor || vnode.el);
        };
        const render2 = (vnode, container, isSVG) => {
          if (vnode == null) {
            if (container._vnode) {
              unmount(container._vnode, null, null, true);
            }
          } else {
            patch(container._vnode || null, vnode, container, null, null, null, isSVG);
          }
          flushPreFlushCbs();
          flushPostFlushCbs();
          container._vnode = vnode;
        };
        const internals = {
          p: patch,
          um: unmount,
          m: move,
          r: remove2,
          mt: mountComponent,
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          n: getNextHostNode,
          o: options
        };
        let hydrate;
        let hydrateNode;
        if (createHydrationFns) {
          [hydrate, hydrateNode] = createHydrationFns(
            internals
          );
        }
        return {
          render: render2,
          hydrate,
          createApp: createAppAPI(render2, hydrate)
        };
      }
      function toggleRecurse({ effect, update }, allowed) {
        effect.allowRecurse = update.allowRecurse = allowed;
      }
      function traverseStaticChildren(n1, n2, shallow = false) {
        const ch1 = n1.children;
        const ch2 = n2.children;
        if (isArray$3(ch1) && isArray$3(ch2)) {
          for (let i2 = 0; i2 < ch1.length; i2++) {
            const c1 = ch1[i2];
            let c2 = ch2[i2];
            if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
              if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
                c2.el = c1.el;
              }
              if (!shallow)
                traverseStaticChildren(c1, c2);
            }
            if (c2.type === Text) {
              c2.el = c1.el;
            }
          }
        }
      }
      function getSequence(arr) {
        const p2 = arr.slice();
        const result = [0];
        let i2, j2, u2, v2, c2;
        const len = arr.length;
        for (i2 = 0; i2 < len; i2++) {
          const arrI = arr[i2];
          if (arrI !== 0) {
            j2 = result[result.length - 1];
            if (arr[j2] < arrI) {
              p2[i2] = j2;
              result.push(i2);
              continue;
            }
            u2 = 0;
            v2 = result.length - 1;
            while (u2 < v2) {
              c2 = u2 + v2 >> 1;
              if (arr[result[c2]] < arrI) {
                u2 = c2 + 1;
              } else {
                v2 = c2;
              }
            }
            if (arrI < arr[result[u2]]) {
              if (u2 > 0) {
                p2[i2] = result[u2 - 1];
              }
              result[u2] = i2;
            }
          }
        }
        u2 = result.length;
        v2 = result[u2 - 1];
        while (u2-- > 0) {
          result[u2] = v2;
          v2 = p2[v2];
        }
        return result;
      }
      const isTeleport = (type2) => type2.__isTeleport;
      const isTeleportDisabled = (props2) => props2 && (props2.disabled || props2.disabled === "");
      const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
      const resolveTarget = (props2, select) => {
        const targetSelector = props2 && props2.to;
        if (isString$2(targetSelector)) {
          if (!select) {
            return null;
          } else {
            const target = select(targetSelector);
            return target;
          }
        } else {
          return targetSelector;
        }
      };
      const TeleportImpl = {
        __isTeleport: true,
        process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
          const {
            mc: mountChildren,
            pc: patchChildren,
            pbc: patchBlockChildren,
            o: { insert, querySelector, createText, createComment }
          } = internals;
          const disabled = isTeleportDisabled(n2.props);
          let { shapeFlag, children, dynamicChildren } = n2;
          if (n1 == null) {
            const placeholder = n2.el = createText("");
            const mainAnchor = n2.anchor = createText("");
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = n2.targetAnchor = createText("");
            if (target) {
              insert(targetAnchor, target);
              isSVG = isSVG || isTargetSVG(target);
            }
            const mount = (container2, anchor2) => {
              if (shapeFlag & 16) {
                mountChildren(
                  children,
                  container2,
                  anchor2,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              }
            };
            if (disabled) {
              mount(container, mainAnchor);
            } else if (target) {
              mount(target, targetAnchor);
            }
          } else {
            n2.el = n1.el;
            const mainAnchor = n2.anchor = n1.anchor;
            const target = n2.target = n1.target;
            const targetAnchor = n2.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
              patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                currentContainer,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds
              );
              traverseStaticChildren(n1, n2, true);
            } else if (!optimized) {
              patchChildren(
                n1,
                n2,
                currentContainer,
                currentAnchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                false
              );
            }
            if (disabled) {
              if (!wasDisabled) {
                moveTeleport(
                  n2,
                  container,
                  mainAnchor,
                  internals,
                  1
                );
              }
            } else {
              if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                const nextTarget = n2.target = resolveTarget(
                  n2.props,
                  querySelector
                );
                if (nextTarget) {
                  moveTeleport(
                    n2,
                    nextTarget,
                    null,
                    internals,
                    0
                  );
                }
              } else if (wasDisabled) {
                moveTeleport(
                  n2,
                  target,
                  targetAnchor,
                  internals,
                  1
                );
              }
            }
          }
          updateCssVars(n2);
        },
        remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
          const { shapeFlag, children, anchor, targetAnchor, target, props: props2 } = vnode;
          if (target) {
            hostRemove(targetAnchor);
          }
          if (doRemove || !isTeleportDisabled(props2)) {
            hostRemove(anchor);
            if (shapeFlag & 16) {
              for (let i2 = 0; i2 < children.length; i2++) {
                const child = children[i2];
                unmount(
                  child,
                  parentComponent,
                  parentSuspense,
                  true,
                  !!child.dynamicChildren
                );
              }
            }
          }
        },
        move: moveTeleport,
        hydrate: hydrateTeleport
      };
      function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
        if (moveType === 0) {
          insert(vnode.targetAnchor, container, parentAnchor);
        }
        const { el, anchor, shapeFlag, children, props: props2 } = vnode;
        const isReorder = moveType === 2;
        if (isReorder) {
          insert(el, container, parentAnchor);
        }
        if (!isReorder || isTeleportDisabled(props2)) {
          if (shapeFlag & 16) {
            for (let i2 = 0; i2 < children.length; i2++) {
              move(
                children[i2],
                container,
                parentAnchor,
                2
              );
            }
          }
        }
        if (isReorder) {
          insert(anchor, container, parentAnchor);
        }
      }
      function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
        o: { nextSibling, parentNode, querySelector }
      }, hydrateChildren) {
        const target = vnode.target = resolveTarget(
          vnode.props,
          querySelector
        );
        if (target) {
          const targetNode = target._lpa || target.firstChild;
          if (vnode.shapeFlag & 16) {
            if (isTeleportDisabled(vnode.props)) {
              vnode.anchor = hydrateChildren(
                nextSibling(node),
                vnode,
                parentNode(node),
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
              vnode.targetAnchor = targetNode;
            } else {
              vnode.anchor = nextSibling(node);
              let targetAnchor = targetNode;
              while (targetAnchor) {
                targetAnchor = nextSibling(targetAnchor);
                if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                  vnode.targetAnchor = targetAnchor;
                  target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                  break;
                }
              }
              hydrateChildren(
                targetNode,
                vnode,
                target,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
            }
          }
          updateCssVars(vnode);
        }
        return vnode.anchor && nextSibling(vnode.anchor);
      }
      const Teleport = TeleportImpl;
      function updateCssVars(vnode) {
        const ctx = vnode.ctx;
        if (ctx && ctx.ut) {
          let node = vnode.children[0].el;
          while (node !== vnode.targetAnchor) {
            if (node.nodeType === 1)
              node.setAttribute("data-v-owner", ctx.uid);
            node = node.nextSibling;
          }
          ctx.ut();
        }
      }
      const Fragment = Symbol.for("v-fgt");
      const Text = Symbol.for("v-txt");
      const Comment = Symbol.for("v-cmt");
      const Static = Symbol.for("v-stc");
      const blockStack = [];
      let currentBlock = null;
      function openBlock(disableTracking = false) {
        blockStack.push(currentBlock = disableTracking ? null : []);
      }
      function closeBlock() {
        blockStack.pop();
        currentBlock = blockStack[blockStack.length - 1] || null;
      }
      let isBlockTreeEnabled = 1;
      function setBlockTracking(value) {
        isBlockTreeEnabled += value;
      }
      function setupBlock(vnode) {
        vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
        closeBlock();
        if (isBlockTreeEnabled > 0 && currentBlock) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      function createElementBlock(type2, props2, children, patchFlag, dynamicProps, shapeFlag) {
        return setupBlock(
          createBaseVNode(
            type2,
            props2,
            children,
            patchFlag,
            dynamicProps,
            shapeFlag,
            true
            /* isBlock */
          )
        );
      }
      function createBlock(type2, props2, children, patchFlag, dynamicProps) {
        return setupBlock(
          createVNode(
            type2,
            props2,
            children,
            patchFlag,
            dynamicProps,
            true
            /* isBlock: prevent a block from tracking itself */
          )
        );
      }
      function isVNode(value) {
        return value ? value.__v_isVNode === true : false;
      }
      function isSameVNodeType(n1, n2) {
        return n1.type === n2.type && n1.key === n2.key;
      }
      const InternalObjectKey = `__vInternal`;
      const normalizeKey = ({ key }) => key != null ? key : null;
      const normalizeRef = ({
        ref: ref2,
        ref_key,
        ref_for
      }) => {
        if (typeof ref2 === "number") {
          ref2 = "" + ref2;
        }
        return ref2 != null ? isString$2(ref2) || isRef(ref2) || isFunction$2(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
      };
      function createBaseVNode(type2, props2 = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
        const vnode = {
          __v_isVNode: true,
          __v_skip: true,
          type: type2,
          props: props2,
          key: props2 && normalizeKey(props2),
          ref: props2 && normalizeRef(props2),
          scopeId: currentScopeId,
          slotScopeIds: null,
          children,
          component: null,
          suspense: null,
          ssContent: null,
          ssFallback: null,
          dirs: null,
          transition: null,
          el: null,
          anchor: null,
          target: null,
          targetAnchor: null,
          staticCount: 0,
          shapeFlag,
          patchFlag,
          dynamicProps,
          dynamicChildren: null,
          appContext: null,
          ctx: currentRenderingInstance
        };
        if (needFullChildrenNormalization) {
          normalizeChildren(vnode, children);
          if (shapeFlag & 128) {
            type2.normalize(vnode);
          }
        } else if (children) {
          vnode.shapeFlag |= isString$2(children) ? 8 : 16;
        }
        if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
        !isBlockNode && // has current parent block
        currentBlock && // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        vnode.patchFlag !== 32) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      const createVNode = _createVNode;
      function _createVNode(type2, props2 = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
        if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
          type2 = Comment;
        }
        if (isVNode(type2)) {
          const cloned = cloneVNode(
            type2,
            props2,
            true
            /* mergeRef: true */
          );
          if (children) {
            normalizeChildren(cloned, children);
          }
          if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6) {
              currentBlock[currentBlock.indexOf(type2)] = cloned;
            } else {
              currentBlock.push(cloned);
            }
          }
          cloned.patchFlag |= -2;
          return cloned;
        }
        if (isClassComponent(type2)) {
          type2 = type2.__vccOpts;
        }
        if (props2) {
          props2 = guardReactiveProps(props2);
          let { class: klass, style } = props2;
          if (klass && !isString$2(klass)) {
            props2.class = normalizeClass(klass);
          }
          if (isObject$1(style)) {
            if (isProxy(style) && !isArray$3(style)) {
              style = extend({}, style);
            }
            props2.style = normalizeStyle(style);
          }
        }
        const shapeFlag = isString$2(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject$1(type2) ? 4 : isFunction$2(type2) ? 2 : 0;
        return createBaseVNode(
          type2,
          props2,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          isBlockNode,
          true
        );
      }
      function guardReactiveProps(props2) {
        if (!props2)
          return null;
        return isProxy(props2) || InternalObjectKey in props2 ? extend({}, props2) : props2;
      }
      function cloneVNode(vnode, extraProps, mergeRef = false) {
        const { props: props2, ref: ref2, patchFlag, children } = vnode;
        const mergedProps = extraProps ? mergeProps(props2 || {}, extraProps) : props2;
        const cloned = {
          __v_isVNode: true,
          __v_skip: true,
          type: vnode.type,
          props: mergedProps,
          key: mergedProps && normalizeKey(mergedProps),
          ref: extraProps && extraProps.ref ? (
            // #2078 in the case of <component :is="vnode" ref="extra"/>
            // if the vnode itself already has a ref, cloneVNode will need to merge
            // the refs so the single vnode can be set on multiple refs
            mergeRef && ref2 ? isArray$3(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
          ) : ref2,
          scopeId: vnode.scopeId,
          slotScopeIds: vnode.slotScopeIds,
          children,
          target: vnode.target,
          targetAnchor: vnode.targetAnchor,
          staticCount: vnode.staticCount,
          shapeFlag: vnode.shapeFlag,
          // if the vnode is cloned with extra props, we can no longer assume its
          // existing patch flag to be reliable and need to add the FULL_PROPS flag.
          // note: preserve flag for fragments since they use the flag for children
          // fast paths only.
          patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
          dynamicProps: vnode.dynamicProps,
          dynamicChildren: vnode.dynamicChildren,
          appContext: vnode.appContext,
          dirs: vnode.dirs,
          transition: vnode.transition,
          // These should technically only be non-null on mounted VNodes. However,
          // they *should* be copied for kept-alive vnodes. So we just always copy
          // them since them being non-null during a mount doesn't affect the logic as
          // they will simply be overwritten.
          component: vnode.component,
          suspense: vnode.suspense,
          ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
          ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
          el: vnode.el,
          anchor: vnode.anchor,
          ctx: vnode.ctx,
          ce: vnode.ce
        };
        return cloned;
      }
      function createTextVNode(text = " ", flag = 0) {
        return createVNode(Text, null, text, flag);
      }
      function createCommentVNode(text = "", asBlock = false) {
        return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
      }
      function normalizeVNode(child) {
        if (child == null || typeof child === "boolean") {
          return createVNode(Comment);
        } else if (isArray$3(child)) {
          return createVNode(
            Fragment,
            null,
            // #3666, avoid reference pollution when reusing vnode
            child.slice()
          );
        } else if (typeof child === "object") {
          return cloneIfMounted(child);
        } else {
          return createVNode(Text, null, String(child));
        }
      }
      function cloneIfMounted(child) {
        return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
      }
      function normalizeChildren(vnode, children) {
        let type2 = 0;
        const { shapeFlag } = vnode;
        if (children == null) {
          children = null;
        } else if (isArray$3(children)) {
          type2 = 16;
        } else if (typeof children === "object") {
          if (shapeFlag & (1 | 64)) {
            const slot = children.default;
            if (slot) {
              slot._c && (slot._d = false);
              normalizeChildren(vnode, slot());
              slot._c && (slot._d = true);
            }
            return;
          } else {
            type2 = 32;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) {
              children._ctx = currentRenderingInstance;
            } else if (slotFlag === 3 && currentRenderingInstance) {
              if (currentRenderingInstance.slots._ === 1) {
                children._ = 1;
              } else {
                children._ = 2;
                vnode.patchFlag |= 1024;
              }
            }
          }
        } else if (isFunction$2(children)) {
          children = { default: children, _ctx: currentRenderingInstance };
          type2 = 32;
        } else {
          children = String(children);
          if (shapeFlag & 64) {
            type2 = 16;
            children = [createTextVNode(children)];
          } else {
            type2 = 8;
          }
        }
        vnode.children = children;
        vnode.shapeFlag |= type2;
      }
      function mergeProps(...args) {
        const ret = {};
        for (let i2 = 0; i2 < args.length; i2++) {
          const toMerge = args[i2];
          for (const key in toMerge) {
            if (key === "class") {
              if (ret.class !== toMerge.class) {
                ret.class = normalizeClass([ret.class, toMerge.class]);
              }
            } else if (key === "style") {
              ret.style = normalizeStyle([ret.style, toMerge.style]);
            } else if (isOn(key)) {
              const existing = ret[key];
              const incoming = toMerge[key];
              if (incoming && existing !== incoming && !(isArray$3(existing) && existing.includes(incoming))) {
                ret[key] = existing ? [].concat(existing, incoming) : incoming;
              }
            } else if (key !== "") {
              ret[key] = toMerge[key];
            }
          }
        }
        return ret;
      }
      function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
        callWithAsyncErrorHandling(hook, instance, 7, [
          vnode,
          prevVNode
        ]);
      }
      const emptyAppContext = createAppContext();
      let uid = 0;
      function createComponentInstance(vnode, parent, suspense) {
        const type2 = vnode.type;
        const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
        const instance = {
          uid: uid++,
          vnode,
          type: type2,
          parent,
          appContext,
          root: null,
          // to be immediately set
          next: null,
          subTree: null,
          // will be set synchronously right after creation
          effect: null,
          update: null,
          // will be set synchronously right after creation
          scope: new EffectScope(
            true
            /* detached */
          ),
          render: null,
          proxy: null,
          exposed: null,
          exposeProxy: null,
          withProxy: null,
          provides: parent ? parent.provides : Object.create(appContext.provides),
          accessCache: null,
          renderCache: [],
          // local resolved assets
          components: null,
          directives: null,
          // resolved props and emits options
          propsOptions: normalizePropsOptions(type2, appContext),
          emitsOptions: normalizeEmitsOptions(type2, appContext),
          // emit
          emit: null,
          // to be set immediately
          emitted: null,
          // props default value
          propsDefaults: EMPTY_OBJ,
          // inheritAttrs
          inheritAttrs: type2.inheritAttrs,
          // state
          ctx: EMPTY_OBJ,
          data: EMPTY_OBJ,
          props: EMPTY_OBJ,
          attrs: EMPTY_OBJ,
          slots: EMPTY_OBJ,
          refs: EMPTY_OBJ,
          setupState: EMPTY_OBJ,
          setupContext: null,
          attrsProxy: null,
          slotsProxy: null,
          // suspense related
          suspense,
          suspenseId: suspense ? suspense.pendingId : 0,
          asyncDep: null,
          asyncResolved: false,
          // lifecycle hooks
          // not using enums here because it results in computed properties
          isMounted: false,
          isUnmounted: false,
          isDeactivated: false,
          bc: null,
          c: null,
          bm: null,
          m: null,
          bu: null,
          u: null,
          um: null,
          bum: null,
          da: null,
          a: null,
          rtg: null,
          rtc: null,
          ec: null,
          sp: null
        };
        {
          instance.ctx = { _: instance };
        }
        instance.root = parent ? parent.root : instance;
        instance.emit = emit.bind(null, instance);
        if (vnode.ce) {
          vnode.ce(instance);
        }
        return instance;
      }
      let currentInstance = null;
      const getCurrentInstance = () => currentInstance || currentRenderingInstance;
      let internalSetCurrentInstance;
      let globalCurrentInstanceSetters;
      let settersKey = "__VUE_INSTANCE_SETTERS__";
      {
        if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
          globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
        }
        globalCurrentInstanceSetters.push((i2) => currentInstance = i2);
        internalSetCurrentInstance = (instance) => {
          if (globalCurrentInstanceSetters.length > 1) {
            globalCurrentInstanceSetters.forEach((s2) => s2(instance));
          } else {
            globalCurrentInstanceSetters[0](instance);
          }
        };
      }
      const setCurrentInstance = (instance) => {
        internalSetCurrentInstance(instance);
        instance.scope.on();
      };
      const unsetCurrentInstance = () => {
        currentInstance && currentInstance.scope.off();
        internalSetCurrentInstance(null);
      };
      function isStatefulComponent(instance) {
        return instance.vnode.shapeFlag & 4;
      }
      let isInSSRComponentSetup = false;
      function setupComponent(instance, isSSR = false) {
        isInSSRComponentSetup = isSSR;
        const { props: props2, children } = instance.vnode;
        const isStateful = isStatefulComponent(instance);
        initProps(instance, props2, isStateful, isSSR);
        initSlots(instance, children);
        const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
        isInSSRComponentSetup = false;
        return setupResult;
      }
      function setupStatefulComponent(instance, isSSR) {
        const Component = instance.type;
        instance.accessCache = /* @__PURE__ */ Object.create(null);
        instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
        const { setup } = Component;
        if (setup) {
          const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
          setCurrentInstance(instance);
          pauseTracking();
          const setupResult = callWithErrorHandling(
            setup,
            instance,
            0,
            [instance.props, setupContext]
          );
          resetTracking();
          unsetCurrentInstance();
          if (isPromise(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
              return setupResult.then((resolvedResult) => {
                handleSetupResult(instance, resolvedResult, isSSR);
              }).catch((e2) => {
                handleError(e2, instance, 0);
              });
            } else {
              instance.asyncDep = setupResult;
            }
          } else {
            handleSetupResult(instance, setupResult, isSSR);
          }
        } else {
          finishComponentSetup(instance, isSSR);
        }
      }
      function handleSetupResult(instance, setupResult, isSSR) {
        if (isFunction$2(setupResult)) {
          if (instance.type.__ssrInlineRender) {
            instance.ssrRender = setupResult;
          } else {
            instance.render = setupResult;
          }
        } else if (isObject$1(setupResult)) {
          instance.setupState = proxyRefs(setupResult);
        } else
          ;
        finishComponentSetup(instance, isSSR);
      }
      let compile;
      function finishComponentSetup(instance, isSSR, skipOptions) {
        const Component = instance.type;
        if (!instance.render) {
          if (!isSSR && compile && !Component.render) {
            const template = Component.template || resolveMergedOptions(instance).template;
            if (template) {
              const { isCustomElement, compilerOptions } = instance.appContext.config;
              const { delimiters, compilerOptions: componentCompilerOptions } = Component;
              const finalCompilerOptions = extend(
                extend(
                  {
                    isCustomElement,
                    delimiters
                  },
                  compilerOptions
                ),
                componentCompilerOptions
              );
              Component.render = compile(template, finalCompilerOptions);
            }
          }
          instance.render = Component.render || NOOP;
        }
        {
          setCurrentInstance(instance);
          pauseTracking();
          applyOptions(instance);
          resetTracking();
          unsetCurrentInstance();
        }
      }
      function getAttrsProxy(instance) {
        return instance.attrsProxy || (instance.attrsProxy = new Proxy(
          instance.attrs,
          {
            get(target, key) {
              track(instance, "get", "$attrs");
              return target[key];
            }
          }
        ));
      }
      function createSetupContext(instance) {
        const expose = (exposed) => {
          instance.exposed = exposed || {};
        };
        {
          return {
            get attrs() {
              return getAttrsProxy(instance);
            },
            slots: instance.slots,
            emit: instance.emit,
            expose
          };
        }
      }
      function getExposeProxy(instance) {
        if (instance.exposed) {
          return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
            get(target, key) {
              if (key in target) {
                return target[key];
              } else if (key in publicPropertiesMap) {
                return publicPropertiesMap[key](instance);
              }
            },
            has(target, key) {
              return key in target || key in publicPropertiesMap;
            }
          }));
        }
      }
      function getComponentName(Component, includeInferred = true) {
        return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
      }
      function isClassComponent(value) {
        return isFunction$2(value) && "__vccOpts" in value;
      }
      const computed = (getterOrOptions, debugOptions) => {
        return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
      };
      function h$1(type2, propsOrChildren, children) {
        const l2 = arguments.length;
        if (l2 === 2) {
          if (isObject$1(propsOrChildren) && !isArray$3(propsOrChildren)) {
            if (isVNode(propsOrChildren)) {
              return createVNode(type2, null, [propsOrChildren]);
            }
            return createVNode(type2, propsOrChildren);
          } else {
            return createVNode(type2, null, propsOrChildren);
          }
        } else {
          if (l2 > 3) {
            children = Array.prototype.slice.call(arguments, 2);
          } else if (l2 === 3 && isVNode(children)) {
            children = [children];
          }
          return createVNode(type2, propsOrChildren, children);
        }
      }
      const ssrContextKey = Symbol.for("v-scx");
      const useSSRContext = () => {
        {
          const ctx = inject(ssrContextKey);
          return ctx;
        }
      };
      const version = "3.3.4";
      const svgNS = "http://www.w3.org/2000/svg";
      const doc = typeof document !== "undefined" ? document : null;
      const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
      const nodeOps = {
        insert: (child, parent, anchor) => {
          parent.insertBefore(child, anchor || null);
        },
        remove: (child) => {
          const parent = child.parentNode;
          if (parent) {
            parent.removeChild(child);
          }
        },
        createElement: (tag, isSVG, is, props2) => {
          const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
          if (tag === "select" && props2 && props2.multiple != null) {
            el.setAttribute("multiple", props2.multiple);
          }
          return el;
        },
        createText: (text) => doc.createTextNode(text),
        createComment: (text) => doc.createComment(text),
        setText: (node, text) => {
          node.nodeValue = text;
        },
        setElementText: (el, text) => {
          el.textContent = text;
        },
        parentNode: (node) => node.parentNode,
        nextSibling: (node) => node.nextSibling,
        querySelector: (selector) => doc.querySelector(selector),
        setScopeId(el, id2) {
          el.setAttribute(id2, "");
        },
        // __UNSAFE__
        // Reason: innerHTML.
        // Static content here can only come from compiled templates.
        // As long as the user only uses trusted templates, this is safe.
        insertStaticContent(content, parent, anchor, isSVG, start, end2) {
          const before = anchor ? anchor.previousSibling : parent.lastChild;
          if (start && (start === end2 || start.nextSibling)) {
            while (true) {
              parent.insertBefore(start.cloneNode(true), anchor);
              if (start === end2 || !(start = start.nextSibling))
                break;
            }
          } else {
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template = templateContainer.content;
            if (isSVG) {
              const wrapper = template.firstChild;
              while (wrapper.firstChild) {
                template.appendChild(wrapper.firstChild);
              }
              template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
          }
          return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
          ];
        }
      };
      function patchClass(el, value, isSVG) {
        const transitionClasses = el._vtc;
        if (transitionClasses) {
          value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
        }
        if (value == null) {
          el.removeAttribute("class");
        } else if (isSVG) {
          el.setAttribute("class", value);
        } else {
          el.className = value;
        }
      }
      function patchStyle(el, prev, next) {
        const style = el.style;
        const isCssString = isString$2(next);
        if (next && !isCssString) {
          if (prev && !isString$2(prev)) {
            for (const key in prev) {
              if (next[key] == null) {
                setStyle(style, key, "");
              }
            }
          }
          for (const key in next) {
            setStyle(style, key, next[key]);
          }
        } else {
          const currentDisplay = style.display;
          if (isCssString) {
            if (prev !== next) {
              style.cssText = next;
            }
          } else if (prev) {
            el.removeAttribute("style");
          }
          if ("_vod" in el) {
            style.display = currentDisplay;
          }
        }
      }
      const importantRE = /\s*!important$/;
      function setStyle(style, name, val) {
        if (isArray$3(val)) {
          val.forEach((v2) => setStyle(style, name, v2));
        } else {
          if (val == null)
            val = "";
          if (name.startsWith("--")) {
            style.setProperty(name, val);
          } else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
              style.setProperty(
                hyphenate(prefixed),
                val.replace(importantRE, ""),
                "important"
              );
            } else {
              style[prefixed] = val;
            }
          }
        }
      }
      const prefixes = ["Webkit", "Moz", "ms"];
      const prefixCache = {};
      function autoPrefix(style, rawName) {
        const cached = prefixCache[rawName];
        if (cached) {
          return cached;
        }
        let name = camelize$1(rawName);
        if (name !== "filter" && name in style) {
          return prefixCache[rawName] = name;
        }
        name = capitalize$1(name);
        for (let i2 = 0; i2 < prefixes.length; i2++) {
          const prefixed = prefixes[i2] + name;
          if (prefixed in style) {
            return prefixCache[rawName] = prefixed;
          }
        }
        return rawName;
      }
      const xlinkNS = "http://www.w3.org/1999/xlink";
      function patchAttr(el, key, value, isSVG, instance) {
        if (isSVG && key.startsWith("xlink:")) {
          if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
          } else {
            el.setAttributeNS(xlinkNS, key, value);
          }
        } else {
          const isBoolean2 = isSpecialBooleanAttr(key);
          if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
            el.removeAttribute(key);
          } else {
            el.setAttribute(key, isBoolean2 ? "" : value);
          }
        }
      }
      function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
        if (key === "innerHTML" || key === "textContent") {
          if (prevChildren) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
          }
          el[key] = value == null ? "" : value;
          return;
        }
        const tag = el.tagName;
        if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
        !tag.includes("-")) {
          el._value = value;
          const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
          const newValue = value == null ? "" : value;
          if (oldValue !== newValue) {
            el.value = newValue;
          }
          if (value == null) {
            el.removeAttribute(key);
          }
          return;
        }
        let needRemove = false;
        if (value === "" || value == null) {
          const type2 = typeof el[key];
          if (type2 === "boolean") {
            value = includeBooleanAttr(value);
          } else if (value == null && type2 === "string") {
            value = "";
            needRemove = true;
          } else if (type2 === "number") {
            value = 0;
            needRemove = true;
          }
        }
        try {
          el[key] = value;
        } catch (e2) {
        }
        needRemove && el.removeAttribute(key);
      }
      function addEventListener(el, event, handler, options) {
        el.addEventListener(event, handler, options);
      }
      function removeEventListener(el, event, handler, options) {
        el.removeEventListener(event, handler, options);
      }
      function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
        const invokers = el._vei || (el._vei = {});
        const existingInvoker = invokers[rawName];
        if (nextValue && existingInvoker) {
          existingInvoker.value = nextValue;
        } else {
          const [name, options] = parseName(rawName);
          if (nextValue) {
            const invoker = invokers[rawName] = createInvoker(nextValue, instance);
            addEventListener(el, name, invoker, options);
          } else if (existingInvoker) {
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = void 0;
          }
        }
      }
      const optionsModifierRE = /(?:Once|Passive|Capture)$/;
      function parseName(name) {
        let options;
        if (optionsModifierRE.test(name)) {
          options = {};
          let m2;
          while (m2 = name.match(optionsModifierRE)) {
            name = name.slice(0, name.length - m2[0].length);
            options[m2[0].toLowerCase()] = true;
          }
        }
        const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
        return [event, options];
      }
      let cachedNow = 0;
      const p$1 = /* @__PURE__ */ Promise.resolve();
      const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
      function createInvoker(initialValue, instance) {
        const invoker = (e2) => {
          if (!e2._vts) {
            e2._vts = Date.now();
          } else if (e2._vts <= invoker.attached) {
            return;
          }
          callWithAsyncErrorHandling(
            patchStopImmediatePropagation(e2, invoker.value),
            instance,
            5,
            [e2]
          );
        };
        invoker.value = initialValue;
        invoker.attached = getNow();
        return invoker;
      }
      function patchStopImmediatePropagation(e2, value) {
        if (isArray$3(value)) {
          const originalStop = e2.stopImmediatePropagation;
          e2.stopImmediatePropagation = () => {
            originalStop.call(e2);
            e2._stopped = true;
          };
          return value.map((fn2) => (e22) => !e22._stopped && fn2 && fn2(e22));
        } else {
          return value;
        }
      }
      const nativeOnRE = /^on[a-z]/;
      const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
        if (key === "class") {
          patchClass(el, nextValue, isSVG);
        } else if (key === "style") {
          patchStyle(el, prevValue, nextValue);
        } else if (isOn(key)) {
          if (!isModelListener(key)) {
            patchEvent(el, key, prevValue, nextValue, parentComponent);
          }
        } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
          patchDOMProp(
            el,
            key,
            nextValue,
            prevChildren,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        } else {
          if (key === "true-value") {
            el._trueValue = nextValue;
          } else if (key === "false-value") {
            el._falseValue = nextValue;
          }
          patchAttr(el, key, nextValue, isSVG);
        }
      };
      function shouldSetAsProp(el, key, value, isSVG) {
        if (isSVG) {
          if (key === "innerHTML" || key === "textContent") {
            return true;
          }
          if (key in el && nativeOnRE.test(key) && isFunction$2(value)) {
            return true;
          }
          return false;
        }
        if (key === "spellcheck" || key === "draggable" || key === "translate") {
          return false;
        }
        if (key === "form") {
          return false;
        }
        if (key === "list" && el.tagName === "INPUT") {
          return false;
        }
        if (key === "type" && el.tagName === "TEXTAREA") {
          return false;
        }
        if (nativeOnRE.test(key) && isString$2(value)) {
          return false;
        }
        return key in el;
      }
      const TRANSITION = "transition";
      const ANIMATION = "animation";
      const Transition = (props2, { slots }) => h$1(BaseTransition, resolveTransitionProps(props2), slots);
      Transition.displayName = "Transition";
      const DOMTransitionPropsValidators = {
        name: String,
        type: String,
        css: {
          type: Boolean,
          default: true
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
      };
      const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
        {},
        BaseTransitionPropsValidators,
        DOMTransitionPropsValidators
      );
      const callHook = (hook, args = []) => {
        if (isArray$3(hook)) {
          hook.forEach((h2) => h2(...args));
        } else if (hook) {
          hook(...args);
        }
      };
      const hasExplicitCallback = (hook) => {
        return hook ? isArray$3(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
      };
      function resolveTransitionProps(rawProps) {
        const baseProps = {};
        for (const key in rawProps) {
          if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
          }
        }
        if (rawProps.css === false) {
          return baseProps;
        }
        const {
          name = "v",
          type: type2,
          duration,
          enterFromClass = `${name}-enter-from`,
          enterActiveClass = `${name}-enter-active`,
          enterToClass = `${name}-enter-to`,
          appearFromClass = enterFromClass,
          appearActiveClass = enterActiveClass,
          appearToClass = enterToClass,
          leaveFromClass = `${name}-leave-from`,
          leaveActiveClass = `${name}-leave-active`,
          leaveToClass = `${name}-leave-to`
        } = rawProps;
        const durations = normalizeDuration(duration);
        const enterDuration = durations && durations[0];
        const leaveDuration = durations && durations[1];
        const {
          onBeforeEnter,
          onEnter,
          onEnterCancelled,
          onLeave,
          onLeaveCancelled,
          onBeforeAppear = onBeforeEnter,
          onAppear = onEnter,
          onAppearCancelled = onEnterCancelled
        } = baseProps;
        const finishEnter = (el, isAppear, done) => {
          removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
          removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
          done && done();
        };
        const finishLeave = (el, done) => {
          el._isLeaving = false;
          removeTransitionClass(el, leaveFromClass);
          removeTransitionClass(el, leaveToClass);
          removeTransitionClass(el, leaveActiveClass);
          done && done();
        };
        const makeEnterHook = (isAppear) => {
          return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve2 = () => finishEnter(el, isAppear, done);
            callHook(hook, [el, resolve2]);
            nextFrame(() => {
              removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
              addTransitionClass(el, isAppear ? appearToClass : enterToClass);
              if (!hasExplicitCallback(hook)) {
                whenTransitionEnds(el, type2, enterDuration, resolve2);
              }
            });
          };
        };
        return extend(baseProps, {
          onBeforeEnter(el) {
            callHook(onBeforeEnter, [el]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
          },
          onBeforeAppear(el) {
            callHook(onBeforeAppear, [el]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
          },
          onEnter: makeEnterHook(false),
          onAppear: makeEnterHook(true),
          onLeave(el, done) {
            el._isLeaving = true;
            const resolve2 = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
              if (!el._isLeaving) {
                return;
              }
              removeTransitionClass(el, leaveFromClass);
              addTransitionClass(el, leaveToClass);
              if (!hasExplicitCallback(onLeave)) {
                whenTransitionEnds(el, type2, leaveDuration, resolve2);
              }
            });
            callHook(onLeave, [el, resolve2]);
          },
          onEnterCancelled(el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [el]);
          },
          onAppearCancelled(el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [el]);
          },
          onLeaveCancelled(el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [el]);
          }
        });
      }
      function normalizeDuration(duration) {
        if (duration == null) {
          return null;
        } else if (isObject$1(duration)) {
          return [NumberOf(duration.enter), NumberOf(duration.leave)];
        } else {
          const n2 = NumberOf(duration);
          return [n2, n2];
        }
      }
      function NumberOf(val) {
        const res = toNumber$2(val);
        return res;
      }
      function addTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
        (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
      }
      function removeTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
        const { _vtc } = el;
        if (_vtc) {
          _vtc.delete(cls);
          if (!_vtc.size) {
            el._vtc = void 0;
          }
        }
      }
      function nextFrame(cb) {
        requestAnimationFrame(() => {
          requestAnimationFrame(cb);
        });
      }
      let endId = 0;
      function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
        const id2 = el._endId = ++endId;
        const resolveIfNotStale = () => {
          if (id2 === el._endId) {
            resolve2();
          }
        };
        if (explicitTimeout) {
          return setTimeout(resolveIfNotStale, explicitTimeout);
        }
        const { type: type2, timeout, propCount } = getTransitionInfo(el, expectedType);
        if (!type2) {
          return resolve2();
        }
        const endEvent = type2 + "end";
        let ended = 0;
        const end2 = () => {
          el.removeEventListener(endEvent, onEnd);
          resolveIfNotStale();
        };
        const onEnd = (e2) => {
          if (e2.target === el && ++ended >= propCount) {
            end2();
          }
        };
        setTimeout(() => {
          if (ended < propCount) {
            end2();
          }
        }, timeout + 1);
        el.addEventListener(endEvent, onEnd);
      }
      function getTransitionInfo(el, expectedType) {
        const styles = window.getComputedStyle(el);
        const getStyleProperties = (key) => (styles[key] || "").split(", ");
        const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
        const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
        const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
        const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
        const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
        const animationTimeout = getTimeout(animationDelays, animationDurations);
        let type2 = null;
        let timeout = 0;
        let propCount = 0;
        if (expectedType === TRANSITION) {
          if (transitionTimeout > 0) {
            type2 = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
          }
        } else if (expectedType === ANIMATION) {
          if (animationTimeout > 0) {
            type2 = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
          }
        } else {
          timeout = Math.max(transitionTimeout, animationTimeout);
          type2 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
          propCount = type2 ? type2 === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
        }
        const hasTransform = type2 === TRANSITION && /\b(transform|all)(,|$)/.test(
          getStyleProperties(`${TRANSITION}Property`).toString()
        );
        return {
          type: type2,
          timeout,
          propCount,
          hasTransform
        };
      }
      function getTimeout(delays, durations) {
        while (delays.length < durations.length) {
          delays = delays.concat(delays);
        }
        return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
      }
      function toMs(s2) {
        return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
      }
      function forceReflow() {
        return document.body.offsetHeight;
      }
      const positionMap = /* @__PURE__ */ new WeakMap();
      const newPositionMap = /* @__PURE__ */ new WeakMap();
      const TransitionGroupImpl = {
        name: "TransitionGroup",
        props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
          tag: String,
          moveClass: String
        }),
        setup(props2, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          let prevChildren;
          let children;
          onUpdated(() => {
            if (!prevChildren.length) {
              return;
            }
            const moveClass = props2.moveClass || `${props2.name || "v"}-move`;
            if (!hasCSSTransform(
              prevChildren[0].el,
              instance.vnode.el,
              moveClass
            )) {
              return;
            }
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            forceReflow();
            movedChildren.forEach((c2) => {
              const el = c2.el;
              const style = el.style;
              addTransitionClass(el, moveClass);
              style.transform = style.webkitTransform = style.transitionDuration = "";
              const cb = el._moveCb = (e2) => {
                if (e2 && e2.target !== el) {
                  return;
                }
                if (!e2 || /transform$/.test(e2.propertyName)) {
                  el.removeEventListener("transitionend", cb);
                  el._moveCb = null;
                  removeTransitionClass(el, moveClass);
                }
              };
              el.addEventListener("transitionend", cb);
            });
          });
          return () => {
            const rawProps = toRaw(props2);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || Fragment;
            prevChildren = children;
            children = slots.default ? getTransitionRawChildren(slots.default()) : [];
            for (let i2 = 0; i2 < children.length; i2++) {
              const child = children[i2];
              if (child.key != null) {
                setTransitionHooks(
                  child,
                  resolveTransitionHooks(child, cssTransitionProps, state, instance)
                );
              }
            }
            if (prevChildren) {
              for (let i2 = 0; i2 < prevChildren.length; i2++) {
                const child = prevChildren[i2];
                setTransitionHooks(
                  child,
                  resolveTransitionHooks(child, cssTransitionProps, state, instance)
                );
                positionMap.set(child, child.el.getBoundingClientRect());
              }
            }
            return createVNode(tag, null, children);
          };
        }
      };
      const removeMode = (props2) => delete props2.mode;
      /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
      const TransitionGroup = TransitionGroupImpl;
      function callPendingCbs(c2) {
        const el = c2.el;
        if (el._moveCb) {
          el._moveCb();
        }
        if (el._enterCb) {
          el._enterCb();
        }
      }
      function recordPosition(c2) {
        newPositionMap.set(c2, c2.el.getBoundingClientRect());
      }
      function applyTranslation(c2) {
        const oldPos = positionMap.get(c2);
        const newPos = newPositionMap.get(c2);
        const dx = oldPos.left - newPos.left;
        const dy = oldPos.top - newPos.top;
        if (dx || dy) {
          const s2 = c2.el.style;
          s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
          s2.transitionDuration = "0s";
          return c2;
        }
      }
      function hasCSSTransform(el, root2, moveClass) {
        const clone2 = el.cloneNode();
        if (el._vtc) {
          el._vtc.forEach((cls) => {
            cls.split(/\s+/).forEach((c2) => c2 && clone2.classList.remove(c2));
          });
        }
        moveClass.split(/\s+/).forEach((c2) => c2 && clone2.classList.add(c2));
        clone2.style.display = "none";
        const container = root2.nodeType === 1 ? root2 : root2.parentNode;
        container.appendChild(clone2);
        const { hasTransform } = getTransitionInfo(clone2);
        container.removeChild(clone2);
        return hasTransform;
      }
      const getModelAssigner = (vnode) => {
        const fn2 = vnode.props["onUpdate:modelValue"] || false;
        return isArray$3(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
      };
      function onCompositionStart(e2) {
        e2.target.composing = true;
      }
      function onCompositionEnd(e2) {
        const target = e2.target;
        if (target.composing) {
          target.composing = false;
          target.dispatchEvent(new Event("input"));
        }
      }
      const vModelText = {
        created(el, { modifiers: { lazy, trim, number: number2 } }, vnode) {
          el._assign = getModelAssigner(vnode);
          const castToNumber = number2 || vnode.props && vnode.props.type === "number";
          addEventListener(el, lazy ? "change" : "input", (e2) => {
            if (e2.target.composing)
              return;
            let domValue = el.value;
            if (trim) {
              domValue = domValue.trim();
            }
            if (castToNumber) {
              domValue = looseToNumber(domValue);
            }
            el._assign(domValue);
          });
          if (trim) {
            addEventListener(el, "change", () => {
              el.value = el.value.trim();
            });
          }
          if (!lazy) {
            addEventListener(el, "compositionstart", onCompositionStart);
            addEventListener(el, "compositionend", onCompositionEnd);
            addEventListener(el, "change", onCompositionEnd);
          }
        },
        // set value on mounted so it's after min/max for type="range"
        mounted(el, { value }) {
          el.value = value == null ? "" : value;
        },
        beforeUpdate(el, { value, modifiers: { lazy, trim, number: number2 } }, vnode) {
          el._assign = getModelAssigner(vnode);
          if (el.composing)
            return;
          if (document.activeElement === el && el.type !== "range") {
            if (lazy) {
              return;
            }
            if (trim && el.value.trim() === value) {
              return;
            }
            if ((number2 || el.type === "number") && looseToNumber(el.value) === value) {
              return;
            }
          }
          const newValue = value == null ? "" : value;
          if (el.value !== newValue) {
            el.value = newValue;
          }
        }
      };
      const vModelCheckbox = {
        // #4096 array checkboxes need to be deep traversed
        deep: true,
        created(el, _2, vnode) {
          el._assign = getModelAssigner(vnode);
          addEventListener(el, "change", () => {
            const modelValue = el._modelValue;
            const elementValue = getValue$2(el);
            const checked = el.checked;
            const assign2 = el._assign;
            if (isArray$3(modelValue)) {
              const index = looseIndexOf(modelValue, elementValue);
              const found = index !== -1;
              if (checked && !found) {
                assign2(modelValue.concat(elementValue));
              } else if (!checked && found) {
                const filtered = [...modelValue];
                filtered.splice(index, 1);
                assign2(filtered);
              }
            } else if (isSet$2(modelValue)) {
              const cloned = new Set(modelValue);
              if (checked) {
                cloned.add(elementValue);
              } else {
                cloned.delete(elementValue);
              }
              assign2(cloned);
            } else {
              assign2(getCheckboxValue(el, checked));
            }
          });
        },
        // set initial checked on mount to wait for true-value/false-value
        mounted: setChecked,
        beforeUpdate(el, binding, vnode) {
          el._assign = getModelAssigner(vnode);
          setChecked(el, binding, vnode);
        }
      };
      function setChecked(el, { value, oldValue }, vnode) {
        el._modelValue = value;
        if (isArray$3(value)) {
          el.checked = looseIndexOf(value, vnode.props.value) > -1;
        } else if (isSet$2(value)) {
          el.checked = value.has(vnode.props.value);
        } else if (value !== oldValue) {
          el.checked = looseEqual(value, getCheckboxValue(el, true));
        }
      }
      function getValue$2(el) {
        return "_value" in el ? el._value : el.value;
      }
      function getCheckboxValue(el, checked) {
        const key = checked ? "_trueValue" : "_falseValue";
        return key in el ? el[key] : checked;
      }
      const systemModifiers = ["ctrl", "shift", "alt", "meta"];
      const modifierGuards = {
        stop: (e2) => e2.stopPropagation(),
        prevent: (e2) => e2.preventDefault(),
        self: (e2) => e2.target !== e2.currentTarget,
        ctrl: (e2) => !e2.ctrlKey,
        shift: (e2) => !e2.shiftKey,
        alt: (e2) => !e2.altKey,
        meta: (e2) => !e2.metaKey,
        left: (e2) => "button" in e2 && e2.button !== 0,
        middle: (e2) => "button" in e2 && e2.button !== 1,
        right: (e2) => "button" in e2 && e2.button !== 2,
        exact: (e2, modifiers) => systemModifiers.some((m2) => e2[`${m2}Key`] && !modifiers.includes(m2))
      };
      const withModifiers = (fn2, modifiers) => {
        return (event, ...args) => {
          for (let i2 = 0; i2 < modifiers.length; i2++) {
            const guard = modifierGuards[modifiers[i2]];
            if (guard && guard(event, modifiers))
              return;
          }
          return fn2(event, ...args);
        };
      };
      const keyNames = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
      };
      const withKeys = (fn2, modifiers) => {
        return (event) => {
          if (!("key" in event)) {
            return;
          }
          const eventKey = hyphenate(event.key);
          if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
            return fn2(event);
          }
        };
      };
      const vShow = {
        beforeMount(el, { value }, { transition }) {
          el._vod = el.style.display === "none" ? "" : el.style.display;
          if (transition && value) {
            transition.beforeEnter(el);
          } else {
            setDisplay(el, value);
          }
        },
        mounted(el, { value }, { transition }) {
          if (transition && value) {
            transition.enter(el);
          }
        },
        updated(el, { value, oldValue }, { transition }) {
          if (!value === !oldValue)
            return;
          if (transition) {
            if (value) {
              transition.beforeEnter(el);
              setDisplay(el, true);
              transition.enter(el);
            } else {
              transition.leave(el, () => {
                setDisplay(el, false);
              });
            }
          } else {
            setDisplay(el, value);
          }
        },
        beforeUnmount(el, { value }) {
          setDisplay(el, value);
        }
      };
      function setDisplay(el, value) {
        el.style.display = value ? el._vod : "none";
      }
      const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
      let renderer;
      function ensureRenderer() {
        return renderer || (renderer = createRenderer(rendererOptions));
      }
      const render$k = (...args) => {
        ensureRenderer().render(...args);
      };
      const createApp = (...args) => {
        const app2 = ensureRenderer().createApp(...args);
        const { mount } = app2;
        app2.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (!container)
            return;
          const component = app2._component;
          if (!isFunction$2(component) && !component.render && !component.template) {
            component.template = container.innerHTML;
          }
          container.innerHTML = "";
          const proxy = mount(container, false, container instanceof SVGElement);
          if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
          }
          return proxy;
        };
        return app2;
      };
      function normalizeContainer(container) {
        if (isString$2(container)) {
          const res = document.querySelector(container);
          return res;
        }
        return container;
      }
      function touchX(event) {
        if (event.type.indexOf("mouse") !== -1) {
          return event.clientX;
        }
        return event.touches[0].clientX;
      }
      function touchY(event) {
        if (event.type.indexOf("mouse") !== -1) {
          return event.clientY;
        }
        return event.touches[0].clientY;
      }
      var isPassiveSupported = function() {
        var supportsPassive = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supportsPassive = true;
            }
          });
          window.addEventListener("test", null, opts);
        } catch (e2) {
        }
        return supportsPassive;
      }();
      var vueTouchEvents = {
        install: function(app2, constructorOptions) {
          var globalOptions = Object.assign({}, {
            disableClick: false,
            tapTolerance: 10,
            // px
            swipeTolerance: 30,
            // px
            touchHoldTolerance: 400,
            // ms
            longTapTimeInterval: 400,
            // ms
            touchClass: "",
            dragFrequency: 100,
            // ms
            rollOverFrequency: 100
            // ms
          }, constructorOptions);
          function touchStartEvent(event) {
            var $this = this.$$touchObj, isTouchEvent = event.type.indexOf("touch") >= 0, isMouseEvent = event.type.indexOf("mouse") >= 0, $el = this;
            if (isTouchEvent) {
              $this.lastTouchStartTime = event.timeStamp;
            }
            if (isMouseEvent && $this.lastTouchStartTime && event.timeStamp - $this.lastTouchStartTime < 350) {
              return;
            }
            if ($this.touchStarted) {
              return;
            }
            addTouchClass(this);
            $this.touchStarted = true;
            $this.touchMoved = false;
            $this.swipeOutBounded = false;
            $this.startX = touchX(event);
            $this.startY = touchY(event);
            $this.currentX = 0;
            $this.currentY = 0;
            $this.touchStartTime = event.timeStamp;
            $this.hasSwipe = hasEvent(this, "swipe") || hasEvent(this, "swipe.left") || hasEvent(this, "swipe.right") || hasEvent(this, "swipe.top") || hasEvent(this, "swipe.bottom");
            if (hasEvent(this, "hold")) {
              $this.touchHoldTimer = setTimeout(function() {
                $this.touchHoldTimer = null;
                triggerEvent(event, $el, "hold");
              }, $this.options.touchHoldTolerance);
            }
            triggerEvent(event, this, "press");
          }
          function touchMoveEvent(event) {
            var $this = this.$$touchObj;
            var curX = touchX(event);
            var curY = touchY(event);
            var movedAgain = $this.currentX != curX || $this.currentY != curY;
            $this.currentX = curX;
            $this.currentY = curY;
            if (!$this.touchMoved) {
              var tapTolerance = $this.options.tapTolerance;
              $this.touchMoved = Math.abs($this.startX - $this.currentX) > tapTolerance || Math.abs($this.startY - $this.currentY) > tapTolerance;
              if ($this.touchMoved) {
                cancelTouchHoldTimer($this);
                triggerEvent(event, this, "drag.once");
              }
            } else if ($this.hasSwipe && !$this.swipeOutBounded) {
              var swipeOutBounded = $this.options.swipeTolerance;
              $this.swipeOutBounded = Math.abs($this.startX - $this.currentX) > swipeOutBounded && Math.abs($this.startY - $this.currentY) > swipeOutBounded;
            }
            if (hasEvent(this, "rollover") && movedAgain) {
              var now2 = event.timeStamp;
              var throttle2 = $this.options.rollOverFrequency;
              if ($this.touchRollTime == null || now2 > $this.touchRollTime + throttle2) {
                $this.touchRollTime = now2;
                triggerEvent(event, this, "rollover");
              }
            }
            if (hasEvent(this, "drag") && $this.touchStarted && $this.touchMoved && movedAgain) {
              var now2 = event.timeStamp;
              var throttle2 = $this.options.dragFrequency;
              if ($this.touchDragTime == null || now2 > $this.touchDragTime + throttle2) {
                $this.touchDragTime = now2;
                triggerEvent(event, this, "drag");
              }
            }
          }
          function touchCancelEvent() {
            var $this = this.$$touchObj;
            cancelTouchHoldTimer($this);
            removeTouchClass(this);
            $this.touchStarted = $this.touchMoved = false;
            $this.startX = $this.startY = 0;
          }
          function touchEndEvent(event) {
            var $this = this.$$touchObj, isTouchEvent = event.type.indexOf("touch") >= 0, isMouseEvent = event.type.indexOf("mouse") >= 0;
            if (isTouchEvent) {
              $this.lastTouchEndTime = event.timeStamp;
            }
            var touchholdEnd = isTouchEvent && !$this.touchHoldTimer;
            cancelTouchHoldTimer($this);
            $this.touchStarted = false;
            removeTouchClass(this);
            if (isMouseEvent && $this.lastTouchEndTime && event.timeStamp - $this.lastTouchEndTime < 350) {
              return;
            }
            triggerEvent(event, this, "release");
            if (!$this.touchMoved) {
              if (hasEvent(this, "longtap") && event.timeStamp - $this.touchStartTime > $this.options.longTapTimeInterval) {
                if (event.cancelable) {
                  event.preventDefault();
                }
                triggerEvent(event, this, "longtap");
              } else if (hasEvent(this, "hold") && touchholdEnd) {
                if (event.cancelable) {
                  event.preventDefault();
                }
                return;
              } else {
                triggerEvent(event, this, "tap");
              }
            } else if ($this.hasSwipe && !$this.swipeOutBounded) {
              var swipeOutBounded = $this.options.swipeTolerance, direction2, distanceY = Math.abs($this.startY - $this.currentY), distanceX = Math.abs($this.startX - $this.currentX);
              if (distanceY > swipeOutBounded || distanceX > swipeOutBounded) {
                if (distanceY > swipeOutBounded) {
                  direction2 = $this.startY > $this.currentY ? "top" : "bottom";
                } else {
                  direction2 = $this.startX > $this.currentX ? "left" : "right";
                }
                if (hasEvent(this, "swipe." + direction2)) {
                  triggerEvent(event, this, "swipe." + direction2, direction2);
                } else {
                  triggerEvent(event, this, "swipe", direction2);
                }
              }
            }
          }
          function mouseEnterEvent() {
            addTouchClass(this);
          }
          function mouseLeaveEvent() {
            removeTouchClass(this);
          }
          function hasEvent($el, eventType) {
            var callbacks = $el.$$touchObj.callbacks[eventType];
            return callbacks != null && callbacks.length > 0;
          }
          function triggerEvent(e2, $el, eventType, param) {
            var $this = $el.$$touchObj;
            var callbacks = $this.callbacks[eventType];
            if (callbacks == null || callbacks.length === 0) {
              return null;
            }
            for (var i2 = 0; i2 < callbacks.length; i2++) {
              var binding = callbacks[i2];
              if (binding.modifiers.stop) {
                e2.stopPropagation();
              }
              if (binding.modifiers.prevent) {
                e2.preventDefault();
              }
              if (binding.modifiers.self && e2.target !== e2.currentTarget) {
                continue;
              }
              if (typeof binding.value === "function") {
                if (param) {
                  binding.value(param, e2);
                } else {
                  binding.value(e2);
                }
              }
            }
          }
          function addTouchClass($el) {
            var className = $el.$$touchObj.options.touchClass;
            className && $el.classList.add(className);
          }
          function removeTouchClass($el) {
            var className = $el.$$touchObj.options.touchClass;
            className && $el.classList.remove(className);
          }
          function cancelTouchHoldTimer($this) {
            if ($this.touchHoldTimer) {
              clearTimeout($this.touchHoldTimer);
              $this.touchHoldTimer = null;
            }
          }
          function buildTouchObj($el, extraOptions) {
            var touchObj = $el.$$touchObj || {
              // an object contains all callbacks registered,
              // key is event name, value is an array
              callbacks: {},
              // prevent bind twice, set to true when event bound
              hasBindTouchEvents: false,
              // default options, would be override by v-touch-options
              options: globalOptions
            };
            if (extraOptions) {
              touchObj.options = Object.assign({}, touchObj.options, extraOptions);
            }
            $el.$$touchObj = touchObj;
            return $el.$$touchObj;
          }
          app2.directive("touch", {
            beforeMount: function($el, binding) {
              var $this = buildTouchObj($el);
              var passiveOpt = isPassiveSupported ? { passive: true } : false;
              var eventType = binding.arg || "tap";
              switch (eventType) {
                case "swipe":
                  var _m = binding.modifiers;
                  if (_m.left || _m.right || _m.top || _m.bottom) {
                    for (var i2 in binding.modifiers) {
                      if (["left", "right", "top", "bottom"].indexOf(i2) >= 0) {
                        var _e = "swipe." + i2;
                        $this.callbacks[_e] = $this.callbacks[_e] || [];
                        $this.callbacks[_e].push(binding);
                      }
                    }
                  } else {
                    $this.callbacks.swipe = $this.callbacks.swipe || [];
                    $this.callbacks.swipe.push(binding);
                  }
                  break;
                case "press":
                case "drag":
                  if (binding.modifiers.disablePassive) {
                    passiveOpt = false;
                  }
                default:
                  $this.callbacks[eventType] = $this.callbacks[eventType] || [];
                  $this.callbacks[eventType].push(binding);
              }
              if ($this.hasBindTouchEvents) {
                return;
              }
              $el.addEventListener("touchstart", touchStartEvent, passiveOpt);
              $el.addEventListener("touchmove", touchMoveEvent, passiveOpt);
              $el.addEventListener("touchcancel", touchCancelEvent);
              $el.addEventListener("touchend", touchEndEvent);
              if (!$this.options.disableClick) {
                $el.addEventListener("mousedown", touchStartEvent);
                $el.addEventListener("mousemove", touchMoveEvent);
                $el.addEventListener("mouseup", touchEndEvent);
                $el.addEventListener("mouseenter", mouseEnterEvent);
                $el.addEventListener("mouseleave", mouseLeaveEvent);
              }
              $this.hasBindTouchEvents = true;
            },
            unmounted: function($el) {
              $el.removeEventListener("touchstart", touchStartEvent);
              $el.removeEventListener("touchmove", touchMoveEvent);
              $el.removeEventListener("touchcancel", touchCancelEvent);
              $el.removeEventListener("touchend", touchEndEvent);
              if ($el.$$touchObj && !$el.$$touchObj.options.disableClick) {
                $el.removeEventListener("mousedown", touchStartEvent);
                $el.removeEventListener("mousemove", touchMoveEvent);
                $el.removeEventListener("mouseup", touchEndEvent);
                $el.removeEventListener("mouseenter", mouseEnterEvent);
                $el.removeEventListener("mouseleave", mouseLeaveEvent);
              }
              delete $el.$$touchObj;
            }
          });
          app2.directive("touch-class", {
            beforeMount: function($el, binding) {
              buildTouchObj($el, {
                touchClass: binding.value
              });
            }
          });
          app2.directive("touch-options", {
            beforeMount: function($el, binding) {
              buildTouchObj($el, binding.value);
            }
          });
        }
      };
      var isVue2 = false;
      /*!
        * pinia v2.1.4
        * (c) 2023 Eduardo San Martin Morote
        * @license MIT
        */
      let activePinia;
      const setActivePinia = (pinia2) => activePinia = pinia2;
      const piniaSymbol = (
        /* istanbul ignore next */
        Symbol()
      );
      function isPlainObject(o2) {
        return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
      }
      var MutationType;
      (function(MutationType2) {
        MutationType2["direct"] = "direct";
        MutationType2["patchObject"] = "patch object";
        MutationType2["patchFunction"] = "patch function";
      })(MutationType || (MutationType = {}));
      function createPinia() {
        const scope = effectScope(true);
        const state = scope.run(() => ref({}));
        let _p = [];
        let toBeInstalled = [];
        const pinia2 = markRaw({
          install(app2) {
            setActivePinia(pinia2);
            {
              pinia2._a = app2;
              app2.provide(piniaSymbol, pinia2);
              app2.config.globalProperties.$pinia = pinia2;
              toBeInstalled.forEach((plugin) => _p.push(plugin));
              toBeInstalled = [];
            }
          },
          use(plugin) {
            if (!this._a && !isVue2) {
              toBeInstalled.push(plugin);
            } else {
              _p.push(plugin);
            }
            return this;
          },
          _p,
          // it's actually undefined here
          // @ts-expect-error
          _a: null,
          _e: scope,
          _s: /* @__PURE__ */ new Map(),
          state
        });
        return pinia2;
      }
      const noop$2 = () => {
      };
      function addSubscription(subscriptions, callback, detached, onCleanup = noop$2) {
        subscriptions.push(callback);
        const removeSubscription = () => {
          const idx = subscriptions.indexOf(callback);
          if (idx > -1) {
            subscriptions.splice(idx, 1);
            onCleanup();
          }
        };
        if (!detached && getCurrentScope()) {
          onScopeDispose(removeSubscription);
        }
        return removeSubscription;
      }
      function triggerSubscriptions(subscriptions, ...args) {
        subscriptions.slice().forEach((callback) => {
          callback(...args);
        });
      }
      const fallbackRunWithContext = (fn2) => fn2();
      function mergeReactiveObjects(target, patchToApply) {
        if (target instanceof Map && patchToApply instanceof Map) {
          patchToApply.forEach((value, key) => target.set(key, value));
        }
        if (target instanceof Set && patchToApply instanceof Set) {
          patchToApply.forEach(target.add, target);
        }
        for (const key in patchToApply) {
          if (!patchToApply.hasOwnProperty(key))
            continue;
          const subPatch = patchToApply[key];
          const targetValue = target[key];
          if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
            target[key] = mergeReactiveObjects(targetValue, subPatch);
          } else {
            target[key] = subPatch;
          }
        }
        return target;
      }
      const skipHydrateSymbol = (
        /* istanbul ignore next */
        Symbol()
      );
      function shouldHydrate(obj) {
        return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
      }
      const { assign } = Object;
      function isComputed(o2) {
        return !!(isRef(o2) && o2.effect);
      }
      function createOptionsStore(id2, options, pinia2, hot) {
        const { state, actions, getters } = options;
        const initialState = pinia2.state.value[id2];
        let store;
        function setup() {
          if (!initialState && true) {
            {
              pinia2.state.value[id2] = state ? state() : {};
            }
          }
          const localState = toRefs$1(pinia2.state.value[id2]);
          return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
            computedGetters[name] = markRaw(computed(() => {
              setActivePinia(pinia2);
              const store2 = pinia2._s.get(id2);
              return getters[name].call(store2, store2);
            }));
            return computedGetters;
          }, {}));
        }
        store = createSetupStore(id2, setup, options, pinia2, hot, true);
        return store;
      }
      function createSetupStore($id, setup, options = {}, pinia2, hot, isOptionsStore) {
        let scope;
        const optionsForPlugin = assign({ actions: {} }, options);
        const $subscribeOptions = {
          deep: true
          // flush: 'post',
        };
        let isListening;
        let isSyncListening;
        let subscriptions = [];
        let actionSubscriptions = [];
        let debuggerEvents;
        const initialState = pinia2.state.value[$id];
        if (!isOptionsStore && !initialState && true) {
          {
            pinia2.state.value[$id] = {};
          }
        }
        ref({});
        let activeListener;
        function $patch(partialStateOrMutator) {
          let subscriptionMutation;
          isListening = isSyncListening = false;
          if (typeof partialStateOrMutator === "function") {
            partialStateOrMutator(pinia2.state.value[$id]);
            subscriptionMutation = {
              type: MutationType.patchFunction,
              storeId: $id,
              events: debuggerEvents
            };
          } else {
            mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
            subscriptionMutation = {
              type: MutationType.patchObject,
              payload: partialStateOrMutator,
              storeId: $id,
              events: debuggerEvents
            };
          }
          const myListenerId = activeListener = Symbol();
          nextTick().then(() => {
            if (activeListener === myListenerId) {
              isListening = true;
            }
          });
          isSyncListening = true;
          triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
        }
        const $reset = isOptionsStore ? function $reset2() {
          const { state } = options;
          const newState = state ? state() : {};
          this.$patch(($state) => {
            assign($state, newState);
          });
        } : (
          /* istanbul ignore next */
          noop$2
        );
        function $dispose() {
          scope.stop();
          subscriptions = [];
          actionSubscriptions = [];
          pinia2._s.delete($id);
        }
        function wrapAction(name, action) {
          return function() {
            setActivePinia(pinia2);
            const args = Array.from(arguments);
            const afterCallbackList = [];
            const onErrorCallbackList = [];
            function after(callback) {
              afterCallbackList.push(callback);
            }
            function onError(callback) {
              onErrorCallbackList.push(callback);
            }
            triggerSubscriptions(actionSubscriptions, {
              args,
              name,
              store,
              after,
              onError
            });
            let ret;
            try {
              ret = action.apply(this && this.$id === $id ? this : store, args);
            } catch (error) {
              triggerSubscriptions(onErrorCallbackList, error);
              throw error;
            }
            if (ret instanceof Promise) {
              return ret.then((value) => {
                triggerSubscriptions(afterCallbackList, value);
                return value;
              }).catch((error) => {
                triggerSubscriptions(onErrorCallbackList, error);
                return Promise.reject(error);
              });
            }
            triggerSubscriptions(afterCallbackList, ret);
            return ret;
          };
        }
        const partialStore = {
          _p: pinia2,
          // _s: scope,
          $id,
          $onAction: addSubscription.bind(null, actionSubscriptions),
          $patch,
          $reset,
          $subscribe(callback, options2 = {}) {
            const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
            const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
              if (options2.flush === "sync" ? isSyncListening : isListening) {
                callback({
                  storeId: $id,
                  type: MutationType.direct,
                  events: debuggerEvents
                }, state);
              }
            }, assign({}, $subscribeOptions, options2)));
            return removeSubscription;
          },
          $dispose
        };
        const store = reactive(partialStore);
        pinia2._s.set($id, store);
        const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
        const setupStore = pinia2._e.run(() => {
          scope = effectScope();
          return runWithContext(() => scope.run(setup));
        });
        for (const key in setupStore) {
          const prop = setupStore[key];
          if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
            if (!isOptionsStore) {
              if (initialState && shouldHydrate(prop)) {
                if (isRef(prop)) {
                  prop.value = initialState[key];
                } else {
                  mergeReactiveObjects(prop, initialState[key]);
                }
              }
              {
                pinia2.state.value[$id][key] = prop;
              }
            }
          } else if (typeof prop === "function") {
            const actionValue = wrapAction(key, prop);
            {
              setupStore[key] = actionValue;
            }
            optionsForPlugin.actions[key] = prop;
          } else
            ;
        }
        {
          assign(store, setupStore);
          assign(toRaw(store), setupStore);
        }
        Object.defineProperty(store, "$state", {
          get: () => pinia2.state.value[$id],
          set: (state) => {
            $patch(($state) => {
              assign($state, state);
            });
          }
        });
        pinia2._p.forEach((extender) => {
          {
            assign(store, scope.run(() => extender({
              store,
              app: pinia2._a,
              pinia: pinia2,
              options: optionsForPlugin
            })));
          }
        });
        if (initialState && isOptionsStore && options.hydrate) {
          options.hydrate(store.$state, initialState);
        }
        isListening = true;
        isSyncListening = true;
        return store;
      }
      function defineStore(idOrOptions, setup, setupOptions) {
        let id2;
        let options;
        const isSetupStore = typeof setup === "function";
        if (typeof idOrOptions === "string") {
          id2 = idOrOptions;
          options = isSetupStore ? setupOptions : setup;
        } else {
          options = idOrOptions;
          id2 = idOrOptions.id;
        }
        function useStore(pinia2, hot) {
          const hasContext = hasInjectionContext();
          pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
          // pinia instance with getActivePinia()
          pinia2 || (hasContext ? inject(piniaSymbol, null) : null);
          if (pinia2)
            setActivePinia(pinia2);
          pinia2 = activePinia;
          if (!pinia2._s.has(id2)) {
            if (isSetupStore) {
              createSetupStore(id2, setup, options, pinia2);
            } else {
              createOptionsStore(id2, options, pinia2);
            }
          }
          const store = pinia2._s.get(id2);
          return store;
        }
        useStore.$id = id2;
        return useStore;
      }
      const inBrowser$1 = typeof window !== "undefined";
      const supportTouch$1 = inBrowser$1 && "ontouchstart" in window;
      let initiated = false;
      let eventTarget;
      const isMousedown = (eventType) => eventType === "mousedown";
      const isMousemove = (eventType) => eventType === "mousemove";
      const isMouseup = (eventType) => eventType === "mouseup";
      const isUpdateTarget = (eventType) => isMousedown(eventType) || !eventTarget || eventTarget && !eventTarget.dispatchEvent;
      function Touch$1(target, identifier, mouseEvent) {
        const { clientX, clientY, screenX, screenY, pageX, pageY } = mouseEvent;
        this.identifier = identifier;
        this.target = target;
        this.clientX = clientX;
        this.clientY = clientY;
        this.screenX = screenX;
        this.screenY = screenY;
        this.pageX = pageX;
        this.pageY = pageY;
      }
      function updateTouchList(mouseEvent) {
        const touchList = createTouchList();
        touchList.push(new Touch$1(eventTarget, 1, mouseEvent));
        return touchList;
      }
      function createTouchList() {
        const touchList = [];
        touchList.item = function(index) {
          return this[index] || null;
        };
        return touchList;
      }
      function getActiveTouches(mouseEvent) {
        const { type: type2 } = mouseEvent;
        if (isMouseup(type2))
          return createTouchList();
        return updateTouchList(mouseEvent);
      }
      function triggerTouch(touchType, mouseEvent) {
        const { altKey, ctrlKey, metaKey, shiftKey } = mouseEvent;
        const touchEvent = new Event(touchType, { bubbles: true, cancelable: true });
        touchEvent.altKey = altKey;
        touchEvent.ctrlKey = ctrlKey;
        touchEvent.metaKey = metaKey;
        touchEvent.shiftKey = shiftKey;
        touchEvent.touches = getActiveTouches(mouseEvent);
        touchEvent.targetTouches = getActiveTouches(mouseEvent);
        touchEvent.changedTouches = createTouchList();
        eventTarget.dispatchEvent(touchEvent);
      }
      function onMouse(mouseEvent, touchType) {
        const { type: type2, target } = mouseEvent;
        initiated = isMousedown(type2) ? true : isMouseup(type2) ? false : initiated;
        if (isMousemove(type2) && !initiated)
          return;
        if (isUpdateTarget(type2))
          eventTarget = target;
        triggerTouch(touchType, mouseEvent);
        if (isMouseup(type2))
          eventTarget = null;
      }
      function createTouchEmulator() {
        window.addEventListener("mousedown", (event) => onMouse(event, "touchstart"), true);
        window.addEventListener("mousemove", (event) => onMouse(event, "touchmove"), true);
        window.addEventListener("mouseup", (event) => onMouse(event, "touchend"), true);
      }
      if (inBrowser$1 && !supportTouch$1) {
        createTouchEmulator();
      }
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      var FileSaver_min = { exports: {} };
      (function(module2, exports2) {
        (function(a2, b2) {
          b2();
        })(commonjsGlobal, function() {
          function b2(a3, b3) {
            return "undefined" == typeof b3 ? b3 = { autoBom: false } : "object" != typeof b3 && (console.warn("Deprecated: Expected third argument to be a object"), b3 = { autoBom: !b3 }), b3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a3.type) ? new Blob(["\uFEFF", a3], { type: a3.type }) : a3;
          }
          function c2(a3, b3, c3) {
            var d3 = new XMLHttpRequest();
            d3.open("GET", a3), d3.responseType = "blob", d3.onload = function() {
              g2(d3.response, b3, c3);
            }, d3.onerror = function() {
              console.error("could not download file");
            }, d3.send();
          }
          function d2(a3) {
            var b3 = new XMLHttpRequest();
            b3.open("HEAD", a3, false);
            try {
              b3.send();
            } catch (a4) {
            }
            return 200 <= b3.status && 299 >= b3.status;
          }
          function e2(a3) {
            try {
              a3.dispatchEvent(new MouseEvent("click"));
            } catch (c3) {
              var b3 = document.createEvent("MouseEvents");
              b3.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a3.dispatchEvent(b3);
            }
          }
          var f2 = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof commonjsGlobal && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0, a2 = f2.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g2 = f2.saveAs || ("object" != typeof window || window !== f2 ? function() {
          } : "download" in HTMLAnchorElement.prototype && !a2 ? function(b3, g3, h2) {
            var i2 = f2.URL || f2.webkitURL, j2 = document.createElement("a");
            g3 = g3 || b3.name || "download", j2.download = g3, j2.rel = "noopener", "string" == typeof b3 ? (j2.href = b3, j2.origin === location.origin ? e2(j2) : d2(j2.href) ? c2(b3, g3, h2) : e2(j2, j2.target = "_blank")) : (j2.href = i2.createObjectURL(b3), setTimeout(function() {
              i2.revokeObjectURL(j2.href);
            }, 4e4), setTimeout(function() {
              e2(j2);
            }, 0));
          } : "msSaveOrOpenBlob" in navigator ? function(f3, g3, h2) {
            if (g3 = g3 || f3.name || "download", "string" != typeof f3)
              navigator.msSaveOrOpenBlob(b2(f3, h2), g3);
            else if (d2(f3))
              c2(f3, g3, h2);
            else {
              var i2 = document.createElement("a");
              i2.href = f3, i2.target = "_blank", setTimeout(function() {
                e2(i2);
              });
            }
          } : function(b3, d3, e3, g3) {
            if (g3 = g3 || open("", "_blank"), g3 && (g3.document.title = g3.document.body.innerText = "downloading..."), "string" == typeof b3)
              return c2(b3, d3, e3);
            var h2 = "application/octet-stream" === b3.type, i2 = /constructor/i.test(f2.HTMLElement) || f2.safari, j2 = /CriOS\/[\d]+/.test(navigator.userAgent);
            if ((j2 || h2 && i2 || a2) && "undefined" != typeof FileReader) {
              var k2 = new FileReader();
              k2.onloadend = function() {
                var a3 = k2.result;
                a3 = j2 ? a3 : a3.replace(/^data:[^;]*;/, "data:attachment/file;"), g3 ? g3.location.href = a3 : location = a3, g3 = null;
              }, k2.readAsDataURL(b3);
            } else {
              var l2 = f2.URL || f2.webkitURL, m2 = l2.createObjectURL(b3);
              g3 ? g3.location = m2 : location.href = m2, g3 = null, setTimeout(function() {
                l2.revokeObjectURL(m2);
              }, 4e4);
            }
          });
          f2.saveAs = g2.saveAs = g2, module2.exports = g2;
        });
      })(FileSaver_min);
      var FileSaver_minExports = FileSaver_min.exports;
      var context = {
        locks: {},
        zIndex: 2e3,
        enableRipple: true
      };
      reactive(context);
      const Context = reactive(context);
      const isString$1 = (val) => typeof val === "string";
      const isBoolean$1 = (val) => typeof val === "boolean";
      const isNumber$1 = (val) => typeof val === "number";
      const isFunction$1 = (val) => typeof val === "function";
      const isArray$2 = (val) => Array.isArray(val);
      const isURL = (val) => {
        if (!val) {
          return false;
        }
        return /^(http)|(\.*\/)/.test(val);
      };
      const isWindow = (val) => val === window;
      const toNumber$1 = (val) => {
        if (val == null)
          return 0;
        if (isString$1(val)) {
          val = parseFloat(val);
          val = Number.isNaN(val) ? 0 : val;
          return val;
        }
        if (isBoolean$1(val))
          return Number(val);
        return val;
      };
      const inBrowser = () => typeof window !== "undefined";
      const camelize = (s2) => s2.replace(/-(\w)/g, (_2, p2) => p2.toUpperCase());
      const clamp = (num, min, max) => Math.min(max, Math.max(min, num));
      function _extends$4() {
        _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends$4.apply(this, arguments);
      }
      function getStyle$2(element) {
        return window.getComputedStyle(element);
      }
      function getRect(element) {
        if (isWindow(element)) {
          var width = element.innerWidth;
          var height = element.innerHeight;
          var rect = {
            x: 0,
            y: 0,
            top: 0,
            left: 0,
            right: width,
            bottom: height,
            width,
            height
          };
          return _extends$4({}, rect, {
            toJSON: () => rect
          });
        }
        return element.getBoundingClientRect();
      }
      function getViewportSize() {
        var {
          width,
          height
        } = getRect(window);
        return {
          vw: width,
          vh: height,
          vMin: Math.min(width, height),
          vMax: Math.max(width, height)
        };
      }
      var isRem = (value) => isString$1(value) && value.endsWith("rem");
      var isEm = (value) => isString$1(value) && value.endsWith("em") && !value.endsWith("rem");
      var isPx = (value) => isString$1(value) && value.endsWith("px") || isNumber$1(value);
      var isPercent = (value) => isString$1(value) && value.endsWith("%");
      var isVw = (value) => isString$1(value) && value.endsWith("vw");
      var isVh = (value) => isString$1(value) && value.endsWith("vh");
      var isVMin = (value) => isString$1(value) && value.endsWith("vmin");
      var isVMax = (value) => isString$1(value) && value.endsWith("vmax");
      var isCalc = (value) => isString$1(value) && value.startsWith("calc(");
      var isVar = (value) => isString$1(value) && value.startsWith("var(");
      var toPxNum = (value) => {
        if (isNumber$1(value)) {
          return value;
        }
        if (isPx(value)) {
          return +value.replace("px", "");
        }
        if (!inBrowser()) {
          return 0;
        }
        var {
          vw,
          vh,
          vMin,
          vMax
        } = getViewportSize();
        if (isVw(value)) {
          return +value.replace("vw", "") * vw / 100;
        }
        if (isVh(value)) {
          return +value.replace("vh", "") * vh / 100;
        }
        if (isVMin(value)) {
          return +value.replace("vmin", "") * vMin / 100;
        }
        if (isVMax(value)) {
          return +value.replace("vmax", "") * vMax / 100;
        }
        if (isRem(value)) {
          var num = +value.replace("rem", "");
          var rootFontSize = getStyle$2(document.documentElement).fontSize;
          return num * parseFloat(rootFontSize);
        }
        if (isString$1(value)) {
          return toNumber$1(value);
        }
        return 0;
      };
      var toSizeUnit = (value) => {
        if (value == null) {
          return void 0;
        }
        if (isPercent(value) || isVw(value) || isVh(value) || isEm(value) || isRem(value) || isCalc(value) || isVar(value) || isVMin(value) || isVMax(value)) {
          return value;
        }
        return toPxNum(value) + "px";
      };
      var multiplySizeUnit = function(value, quantity) {
        if (quantity === void 0) {
          quantity = 1;
        }
        if (value == null) {
          return void 0;
        }
        var legalSize = toSizeUnit(value);
        var unit = legalSize.match(/(vh|%|r?em|px|vw|vmin|vmax)$/)[0];
        return "" + parseFloat(legalSize) * quantity + unit;
      };
      function supportTouch() {
        var inBrowser2 = typeof window !== "undefined";
        return inBrowser2 && "ontouchstart" in window;
      }
      function onSmartMounted(hook) {
        let isMounted = false;
        onMounted(() => {
          hook();
          nextTick(() => {
            isMounted = true;
          });
        });
        onActivated(() => {
          if (!isMounted) {
            return;
          }
          hook();
        });
      }
      function useEventListener$2(target, type2, listener, options = {}) {
        if (!inBrowser()) {
          return;
        }
        const { passive = false, capture = false } = options;
        let listening = false;
        let cleaned = false;
        const getElement = (target2) => isFunction$1(target2) ? target2() : unref(target2);
        const add2 = (target2) => {
          if (listening || cleaned) {
            return;
          }
          const element = getElement(target2);
          if (element) {
            element.addEventListener(type2, listener, {
              passive,
              capture
            });
            listening = true;
          }
        };
        const remove2 = (target2) => {
          if (!listening || cleaned) {
            return;
          }
          const element = getElement(target2);
          if (element) {
            element.removeEventListener(type2, listener, {
              capture
            });
            listening = false;
          }
        };
        let watchStopHandle;
        if (isRef(target)) {
          watchStopHandle = watch(() => target.value, (newValue, oldValue) => {
            remove2(oldValue);
            add2(newValue);
          });
        }
        const cleanup = () => {
          watchStopHandle === null || watchStopHandle === void 0 ? void 0 : watchStopHandle();
          remove2(target);
          cleaned = true;
        };
        onSmartMounted(() => {
          add2(target);
        });
        onBeforeUnmount(() => {
          remove2(target);
        });
        onDeactivated(() => {
          remove2(target);
        });
        return cleanup;
      }
      function useClickOutside(target, type2, listener) {
        if (!inBrowser()) {
          return;
        }
        const handler = (event) => {
          const element = isFunction$1(target) ? target() : unref(target);
          if (element && !element.contains(event.target)) {
            listener(event);
          }
        };
        useEventListener$2(document, type2, handler);
      }
      var __rest = globalThis && globalThis.__rest || function(s2, e2) {
        var t2 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t2[p2[i2]] = s2[p2[i2]];
          }
        return t2;
      };
      function keyInProvides(key) {
        const instance = getCurrentInstance();
        return key in instance.provides;
      }
      function useParent(key) {
        if (!keyInProvides(key)) {
          return {
            index: null,
            parentProvider: null,
            bindParent: null
          };
        }
        const provider = inject(key);
        const { childInstances, collect, clear: clear2 } = provider, parentProvider = __rest(provider, ["childInstances", "collect", "clear"]);
        const childInstance = getCurrentInstance();
        const index = computed(() => childInstances.indexOf(childInstance));
        const bindParent = (childProvider) => {
          onMounted(() => {
            nextTick().then(() => {
              collect(childInstance, childProvider);
            });
          });
          onBeforeUnmount(() => {
            nextTick().then(() => {
              clear2(childInstance, childProvider);
            });
          });
        };
        return {
          index,
          parentProvider,
          bindParent
        };
      }
      function onWindowResize(listener) {
        useEventListener$2(() => window, "resize", listener, { passive: true });
        useEventListener$2(() => window, "orientationchange", listener, { passive: true });
      }
      function pickProps(props2, propsKey) {
        return Array.isArray(propsKey) ? propsKey.reduce((pickedProps, key) => {
          pickedProps[key] = props2[key];
          return pickedProps;
        }, {}) : props2[propsKey];
      }
      function withInstall$1(component, target) {
        var componentWithInstall = target != null ? target : component;
        componentWithInstall.install = function(app2) {
          var {
            name
          } = component;
          if (name) {
            app2.component(name, component);
          }
        };
        return componentWithInstall;
      }
      function flatFragment(vNodes) {
        var result = [];
        vNodes.forEach((vNode) => {
          if (vNode.type === Comment) {
            return;
          }
          if (vNode.type === Fragment && isArray$2(vNode.children)) {
            vNode.children.forEach((item) => {
              result.push(item);
            });
            return;
          }
          result.push(vNode);
        });
        return result;
      }
      function useTeleport() {
        var disabled = ref(false);
        onActivated(() => {
          disabled.value = false;
        });
        onDeactivated(() => {
          disabled.value = true;
        });
        return {
          disabled
        };
      }
      function createNamespace(name) {
        var namespace = "var";
        var componentName = namespace + "-" + name;
        var createBEM = (suffix) => {
          if (!suffix) {
            return componentName;
          }
          if (suffix[0] === "$") {
            return suffix.replace("$", namespace);
          }
          return suffix.startsWith("--") ? "" + componentName + suffix : componentName + "__" + suffix;
        };
        var classes2 = function() {
          for (var _len = arguments.length, classes3 = new Array(_len), _key = 0; _key < _len; _key++) {
            classes3[_key] = arguments[_key];
          }
          return classes3.map((className) => {
            if (isArray$2(className)) {
              var [condition, truthy, falsy = null] = className;
              return condition ? truthy : falsy;
            }
            return className;
          });
        };
        return {
          n: createBEM,
          classes: classes2
        };
      }
      function call(fn2) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        if (isArray$2(fn2)) {
          return fn2.map((f2) => f2(...args));
        }
        if (fn2) {
          return fn2(...args);
        }
      }
      function defineListenerProp(fallback) {
        return {
          type: [Function, Array],
          default: fallback
        };
      }
      function formatElevation(elevation2, defaultLevel) {
        if (elevation2 === false) {
          return null;
        }
        if (elevation2 === true && defaultLevel) {
          elevation2 = defaultLevel;
        }
        return "var-elevation--" + elevation2;
      }
      function useVModel(props2, key, options) {
        if (options === void 0) {
          options = {};
        }
        var {
          passive = true,
          eventName,
          defaultValue,
          emit: emit2
        } = options;
        var event = eventName != null ? eventName : "onUpdate:" + key.toString();
        var getValue2 = () => props2[key] != null ? props2[key] : defaultValue;
        if (!passive) {
          return computed({
            get() {
              return getValue2();
            },
            set(value) {
              emit2 ? emit2(event, value) : call(props2[event], value);
            }
          });
        }
        var proxy = ref(getValue2());
        watch(() => props2[key], () => {
          proxy.value = getValue2();
        });
        watch(() => proxy.value, (newValue) => {
          emit2 ? emit2(event, newValue) : call(props2[event], newValue);
        });
        return proxy;
      }
      function _extends$3() {
        _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends$3.apply(this, arguments);
      }
      var {
        n: n$8
      } = createNamespace("ripple");
      var ANIMATION_DURATION = 250;
      function setStyles(element) {
        var {
          zIndex: zIndex2,
          position
        } = getStyle$2(element);
        element.style.overflow = "hidden";
        element.style.overflowX = "hidden";
        element.style.overflowY = "hidden";
        position === "static" && (element.style.position = "relative");
        zIndex2 === "auto" && (element.style.zIndex = "1");
      }
      function computeRippleStyles(element, event) {
        var {
          top,
          left: left2
        } = getRect(element);
        var {
          clientWidth,
          clientHeight
        } = element;
        var radius = Math.sqrt(Math.pow(clientWidth, 2) + Math.pow(clientHeight, 2)) / 2;
        var size2 = radius * 2;
        var localX = event.touches[0].clientX - left2;
        var localY = event.touches[0].clientY - top;
        var centerX = (clientWidth - radius * 2) / 2;
        var centerY = (clientHeight - radius * 2) / 2;
        var x2 = localX - radius;
        var y2 = localY - radius;
        return {
          x: x2,
          y: y2,
          centerX,
          centerY,
          size: size2
        };
      }
      function createRipple(event) {
        var _ripple = this._ripple;
        _ripple.removeRipple();
        if (_ripple.disabled || _ripple.tasker || !Context.enableRipple) {
          return;
        }
        var task = () => {
          _ripple.tasker = null;
          var {
            x: x2,
            y: y2,
            centerX,
            centerY,
            size: size2
          } = computeRippleStyles(this, event);
          var ripple2 = document.createElement("div");
          ripple2.classList.add(n$8());
          ripple2.style.opacity = "0";
          ripple2.style.transform = "translate(" + x2 + "px, " + y2 + "px) scale3d(.3, .3, .3)";
          ripple2.style.width = size2 + "px";
          ripple2.style.height = size2 + "px";
          _ripple.color && (ripple2.style.backgroundColor = _ripple.color);
          ripple2.dataset.createdAt = String(performance.now());
          setStyles(this);
          this.appendChild(ripple2);
          window.setTimeout(() => {
            ripple2.style.transform = "translate(" + centerX + "px, " + centerY + "px) scale3d(1, 1, 1)";
            ripple2.style.opacity = ".25";
          }, 20);
        };
        _ripple.tasker = window.setTimeout(task, 30);
      }
      function removeRipple() {
        var _ripple = this._ripple;
        var task = () => {
          var ripples = this.querySelectorAll("." + n$8());
          if (!ripples.length) {
            return;
          }
          var lastRipple = ripples[ripples.length - 1];
          var delay = ANIMATION_DURATION - performance.now() + Number(lastRipple.dataset.createdAt);
          window.setTimeout(() => {
            lastRipple.style.opacity = "0";
            window.setTimeout(() => {
              var _lastRipple$parentNod;
              return (_lastRipple$parentNod = lastRipple.parentNode) == null ? void 0 : _lastRipple$parentNod.removeChild(lastRipple);
            }, ANIMATION_DURATION);
          }, delay);
        };
        _ripple.tasker ? window.setTimeout(task, 30) : task();
      }
      function forbidRippleTask() {
        if (!supportTouch() || !Context.enableRipple) {
          return;
        }
        var _ripple = this._ripple;
        _ripple.tasker && window.clearTimeout(_ripple.tasker);
        _ripple.tasker = null;
      }
      function mounted$1(el, binding) {
        var _binding$value;
        el._ripple = _extends$3({
          tasker: null
        }, (_binding$value = binding.value) != null ? _binding$value : {}, {
          removeRipple: removeRipple.bind(el)
        });
        el.addEventListener("touchstart", createRipple, {
          passive: true
        });
        el.addEventListener("touchmove", forbidRippleTask, {
          passive: true
        });
        el.addEventListener("dragstart", removeRipple, {
          passive: true
        });
        document.addEventListener("touchend", el._ripple.removeRipple, {
          passive: true
        });
        document.addEventListener("touchcancel", el._ripple.removeRipple, {
          passive: true
        });
      }
      function unmounted$1(el) {
        el.removeEventListener("touchstart", createRipple);
        el.removeEventListener("touchmove", forbidRippleTask);
        el.removeEventListener("dragstart", removeRipple);
        document.removeEventListener("touchend", el._ripple.removeRipple);
        document.removeEventListener("touchcancel", el._ripple.removeRipple);
      }
      function updated$1(el, binding) {
        var _binding$value2, _binding$value3, _el$_ripple, _el$_ripple2;
        var newBinding = {
          color: (_binding$value2 = binding.value) == null ? void 0 : _binding$value2.color,
          disabled: (_binding$value3 = binding.value) == null ? void 0 : _binding$value3.disabled
        };
        var diff = newBinding.color !== ((_el$_ripple = el._ripple) == null ? void 0 : _el$_ripple.color) || newBinding.disabled !== ((_el$_ripple2 = el._ripple) == null ? void 0 : _el$_ripple2.disabled);
        if (diff) {
          var _el$_ripple3, _el$_ripple4;
          el._ripple = _extends$3({
            tasker: newBinding.disabled ? null : (_el$_ripple3 = el._ripple) == null ? void 0 : _el$_ripple3.tasker,
            removeRipple: (_el$_ripple4 = el._ripple) == null ? void 0 : _el$_ripple4.removeRipple
          }, newBinding);
        }
      }
      var Ripple = {
        mounted: mounted$1,
        unmounted: unmounted$1,
        updated: updated$1,
        install(app2) {
          app2.directive("ripple", this);
        }
      };
      const Ripple$1 = Ripple;
      var props$6 = {
        name: {
          type: String
        },
        size: {
          type: [Number, String]
        },
        color: {
          type: String
        },
        namespace: {
          type: String,
          default: "var-icon"
        },
        transition: {
          type: [Number, String],
          default: 0
        },
        animationClass: {
          type: String
        },
        onClick: defineListenerProp()
      };
      function asyncGeneratorStep$1(gen, resolve2, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve2(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator$1(fn2) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve2, reject) {
            var gen = fn2.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep$1(gen, resolve2, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep$1(gen, resolve2, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var {
        n: n$7,
        classes: classes$6
      } = createNamespace("icon");
      function __render__$5(_ctx, _cache) {
        return openBlock(), createBlock(resolveDynamicComponent(_ctx.isURL(_ctx.name) ? "img" : "i"), {
          class: normalizeClass(_ctx.classes(_ctx.n(), [_ctx.namespace !== _ctx.n(), _ctx.namespace], _ctx.namespace + "--set", [_ctx.isURL(_ctx.name), _ctx.n("image"), _ctx.namespace + "-" + _ctx.nextName], [_ctx.animateInProgress, _ctx.animationClass == null ? _ctx.n("--shrinking") : _ctx.animationClass])),
          style: normalizeStyle({
            color: _ctx.color,
            "transition-duration": _ctx.toNumber(_ctx.transition) + "ms",
            width: _ctx.isURL(_ctx.name) ? _ctx.toSizeUnit(_ctx.size) : null,
            height: _ctx.isURL(_ctx.name) ? _ctx.toSizeUnit(_ctx.size) : null,
            fontSize: _ctx.toSizeUnit(_ctx.size)
          }),
          src: _ctx.isURL(_ctx.name) ? _ctx.nextName : null,
          onClick: _ctx.onClick
        }, null, 8, ["class", "style", "src", "onClick"]);
      }
      var __sfc__$5 = defineComponent({
        name: "VarIcon",
        props: props$6,
        setup(props2) {
          var nextName = ref("");
          var animateInProgress = ref(false);
          var handleNameChange = /* @__PURE__ */ function() {
            var _ref = _asyncToGenerator$1(function* (newName, oldName) {
              var {
                transition
              } = props2;
              if (oldName == null || toNumber$1(transition) === 0) {
                nextName.value = newName;
                return;
              }
              animateInProgress.value = true;
              yield nextTick();
              setTimeout(() => {
                if (oldName != null) {
                  nextName.value = newName;
                }
                animateInProgress.value = false;
              }, toNumber$1(transition));
            });
            return function handleNameChange2(_x, _x2) {
              return _ref.apply(this, arguments);
            };
          }();
          watch(() => props2.name, handleNameChange, {
            immediate: true
          });
          return {
            n: n$7,
            classes: classes$6,
            nextName,
            animateInProgress,
            isURL,
            toNumber: toNumber$1,
            toSizeUnit
          };
        }
      });
      __sfc__$5.render = __render__$5;
      const Icon$1 = __sfc__$5;
      withInstall$1(Icon$1);
      function typeValidator$2(type2) {
        return ["circle", "wave", "cube", "rect", "disappear"].includes(type2);
      }
      function sizeValidator$1(size2) {
        return ["normal", "mini", "small", "large"].includes(size2);
      }
      var props$5 = {
        type: {
          type: String,
          default: "circle",
          validator: typeValidator$2
        },
        radius: {
          type: [String, Number]
        },
        size: {
          type: String,
          default: "normal",
          validator: sizeValidator$1
        },
        color: {
          type: String
        },
        description: {
          type: String
        },
        loading: {
          type: Boolean,
          default: false
        }
      };
      var {
        n: n$6,
        classes: classes$5
      } = createNamespace("loading");
      var _withScopeId$1 = (n2) => (pushScopeId(""), n2 = n2(), popScopeId(), n2);
      var _hoisted_1$R = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode(
        "svg",
        {
          viewBox: "25 25 50 50"
        },
        [/* @__PURE__ */ createBaseVNode("circle", {
          cx: "50",
          cy: "50",
          r: "20",
          fill: "none"
        })],
        -1
        /* HOISTED */
      ));
      var _hoisted_2$E = [_hoisted_1$R];
      function __render__$4(_ctx, _cache) {
        return openBlock(), createElementBlock(
          "div",
          {
            class: normalizeClass(_ctx.n())
          },
          [_ctx.$slots.default ? (openBlock(), createElementBlock(
            "div",
            {
              key: 0,
              class: normalizeClass(_ctx.classes(_ctx.n("content"), [_ctx.loading, _ctx.n("content--active")]))
            },
            [renderSlot(_ctx.$slots, "default"), _ctx.loading ? (openBlock(), createElementBlock(
              "div",
              {
                key: 0,
                class: normalizeClass(_ctx.n("content-mask"))
              },
              null,
              2
              /* CLASS */
            )) : createCommentVNode("v-if", true)],
            2
            /* CLASS */
          )) : createCommentVNode("v-if", true), _ctx.isShow ? (openBlock(), createElementBlock(
            "div",
            {
              key: 1,
              class: normalizeClass(_ctx.classes(_ctx.n("$--box"), _ctx.n("body"), [_ctx.$slots.default, _ctx.n("inside")]))
            },
            [_ctx.type === "circle" ? (openBlock(), createElementBlock(
              "div",
              {
                key: 0,
                class: normalizeClass(_ctx.n("circle"))
              },
              [createBaseVNode(
                "span",
                {
                  class: normalizeClass(_ctx.classes(_ctx.n("circle-block"), _ctx.n("circle-block--" + _ctx.size))),
                  style: normalizeStyle({
                    width: _ctx.multiplySizeUnit(_ctx.radius, 2),
                    height: _ctx.multiplySizeUnit(_ctx.radius, 2),
                    color: _ctx.color
                  })
                },
                _hoisted_2$E,
                6
                /* CLASS, STYLE */
              )],
              2
              /* CLASS */
            )) : createCommentVNode("v-if", true), (openBlock(true), createElementBlock(
              Fragment,
              null,
              renderList(_ctx.loadingTypeDict, (nums, key) => {
                return openBlock(), createElementBlock(
                  Fragment,
                  {
                    key
                  },
                  [_ctx.type === key ? (openBlock(), createElementBlock(
                    "div",
                    {
                      key: 0,
                      class: normalizeClass(_ctx.classes(_ctx.n(key), _ctx.n(key + "--" + _ctx.size)))
                    },
                    [(openBlock(true), createElementBlock(
                      Fragment,
                      null,
                      renderList(nums, (num) => {
                        return openBlock(), createElementBlock(
                          "div",
                          {
                            key: num + key,
                            style: normalizeStyle({
                              backgroundColor: _ctx.color
                            }),
                            class: normalizeClass(_ctx.classes(_ctx.n(key + "-item"), _ctx.n(key + "-item--" + _ctx.size)))
                          },
                          null,
                          6
                          /* CLASS, STYLE */
                        );
                      }),
                      128
                      /* KEYED_FRAGMENT */
                    ))],
                    2
                    /* CLASS */
                  )) : createCommentVNode("v-if", true)],
                  64
                  /* STABLE_FRAGMENT */
                );
              }),
              128
              /* KEYED_FRAGMENT */
            )), _ctx.$slots.description || _ctx.description ? (openBlock(), createElementBlock(
              "div",
              {
                key: 1,
                class: normalizeClass(_ctx.classes(_ctx.n("description"), _ctx.n("description--" + _ctx.size))),
                style: normalizeStyle({
                  color: _ctx.color
                })
              },
              [renderSlot(_ctx.$slots, "description", {}, () => [createTextVNode(
                toDisplayString(_ctx.description),
                1
                /* TEXT */
              )])],
              6
              /* CLASS, STYLE */
            )) : createCommentVNode("v-if", true)],
            2
            /* CLASS */
          )) : createCommentVNode("v-if", true)],
          2
          /* CLASS */
        );
      }
      var __sfc__$4 = defineComponent({
        name: "VarLoading",
        props: props$5,
        setup(props2, _ref) {
          var {
            slots
          } = _ref;
          var loadingTypeDict = {
            wave: 5,
            cube: 4,
            rect: 8,
            disappear: 3
          };
          var isShow = computed(() => {
            if (!call(slots.default))
              return true;
            return props2.loading;
          });
          return {
            n: n$6,
            classes: classes$5,
            multiplySizeUnit,
            loadingTypeDict,
            isShow
          };
        }
      });
      __sfc__$4.render = __render__$4;
      const Loading = __sfc__$4;
      withInstall$1(Loading);
      var props$4 = {
        hovering: {
          type: Boolean,
          default: true
        }
      };
      var {
        n: n$5,
        classes: classes$4
      } = createNamespace("hover-overlay");
      function __render__$3(_ctx, _cache) {
        return openBlock(), createElementBlock(
          "div",
          {
            class: normalizeClass(_ctx.classes(_ctx.n(), [_ctx.hovering, _ctx.n("--hovering")]))
          },
          null,
          2
          /* CLASS */
        );
      }
      var __sfc__$3 = defineComponent({
        name: "VarHoverOverlay",
        props: props$4,
        setup() {
          return {
            n: n$5,
            classes: classes$4
          };
        }
      });
      __sfc__$3.render = __render__$3;
      const HoverOverlay = __sfc__$3;
      withInstall$1(HoverOverlay);
      function useHoverOverlay() {
        var hovering = ref(false);
        var handleHovering = (value) => {
          hovering.value = value;
        };
        return {
          hovering,
          handleHovering
        };
      }
      function shouldDisabled(arg) {
        if (!arg) {
          return false;
        }
        var isMobile2 = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (arg === "desktop" && isMobile2) {
          return true;
        }
        if (arg === "mobile" && !isMobile2) {
          return true;
        }
        return false;
      }
      function getStyle$1(element) {
        var style = element.getAttribute("style");
        if (!style)
          return {};
        return style.split(";").filter(Boolean).reduce((style2, item) => {
          var [key, value] = item.split(":").map((item2) => item2.trim());
          style2[camelize(key)] = value;
          return style2;
        }, {});
      }
      function updateRawStyle(element) {
        var {
          value
        } = element._hover;
        var style = getStyle$1(element);
        Object.keys(value).forEach((key) => {
          var camelizedKey = camelize(key);
          var styleValue = value[camelizedKey];
          if (styleValue != null && style[camelizedKey]) {
            element._hover.rawStyle[camelizedKey] = style[camelizedKey];
          }
        });
      }
      function updateStyle(element, styleValue) {
        Object.keys(styleValue).forEach((key) => {
          var value = styleValue[key];
          if (value != null) {
            element.style[key] = value;
          }
        });
      }
      function clearStyle(element) {
        Object.keys(element._hover.value).forEach((key) => {
          var value = element._hover.value[key];
          if (value != null) {
            element.style[key] = "";
          }
        });
      }
      function restoreStyle(element) {
        clearStyle(element);
        updateStyle(element, element._hover.rawStyle);
      }
      function createHover() {
        var {
          value
        } = this._hover;
        this._hover.hovering = true;
        if (isFunction$1(value)) {
          value(this._hover.hovering);
          return;
        }
        updateStyle(this, value);
      }
      function removeHover() {
        this._hover.hovering = false;
        if (isFunction$1(this._hover.value)) {
          this._hover.value(this._hover.hovering);
          return;
        }
        restoreStyle(this);
      }
      function mounted(element, binding) {
        var _element$_hover$hover, _element$_hover;
        var {
          arg,
          value
        } = binding;
        if (shouldDisabled(arg)) {
          return;
        }
        element._hover = {
          value,
          hovering: (_element$_hover$hover = (_element$_hover = element._hover) == null ? void 0 : _element$_hover.hovering) != null ? _element$_hover$hover : false,
          rawStyle: {}
        };
        updateRawStyle(element);
        element.addEventListener("mouseenter", createHover);
        element.addEventListener("mouseleave", removeHover);
      }
      function unmounted(element, binding) {
        if (shouldDisabled(binding.arg)) {
          return;
        }
        restoreStyle(element);
        element.removeEventListener("mouseenter", createHover);
        element.removeEventListener("mouseleave", removeHover);
      }
      function beforeUpdate(element, binding) {
        if (!element._hover) {
          return;
        }
        unmounted(element, binding);
      }
      function shouldUpdateStyle(element, binding) {
        return !isFunction$1(binding.value) && element._hover.hovering;
      }
      function updated(element, binding) {
        mounted(element, binding);
        if (shouldUpdateStyle(element, binding)) {
          updateStyle(element, binding.value);
        }
      }
      var Hover = {
        mounted,
        unmounted,
        beforeUpdate,
        updated,
        install(app2) {
          app2.directive("hover", this);
        }
      };
      const Hover$1 = Hover;
      function _extends$2() {
        _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends$2.apply(this, arguments);
      }
      function typeValidator$1(type2) {
        return ["default", "primary", "info", "success", "warning", "danger"].includes(type2);
      }
      function sizeValidator(size2) {
        return ["normal", "mini", "small", "large"].includes(size2);
      }
      function nativeTypeValidator(nativeType) {
        return ["button", "reset", "submit"].includes(nativeType);
      }
      var props$3 = {
        type: {
          type: String,
          validator: typeValidator$1
        },
        nativeType: {
          type: String,
          default: "button",
          validator: nativeTypeValidator
        },
        size: {
          type: String,
          validator: sizeValidator
        },
        loading: {
          type: Boolean,
          default: false
        },
        round: {
          type: Boolean,
          default: false
        },
        block: {
          type: Boolean,
          default: false
        },
        text: {
          type: Boolean,
          default: false
        },
        outline: {
          type: Boolean,
          default: false
        },
        disabled: {
          type: Boolean,
          default: false
        },
        ripple: {
          type: Boolean,
          default: true
        },
        color: {
          type: String
        },
        textColor: {
          type: String
        },
        elevation: {
          type: [Boolean, Number, String],
          default: true
        },
        autoLoading: {
          type: Boolean,
          default: false
        },
        loadingRadius: {
          type: [Number, String]
        },
        loadingType: pickProps(props$5, "type"),
        loadingSize: pickProps(props$5, "size"),
        loadingColor: _extends$2({}, pickProps(props$5, "color"), {
          default: "currentColor"
        }),
        onClick: defineListenerProp(),
        onTouchstart: defineListenerProp()
      };
      var BUTTON_GROUP_BIND_BUTTON_KEY = Symbol("BUTTON_GROUP_BIND_BUTTON_KEY");
      function useButtonGroup() {
        var {
          bindParent,
          parentProvider,
          index
        } = useParent(BUTTON_GROUP_BIND_BUTTON_KEY);
        return {
          index,
          buttonGroup: parentProvider,
          bindButtonGroup: bindParent
        };
      }
      var {
        n: n$4,
        classes: classes$3
      } = createNamespace("button");
      var _hoisted_1$Q = ["type", "disabled"];
      function __render__$2(_ctx, _cache) {
        var _component_var_loading = resolveComponent("var-loading");
        var _component_var_hover_overlay = resolveComponent("var-hover-overlay");
        var _directive_ripple = resolveDirective("ripple");
        var _directive_hover = resolveDirective("hover");
        return withDirectives((openBlock(), createElementBlock("button", {
          class: normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box"), _ctx.n("--" + _ctx.states.size), [_ctx.block, _ctx.n("$--flex") + " " + _ctx.n("--block"), _ctx.n("$--inline-flex")], [_ctx.disabled, _ctx.n("--disabled")], [_ctx.states.text, _ctx.n("--text-" + _ctx.states.type) + " " + _ctx.n("--text"), _ctx.n("--" + _ctx.states.type) + " " + _ctx.states.elevation], [_ctx.states.text && _ctx.disabled, _ctx.n("--text-disabled")], [_ctx.round, _ctx.n("--round")], [_ctx.states.outline, _ctx.n("--outline")])),
          style: normalizeStyle({
            color: _ctx.states.textColor,
            background: _ctx.states.color
          }),
          type: _ctx.nativeType,
          disabled: _ctx.disabled,
          onClick: _cache[0] || (_cache[0] = function() {
            return _ctx.handleClick && _ctx.handleClick(...arguments);
          }),
          onTouchstart: _cache[1] || (_cache[1] = function() {
            return _ctx.handleTouchstart && _ctx.handleTouchstart(...arguments);
          })
        }, [_ctx.loading || _ctx.pending ? (openBlock(), createBlock(_component_var_loading, {
          key: 0,
          class: normalizeClass(_ctx.n("loading")),
          "var-button-cover": "",
          color: _ctx.loadingColor,
          type: _ctx.loadingType,
          size: _ctx.loadingSize,
          radius: _ctx.loadingRadius
        }, null, 8, ["class", "color", "type", "size", "radius"])) : createCommentVNode("v-if", true), createBaseVNode(
          "div",
          {
            class: normalizeClass(_ctx.classes(_ctx.n("content"), [_ctx.loading || _ctx.pending, _ctx.n("--hidden")]))
          },
          [renderSlot(_ctx.$slots, "default")],
          2
          /* CLASS */
        ), createVNode(_component_var_hover_overlay, {
          hovering: _ctx.hovering
        }, null, 8, ["hovering"])], 46, _hoisted_1$Q)), [[_directive_ripple, {
          disabled: _ctx.disabled || !_ctx.ripple
        }], [_directive_hover, _ctx.handleHovering, "desktop"]]);
      }
      var __sfc__$2 = defineComponent({
        name: "VarButton",
        components: {
          VarLoading: Loading,
          VarHoverOverlay: HoverOverlay
        },
        directives: {
          Ripple: Ripple$1,
          Hover: Hover$1
        },
        props: props$3,
        setup(props2) {
          var pending = ref(false);
          var {
            buttonGroup
          } = useButtonGroup();
          var {
            hovering,
            handleHovering
          } = useHoverOverlay();
          var states = computed(() => {
            if (!buttonGroup) {
              return {
                elevation: formatElevation(props2.elevation, 2),
                type: props2.type != null ? props2.type : "default",
                size: props2.size != null ? props2.size : "normal",
                color: props2.color,
                text: props2.text,
                textColor: props2.textColor,
                outline: props2.outline
              };
            }
            var {
              type: type2,
              size: size2,
              color,
              textColor,
              mode
            } = buttonGroup;
            return {
              elevation: "",
              type: props2.type != null ? props2.type : type2.value,
              size: props2.size != null ? props2.size : size2.value,
              color: props2.color != null ? props2.color : color.value,
              textColor: props2.textColor != null ? props2.textColor : textColor.value,
              text: mode.value !== "normal",
              outline: mode.value === "outline"
            };
          });
          var attemptAutoLoading = (result) => {
            if (props2.autoLoading) {
              pending.value = true;
              result = isArray$2(result) ? result : [result];
              Promise.all(result).then(() => {
                pending.value = false;
              }).catch(() => {
                pending.value = false;
              });
            }
          };
          var handleClick = (e2) => {
            var {
              loading: loading2,
              disabled,
              onClick
            } = props2;
            if (!onClick || loading2 || disabled || pending.value) {
              return;
            }
            attemptAutoLoading(call(onClick, e2));
          };
          var handleTouchstart = (e2) => {
            var {
              loading: loading2,
              disabled,
              onTouchstart
            } = props2;
            if (!onTouchstart || loading2 || disabled || pending.value) {
              return;
            }
            attemptAutoLoading(call(onTouchstart, e2));
          };
          return {
            n: n$4,
            classes: classes$3,
            pending,
            states,
            hovering,
            handleHovering,
            handleClick,
            handleTouchstart
          };
        }
      });
      __sfc__$2.render = __render__$2;
      const Button$1 = __sfc__$2;
      withInstall$1(Button$1);
      function typeValidator(type2) {
        return ["default", "primary", "info", "success", "warning", "danger"].includes(type2);
      }
      function positionValidator$1(position) {
        return ["right-top", "right-bottom", "left-top", "left-bottom"].includes(position);
      }
      var props$2 = {
        type: {
          type: String,
          default: "default",
          validator: typeValidator
        },
        position: {
          type: String,
          default: "right-top",
          validator: positionValidator$1
        },
        hidden: {
          type: Boolean,
          default: false
        },
        value: {
          type: [String, Number],
          default: 0
        },
        maxValue: {
          type: [String, Number]
        },
        dot: {
          type: Boolean,
          default: false
        },
        icon: {
          type: String
        },
        color: {
          type: String
        }
      };
      var {
        n: n$3,
        classes: classes$2
      } = createNamespace("badge");
      function __render__$1(_ctx, _cache) {
        var _component_var_icon = resolveComponent("var-icon");
        return openBlock(), createElementBlock(
          "div",
          {
            class: normalizeClass(_ctx.classes(_ctx.n(), _ctx.n("$--box")))
          },
          [renderSlot(_ctx.$slots, "default"), createVNode(Transition, {
            name: _ctx.n("$-badge-fade"),
            persisted: ""
          }, {
            default: withCtx(() => [withDirectives(createBaseVNode(
              "span",
              mergeProps({
                class: _ctx.classes(_ctx.n("content"), _ctx.n("--" + _ctx.type), [_ctx.$slots.default, _ctx.n("--" + _ctx.position)], [_ctx.dot, _ctx.n("--dot")], [_ctx.icon, _ctx.n("--icon")]),
                style: {
                  background: _ctx.color
                }
              }, _ctx.$attrs),
              [_ctx.icon ? (openBlock(), createBlock(_component_var_icon, {
                key: 0,
                class: normalizeClass(_ctx.n("icon")),
                "var-badge-cover": "",
                name: _ctx.icon
              }, null, 8, ["class", "name"])) : createCommentVNode("v-if", true), renderSlot(_ctx.$slots, "value", {}, () => [!_ctx.icon && !_ctx.dot ? (openBlock(), createElementBlock(
                "span",
                {
                  key: 0,
                  class: normalizeClass(_ctx.n("value"))
                },
                toDisplayString(_ctx.value),
                3
                /* TEXT, CLASS */
              )) : createCommentVNode("v-if", true)])],
              16
              /* FULL_PROPS */
            ), [[vShow, !_ctx.hidden]])]),
            _: 3
            /* FORWARDED */
          }, 8, ["name"])],
          2
          /* CLASS */
        );
      }
      var __sfc__$1 = defineComponent({
        name: "VarBadge",
        components: {
          VarIcon: Icon$1
        },
        inheritAttrs: false,
        props: props$2,
        setup(props2) {
          var value = computed(() => {
            var {
              value: value2,
              maxValue
            } = props2;
            return value2 != null && maxValue != null && toNumber$1(value2) > toNumber$1(maxValue) ? maxValue + "+" : value2;
          });
          return {
            n: n$3,
            classes: classes$2,
            value
          };
        }
      });
      __sfc__$1.render = __render__$1;
      const Badge$1 = __sfc__$1;
      withInstall$1(Badge$1);
      var props$1 = {
        direction: {
          type: String,
          default: "xy"
        },
        attraction: {
          type: String
        },
        disabled: {
          type: Boolean,
          default: false
        },
        boundary: {
          type: Object,
          default: () => ({
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
          })
        },
        zIndex: {
          type: [Number, String],
          default: 90
        },
        teleport: {
          type: [String, Object],
          default: "body"
        }
      };
      function _extends$1() {
        _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends$1.apply(this, arguments);
      }
      function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve2(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn2) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve2, reject) {
            var gen = fn2.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var {
        n: n$2,
        classes: classes$1
      } = createNamespace("drag");
      function __render__(_ctx, _cache) {
        return openBlock(), createBlock(Teleport, {
          to: _ctx.teleport,
          disabled: _ctx.teleportDisabled
        }, [createBaseVNode(
          "div",
          mergeProps({
            ref: "drag",
            class: _ctx.classes(_ctx.n(), _ctx.n("$--box"), [_ctx.enableTransition, _ctx.n("--transition")]),
            style: {
              "z-index": _ctx.zIndex
            },
            onTouchstart: _cache[0] || (_cache[0] = function() {
              return _ctx.handleTouchstart && _ctx.handleTouchstart(...arguments);
            }),
            onTouchmove: _cache[1] || (_cache[1] = function() {
              return _ctx.handleTouchmove && _ctx.handleTouchmove(...arguments);
            }),
            onTouchend: _cache[2] || (_cache[2] = function() {
              return _ctx.handleTouchend && _ctx.handleTouchend(...arguments);
            }),
            onTouchcancel: _cache[3] || (_cache[3] = function() {
              return _ctx.handleTouchend && _ctx.handleTouchend(...arguments);
            })
          }, _ctx.getAttrs()),
          [renderSlot(_ctx.$slots, "default")],
          16
          /* FULL_PROPS */
        )], 8, ["to", "disabled"]);
      }
      var __sfc__ = defineComponent({
        name: "VarDrag",
        inheritAttrs: false,
        props: props$1,
        setup(props2, _ref) {
          var {
            attrs
          } = _ref;
          var drag2 = ref(null);
          var x2 = ref(0);
          var y2 = ref(0);
          var boundary = reactive({
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
          });
          var dragged = ref(false);
          var enableTransition = ref(false);
          var dragging = ref(false);
          var {
            disabled: teleportDisabled
          } = useTeleport();
          var touching = false;
          var prevX = 0;
          var prevY = 0;
          var draggingRunner = null;
          var handleTouchstart = (event) => {
            if (props2.disabled) {
              return;
            }
            draggingRunner && window.clearTimeout(draggingRunner);
            var {
              clientX,
              clientY
            } = event.touches[0];
            saveXY();
            prevX = clientX;
            prevY = clientY;
            touching = true;
            dragging.value = false;
          };
          var handleTouchmove = /* @__PURE__ */ function() {
            var _ref2 = _asyncToGenerator(function* (event) {
              if (!touching || props2.disabled) {
                return;
              }
              event.preventDefault();
              enableTransition.value = false;
              dragged.value = true;
              dragging.value = true;
              var {
                clientX,
                clientY
              } = event.touches[0];
              var deltaX = clientX - prevX;
              var deltaY = clientY - prevY;
              prevX = clientX;
              prevY = clientY;
              if (props2.direction.includes("x")) {
                x2.value += deltaX;
              }
              if (props2.direction.includes("y")) {
                y2.value += deltaY;
              }
              clampToBoundary();
            });
            return function handleTouchmove2(_x) {
              return _ref2.apply(this, arguments);
            };
          }();
          var handleTouchend = () => {
            if (props2.disabled) {
              return;
            }
            touching = false;
            enableTransition.value = true;
            attract();
            draggingRunner = window.setTimeout(() => {
              dragging.value = false;
            });
          };
          var saveXY = () => {
            var {
              left: left2,
              top
            } = getOffset();
            x2.value = left2;
            y2.value = top;
          };
          var getOffset = () => {
            var dragRect = getRect(drag2.value);
            var windowRect = getRect(window);
            var top = dragRect.top - windowRect.top;
            var bottom = windowRect.bottom - dragRect.bottom;
            var left2 = dragRect.left - windowRect.left;
            var right2 = windowRect.right - dragRect.right;
            var {
              width,
              height
            } = dragRect;
            var {
              width: windowWidth,
              height: windowHeight
            } = windowRect;
            return {
              top,
              bottom,
              left: left2,
              right: right2,
              width,
              height,
              halfWidth: width / 2,
              halfHeight: height / 2,
              windowWidth,
              windowHeight
            };
          };
          var getRange = () => {
            var offset = getOffset();
            var x1 = boundary.left;
            var x22 = offset.windowWidth - boundary.right - offset.width;
            var y1 = boundary.top;
            var y22 = offset.windowHeight - boundary.bottom - offset.height;
            return {
              minX: x1,
              minY: y1,
              // fallback the drag element overflows boundary
              maxX: x1 < x22 ? x22 : x1,
              maxY: y1 < y22 ? y22 : y1
            };
          };
          var attract = () => {
            if (props2.attraction == null) {
              return;
            }
            var {
              halfWidth,
              halfHeight,
              top,
              bottom,
              left: left2,
              right: right2
            } = getOffset();
            var {
              minX,
              minY,
              maxX,
              maxY
            } = getRange();
            var leftDistance = left2 + halfWidth - boundary.left;
            var rightDistance = right2 + halfWidth - boundary.right;
            var topDistance = top + halfHeight - boundary.top;
            var bottomDistance = bottom + halfHeight - boundary.bottom;
            var nearLeft = leftDistance <= rightDistance;
            var nearTop = topDistance <= bottomDistance;
            if (props2.attraction.includes("x")) {
              x2.value = nearLeft ? minX : maxX;
            }
            if (props2.attraction.includes("y")) {
              y2.value = nearTop ? minY : maxY;
            }
          };
          var clampToBoundary = () => {
            var {
              minX,
              minY,
              maxX,
              maxY
            } = getRange();
            x2.value = clamp(x2.value, minX, maxX);
            y2.value = clamp(y2.value, minY, maxY);
          };
          var toPxBoundary = () => {
            var {
              top = 0,
              bottom = 0,
              left: left2 = 0,
              right: right2 = 0
            } = props2.boundary;
            boundary.top = toPxNum(top);
            boundary.bottom = toPxNum(bottom);
            boundary.left = toPxNum(left2);
            boundary.right = toPxNum(right2);
          };
          var getAttrs = () => {
            var _ref3;
            var style = (_ref3 = attrs.style) != null ? _ref3 : {};
            return _extends$1({}, attrs, {
              style: _extends$1({}, style, {
                // when the drag element is dragged for the first time, the inset should be cleared to avoid affecting translateX and translateY.
                top: dragged.value ? 0 : style.top,
                left: dragged.value ? 0 : style.left,
                right: dragged.value ? "auto" : style.right,
                bottom: dragged.value ? "auto" : style.bottom,
                transform: dragged.value ? "translate(" + x2.value + "px, " + y2.value + "px)" : style.transform
              })
            });
          };
          var resize = () => {
            if (!dragged.value) {
              return;
            }
            saveXY();
            clampToBoundary();
          };
          var reset = () => {
            enableTransition.value = false;
            dragged.value = false;
            dragging.value = false;
            x2.value = 0;
            y2.value = 0;
            touching = false;
            prevX = 0;
            prevY = 0;
          };
          watch(() => props2.boundary, toPxBoundary);
          onWindowResize(resize);
          onSmartMounted(() => {
            toPxBoundary();
            resize();
          });
          return {
            drag: drag2,
            x: x2,
            y: y2,
            enableTransition,
            dragging,
            teleportDisabled,
            n: n$2,
            classes: classes$1,
            getAttrs,
            handleTouchstart,
            handleTouchmove,
            handleTouchend,
            resize,
            reset
          };
        }
      });
      __sfc__.render = __render__;
      const Drag = __sfc__;
      withInstall$1(Drag);
      function positionValidator(position) {
        return ["left-top", "right-top", "left-bottom", "right-bottom"].includes(position);
      }
      function directionValidator(direction2) {
        return ["top", "right", "bottom", "left"].includes(direction2);
      }
      function triggerValidator(trigger2) {
        return ["click", "hover"].includes(trigger2);
      }
      var props = {
        active: {
          type: Boolean,
          default: false
        },
        show: {
          type: Boolean,
          default: true
        },
        drag: {
          type: Boolean,
          default: false
        },
        type: {
          type: String,
          default: "primary",
          validator: typeValidator$1
        },
        position: {
          type: String,
          default: "right-bottom",
          validator: positionValidator
        },
        direction: {
          type: String,
          default: "top",
          validator: directionValidator
        },
        trigger: {
          type: String,
          default: "click",
          validator: triggerValidator
        },
        disabled: {
          type: Boolean,
          default: false
        },
        color: {
          type: String
        },
        inactiveIcon: {
          type: String,
          default: "plus"
        },
        activeIcon: {
          type: String,
          default: "window-close"
        },
        inactiveIconSize: {
          type: [Number, String]
        },
        activeIconSize: {
          type: [Number, String]
        },
        fixed: {
          type: Boolean,
          default: true
        },
        zIndex: {
          type: [Number, String],
          default: 90
        },
        top: {
          type: [Number, String]
        },
        bottom: {
          type: [Number, String]
        },
        left: {
          type: [Number, String]
        },
        right: {
          type: [Number, String]
        },
        elevation: {
          type: [Boolean, Number, String],
          default: true
        },
        safeArea: {
          type: Boolean,
          default: false
        },
        teleport: {
          type: [String, Object],
          default: "body"
        },
        onClick: defineListenerProp(),
        onOpen: defineListenerProp(),
        onOpened: defineListenerProp(),
        onClose: defineListenerProp(),
        onClosed: defineListenerProp(),
        "onUpdate:active": defineListenerProp()
      };
      function _isSlot(s2) {
        return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
      }
      var {
        classes,
        n: n$1
      } = createNamespace("fab");
      const Fab = defineComponent({
        name: "VarFab",
        inheritAttrs: false,
        props,
        setup(props2, _ref) {
          var {
            slots,
            attrs
          } = _ref;
          var isActive = useVModel(props2, "active");
          var host = ref(null);
          var dragRef = ref(null);
          var handleClick = (e2, value, childrenLength) => {
            var _dragRef$value;
            e2.stopPropagation();
            if (props2.trigger !== "click" || props2.disabled) {
              return;
            }
            if (childrenLength === 0) {
              call(props2.onClick, isActive.value, e2);
              return;
            }
            if ((_dragRef$value = dragRef.value) != null && _dragRef$value.dragging) {
              return;
            }
            isActive.value = value;
            call(props2.onClick, isActive.value, e2);
            call(isActive.value ? props2.onOpen : props2.onClose);
          };
          var handleMouse = (value, childrenLength) => {
            if (props2.trigger !== "hover" || props2.disabled || childrenLength === 0) {
              return;
            }
            isActive.value = value;
            call(isActive.value ? props2.onOpen : props2.onClose);
          };
          var handleClickOutside = () => {
            if (props2.trigger !== "click" || props2.disabled) {
              return;
            }
            if (isActive.value !== false) {
              isActive.value = false;
              call(props2.onClose);
            }
          };
          var renderTrigger = () => {
            if (slots.trigger) {
              return props2.show ? slots.trigger({
                active: isActive.value
              }) : null;
            }
            return withDirectives(createVNode(Button$1, {
              "var-fab-cover": true,
              "class": n$1("trigger"),
              "type": props2.type,
              "color": props2.color,
              "disabled": props2.disabled,
              "elevation": props2.elevation,
              "round": true
            }, {
              default: () => [createVNode(Icon$1, {
                "var-fab-cover": true,
                "class": classes([isActive.value, n$1("trigger-active-icon"), n$1("trigger-inactive-icon")]),
                "name": isActive.value ? props2.activeIcon : props2.inactiveIcon,
                "size": isActive.value ? props2.inactiveIconSize : props2.activeIconSize,
                "transition": 200,
                "animationClass": n$1("--trigger-icon-animation")
              }, null)]
            }), [[vShow, props2.show]]);
          };
          watch(() => props2.trigger, () => {
            isActive.value = false;
          });
          watch(() => props2.disabled, () => {
            isActive.value = false;
          });
          watch(() => [props2.position, props2.fixed, props2.top, props2.bottom, props2.left, props2.right], () => {
            var _dragRef$value2;
            (_dragRef$value2 = dragRef.value) == null ? void 0 : _dragRef$value2.reset();
          });
          useClickOutside(host, "click", handleClickOutside);
          return () => {
            var _slot;
            var _call;
            var children = flatFragment((_call = call(slots.default)) != null ? _call : []);
            return createVNode(Drag, mergeProps({
              "ref": dragRef,
              "class": classes(n$1("--position-" + props2.position), [!props2.fixed, n$1("--absolute")]),
              "style": {
                top: toSizeUnit(props2.top),
                bottom: toSizeUnit(props2.bottom),
                left: toSizeUnit(props2.left),
                right: toSizeUnit(props2.right)
              },
              "zIndex": props2.zIndex,
              "teleport": props2.teleport,
              "disabled": props2.disabled || !props2.drag || !props2.fixed
            }, attrs), {
              default: () => [createVNode("div", {
                "class": classes(n$1(), n$1("--direction-" + props2.direction), [props2.safeArea, n$1("--safe-area")]),
                "ref": host,
                "onClick": (e2) => handleClick(e2, !isActive.value, children.length),
                "onMouseleave": () => handleMouse(false, children.length),
                "onMouseenter": () => handleMouse(true, children.length)
              }, [createVNode(Transition, {
                "name": n$1("--active-transition")
              }, _isSlot(_slot = renderTrigger()) ? _slot : {
                default: () => [_slot]
              }), createVNode(Transition, {
                "name": n$1("--actions-transition-" + props2.direction),
                "onAfterEnter": props2.onOpened,
                "onAfterLeave": props2.onClosed
              }, {
                default: () => [withDirectives(createVNode("div", {
                  "class": n$1("actions"),
                  "onClick": (e2) => e2.stopPropagation()
                }, [children.map((child) => createVNode("div", {
                  "class": n$1("action")
                }, [child]))]), [[vShow, props2.show && isActive.value && children.length]])]
              })])]
            });
          };
        }
      });
      withInstall$1(Fab);
      const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
      const isVisible = (element) => {
        const computed2 = getComputedStyle(element);
        return computed2.position === "fixed" ? false : element.offsetParent !== null;
      };
      const obtainAllFocusableElements$1 = (element) => {
        return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter((item) => isFocusable(item) && isVisible(item));
      };
      const isFocusable = (element) => {
        if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
          return true;
        }
        if (element.disabled) {
          return false;
        }
        switch (element.nodeName) {
          case "A": {
            return !!element.href && element.rel !== "ignore";
          }
          case "INPUT": {
            return !(element.type === "hidden" || element.type === "file");
          }
          case "BUTTON":
          case "SELECT":
          case "TEXTAREA": {
            return true;
          }
          default: {
            return false;
          }
        }
      };
      const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
        const handleEvent = (event) => {
          const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
          if (checkForDefaultPrevented === false || !shouldPrevent) {
            return oursHandler == null ? void 0 : oursHandler(event);
          }
        };
        return handleEvent;
      };
      const whenMouse = (handler) => {
        return (e2) => e2.pointerType === "mouse" ? handler(e2) : void 0;
      };
      var __defProp$9$1 = Object.defineProperty;
      var __defProps$6$1 = Object.defineProperties;
      var __getOwnPropDescs$6$1 = Object.getOwnPropertyDescriptors;
      var __getOwnPropSymbols$b$1 = Object.getOwnPropertySymbols;
      var __hasOwnProp$b$1 = Object.prototype.hasOwnProperty;
      var __propIsEnum$b$1 = Object.prototype.propertyIsEnumerable;
      var __defNormalProp$9$1 = (obj, key, value) => key in obj ? __defProp$9$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues$9$1 = (a2, b2) => {
        for (var prop in b2 || (b2 = {}))
          if (__hasOwnProp$b$1.call(b2, prop))
            __defNormalProp$9$1(a2, prop, b2[prop]);
        if (__getOwnPropSymbols$b$1)
          for (var prop of __getOwnPropSymbols$b$1(b2)) {
            if (__propIsEnum$b$1.call(b2, prop))
              __defNormalProp$9$1(a2, prop, b2[prop]);
          }
        return a2;
      };
      var __spreadProps$6$1 = (a2, b2) => __defProps$6$1(a2, __getOwnPropDescs$6$1(b2));
      function computedEager(fn2, options) {
        var _a2;
        const result = shallowRef();
        watchEffect(() => {
          result.value = fn2();
        }, __spreadProps$6$1(__spreadValues$9$1({}, options), {
          flush: (_a2 = options == null ? void 0 : options.flush) != null ? _a2 : "sync"
        }));
        return readonly(result);
      }
      var _a;
      const isClient$1 = typeof window !== "undefined";
      const isString = (val) => typeof val === "string";
      const noop$1 = () => {
      };
      const isIOS = isClient$1 && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
      function resolveUnref(r2) {
        return typeof r2 === "function" ? r2() : unref(r2);
      }
      function createFilterWrapper(filter, fn2) {
        function wrapper(...args) {
          return new Promise((resolve2, reject) => {
            Promise.resolve(filter(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve2).catch(reject);
          });
        }
        return wrapper;
      }
      function debounceFilter(ms, options = {}) {
        let timer;
        let maxTimer;
        let lastRejector = noop$1;
        const _clearTimeout = (timer2) => {
          clearTimeout(timer2);
          lastRejector();
          lastRejector = noop$1;
        };
        const filter = (invoke) => {
          const duration = resolveUnref(ms);
          const maxDuration = resolveUnref(options.maxWait);
          if (timer)
            _clearTimeout(timer);
          if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
            if (maxTimer) {
              _clearTimeout(maxTimer);
              maxTimer = null;
            }
            return Promise.resolve(invoke());
          }
          return new Promise((resolve2, reject) => {
            lastRejector = options.rejectOnCancel ? reject : resolve2;
            if (maxDuration && !maxTimer) {
              maxTimer = setTimeout(() => {
                if (timer)
                  _clearTimeout(timer);
                maxTimer = null;
                resolve2(invoke());
              }, maxDuration);
            }
            timer = setTimeout(() => {
              if (maxTimer)
                _clearTimeout(maxTimer);
              maxTimer = null;
              resolve2(invoke());
            }, duration);
          });
        };
        return filter;
      }
      function throttleFilter(ms, trailing = true, leading = true, rejectOnCancel = false) {
        let lastExec = 0;
        let timer;
        let isLeading = true;
        let lastRejector = noop$1;
        let lastValue;
        const clear2 = () => {
          if (timer) {
            clearTimeout(timer);
            timer = void 0;
            lastRejector();
            lastRejector = noop$1;
          }
        };
        const filter = (_invoke) => {
          const duration = resolveUnref(ms);
          const elapsed = Date.now() - lastExec;
          const invoke = () => {
            return lastValue = _invoke();
          };
          clear2();
          if (duration <= 0) {
            lastExec = Date.now();
            return invoke();
          }
          if (elapsed > duration && (leading || !isLeading)) {
            lastExec = Date.now();
            invoke();
          } else if (trailing) {
            lastValue = new Promise((resolve2, reject) => {
              lastRejector = rejectOnCancel ? reject : resolve2;
              timer = setTimeout(() => {
                lastExec = Date.now();
                isLeading = true;
                resolve2(invoke());
                clear2();
              }, Math.max(0, duration - elapsed));
            });
          }
          if (!leading && !timer)
            timer = setTimeout(() => isLeading = true, duration);
          isLeading = false;
          return lastValue;
        };
        return filter;
      }
      function identity$1(arg) {
        return arg;
      }
      function tryOnScopeDispose$1(fn2) {
        if (getCurrentScope()) {
          onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      function useDebounceFn(fn2, ms = 200, options = {}) {
        return createFilterWrapper(debounceFilter(ms, options), fn2);
      }
      function refDebounced(value, ms = 200, options = {}) {
        const debounced = ref(value.value);
        const updater = useDebounceFn(() => {
          debounced.value = value.value;
        }, ms, options);
        watch(value, () => updater());
        return debounced;
      }
      function useThrottleFn(fn2, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {
        return createFilterWrapper(throttleFilter(ms, trailing, leading, rejectOnCancel), fn2);
      }
      function tryOnMounted$1(fn2, sync = true) {
        if (getCurrentInstance())
          onMounted(fn2);
        else if (sync)
          fn2();
        else
          nextTick(fn2);
      }
      function useTimeoutFn$1(cb, interval, options = {}) {
        const {
          immediate = true
        } = options;
        const isPending = ref(false);
        let timer = null;
        function clear2() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function stop() {
          isPending.value = false;
          clear2();
        }
        function start(...args) {
          clear2();
          isPending.value = true;
          timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            cb(...args);
          }, resolveUnref(interval));
        }
        if (immediate) {
          isPending.value = true;
          if (isClient$1)
            start();
        }
        tryOnScopeDispose$1(stop);
        return {
          isPending: readonly(isPending),
          start,
          stop
        };
      }
      function unrefElement$1(elRef) {
        var _a2;
        const plain = resolveUnref(elRef);
        return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
      }
      const defaultWindow$1 = isClient$1 ? window : void 0;
      const defaultDocument = isClient$1 ? window.document : void 0;
      function useEventListener$1(...args) {
        let target;
        let events;
        let listeners;
        let options;
        if (isString(args[0]) || Array.isArray(args[0])) {
          [events, listeners, options] = args;
          target = defaultWindow$1;
        } else {
          [target, events, listeners, options] = args;
        }
        if (!target)
          return noop$1;
        if (!Array.isArray(events))
          events = [events];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = watch(() => [unrefElement$1(target), resolveUnref(options)], ([el, options2]) => {
          cleanup();
          if (!el)
            return;
          cleanups.push(...events.flatMap((event) => {
            return listeners.map((listener) => register(el, event, listener, options2));
          }));
        }, { immediate: true, flush: "post" });
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose$1(stop);
        return stop;
      }
      let _iOSWorkaround = false;
      function onClickOutside(target, handler, options = {}) {
        const { window: window2 = defaultWindow$1, ignore = [], capture = true, detectIframe = false } = options;
        if (!window2)
          return;
        if (isIOS && !_iOSWorkaround) {
          _iOSWorkaround = true;
          Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop$1));
        }
        let shouldListen = true;
        const shouldIgnore = (event) => {
          return ignore.some((target2) => {
            if (typeof target2 === "string") {
              return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
            } else {
              const el = unrefElement$1(target2);
              return el && (event.target === el || event.composedPath().includes(el));
            }
          });
        };
        const listener = (event) => {
          const el = unrefElement$1(target);
          if (!el || el === event.target || event.composedPath().includes(el))
            return;
          if (event.detail === 0)
            shouldListen = !shouldIgnore(event);
          if (!shouldListen) {
            shouldListen = true;
            return;
          }
          handler(event);
        };
        const cleanup = [
          useEventListener$1(window2, "click", listener, { passive: true, capture }),
          useEventListener$1(window2, "pointerdown", (e2) => {
            const el = unrefElement$1(target);
            if (el)
              shouldListen = !e2.composedPath().includes(el) && !shouldIgnore(e2);
          }, { passive: true }),
          detectIframe && useEventListener$1(window2, "blur", (event) => {
            var _a2;
            const el = unrefElement$1(target);
            if (((_a2 = window2.document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
              handler(event);
          })
        ].filter(Boolean);
        const stop = () => cleanup.forEach((fn2) => fn2());
        return stop;
      }
      function useSupported$1(callback, sync = false) {
        const isSupported = ref();
        const update = () => isSupported.value = Boolean(callback());
        update();
        tryOnMounted$1(update, sync);
        return isSupported;
      }
      const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      const globalKey = "__vueuse_ssr_handlers__";
      _global[globalKey] = _global[globalKey] || {};
      function useDocumentVisibility({ document: document2 = defaultDocument } = {}) {
        if (!document2)
          return ref("visible");
        const visibility = ref(document2.visibilityState);
        useEventListener$1(document2, "visibilitychange", () => {
          visibility.value = document2.visibilityState;
        });
        return visibility;
      }
      var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
      var __hasOwnProp$g = Object.prototype.hasOwnProperty;
      var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
      var __objRest$2 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$g)
          for (var prop of __getOwnPropSymbols$g(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useResizeObserver(target, callback, options = {}) {
        const _a2 = options, { window: window2 = defaultWindow$1 } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
        let observer;
        const isSupported = useSupported$1(() => window2 && "ResizeObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = watch(() => unrefElement$1(target), (el) => {
          cleanup();
          if (isSupported.value && window2 && el) {
            observer = new ResizeObserver(callback);
            observer.observe(el, observerOptions);
          }
        }, { immediate: true, flush: "post" });
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose$1(stop);
        return {
          isSupported,
          stop
        };
      }
      var SwipeDirection;
      (function(SwipeDirection2) {
        SwipeDirection2["UP"] = "UP";
        SwipeDirection2["RIGHT"] = "RIGHT";
        SwipeDirection2["DOWN"] = "DOWN";
        SwipeDirection2["LEFT"] = "LEFT";
        SwipeDirection2["NONE"] = "NONE";
      })(SwipeDirection || (SwipeDirection = {}));
      var __defProp2 = Object.defineProperty;
      var __getOwnPropSymbols = Object.getOwnPropertySymbols;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __propIsEnum = Object.prototype.propertyIsEnumerable;
      var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues = (a2, b2) => {
        for (var prop in b2 || (b2 = {}))
          if (__hasOwnProp.call(b2, prop))
            __defNormalProp2(a2, prop, b2[prop]);
        if (__getOwnPropSymbols)
          for (var prop of __getOwnPropSymbols(b2)) {
            if (__propIsEnum.call(b2, prop))
              __defNormalProp2(a2, prop, b2[prop]);
          }
        return a2;
      };
      const _TransitionPresets = {
        easeInSine: [0.12, 0, 0.39, 0],
        easeOutSine: [0.61, 1, 0.88, 1],
        easeInOutSine: [0.37, 0, 0.63, 1],
        easeInQuad: [0.11, 0, 0.5, 0],
        easeOutQuad: [0.5, 1, 0.89, 1],
        easeInOutQuad: [0.45, 0, 0.55, 1],
        easeInCubic: [0.32, 0, 0.67, 0],
        easeOutCubic: [0.33, 1, 0.68, 1],
        easeInOutCubic: [0.65, 0, 0.35, 1],
        easeInQuart: [0.5, 0, 0.75, 0],
        easeOutQuart: [0.25, 1, 0.5, 1],
        easeInOutQuart: [0.76, 0, 0.24, 1],
        easeInQuint: [0.64, 0, 0.78, 0],
        easeOutQuint: [0.22, 1, 0.36, 1],
        easeInOutQuint: [0.83, 0, 0.17, 1],
        easeInExpo: [0.7, 0, 0.84, 0],
        easeOutExpo: [0.16, 1, 0.3, 1],
        easeInOutExpo: [0.87, 0, 0.13, 1],
        easeInCirc: [0.55, 0, 1, 0.45],
        easeOutCirc: [0, 0.55, 0.45, 1],
        easeInOutCirc: [0.85, 0, 0.15, 1],
        easeInBack: [0.36, 0, 0.66, -0.56],
        easeOutBack: [0.34, 1.56, 0.64, 1],
        easeInOutBack: [0.68, -0.6, 0.32, 1.6]
      };
      __spreadValues({
        linear: identity$1
      }, _TransitionPresets);
      function useWindowFocus({ window: window2 = defaultWindow$1 } = {}) {
        if (!window2)
          return ref(false);
        const focused = ref(window2.document.hasFocus());
        useEventListener$1(window2, "blur", () => {
          focused.value = false;
        });
        useEventListener$1(window2, "focus", () => {
          focused.value = true;
        });
        return focused;
      }
      const isFirefox = () => isClient$1 && /firefox/i.test(window.navigator.userAgent);
      const isInContainer = (el, container) => {
        if (!isClient$1 || !el || !container)
          return false;
        const elRect = el.getBoundingClientRect();
        let containerRect;
        if (container instanceof Element) {
          containerRect = container.getBoundingClientRect();
        } else {
          containerRect = {
            top: 0,
            right: window.innerWidth,
            bottom: window.innerHeight,
            left: 0
          };
        }
        return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;
      };
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      const freeGlobal$1 = freeGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal$1 || freeSelf || Function("return this")();
      const root$1 = root;
      var Symbol$1 = root$1.Symbol;
      const Symbol$2 = Symbol$1;
      var objectProto$e = Object.prototype;
      var hasOwnProperty$b = objectProto$e.hasOwnProperty;
      var nativeObjectToString$1 = objectProto$e.toString;
      var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e2) {
        }
        var result = nativeObjectToString$1.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result;
      }
      var objectProto$d = Object.prototype;
      var nativeObjectToString = objectProto$d.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var symbolTag$3 = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
      }
      function arrayMap(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array2[index], index, array2);
        }
        return result;
      }
      var isArray = Array.isArray;
      const isArray$1 = isArray;
      var INFINITY$1 = 1 / 0;
      var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray$1(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
      }
      var reWhitespace = /\s/;
      function trimmedEndIndex(string2) {
        var index = string2.length;
        while (index-- && reWhitespace.test(string2.charAt(index))) {
        }
        return index;
      }
      var reTrimStart = /^\s+/;
      function baseTrim(string2) {
        return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
      }
      function isObject(value) {
        var type2 = typeof value;
        return value != null && (type2 == "object" || type2 == "function");
      }
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function identity(value) {
        return value;
      }
      var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
      }
      var coreJsData = root$1["__core-js_shared__"];
      const coreJsData$1 = coreJsData;
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var funcProto$1 = Function.prototype;
      var funcToString$1 = funcProto$1.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString$1.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype, objectProto$c = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty$a = objectProto$c.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern2 = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern2.test(toSource(value));
      }
      function getValue$1(object2, key) {
        return object2 == null ? void 0 : object2[key];
      }
      function getNative(object2, key) {
        var value = getValue$1(object2, key);
        return baseIsNative(value) ? value : void 0;
      }
      var WeakMap$1 = getNative(root$1, "WeakMap");
      const WeakMap$2 = WeakMap$1;
      var objectCreate = Object.create;
      var baseCreate = function() {
        function object2() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object2.prototype = proto;
          var result = new object2();
          object2.prototype = void 0;
          return result;
        };
      }();
      const baseCreate$1 = baseCreate;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function copyArray(source, array2) {
        var index = -1, length = source.length;
        array2 || (array2 = Array(length));
        while (++index < length) {
          array2[index] = source[index];
        }
        return array2;
      }
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      const defineProperty$1 = defineProperty;
      var baseSetToString = !defineProperty$1 ? identity : function(func, string2) {
        return defineProperty$1(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string2),
          "writable": true
        });
      };
      const baseSetToString$1 = baseSetToString;
      var setToString = shortOut(baseSetToString$1);
      const setToString$1 = setToString;
      function arrayEach(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (iteratee(array2[index], index, array2) === false) {
            break;
          }
        }
        return array2;
      }
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type2 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER$1 : length;
        return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function baseAssignValue(object2, key, value) {
        if (key == "__proto__" && defineProperty$1) {
          defineProperty$1(object2, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object2[key] = value;
        }
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var objectProto$b = Object.prototype;
      var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
      function assignValue(object2, key, value) {
        var objValue = object2[key];
        if (!(hasOwnProperty$9.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
          baseAssignValue(object2, key, value);
        }
      }
      function copyObject(source, props2, object2, customizer) {
        var isNew = !object2;
        object2 || (object2 = {});
        var index = -1, length = props2.length;
        while (++index < length) {
          var key = props2[index];
          var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object2, key, newValue);
          } else {
            assignValue(object2, key, newValue);
          }
        }
        return object2;
      }
      var nativeMax$1 = Math.max;
      function overRest(func, start, transform) {
        start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array2 = Array(length);
          while (++index < length) {
            array2[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array2);
          return apply(func, this, otherArgs);
        };
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      var objectProto$a = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
        return value === proto;
      }
      function baseTimes(n2, iteratee) {
        var index = -1, result = Array(n2);
        while (++index < n2) {
          result[index] = iteratee(index);
        }
        return result;
      }
      var argsTag$3 = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag$3;
      }
      var objectProto$9 = Object.prototype;
      var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
      var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
      };
      const isArguments$1 = isArguments;
      function stubFalse() {
        return false;
      }
      var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
      var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;
      var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      const isBuffer$1 = isBuffer;
      var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
      var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
      typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var freeProcess = moduleExports$1 && freeGlobal$1.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      const nodeUtil$1 = nodeUtil;
      var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      const isTypedArray$1 = isTypedArray;
      var objectProto$8 = Object.prototype;
      var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var nativeKeys = overArg(Object.keys, Object);
      const nativeKeys$1 = nativeKeys;
      var objectProto$7 = Object.prototype;
      var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
      function baseKeys(object2) {
        if (!isPrototype(object2)) {
          return nativeKeys$1(object2);
        }
        var result = [];
        for (var key in Object(object2)) {
          if (hasOwnProperty$6.call(object2, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function keys(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
      }
      function nativeKeysIn(object2) {
        var result = [];
        if (object2 != null) {
          for (var key in Object(object2)) {
            result.push(key);
          }
        }
        return result;
      }
      var objectProto$6 = Object.prototype;
      var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
      function baseKeysIn(object2) {
        if (!isObject(object2)) {
          return nativeKeysIn(object2);
        }
        var isProto = isPrototype(object2), result = [];
        for (var key in object2) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty$5.call(object2, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function keysIn(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
      }
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
      function isKey(value, object2) {
        if (isArray$1(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
      }
      var nativeCreate = getNative(Object, "create");
      const nativeCreate$1 = nativeCreate;
      function hashClear() {
        this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
      var objectProto$5 = Object.prototype;
      var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate$1) {
          var result = data[key];
          return result === HASH_UNDEFINED$2 ? void 0 : result;
        }
        return hasOwnProperty$4.call(data, key) ? data[key] : void 0;
      }
      var objectProto$4 = Object.prototype;
      var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$3.call(data, key);
      }
      var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
        return this;
      }
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function assocIndexOf(array2, key) {
        var length = array2.length;
        while (length--) {
          if (eq(array2[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      var Map$1 = getNative(root$1, "Map");
      const Map$2 = Map$1;
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map$2 || ListCache)(),
          "string": new Hash()
        };
      }
      function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      var FUNC_ERROR_TEXT$2 = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$2);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache2.set(key, result) || cache2;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result.cache;
        return result;
      }
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string2) {
        var result = [];
        if (string2.charCodeAt(0) === 46) {
          result.push("");
        }
        string2.replace(rePropName, function(match, number2, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
        });
        return result;
      });
      const stringToPath$1 = stringToPath;
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      function castPath(value, object2) {
        if (isArray$1(value)) {
          return value;
        }
        return isKey(value, object2) ? [value] : stringToPath$1(toString(value));
      }
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function baseGet(object2, path) {
        path = castPath(path, object2);
        var index = 0, length = path.length;
        while (object2 != null && index < length) {
          object2 = object2[toKey(path[index++])];
        }
        return index && index == length ? object2 : void 0;
      }
      function get(object2, path, defaultValue) {
        var result = object2 == null ? void 0 : baseGet(object2, path);
        return result === void 0 ? defaultValue : result;
      }
      function arrayPush(array2, values) {
        var index = -1, length = values.length, offset = array2.length;
        while (++index < length) {
          array2[offset + index] = values[index];
        }
        return array2;
      }
      var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray$1(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function baseFlatten(array2, depth, predicate, isStrict, result) {
        var index = -1, length = array2.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array2[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      function flatten(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseFlatten(array2, 1) : [];
      }
      function flatRest(func) {
        return setToString$1(overRest(func, void 0, flatten), func + "");
      }
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      const getPrototype$1 = getPrototype;
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray$1(value) ? value : [value];
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function baseAssign(object2, source) {
        return object2 && copyObject(source, keys(source), object2);
      }
      function baseAssignIn(object2, source) {
        return object2 && copyObject(source, keysIn(source), object2);
      }
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      function arrayFilter(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (predicate(value, index, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function stubArray() {
        return [];
      }
      var objectProto$3 = Object.prototype;
      var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
      var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object2) {
        if (object2 == null) {
          return [];
        }
        object2 = Object(object2);
        return arrayFilter(nativeGetSymbols$1(object2), function(symbol) {
          return propertyIsEnumerable.call(object2, symbol);
        });
      };
      const getSymbols$1 = getSymbols;
      function copySymbols(source, object2) {
        return copyObject(source, getSymbols$1(source), object2);
      }
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
        var result = [];
        while (object2) {
          arrayPush(result, getSymbols$1(object2));
          object2 = getPrototype$1(object2);
        }
        return result;
      };
      const getSymbolsIn$1 = getSymbolsIn;
      function copySymbolsIn(source, object2) {
        return copyObject(source, getSymbolsIn$1(source), object2);
      }
      function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
        var result = keysFunc(object2);
        return isArray$1(object2) ? result : arrayPush(result, symbolsFunc(object2));
      }
      function getAllKeys(object2) {
        return baseGetAllKeys(object2, keys, getSymbols$1);
      }
      function getAllKeysIn(object2) {
        return baseGetAllKeys(object2, keysIn, getSymbolsIn$1);
      }
      var DataView = getNative(root$1, "DataView");
      const DataView$1 = DataView;
      var Promise$1 = getNative(root$1, "Promise");
      const Promise$2 = Promise$1;
      var Set$1 = getNative(root$1, "Set");
      const Set$2 = Set$1;
      var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
      var dataViewTag$3 = "[object DataView]";
      var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
      var getTag = baseGetTag;
      if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$2 && getTag(new Map$2()) != mapTag$4 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$4 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag$3;
              case mapCtorString:
                return mapTag$4;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag$4;
              case weakMapCtorString:
                return weakMapTag$1;
            }
          }
          return result;
        };
      }
      const getTag$1 = getTag;
      var objectProto$2 = Object.prototype;
      var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
      function initCloneArray(array2) {
        var length = array2.length, result = new array2.constructor(length);
        if (length && typeof array2[0] == "string" && hasOwnProperty$2.call(array2, "index")) {
          result.index = array2.index;
          result.input = array2.input;
        }
        return result;
      }
      var Uint8Array2 = root$1.Uint8Array;
      const Uint8Array$1 = Uint8Array2;
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
        return result;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      var reFlags = /\w*$/;
      function cloneRegExp(regexp2) {
        var result = new regexp2.constructor(regexp2.source, reFlags.exec(regexp2));
        result.lastIndex = regexp2.lastIndex;
        return result;
      }
      var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
      var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
      function initCloneByTag(object2, tag, isDeep) {
        var Ctor = object2.constructor;
        switch (tag) {
          case arrayBufferTag$2:
            return cloneArrayBuffer(object2);
          case boolTag$2:
          case dateTag$2:
            return new Ctor(+object2);
          case dataViewTag$2:
            return cloneDataView(object2, isDeep);
          case float32Tag$1:
          case float64Tag$1:
          case int8Tag$1:
          case int16Tag$1:
          case int32Tag$1:
          case uint8Tag$1:
          case uint8ClampedTag$1:
          case uint16Tag$1:
          case uint32Tag$1:
            return cloneTypedArray(object2, isDeep);
          case mapTag$3:
            return new Ctor();
          case numberTag$2:
          case stringTag$2:
            return new Ctor(object2);
          case regexpTag$2:
            return cloneRegExp(object2);
          case setTag$3:
            return new Ctor();
          case symbolTag$2:
            return cloneSymbol(object2);
        }
      }
      function initCloneObject(object2) {
        return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate$1(getPrototype$1(object2)) : {};
      }
      var mapTag$2 = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag$1(value) == mapTag$2;
      }
      var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      const isMap$1 = isMap;
      var setTag$2 = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag$1(value) == setTag$2;
      }
      var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      const isSet$1 = isSet;
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
      var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
      var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object2, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
        if (customizer) {
          result = object2 ? customizer(value, key, object2, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray$1(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer$1(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object2) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object2 ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet$1(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap$1(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props2 = isArr ? void 0 : keysFunc(value);
        arrayEach(props2 || value, function(subValue, key2) {
          if (props2) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result;
      }
      var CLONE_SYMBOLS_FLAG = 4;
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function arraySome(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (predicate(array2[index], index, array2)) {
            return true;
          }
        }
        return false;
      }
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
      function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array2);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array2;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
        stack.set(array2, other);
        stack.set(other, array2);
        while (++index < arrLength) {
          var arrValue = array2[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array2);
        stack["delete"](other);
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
      var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
      var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
              return false;
            }
            object2 = object2.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object2), new Uint8Array$1(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object2, +other);
          case errorTag:
            return object2.name == other.name && object2.message == other.message;
          case regexpTag:
          case stringTag:
            return object2 == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
            convert || (convert = setToArray);
            if (object2.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object2);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object2, other);
            var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object2);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object2) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      var COMPARE_PARTIAL_FLAG$1 = 1;
      var objectProto$1 = Object.prototype;
      var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
      function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object2);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object2;
        }
        var result = true;
        stack.set(object2, other);
        stack.set(other, object2);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object2[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object2.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object2);
        stack["delete"](other);
        return result;
      }
      var COMPARE_PARTIAL_FLAG = 1;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray$1(object2), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object2), othTag = othIsArr ? arrayTag : getTag$1(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer$1(object2)) {
          if (!isBuffer$1(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray$1(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseHasIn(object2, key) {
        return object2 != null && key in Object(object2);
      }
      function hasPath(object2, path, hasFunc) {
        path = castPath(path, object2);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object2 != null && hasFunc(object2, key))) {
            break;
          }
          object2 = object2[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object2 == null ? 0 : object2.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object2) || isArguments$1(object2));
      }
      function hasIn(object2, path) {
        return object2 != null && hasPath(object2, path, baseHasIn);
      }
      var now = function() {
        return root$1.Date.now();
      };
      const now$1 = now;
      var FUNC_ERROR_TEXT$1 = "Expected a function";
      var nativeMax = Math.max, nativeMin = Math.min;
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$1);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now$1();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now$1());
        }
        function debounced() {
          var time = now$1(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
        while (++index < length) {
          var pair = pairs[index];
          result[pair[0]] = pair[1];
        }
        return result;
      }
      function isEqual$1(value, other) {
        return baseIsEqual(value, other);
      }
      function isNil(value) {
        return value == null;
      }
      function isUndefined$1(value) {
        return value === void 0;
      }
      function baseSet(object2, path, value, customizer) {
        if (!isObject(object2)) {
          return object2;
        }
        path = castPath(path, object2);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object2;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object2;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object2;
      }
      function basePickBy(object2, paths, predicate) {
        var index = -1, length = paths.length, result = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object2, path);
          if (predicate(value, path)) {
            baseSet(result, castPath(path, object2), value);
          }
        }
        return result;
      }
      function basePick(object2, paths) {
        return basePickBy(object2, paths, function(value, path) {
          return hasIn(object2, path);
        });
      }
      var pick = flatRest(function(object2, paths) {
        return object2 == null ? {} : basePick(object2, paths);
      });
      const pick$1 = pick;
      function set(object2, path, value) {
        return object2 == null ? object2 : baseSet(object2, path, value);
      }
      var FUNC_ERROR_TEXT = "Expected a function";
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      const isUndefined = (val) => val === void 0;
      const isBoolean = (val) => typeof val === "boolean";
      const isNumber = (val) => typeof val === "number";
      const isElement = (e2) => {
        if (typeof Element === "undefined")
          return false;
        return e2 instanceof Element;
      };
      const isStringNumber = (val) => {
        if (!isString$2(val)) {
          return false;
        }
        return !Number.isNaN(Number(val));
      };
      const escapeStringRegexp = (string2 = "") => string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      const capitalize = (str) => capitalize$1(str);
      const keysOf = (arr) => Object.keys(arr);
      const getProp = (obj, path, defaultValue) => {
        return {
          get value() {
            return get(obj, path, defaultValue);
          },
          set value(val) {
            set(obj, path, val);
          }
        };
      };
      class ElementPlusError extends Error {
        constructor(m2) {
          super(m2);
          this.name = "ElementPlusError";
        }
      }
      function throwError(scope, m2) {
        throw new ElementPlusError(`[${scope}] ${m2}`);
      }
      function debugWarn(scope, message2) {
      }
      const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
      const hasClass = (el, cls) => {
        if (!el || !cls)
          return false;
        if (cls.includes(" "))
          throw new Error("className should not contain space.");
        return el.classList.contains(cls);
      };
      const addClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.add(...classNameToArray(cls));
      };
      const removeClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.remove(...classNameToArray(cls));
      };
      const getStyle = (element, styleName) => {
        var _a2;
        if (!isClient$1 || !element || !styleName)
          return "";
        let key = camelize$1(styleName);
        if (key === "float")
          key = "cssFloat";
        try {
          const style = element.style[key];
          if (style)
            return style;
          const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
          return computed2 ? computed2[key] : "";
        } catch (e2) {
          return element.style[key];
        }
      };
      function addUnit(value, defaultUnit = "px") {
        if (!value)
          return "";
        if (isNumber(value) || isStringNumber(value)) {
          return `${value}${defaultUnit}`;
        } else if (isString$2(value)) {
          return value;
        }
      }
      const isScroll = (el, isVertical) => {
        if (!isClient$1)
          return false;
        const key = {
          undefined: "overflow",
          true: "overflow-y",
          false: "overflow-x"
        }[String(isVertical)];
        const overflow = getStyle(el, key);
        return ["scroll", "auto", "overlay"].some((s2) => overflow.includes(s2));
      };
      const getScrollContainer = (el, isVertical) => {
        if (!isClient$1)
          return;
        let parent = el;
        while (parent) {
          if ([window, document, document.documentElement].includes(parent))
            return window;
          if (isScroll(parent, isVertical))
            return parent;
          parent = parent.parentNode;
        }
        return parent;
      };
      let scrollBarWidth;
      const getScrollBarWidth = (namespace) => {
        var _a2;
        if (!isClient$1)
          return 0;
        if (scrollBarWidth !== void 0)
          return scrollBarWidth;
        const outer = document.createElement("div");
        outer.className = `${namespace}-scrollbar__wrap`;
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        outer.style.position = "absolute";
        outer.style.top = "-9999px";
        document.body.appendChild(outer);
        const widthNoScroll = outer.offsetWidth;
        outer.style.overflow = "scroll";
        const inner = document.createElement("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        const widthWithScroll = inner.offsetWidth;
        (_a2 = outer.parentNode) == null ? void 0 : _a2.removeChild(outer);
        scrollBarWidth = widthNoScroll - widthWithScroll;
        return scrollBarWidth;
      };
      function scrollIntoView(container, selected) {
        if (!isClient$1)
          return;
        if (!selected) {
          container.scrollTop = 0;
          return;
        }
        const offsetParents = [];
        let pointer = selected.offsetParent;
        while (pointer !== null && container !== pointer && container.contains(pointer)) {
          offsetParents.push(pointer);
          pointer = pointer.offsetParent;
        }
        const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
        const bottom = top + selected.offsetHeight;
        const viewRectTop = container.scrollTop;
        const viewRectBottom = viewRectTop + container.clientHeight;
        if (top < viewRectTop) {
          container.scrollTop = top;
        } else if (bottom > viewRectBottom) {
          container.scrollTop = bottom - container.clientHeight;
        }
      }
      /*! Element Plus Icons Vue v2.1.0 */
      var export_helper_default = (sfc, props2) => {
        let target = sfc.__vccOpts || sfc;
        for (let [key, val] of props2)
          target[key] = val;
        return target;
      };
      var arrow_down_vue_vue_type_script_lang_default = {
        name: "ArrowDown"
      };
      var _hoisted_16$2 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_26$1 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_36 = [
        _hoisted_26$1
      ];
      function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_16$2, _hoisted_36);
      }
      var arrow_down_default = /* @__PURE__ */ export_helper_default(arrow_down_vue_vue_type_script_lang_default, [["render", _sfc_render6], ["__file", "arrow-down.vue"]]);
      var arrow_left_vue_vue_type_script_lang_default = {
        name: "ArrowLeft"
      };
      var _hoisted_18$2 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_28$1 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_38 = [
        _hoisted_28$1
      ];
      function _sfc_render8(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_18$2, _hoisted_38);
      }
      var arrow_left_default = /* @__PURE__ */ export_helper_default(arrow_left_vue_vue_type_script_lang_default, [["render", _sfc_render8], ["__file", "arrow-left.vue"]]);
      var arrow_right_vue_vue_type_script_lang_default = {
        name: "ArrowRight"
      };
      var _hoisted_110 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_210 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_310 = [
        _hoisted_210
      ];
      function _sfc_render10(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_110, _hoisted_310);
      }
      var arrow_right_default = /* @__PURE__ */ export_helper_default(arrow_right_vue_vue_type_script_lang_default, [["render", _sfc_render10], ["__file", "arrow-right.vue"]]);
      var arrow_up_vue_vue_type_script_lang_default = {
        name: "ArrowUp"
      };
      var _hoisted_112 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_212 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_312 = [
        _hoisted_212
      ];
      function _sfc_render12(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_112, _hoisted_312);
      }
      var arrow_up_default = /* @__PURE__ */ export_helper_default(arrow_up_vue_vue_type_script_lang_default, [["render", _sfc_render12], ["__file", "arrow-up.vue"]]);
      var caret_right_vue_vue_type_script_lang_default = {
        name: "CaretRight"
      };
      var _hoisted_134 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_234 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M384 192v640l384-320.064z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_333 = [
        _hoisted_234
      ];
      function _sfc_render34(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_134, _hoisted_333);
      }
      var caret_right_default = /* @__PURE__ */ export_helper_default(caret_right_vue_vue_type_script_lang_default, [["render", _sfc_render34], ["__file", "caret-right.vue"]]);
      var check_vue_vue_type_script_lang_default = {
        name: "Check"
      };
      var _hoisted_143 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_243 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_342 = [
        _hoisted_243
      ];
      function _sfc_render43(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_143, _hoisted_342);
      }
      var check_default = /* @__PURE__ */ export_helper_default(check_vue_vue_type_script_lang_default, [["render", _sfc_render43], ["__file", "check.vue"]]);
      var circle_check_vue_vue_type_script_lang_default = {
        name: "CircleCheck"
      };
      var _hoisted_149 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_249 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_348 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_415 = [
        _hoisted_249,
        _hoisted_348
      ];
      function _sfc_render49(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_149, _hoisted_415);
      }
      var circle_check_default = /* @__PURE__ */ export_helper_default(circle_check_vue_vue_type_script_lang_default, [["render", _sfc_render49], ["__file", "circle-check.vue"]]);
      var circle_close_filled_vue_vue_type_script_lang_default = {
        name: "CircleCloseFilled"
      };
      var _hoisted_150 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_250 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_349 = [
        _hoisted_250
      ];
      function _sfc_render50(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_150, _hoisted_349);
      }
      var circle_close_filled_default = /* @__PURE__ */ export_helper_default(circle_close_filled_vue_vue_type_script_lang_default, [["render", _sfc_render50], ["__file", "circle-close-filled.vue"]]);
      var circle_close_vue_vue_type_script_lang_default = {
        name: "CircleClose"
      };
      var _hoisted_151 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_251 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_350 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_416 = [
        _hoisted_251,
        _hoisted_350
      ];
      function _sfc_render51(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_151, _hoisted_416);
      }
      var circle_close_default = /* @__PURE__ */ export_helper_default(circle_close_vue_vue_type_script_lang_default, [["render", _sfc_render51], ["__file", "circle-close.vue"]]);
      var close_vue_vue_type_script_lang_default = {
        name: "Close"
      };
      var _hoisted_156 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_256 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_355 = [
        _hoisted_256
      ];
      function _sfc_render56(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_156, _hoisted_355);
      }
      var close_default = /* @__PURE__ */ export_helper_default(close_vue_vue_type_script_lang_default, [["render", _sfc_render56], ["__file", "close.vue"]]);
      var full_screen_vue_vue_type_script_lang_default = {
        name: "FullScreen"
      };
      var _hoisted_1118 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2118 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64v.064zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64l-192 .192zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64v-.064z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3117 = [
        _hoisted_2118
      ];
      function _sfc_render118(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1118, _hoisted_3117);
      }
      var full_screen_default = /* @__PURE__ */ export_helper_default(full_screen_vue_vue_type_script_lang_default, [["render", _sfc_render118], ["__file", "full-screen.vue"]]);
      var hide_vue_vue_type_script_lang_default = {
        name: "Hide"
      };
      var _hoisted_1133 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2133 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3132 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_438 = [
        _hoisted_2133,
        _hoisted_3132
      ];
      function _sfc_render133(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1133, _hoisted_438);
      }
      var hide_default = /* @__PURE__ */ export_helper_default(hide_vue_vue_type_script_lang_default, [["render", _sfc_render133], ["__file", "hide.vue"]]);
      var info_filled_vue_vue_type_script_lang_default = {
        name: "InfoFilled"
      };
      var _hoisted_1143 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2143 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3142 = [
        _hoisted_2143
      ];
      function _sfc_render143(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1143, _hoisted_3142);
      }
      var info_filled_default = /* @__PURE__ */ export_helper_default(info_filled_vue_vue_type_script_lang_default, [["render", _sfc_render143], ["__file", "info-filled.vue"]]);
      var loading_vue_vue_type_script_lang_default = {
        name: "Loading"
      };
      var _hoisted_1150 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2150 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3149 = [
        _hoisted_2150
      ];
      function _sfc_render150(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1150, _hoisted_3149);
      }
      var loading_default = /* @__PURE__ */ export_helper_default(loading_vue_vue_type_script_lang_default, [["render", _sfc_render150], ["__file", "loading.vue"]]);
      var minus_vue_vue_type_script_lang_default = {
        name: "Minus"
      };
      var _hoisted_1169 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2169 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3168 = [
        _hoisted_2169
      ];
      function _sfc_render169(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1169, _hoisted_3168);
      }
      var minus_default = /* @__PURE__ */ export_helper_default(minus_vue_vue_type_script_lang_default, [["render", _sfc_render169], ["__file", "minus.vue"]]);
      var plus_vue_vue_type_script_lang_default = {
        name: "Plus"
      };
      var _hoisted_1201 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2201 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64h352z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3200 = [
        _hoisted_2201
      ];
      function _sfc_render201(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1201, _hoisted_3200);
      }
      var plus_default = /* @__PURE__ */ export_helper_default(plus_vue_vue_type_script_lang_default, [["render", _sfc_render201], ["__file", "plus.vue"]]);
      var refresh_left_vue_vue_type_script_lang_default = {
        name: "RefreshLeft"
      };
      var _hoisted_1215 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2215 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3214 = [
        _hoisted_2215
      ];
      function _sfc_render215(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1215, _hoisted_3214);
      }
      var refresh_left_default = /* @__PURE__ */ export_helper_default(refresh_left_vue_vue_type_script_lang_default, [["render", _sfc_render215], ["__file", "refresh-left.vue"]]);
      var refresh_right_vue_vue_type_script_lang_default = {
        name: "RefreshRight"
      };
      var _hoisted_1216 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2216 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3215 = [
        _hoisted_2216
      ];
      function _sfc_render216(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1216, _hoisted_3215);
      }
      var refresh_right_default = /* @__PURE__ */ export_helper_default(refresh_right_vue_vue_type_script_lang_default, [["render", _sfc_render216], ["__file", "refresh-right.vue"]]);
      var scale_to_original_vue_vue_type_script_lang_default = {
        name: "ScaleToOriginal"
      };
      var _hoisted_1222 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2222 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zM512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412zM512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3221 = [
        _hoisted_2222
      ];
      function _sfc_render222(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1222, _hoisted_3221);
      }
      var scale_to_original_default = /* @__PURE__ */ export_helper_default(scale_to_original_vue_vue_type_script_lang_default, [["render", _sfc_render222], ["__file", "scale-to-original.vue"]]);
      var success_filled_vue_vue_type_script_lang_default = {
        name: "SuccessFilled"
      };
      var _hoisted_1249 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2249 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3248 = [
        _hoisted_2249
      ];
      function _sfc_render249(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1249, _hoisted_3248);
      }
      var success_filled_default = /* @__PURE__ */ export_helper_default(success_filled_vue_vue_type_script_lang_default, [["render", _sfc_render249], ["__file", "success-filled.vue"]]);
      var view_vue_vue_type_script_lang_default = {
        name: "View"
      };
      var _hoisted_1283 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2283 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3282 = [
        _hoisted_2283
      ];
      function _sfc_render283(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1283, _hoisted_3282);
      }
      var view_default = /* @__PURE__ */ export_helper_default(view_vue_vue_type_script_lang_default, [["render", _sfc_render283], ["__file", "view.vue"]]);
      var warning_filled_vue_vue_type_script_lang_default = {
        name: "WarningFilled"
      };
      var _hoisted_1287 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2287 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3286 = [
        _hoisted_2287
      ];
      function _sfc_render287(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1287, _hoisted_3286);
      }
      var warning_filled_default = /* @__PURE__ */ export_helper_default(warning_filled_vue_vue_type_script_lang_default, [["render", _sfc_render287], ["__file", "warning-filled.vue"]]);
      var zoom_in_vue_vue_type_script_lang_default = {
        name: "ZoomIn"
      };
      var _hoisted_1292 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2292 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zm-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3291 = [
        _hoisted_2292
      ];
      function _sfc_render292(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1292, _hoisted_3291);
      }
      var zoom_in_default = /* @__PURE__ */ export_helper_default(zoom_in_vue_vue_type_script_lang_default, [["render", _sfc_render292], ["__file", "zoom-in.vue"]]);
      var zoom_out_vue_vue_type_script_lang_default = {
        name: "ZoomOut"
      };
      var _hoisted_1293 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2293 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zM352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3292 = [
        _hoisted_2293
      ];
      function _sfc_render293(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1293, _hoisted_3292);
      }
      var zoom_out_default = /* @__PURE__ */ export_helper_default(zoom_out_vue_vue_type_script_lang_default, [["render", _sfc_render293], ["__file", "zoom-out.vue"]]);
      const epPropKey = "__epPropKey";
      const definePropType = (val) => val;
      const isEpProp = (val) => isObject$1(val) && !!val[epPropKey];
      const buildProp = (prop, key) => {
        if (!isObject$1(prop) || isEpProp(prop))
          return prop;
        const { values, required: required2, default: defaultValue, type: type2, validator } = prop;
        const _validator = values || validator ? (val) => {
          let valid = false;
          let allowedValues = [];
          if (values) {
            allowedValues = Array.from(values);
            if (hasOwn(prop, "default")) {
              allowedValues.push(defaultValue);
            }
            valid || (valid = allowedValues.includes(val));
          }
          if (validator)
            valid || (valid = validator(val));
          if (!valid && allowedValues.length > 0) {
            const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
            warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
          }
          return valid;
        } : void 0;
        const epProp = {
          type: type2,
          required: !!required2,
          validator: _validator,
          [epPropKey]: true
        };
        if (hasOwn(prop, "default"))
          epProp.default = defaultValue;
        return epProp;
      };
      const buildProps = (props2) => fromPairs(Object.entries(props2).map(([key, option]) => [
        key,
        buildProp(option, key)
      ]));
      const iconPropType = definePropType([
        String,
        Object,
        Function
      ]);
      const CloseComponents = {
        Close: close_default
      };
      const TypeComponents = {
        Close: close_default,
        SuccessFilled: success_filled_default,
        InfoFilled: info_filled_default,
        WarningFilled: warning_filled_default,
        CircleCloseFilled: circle_close_filled_default
      };
      const TypeComponentsMap = {
        success: success_filled_default,
        warning: warning_filled_default,
        error: circle_close_filled_default,
        info: info_filled_default
      };
      const ValidateComponentsMap = {
        validating: loading_default,
        success: circle_check_default,
        error: circle_close_default
      };
      const withInstall = (main, extra) => {
        main.install = (app2) => {
          for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
            app2.component(comp.name, comp);
          }
        };
        if (extra) {
          for (const [key, comp] of Object.entries(extra)) {
            main[key] = comp;
          }
        }
        return main;
      };
      const withInstallFunction = (fn2, name) => {
        fn2.install = (app2) => {
          fn2._context = app2._context;
          app2.config.globalProperties[name] = fn2;
        };
        return fn2;
      };
      const withNoopInstall = (component) => {
        component.install = NOOP;
        return component;
      };
      const composeRefs = (...refs) => {
        return (el) => {
          refs.forEach((ref2) => {
            if (isFunction$2(ref2)) {
              ref2(el);
            } else {
              ref2.value = el;
            }
          });
        };
      };
      const EVENT_CODE = {
        tab: "Tab",
        enter: "Enter",
        space: "Space",
        left: "ArrowLeft",
        up: "ArrowUp",
        right: "ArrowRight",
        down: "ArrowDown",
        esc: "Escape",
        delete: "Delete",
        backspace: "Backspace",
        numpadEnter: "NumpadEnter",
        pageUp: "PageUp",
        pageDown: "PageDown",
        home: "Home",
        end: "End"
      };
      const UPDATE_MODEL_EVENT = "update:modelValue";
      const CHANGE_EVENT = "change";
      const INPUT_EVENT = "input";
      const componentSizes = ["", "default", "small", "large"];
      const componentSizeMap = {
        large: 40,
        default: 32,
        small: 24
      };
      const getComponentSize = (size2) => {
        return componentSizeMap[size2 || "default"];
      };
      const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
      var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
        PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
        PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
        PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
        PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
        PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
        PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
        PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
        PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
        PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
        PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
        PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
        return PatchFlags2;
      })(PatchFlags || {});
      const flattedChildren = (children) => {
        const vNodes = isArray$3(children) ? children : [children];
        const result = [];
        vNodes.forEach((child) => {
          var _a2;
          if (isArray$3(child)) {
            result.push(...flattedChildren(child));
          } else if (isVNode(child) && isArray$3(child.children)) {
            result.push(...flattedChildren(child.children));
          } else {
            result.push(child);
            if (isVNode(child) && ((_a2 = child.component) == null ? void 0 : _a2.subTree)) {
              result.push(...flattedChildren(child.component.subTree));
            }
          }
        });
        return result;
      };
      const isKorean = (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text);
      const rAF = (fn2) => isClient$1 ? window.requestAnimationFrame(fn2) : setTimeout(fn2, 16);
      const cAF = (handle) => isClient$1 ? window.cancelAnimationFrame(handle) : clearTimeout(handle);
      const mutable = (val) => val;
      const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
      const LISTENER_PREFIX = /^on[A-Z]/;
      const useAttrs = (params = {}) => {
        const { excludeListeners = false, excludeKeys } = params;
        const allExcludeKeys = computed(() => {
          return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
        });
        const instance = getCurrentInstance();
        if (!instance) {
          return computed(() => ({}));
        }
        return computed(() => {
          var _a2;
          return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
        });
      };
      const useDeprecated = ({ from, replacement, scope, version: version2, ref: ref2, type: type2 = "API" }, condition) => {
        watch(() => unref(condition), (val) => {
        }, {
          immediate: true
        });
      };
      const useDraggable$1 = (targetRef, dragRef, draggable) => {
        let transform = {
          offsetX: 0,
          offsetY: 0
        };
        const onMousedown = (e2) => {
          const downX = e2.clientX;
          const downY = e2.clientY;
          const { offsetX, offsetY } = transform;
          const targetRect = targetRef.value.getBoundingClientRect();
          const targetLeft = targetRect.left;
          const targetTop = targetRect.top;
          const targetWidth = targetRect.width;
          const targetHeight = targetRect.height;
          const clientWidth = document.documentElement.clientWidth;
          const clientHeight = document.documentElement.clientHeight;
          const minLeft = -targetLeft + offsetX;
          const minTop = -targetTop + offsetY;
          const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
          const maxTop = clientHeight - targetTop - targetHeight + offsetY;
          const onMousemove = (e22) => {
            const moveX = Math.min(Math.max(offsetX + e22.clientX - downX, minLeft), maxLeft);
            const moveY = Math.min(Math.max(offsetY + e22.clientY - downY, minTop), maxTop);
            transform = {
              offsetX: moveX,
              offsetY: moveY
            };
            targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
          };
          const onMouseup = () => {
            document.removeEventListener("mousemove", onMousemove);
            document.removeEventListener("mouseup", onMouseup);
          };
          document.addEventListener("mousemove", onMousemove);
          document.addEventListener("mouseup", onMouseup);
        };
        const onDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.addEventListener("mousedown", onMousedown);
          }
        };
        const offDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.removeEventListener("mousedown", onMousedown);
          }
        };
        onMounted(() => {
          watchEffect(() => {
            if (draggable.value) {
              onDraggable();
            } else {
              offDraggable();
            }
          });
        });
        onBeforeUnmount(() => {
          offDraggable();
        });
      };
      const useFocus = (el) => {
        return {
          focus: () => {
            var _a2, _b;
            (_b = (_a2 = el.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          }
        };
      };
      var English = {
        name: "en",
        el: {
          colorpicker: {
            confirm: "OK",
            clear: "Clear",
            defaultLabel: "color picker",
            description: "current color is {color}. press enter to select a new color."
          },
          datepicker: {
            now: "Now",
            today: "Today",
            cancel: "Cancel",
            clear: "Clear",
            confirm: "OK",
            dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
            monthTablePrompt: "Use the arrow keys and enter to select the month",
            yearTablePrompt: "Use the arrow keys and enter to select the year",
            selectedDate: "Selected date",
            selectDate: "Select date",
            selectTime: "Select time",
            startDate: "Start Date",
            startTime: "Start Time",
            endDate: "End Date",
            endTime: "End Time",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            year: "",
            month1: "January",
            month2: "February",
            month3: "March",
            month4: "April",
            month5: "May",
            month6: "June",
            month7: "July",
            month8: "August",
            month9: "September",
            month10: "October",
            month11: "November",
            month12: "December",
            week: "week",
            weeks: {
              sun: "Sun",
              mon: "Mon",
              tue: "Tue",
              wed: "Wed",
              thu: "Thu",
              fri: "Fri",
              sat: "Sat"
            },
            weeksFull: {
              sun: "Sunday",
              mon: "Monday",
              tue: "Tuesday",
              wed: "Wednesday",
              thu: "Thursday",
              fri: "Friday",
              sat: "Saturday"
            },
            months: {
              jan: "Jan",
              feb: "Feb",
              mar: "Mar",
              apr: "Apr",
              may: "May",
              jun: "Jun",
              jul: "Jul",
              aug: "Aug",
              sep: "Sep",
              oct: "Oct",
              nov: "Nov",
              dec: "Dec"
            }
          },
          inputNumber: {
            decrease: "decrease number",
            increase: "increase number"
          },
          select: {
            loading: "Loading",
            noMatch: "No matching data",
            noData: "No data",
            placeholder: "Select"
          },
          dropdown: {
            toggleDropdown: "Toggle Dropdown"
          },
          cascader: {
            noMatch: "No matching data",
            loading: "Loading",
            placeholder: "Select",
            noData: "No data"
          },
          pagination: {
            goto: "Go to",
            pagesize: "/page",
            total: "Total {total}",
            pageClassifier: "",
            page: "Page",
            prev: "Go to previous page",
            next: "Go to next page",
            currentPage: "page {pager}",
            prevPages: "Previous {pager} pages",
            nextPages: "Next {pager} pages",
            deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
          },
          dialog: {
            close: "Close this dialog"
          },
          drawer: {
            close: "Close this dialog"
          },
          messagebox: {
            title: "Message",
            confirm: "OK",
            cancel: "Cancel",
            error: "Illegal input",
            close: "Close this dialog"
          },
          upload: {
            deleteTip: "press delete to remove",
            delete: "Delete",
            preview: "Preview",
            continue: "Continue"
          },
          slider: {
            defaultLabel: "slider between {min} and {max}",
            defaultRangeStartLabel: "pick start value",
            defaultRangeEndLabel: "pick end value"
          },
          table: {
            emptyText: "No Data",
            confirmFilter: "Confirm",
            resetFilter: "Reset",
            clearFilter: "All",
            sumText: "Sum"
          },
          tree: {
            emptyText: "No Data"
          },
          transfer: {
            noMatch: "No matching data",
            noData: "No data",
            titles: ["List 1", "List 2"],
            filterPlaceholder: "Enter keyword",
            noCheckedFormat: "{total} items",
            hasCheckedFormat: "{checked}/{total} checked"
          },
          image: {
            error: "FAILED"
          },
          pageHeader: {
            title: "Back"
          },
          popconfirm: {
            confirmButtonText: "Yes",
            cancelButtonText: "No"
          }
        }
      };
      const buildTranslator = (locale) => (path, option) => translate(path, option, unref(locale));
      const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_2, key) => {
        var _a2;
        return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
      });
      const buildLocaleContext = (locale) => {
        const lang = computed(() => unref(locale).name);
        const localeRef = isRef(locale) ? locale : ref(locale);
        return {
          lang,
          locale: localeRef,
          t: buildTranslator(locale)
        };
      };
      const localeContextKey = Symbol("localeContextKey");
      const useLocale = (localeOverrides) => {
        const locale = localeOverrides || inject(localeContextKey, ref());
        return buildLocaleContext(computed(() => locale.value || English));
      };
      const defaultNamespace = "el";
      const statePrefix = "is-";
      const _bem = (namespace, block, blockSuffix, element, modifier) => {
        let cls = `${namespace}-${block}`;
        if (blockSuffix) {
          cls += `-${blockSuffix}`;
        }
        if (element) {
          cls += `__${element}`;
        }
        if (modifier) {
          cls += `--${modifier}`;
        }
        return cls;
      };
      const namespaceContextKey = Symbol("namespaceContextKey");
      const useGetDerivedNamespace = (namespaceOverrides) => {
        const derivedNamespace = namespaceOverrides || inject(namespaceContextKey, ref(defaultNamespace));
        const namespace = computed(() => {
          return unref(derivedNamespace) || defaultNamespace;
        });
        return namespace;
      };
      const useNamespace = (block, namespaceOverrides) => {
        const namespace = useGetDerivedNamespace(namespaceOverrides);
        const b2 = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
        const e2 = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
        const m2 = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
        const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
        const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
        const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
        const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
        const is = (name, ...args) => {
          const state = args.length >= 1 ? args[0] : true;
          return name && state ? `${statePrefix}${name}` : "";
        };
        const cssVar = (object2) => {
          const styles = {};
          for (const key in object2) {
            if (object2[key]) {
              styles[`--${namespace.value}-${key}`] = object2[key];
            }
          }
          return styles;
        };
        const cssVarBlock = (object2) => {
          const styles = {};
          for (const key in object2) {
            if (object2[key]) {
              styles[`--${namespace.value}-${block}-${key}`] = object2[key];
            }
          }
          return styles;
        };
        const cssVarName = (name) => `--${namespace.value}-${name}`;
        const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
        return {
          namespace,
          b: b2,
          e: e2,
          m: m2,
          be: be2,
          em,
          bm,
          bem,
          is,
          cssVar,
          cssVarName,
          cssVarBlock,
          cssVarBlockName
        };
      };
      const useLockscreen = (trigger2, options = {}) => {
        if (!isRef(trigger2)) {
          throwError("[useLockscreen]", "You need to pass a ref param to this function");
        }
        const ns = options.ns || useNamespace("popup");
        const hiddenCls = computed$1(() => ns.bm("parent", "hidden"));
        if (!isClient$1 || hasClass(document.body, hiddenCls.value)) {
          return;
        }
        let scrollBarWidth2 = 0;
        let withoutHiddenClass = false;
        let bodyWidth = "0";
        const cleanup = () => {
          setTimeout(() => {
            removeClass(document == null ? void 0 : document.body, hiddenCls.value);
            if (withoutHiddenClass && document) {
              document.body.style.width = bodyWidth;
            }
          }, 200);
        };
        watch(trigger2, (val) => {
          if (!val) {
            cleanup();
            return;
          }
          withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
          if (withoutHiddenClass) {
            bodyWidth = document.body.style.width;
          }
          scrollBarWidth2 = getScrollBarWidth(ns.namespace.value);
          const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          const bodyOverflowY = getStyle(document.body, "overflowY");
          if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
            document.body.style.width = `calc(100% - ${scrollBarWidth2}px)`;
          }
          addClass(document.body, hiddenCls.value);
        });
        onScopeDispose(() => cleanup());
      };
      const _prop = buildProp({
        type: definePropType(Boolean),
        default: null
      });
      const _event = buildProp({
        type: definePropType(Function)
      });
      const createModelToggleComposable = (name) => {
        const updateEventKey = `update:${name}`;
        const updateEventKeyRaw = `onUpdate:${name}`;
        const useModelToggleEmits2 = [updateEventKey];
        const useModelToggleProps2 = {
          [name]: _prop,
          [updateEventKeyRaw]: _event
        };
        const useModelToggle2 = ({
          indicator,
          toggleReason,
          shouldHideWhenRouteChanges,
          shouldProceed,
          onShow,
          onHide
        }) => {
          const instance = getCurrentInstance();
          const { emit: emit2 } = instance;
          const props2 = instance.props;
          const hasUpdateHandler = computed(() => isFunction$2(props2[updateEventKeyRaw]));
          const isModelBindingAbsent = computed(() => props2[name] === null);
          const doShow = (event) => {
            if (indicator.value === true) {
              return;
            }
            indicator.value = true;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$2(onShow)) {
              onShow(event);
            }
          };
          const doHide = (event) => {
            if (indicator.value === false) {
              return;
            }
            indicator.value = false;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$2(onHide)) {
              onHide(event);
            }
          };
          const show = (event) => {
            if (props2.disabled === true || isFunction$2(shouldProceed) && !shouldProceed())
              return;
            const shouldEmit = hasUpdateHandler.value && isClient$1;
            if (shouldEmit) {
              emit2(updateEventKey, true);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doShow(event);
            }
          };
          const hide = (event) => {
            if (props2.disabled === true || !isClient$1)
              return;
            const shouldEmit = hasUpdateHandler.value && isClient$1;
            if (shouldEmit) {
              emit2(updateEventKey, false);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doHide(event);
            }
          };
          const onChange = (val) => {
            if (!isBoolean(val))
              return;
            if (props2.disabled && val) {
              if (hasUpdateHandler.value) {
                emit2(updateEventKey, false);
              }
            } else if (indicator.value !== val) {
              if (val) {
                doShow();
              } else {
                doHide();
              }
            }
          };
          const toggle = () => {
            if (indicator.value) {
              hide();
            } else {
              show();
            }
          };
          watch(() => props2[name], onChange);
          if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
            watch(() => ({
              ...instance.proxy.$route
            }), () => {
              if (shouldHideWhenRouteChanges.value && indicator.value) {
                hide();
              }
            });
          }
          onMounted(() => {
            onChange(props2[name]);
          });
          return {
            hide,
            show,
            toggle,
            hasUpdateHandler
          };
        };
        return {
          useModelToggle: useModelToggle2,
          useModelToggleProps: useModelToggleProps2,
          useModelToggleEmits: useModelToggleEmits2
        };
      };
      const useProp = (name) => {
        const vm = getCurrentInstance();
        return computed(() => {
          var _a2, _b;
          return (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$props) == null ? void 0 : _b[name];
        });
      };
      var E$1 = "top", R$1 = "bottom", W$1 = "right", P$1 = "left", me = "auto", G$1 = [E$1, R$1, W$1, P$1], U$1 = "start", J$1 = "end", Xe = "clippingParents", je = "viewport", K$1 = "popper", Ye = "reference", De = G$1.reduce(function(t2, e2) {
        return t2.concat([e2 + "-" + U$1, e2 + "-" + J$1]);
      }, []), Ee = [].concat(G$1, [me]).reduce(function(t2, e2) {
        return t2.concat([e2, e2 + "-" + U$1, e2 + "-" + J$1]);
      }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et$1 = "afterMain", tt$1 = "beforeWrite", nt$1 = "write", rt$1 = "afterWrite", ot$1 = [Ge, Je, Ke, Qe, Ze, et$1, tt$1, nt$1, rt$1];
      function C$1(t2) {
        return t2 ? (t2.nodeName || "").toLowerCase() : null;
      }
      function H$1(t2) {
        if (t2 == null)
          return window;
        if (t2.toString() !== "[object Window]") {
          var e2 = t2.ownerDocument;
          return e2 && e2.defaultView || window;
        }
        return t2;
      }
      function Q$1(t2) {
        var e2 = H$1(t2).Element;
        return t2 instanceof e2 || t2 instanceof Element;
      }
      function B$1(t2) {
        var e2 = H$1(t2).HTMLElement;
        return t2 instanceof e2 || t2 instanceof HTMLElement;
      }
      function Pe(t2) {
        if (typeof ShadowRoot == "undefined")
          return false;
        var e2 = H$1(t2).ShadowRoot;
        return t2 instanceof e2 || t2 instanceof ShadowRoot;
      }
      function Mt$1(t2) {
        var e2 = t2.state;
        Object.keys(e2.elements).forEach(function(n2) {
          var r2 = e2.styles[n2] || {}, o2 = e2.attributes[n2] || {}, i2 = e2.elements[n2];
          !B$1(i2) || !C$1(i2) || (Object.assign(i2.style, r2), Object.keys(o2).forEach(function(a2) {
            var s2 = o2[a2];
            s2 === false ? i2.removeAttribute(a2) : i2.setAttribute(a2, s2 === true ? "" : s2);
          }));
        });
      }
      function Rt$1(t2) {
        var e2 = t2.state, n2 = { popper: { position: e2.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
        return Object.assign(e2.elements.popper.style, n2.popper), e2.styles = n2, e2.elements.arrow && Object.assign(e2.elements.arrow.style, n2.arrow), function() {
          Object.keys(e2.elements).forEach(function(r2) {
            var o2 = e2.elements[r2], i2 = e2.attributes[r2] || {}, a2 = Object.keys(e2.styles.hasOwnProperty(r2) ? e2.styles[r2] : n2[r2]), s2 = a2.reduce(function(f2, c2) {
              return f2[c2] = "", f2;
            }, {});
            !B$1(o2) || !C$1(o2) || (Object.assign(o2.style, s2), Object.keys(i2).forEach(function(f2) {
              o2.removeAttribute(f2);
            }));
          });
        };
      }
      var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt$1, effect: Rt$1, requires: ["computeStyles"] };
      function q$1(t2) {
        return t2.split("-")[0];
      }
      var X$1 = Math.max, ve = Math.min, Z$1 = Math.round;
      function ee(t2, e2) {
        e2 === void 0 && (e2 = false);
        var n2 = t2.getBoundingClientRect(), r2 = 1, o2 = 1;
        if (B$1(t2) && e2) {
          var i2 = t2.offsetHeight, a2 = t2.offsetWidth;
          a2 > 0 && (r2 = Z$1(n2.width) / a2 || 1), i2 > 0 && (o2 = Z$1(n2.height) / i2 || 1);
        }
        return { width: n2.width / r2, height: n2.height / o2, top: n2.top / o2, right: n2.right / r2, bottom: n2.bottom / o2, left: n2.left / r2, x: n2.left / r2, y: n2.top / o2 };
      }
      function ke(t2) {
        var e2 = ee(t2), n2 = t2.offsetWidth, r2 = t2.offsetHeight;
        return Math.abs(e2.width - n2) <= 1 && (n2 = e2.width), Math.abs(e2.height - r2) <= 1 && (r2 = e2.height), { x: t2.offsetLeft, y: t2.offsetTop, width: n2, height: r2 };
      }
      function it$1(t2, e2) {
        var n2 = e2.getRootNode && e2.getRootNode();
        if (t2.contains(e2))
          return true;
        if (n2 && Pe(n2)) {
          var r2 = e2;
          do {
            if (r2 && t2.isSameNode(r2))
              return true;
            r2 = r2.parentNode || r2.host;
          } while (r2);
        }
        return false;
      }
      function N$1(t2) {
        return H$1(t2).getComputedStyle(t2);
      }
      function Wt(t2) {
        return ["table", "td", "th"].indexOf(C$1(t2)) >= 0;
      }
      function I$1(t2) {
        return ((Q$1(t2) ? t2.ownerDocument : t2.document) || window.document).documentElement;
      }
      function ge(t2) {
        return C$1(t2) === "html" ? t2 : t2.assignedSlot || t2.parentNode || (Pe(t2) ? t2.host : null) || I$1(t2);
      }
      function at$1(t2) {
        return !B$1(t2) || N$1(t2).position === "fixed" ? null : t2.offsetParent;
      }
      function Bt$1(t2) {
        var e2 = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n2 = navigator.userAgent.indexOf("Trident") !== -1;
        if (n2 && B$1(t2)) {
          var r2 = N$1(t2);
          if (r2.position === "fixed")
            return null;
        }
        var o2 = ge(t2);
        for (Pe(o2) && (o2 = o2.host); B$1(o2) && ["html", "body"].indexOf(C$1(o2)) < 0; ) {
          var i2 = N$1(o2);
          if (i2.transform !== "none" || i2.perspective !== "none" || i2.contain === "paint" || ["transform", "perspective"].indexOf(i2.willChange) !== -1 || e2 && i2.willChange === "filter" || e2 && i2.filter && i2.filter !== "none")
            return o2;
          o2 = o2.parentNode;
        }
        return null;
      }
      function se(t2) {
        for (var e2 = H$1(t2), n2 = at$1(t2); n2 && Wt(n2) && N$1(n2).position === "static"; )
          n2 = at$1(n2);
        return n2 && (C$1(n2) === "html" || C$1(n2) === "body" && N$1(n2).position === "static") ? e2 : n2 || Bt$1(t2) || e2;
      }
      function Le(t2) {
        return ["top", "bottom"].indexOf(t2) >= 0 ? "x" : "y";
      }
      function fe(t2, e2, n2) {
        return X$1(t2, ve(e2, n2));
      }
      function St$1(t2, e2, n2) {
        var r2 = fe(t2, e2, n2);
        return r2 > n2 ? n2 : r2;
      }
      function st$1() {
        return { top: 0, right: 0, bottom: 0, left: 0 };
      }
      function ft$1(t2) {
        return Object.assign({}, st$1(), t2);
      }
      function ct$1(t2, e2) {
        return e2.reduce(function(n2, r2) {
          return n2[r2] = t2, n2;
        }, {});
      }
      var Tt$1 = function(t2, e2) {
        return t2 = typeof t2 == "function" ? t2(Object.assign({}, e2.rects, { placement: e2.placement })) : t2, ft$1(typeof t2 != "number" ? t2 : ct$1(t2, G$1));
      };
      function Ht$1(t2) {
        var e2, n2 = t2.state, r2 = t2.name, o2 = t2.options, i2 = n2.elements.arrow, a2 = n2.modifiersData.popperOffsets, s2 = q$1(n2.placement), f2 = Le(s2), c2 = [P$1, W$1].indexOf(s2) >= 0, u2 = c2 ? "height" : "width";
        if (!(!i2 || !a2)) {
          var m2 = Tt$1(o2.padding, n2), v2 = ke(i2), l2 = f2 === "y" ? E$1 : P$1, h2 = f2 === "y" ? R$1 : W$1, p2 = n2.rects.reference[u2] + n2.rects.reference[f2] - a2[f2] - n2.rects.popper[u2], g2 = a2[f2] - n2.rects.reference[f2], x2 = se(i2), y2 = x2 ? f2 === "y" ? x2.clientHeight || 0 : x2.clientWidth || 0 : 0, $2 = p2 / 2 - g2 / 2, d2 = m2[l2], b2 = y2 - v2[u2] - m2[h2], w2 = y2 / 2 - v2[u2] / 2 + $2, O2 = fe(d2, w2, b2), j2 = f2;
          n2.modifiersData[r2] = (e2 = {}, e2[j2] = O2, e2.centerOffset = O2 - w2, e2);
        }
      }
      function Ct$1(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = n2.element, o2 = r2 === void 0 ? "[data-popper-arrow]" : r2;
        o2 != null && (typeof o2 == "string" && (o2 = e2.elements.popper.querySelector(o2), !o2) || !it$1(e2.elements.popper, o2) || (e2.elements.arrow = o2));
      }
      var pt$1 = { name: "arrow", enabled: true, phase: "main", fn: Ht$1, effect: Ct$1, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
      function te(t2) {
        return t2.split("-")[1];
      }
      var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
      function Vt(t2) {
        var e2 = t2.x, n2 = t2.y, r2 = window, o2 = r2.devicePixelRatio || 1;
        return { x: Z$1(e2 * o2) / o2 || 0, y: Z$1(n2 * o2) / o2 || 0 };
      }
      function ut$1(t2) {
        var e2, n2 = t2.popper, r2 = t2.popperRect, o2 = t2.placement, i2 = t2.variation, a2 = t2.offsets, s2 = t2.position, f2 = t2.gpuAcceleration, c2 = t2.adaptive, u2 = t2.roundOffsets, m2 = t2.isFixed, v2 = a2.x, l2 = v2 === void 0 ? 0 : v2, h2 = a2.y, p2 = h2 === void 0 ? 0 : h2, g2 = typeof u2 == "function" ? u2({ x: l2, y: p2 }) : { x: l2, y: p2 };
        l2 = g2.x, p2 = g2.y;
        var x2 = a2.hasOwnProperty("x"), y2 = a2.hasOwnProperty("y"), $2 = P$1, d2 = E$1, b2 = window;
        if (c2) {
          var w2 = se(n2), O2 = "clientHeight", j2 = "clientWidth";
          if (w2 === H$1(n2) && (w2 = I$1(n2), N$1(w2).position !== "static" && s2 === "absolute" && (O2 = "scrollHeight", j2 = "scrollWidth")), w2 = w2, o2 === E$1 || (o2 === P$1 || o2 === W$1) && i2 === J$1) {
            d2 = R$1;
            var A2 = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.height : w2[O2];
            p2 -= A2 - r2.height, p2 *= f2 ? 1 : -1;
          }
          if (o2 === P$1 || (o2 === E$1 || o2 === R$1) && i2 === J$1) {
            $2 = W$1;
            var k2 = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.width : w2[j2];
            l2 -= k2 - r2.width, l2 *= f2 ? 1 : -1;
          }
        }
        var D2 = Object.assign({ position: s2 }, c2 && qt), S2 = u2 === true ? Vt({ x: l2, y: p2 }) : { x: l2, y: p2 };
        if (l2 = S2.x, p2 = S2.y, f2) {
          var L2;
          return Object.assign({}, D2, (L2 = {}, L2[d2] = y2 ? "0" : "", L2[$2] = x2 ? "0" : "", L2.transform = (b2.devicePixelRatio || 1) <= 1 ? "translate(" + l2 + "px, " + p2 + "px)" : "translate3d(" + l2 + "px, " + p2 + "px, 0)", L2));
        }
        return Object.assign({}, D2, (e2 = {}, e2[d2] = y2 ? p2 + "px" : "", e2[$2] = x2 ? l2 + "px" : "", e2.transform = "", e2));
      }
      function Nt$1(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = n2.gpuAcceleration, o2 = r2 === void 0 ? true : r2, i2 = n2.adaptive, a2 = i2 === void 0 ? true : i2, s2 = n2.roundOffsets, f2 = s2 === void 0 ? true : s2, c2 = { placement: q$1(e2.placement), variation: te(e2.placement), popper: e2.elements.popper, popperRect: e2.rects.popper, gpuAcceleration: o2, isFixed: e2.options.strategy === "fixed" };
        e2.modifiersData.popperOffsets != null && (e2.styles.popper = Object.assign({}, e2.styles.popper, ut$1(Object.assign({}, c2, { offsets: e2.modifiersData.popperOffsets, position: e2.options.strategy, adaptive: a2, roundOffsets: f2 })))), e2.modifiersData.arrow != null && (e2.styles.arrow = Object.assign({}, e2.styles.arrow, ut$1(Object.assign({}, c2, { offsets: e2.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f2 })))), e2.attributes.popper = Object.assign({}, e2.attributes.popper, { "data-popper-placement": e2.placement });
      }
      var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt$1, data: {} }, ye = { passive: true };
      function It$1(t2) {
        var e2 = t2.state, n2 = t2.instance, r2 = t2.options, o2 = r2.scroll, i2 = o2 === void 0 ? true : o2, a2 = r2.resize, s2 = a2 === void 0 ? true : a2, f2 = H$1(e2.elements.popper), c2 = [].concat(e2.scrollParents.reference, e2.scrollParents.popper);
        return i2 && c2.forEach(function(u2) {
          u2.addEventListener("scroll", n2.update, ye);
        }), s2 && f2.addEventListener("resize", n2.update, ye), function() {
          i2 && c2.forEach(function(u2) {
            u2.removeEventListener("scroll", n2.update, ye);
          }), s2 && f2.removeEventListener("resize", n2.update, ye);
        };
      }
      var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
      }, effect: It$1, data: {} }, _t$1 = { left: "right", right: "left", bottom: "top", top: "bottom" };
      function be(t2) {
        return t2.replace(/left|right|bottom|top/g, function(e2) {
          return _t$1[e2];
        });
      }
      var zt$1 = { start: "end", end: "start" };
      function lt$1(t2) {
        return t2.replace(/start|end/g, function(e2) {
          return zt$1[e2];
        });
      }
      function We(t2) {
        var e2 = H$1(t2), n2 = e2.pageXOffset, r2 = e2.pageYOffset;
        return { scrollLeft: n2, scrollTop: r2 };
      }
      function Be(t2) {
        return ee(I$1(t2)).left + We(t2).scrollLeft;
      }
      function Ft$1(t2) {
        var e2 = H$1(t2), n2 = I$1(t2), r2 = e2.visualViewport, o2 = n2.clientWidth, i2 = n2.clientHeight, a2 = 0, s2 = 0;
        return r2 && (o2 = r2.width, i2 = r2.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a2 = r2.offsetLeft, s2 = r2.offsetTop)), { width: o2, height: i2, x: a2 + Be(t2), y: s2 };
      }
      function Ut(t2) {
        var e2, n2 = I$1(t2), r2 = We(t2), o2 = (e2 = t2.ownerDocument) == null ? void 0 : e2.body, i2 = X$1(n2.scrollWidth, n2.clientWidth, o2 ? o2.scrollWidth : 0, o2 ? o2.clientWidth : 0), a2 = X$1(n2.scrollHeight, n2.clientHeight, o2 ? o2.scrollHeight : 0, o2 ? o2.clientHeight : 0), s2 = -r2.scrollLeft + Be(t2), f2 = -r2.scrollTop;
        return N$1(o2 || n2).direction === "rtl" && (s2 += X$1(n2.clientWidth, o2 ? o2.clientWidth : 0) - i2), { width: i2, height: a2, x: s2, y: f2 };
      }
      function Se(t2) {
        var e2 = N$1(t2), n2 = e2.overflow, r2 = e2.overflowX, o2 = e2.overflowY;
        return /auto|scroll|overlay|hidden/.test(n2 + o2 + r2);
      }
      function dt$1(t2) {
        return ["html", "body", "#document"].indexOf(C$1(t2)) >= 0 ? t2.ownerDocument.body : B$1(t2) && Se(t2) ? t2 : dt$1(ge(t2));
      }
      function ce(t2, e2) {
        var n2;
        e2 === void 0 && (e2 = []);
        var r2 = dt$1(t2), o2 = r2 === ((n2 = t2.ownerDocument) == null ? void 0 : n2.body), i2 = H$1(r2), a2 = o2 ? [i2].concat(i2.visualViewport || [], Se(r2) ? r2 : []) : r2, s2 = e2.concat(a2);
        return o2 ? s2 : s2.concat(ce(ge(a2)));
      }
      function Te(t2) {
        return Object.assign({}, t2, { left: t2.x, top: t2.y, right: t2.x + t2.width, bottom: t2.y + t2.height });
      }
      function Xt(t2) {
        var e2 = ee(t2);
        return e2.top = e2.top + t2.clientTop, e2.left = e2.left + t2.clientLeft, e2.bottom = e2.top + t2.clientHeight, e2.right = e2.left + t2.clientWidth, e2.width = t2.clientWidth, e2.height = t2.clientHeight, e2.x = e2.left, e2.y = e2.top, e2;
      }
      function ht$1(t2, e2) {
        return e2 === je ? Te(Ft$1(t2)) : Q$1(e2) ? Xt(e2) : Te(Ut(I$1(t2)));
      }
      function Yt(t2) {
        var e2 = ce(ge(t2)), n2 = ["absolute", "fixed"].indexOf(N$1(t2).position) >= 0, r2 = n2 && B$1(t2) ? se(t2) : t2;
        return Q$1(r2) ? e2.filter(function(o2) {
          return Q$1(o2) && it$1(o2, r2) && C$1(o2) !== "body";
        }) : [];
      }
      function Gt(t2, e2, n2) {
        var r2 = e2 === "clippingParents" ? Yt(t2) : [].concat(e2), o2 = [].concat(r2, [n2]), i2 = o2[0], a2 = o2.reduce(function(s2, f2) {
          var c2 = ht$1(t2, f2);
          return s2.top = X$1(c2.top, s2.top), s2.right = ve(c2.right, s2.right), s2.bottom = ve(c2.bottom, s2.bottom), s2.left = X$1(c2.left, s2.left), s2;
        }, ht$1(t2, i2));
        return a2.width = a2.right - a2.left, a2.height = a2.bottom - a2.top, a2.x = a2.left, a2.y = a2.top, a2;
      }
      function mt$1(t2) {
        var e2 = t2.reference, n2 = t2.element, r2 = t2.placement, o2 = r2 ? q$1(r2) : null, i2 = r2 ? te(r2) : null, a2 = e2.x + e2.width / 2 - n2.width / 2, s2 = e2.y + e2.height / 2 - n2.height / 2, f2;
        switch (o2) {
          case E$1:
            f2 = { x: a2, y: e2.y - n2.height };
            break;
          case R$1:
            f2 = { x: a2, y: e2.y + e2.height };
            break;
          case W$1:
            f2 = { x: e2.x + e2.width, y: s2 };
            break;
          case P$1:
            f2 = { x: e2.x - n2.width, y: s2 };
            break;
          default:
            f2 = { x: e2.x, y: e2.y };
        }
        var c2 = o2 ? Le(o2) : null;
        if (c2 != null) {
          var u2 = c2 === "y" ? "height" : "width";
          switch (i2) {
            case U$1:
              f2[c2] = f2[c2] - (e2[u2] / 2 - n2[u2] / 2);
              break;
            case J$1:
              f2[c2] = f2[c2] + (e2[u2] / 2 - n2[u2] / 2);
              break;
          }
        }
        return f2;
      }
      function ne(t2, e2) {
        e2 === void 0 && (e2 = {});
        var n2 = e2, r2 = n2.placement, o2 = r2 === void 0 ? t2.placement : r2, i2 = n2.boundary, a2 = i2 === void 0 ? Xe : i2, s2 = n2.rootBoundary, f2 = s2 === void 0 ? je : s2, c2 = n2.elementContext, u2 = c2 === void 0 ? K$1 : c2, m2 = n2.altBoundary, v2 = m2 === void 0 ? false : m2, l2 = n2.padding, h2 = l2 === void 0 ? 0 : l2, p2 = ft$1(typeof h2 != "number" ? h2 : ct$1(h2, G$1)), g2 = u2 === K$1 ? Ye : K$1, x2 = t2.rects.popper, y2 = t2.elements[v2 ? g2 : u2], $2 = Gt(Q$1(y2) ? y2 : y2.contextElement || I$1(t2.elements.popper), a2, f2), d2 = ee(t2.elements.reference), b2 = mt$1({ reference: d2, element: x2, strategy: "absolute", placement: o2 }), w2 = Te(Object.assign({}, x2, b2)), O2 = u2 === K$1 ? w2 : d2, j2 = { top: $2.top - O2.top + p2.top, bottom: O2.bottom - $2.bottom + p2.bottom, left: $2.left - O2.left + p2.left, right: O2.right - $2.right + p2.right }, A2 = t2.modifiersData.offset;
        if (u2 === K$1 && A2) {
          var k2 = A2[o2];
          Object.keys(j2).forEach(function(D2) {
            var S2 = [W$1, R$1].indexOf(D2) >= 0 ? 1 : -1, L2 = [E$1, R$1].indexOf(D2) >= 0 ? "y" : "x";
            j2[D2] += k2[L2] * S2;
          });
        }
        return j2;
      }
      function Jt(t2, e2) {
        e2 === void 0 && (e2 = {});
        var n2 = e2, r2 = n2.placement, o2 = n2.boundary, i2 = n2.rootBoundary, a2 = n2.padding, s2 = n2.flipVariations, f2 = n2.allowedAutoPlacements, c2 = f2 === void 0 ? Ee : f2, u2 = te(r2), m2 = u2 ? s2 ? De : De.filter(function(h2) {
          return te(h2) === u2;
        }) : G$1, v2 = m2.filter(function(h2) {
          return c2.indexOf(h2) >= 0;
        });
        v2.length === 0 && (v2 = m2);
        var l2 = v2.reduce(function(h2, p2) {
          return h2[p2] = ne(t2, { placement: p2, boundary: o2, rootBoundary: i2, padding: a2 })[q$1(p2)], h2;
        }, {});
        return Object.keys(l2).sort(function(h2, p2) {
          return l2[h2] - l2[p2];
        });
      }
      function Kt(t2) {
        if (q$1(t2) === me)
          return [];
        var e2 = be(t2);
        return [lt$1(t2), e2, lt$1(e2)];
      }
      function Qt(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = t2.name;
        if (!e2.modifiersData[r2]._skip) {
          for (var o2 = n2.mainAxis, i2 = o2 === void 0 ? true : o2, a2 = n2.altAxis, s2 = a2 === void 0 ? true : a2, f2 = n2.fallbackPlacements, c2 = n2.padding, u2 = n2.boundary, m2 = n2.rootBoundary, v2 = n2.altBoundary, l2 = n2.flipVariations, h2 = l2 === void 0 ? true : l2, p2 = n2.allowedAutoPlacements, g2 = e2.options.placement, x2 = q$1(g2), y2 = x2 === g2, $2 = f2 || (y2 || !h2 ? [be(g2)] : Kt(g2)), d2 = [g2].concat($2).reduce(function(z2, V2) {
            return z2.concat(q$1(V2) === me ? Jt(e2, { placement: V2, boundary: u2, rootBoundary: m2, padding: c2, flipVariations: h2, allowedAutoPlacements: p2 }) : V2);
          }, []), b2 = e2.rects.reference, w2 = e2.rects.popper, O2 = /* @__PURE__ */ new Map(), j2 = true, A2 = d2[0], k2 = 0; k2 < d2.length; k2++) {
            var D2 = d2[k2], S2 = q$1(D2), L2 = te(D2) === U$1, re = [E$1, R$1].indexOf(S2) >= 0, oe = re ? "width" : "height", M2 = ne(e2, { placement: D2, boundary: u2, rootBoundary: m2, altBoundary: v2, padding: c2 }), T2 = re ? L2 ? W$1 : P$1 : L2 ? R$1 : E$1;
            b2[oe] > w2[oe] && (T2 = be(T2));
            var pe = be(T2), _2 = [];
            if (i2 && _2.push(M2[S2] <= 0), s2 && _2.push(M2[T2] <= 0, M2[pe] <= 0), _2.every(function(z2) {
              return z2;
            })) {
              A2 = D2, j2 = false;
              break;
            }
            O2.set(D2, _2);
          }
          if (j2)
            for (var ue = h2 ? 3 : 1, xe = function(z2) {
              var V2 = d2.find(function(de) {
                var ae = O2.get(de);
                if (ae)
                  return ae.slice(0, z2).every(function(Y2) {
                    return Y2;
                  });
              });
              if (V2)
                return A2 = V2, "break";
            }, ie = ue; ie > 0; ie--) {
              var le = xe(ie);
              if (le === "break")
                break;
            }
          e2.placement !== A2 && (e2.modifiersData[r2]._skip = true, e2.placement = A2, e2.reset = true);
        }
      }
      var vt$1 = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
      function gt$1(t2, e2, n2) {
        return n2 === void 0 && (n2 = { x: 0, y: 0 }), { top: t2.top - e2.height - n2.y, right: t2.right - e2.width + n2.x, bottom: t2.bottom - e2.height + n2.y, left: t2.left - e2.width - n2.x };
      }
      function yt$1(t2) {
        return [E$1, W$1, R$1, P$1].some(function(e2) {
          return t2[e2] >= 0;
        });
      }
      function Zt(t2) {
        var e2 = t2.state, n2 = t2.name, r2 = e2.rects.reference, o2 = e2.rects.popper, i2 = e2.modifiersData.preventOverflow, a2 = ne(e2, { elementContext: "reference" }), s2 = ne(e2, { altBoundary: true }), f2 = gt$1(a2, r2), c2 = gt$1(s2, o2, i2), u2 = yt$1(f2), m2 = yt$1(c2);
        e2.modifiersData[n2] = { referenceClippingOffsets: f2, popperEscapeOffsets: c2, isReferenceHidden: u2, hasPopperEscaped: m2 }, e2.attributes.popper = Object.assign({}, e2.attributes.popper, { "data-popper-reference-hidden": u2, "data-popper-escaped": m2 });
      }
      var bt$1 = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
      function en(t2, e2, n2) {
        var r2 = q$1(t2), o2 = [P$1, E$1].indexOf(r2) >= 0 ? -1 : 1, i2 = typeof n2 == "function" ? n2(Object.assign({}, e2, { placement: t2 })) : n2, a2 = i2[0], s2 = i2[1];
        return a2 = a2 || 0, s2 = (s2 || 0) * o2, [P$1, W$1].indexOf(r2) >= 0 ? { x: s2, y: a2 } : { x: a2, y: s2 };
      }
      function tn(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = t2.name, o2 = n2.offset, i2 = o2 === void 0 ? [0, 0] : o2, a2 = Ee.reduce(function(u2, m2) {
          return u2[m2] = en(m2, e2.rects, i2), u2;
        }, {}), s2 = a2[e2.placement], f2 = s2.x, c2 = s2.y;
        e2.modifiersData.popperOffsets != null && (e2.modifiersData.popperOffsets.x += f2, e2.modifiersData.popperOffsets.y += c2), e2.modifiersData[r2] = a2;
      }
      var wt$1 = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
      function nn(t2) {
        var e2 = t2.state, n2 = t2.name;
        e2.modifiersData[n2] = mt$1({ reference: e2.rects.reference, element: e2.rects.popper, strategy: "absolute", placement: e2.placement });
      }
      var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
      function rn(t2) {
        return t2 === "x" ? "y" : "x";
      }
      function on(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = t2.name, o2 = n2.mainAxis, i2 = o2 === void 0 ? true : o2, a2 = n2.altAxis, s2 = a2 === void 0 ? false : a2, f2 = n2.boundary, c2 = n2.rootBoundary, u2 = n2.altBoundary, m2 = n2.padding, v2 = n2.tether, l2 = v2 === void 0 ? true : v2, h2 = n2.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g2 = ne(e2, { boundary: f2, rootBoundary: c2, padding: m2, altBoundary: u2 }), x2 = q$1(e2.placement), y2 = te(e2.placement), $2 = !y2, d2 = Le(x2), b2 = rn(d2), w2 = e2.modifiersData.popperOffsets, O2 = e2.rects.reference, j2 = e2.rects.popper, A2 = typeof p2 == "function" ? p2(Object.assign({}, e2.rects, { placement: e2.placement })) : p2, k2 = typeof A2 == "number" ? { mainAxis: A2, altAxis: A2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, A2), D2 = e2.modifiersData.offset ? e2.modifiersData.offset[e2.placement] : null, S2 = { x: 0, y: 0 };
        if (w2) {
          if (i2) {
            var L2, re = d2 === "y" ? E$1 : P$1, oe = d2 === "y" ? R$1 : W$1, M2 = d2 === "y" ? "height" : "width", T2 = w2[d2], pe = T2 + g2[re], _2 = T2 - g2[oe], ue = l2 ? -j2[M2] / 2 : 0, xe = y2 === U$1 ? O2[M2] : j2[M2], ie = y2 === U$1 ? -j2[M2] : -O2[M2], le = e2.elements.arrow, z2 = l2 && le ? ke(le) : { width: 0, height: 0 }, V2 = e2.modifiersData["arrow#persistent"] ? e2.modifiersData["arrow#persistent"].padding : st$1(), de = V2[re], ae = V2[oe], Y2 = fe(0, O2[M2], z2[M2]), jt2 = $2 ? O2[M2] / 2 - ue - Y2 - de - k2.mainAxis : xe - Y2 - de - k2.mainAxis, Dt2 = $2 ? -O2[M2] / 2 + ue + Y2 + ae + k2.mainAxis : ie + Y2 + ae + k2.mainAxis, Oe = e2.elements.arrow && se(e2.elements.arrow), Et2 = Oe ? d2 === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L2 = D2 == null ? void 0 : D2[d2]) != null ? L2 : 0, Pt2 = T2 + jt2 - Ce - Et2, At2 = T2 + Dt2 - Ce, qe = fe(l2 ? ve(pe, Pt2) : pe, T2, l2 ? X$1(_2, At2) : _2);
            w2[d2] = qe, S2[d2] = qe - T2;
          }
          if (s2) {
            var Ve, kt2 = d2 === "x" ? E$1 : P$1, Lt2 = d2 === "x" ? R$1 : W$1, F2 = w2[b2], he = b2 === "y" ? "height" : "width", Ne = F2 + g2[kt2], Ie = F2 - g2[Lt2], $e = [E$1, P$1].indexOf(x2) !== -1, _e = (Ve = D2 == null ? void 0 : D2[b2]) != null ? Ve : 0, ze = $e ? Ne : F2 - O2[he] - j2[he] - _e + k2.altAxis, Fe = $e ? F2 + O2[he] + j2[he] - _e - k2.altAxis : Ie, Ue = l2 && $e ? St$1(ze, F2, Fe) : fe(l2 ? ze : Ne, F2, l2 ? Fe : Ie);
            w2[b2] = Ue, S2[b2] = Ue - F2;
          }
          e2.modifiersData[r2] = S2;
        }
      }
      var xt$1 = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
      function an(t2) {
        return { scrollLeft: t2.scrollLeft, scrollTop: t2.scrollTop };
      }
      function sn(t2) {
        return t2 === H$1(t2) || !B$1(t2) ? We(t2) : an(t2);
      }
      function fn(t2) {
        var e2 = t2.getBoundingClientRect(), n2 = Z$1(e2.width) / t2.offsetWidth || 1, r2 = Z$1(e2.height) / t2.offsetHeight || 1;
        return n2 !== 1 || r2 !== 1;
      }
      function cn(t2, e2, n2) {
        n2 === void 0 && (n2 = false);
        var r2 = B$1(e2), o2 = B$1(e2) && fn(e2), i2 = I$1(e2), a2 = ee(t2, o2), s2 = { scrollLeft: 0, scrollTop: 0 }, f2 = { x: 0, y: 0 };
        return (r2 || !r2 && !n2) && ((C$1(e2) !== "body" || Se(i2)) && (s2 = sn(e2)), B$1(e2) ? (f2 = ee(e2, true), f2.x += e2.clientLeft, f2.y += e2.clientTop) : i2 && (f2.x = Be(i2))), { x: a2.left + s2.scrollLeft - f2.x, y: a2.top + s2.scrollTop - f2.y, width: a2.width, height: a2.height };
      }
      function pn(t2) {
        var e2 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Set(), r2 = [];
        t2.forEach(function(i2) {
          e2.set(i2.name, i2);
        });
        function o2(i2) {
          n2.add(i2.name);
          var a2 = [].concat(i2.requires || [], i2.requiresIfExists || []);
          a2.forEach(function(s2) {
            if (!n2.has(s2)) {
              var f2 = e2.get(s2);
              f2 && o2(f2);
            }
          }), r2.push(i2);
        }
        return t2.forEach(function(i2) {
          n2.has(i2.name) || o2(i2);
        }), r2;
      }
      function un(t2) {
        var e2 = pn(t2);
        return ot$1.reduce(function(n2, r2) {
          return n2.concat(e2.filter(function(o2) {
            return o2.phase === r2;
          }));
        }, []);
      }
      function ln(t2) {
        var e2;
        return function() {
          return e2 || (e2 = new Promise(function(n2) {
            Promise.resolve().then(function() {
              e2 = void 0, n2(t2());
            });
          })), e2;
        };
      }
      function dn(t2) {
        var e2 = t2.reduce(function(n2, r2) {
          var o2 = n2[r2.name];
          return n2[r2.name] = o2 ? Object.assign({}, o2, r2, { options: Object.assign({}, o2.options, r2.options), data: Object.assign({}, o2.data, r2.data) }) : r2, n2;
        }, {});
        return Object.keys(e2).map(function(n2) {
          return e2[n2];
        });
      }
      var Ot$1 = { placement: "bottom", modifiers: [], strategy: "absolute" };
      function $t() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++)
          e2[n2] = arguments[n2];
        return !e2.some(function(r2) {
          return !(r2 && typeof r2.getBoundingClientRect == "function");
        });
      }
      function we(t2) {
        t2 === void 0 && (t2 = {});
        var e2 = t2, n2 = e2.defaultModifiers, r2 = n2 === void 0 ? [] : n2, o2 = e2.defaultOptions, i2 = o2 === void 0 ? Ot$1 : o2;
        return function(a2, s2, f2) {
          f2 === void 0 && (f2 = i2);
          var c2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot$1, i2), modifiersData: {}, elements: { reference: a2, popper: s2 }, attributes: {}, styles: {} }, u2 = [], m2 = false, v2 = { state: c2, setOptions: function(p2) {
            var g2 = typeof p2 == "function" ? p2(c2.options) : p2;
            h2(), c2.options = Object.assign({}, i2, c2.options, g2), c2.scrollParents = { reference: Q$1(a2) ? ce(a2) : a2.contextElement ? ce(a2.contextElement) : [], popper: ce(s2) };
            var x2 = un(dn([].concat(r2, c2.options.modifiers)));
            return c2.orderedModifiers = x2.filter(function(y2) {
              return y2.enabled;
            }), l2(), v2.update();
          }, forceUpdate: function() {
            if (!m2) {
              var p2 = c2.elements, g2 = p2.reference, x2 = p2.popper;
              if ($t(g2, x2)) {
                c2.rects = { reference: cn(g2, se(x2), c2.options.strategy === "fixed"), popper: ke(x2) }, c2.reset = false, c2.placement = c2.options.placement, c2.orderedModifiers.forEach(function(j2) {
                  return c2.modifiersData[j2.name] = Object.assign({}, j2.data);
                });
                for (var y2 = 0; y2 < c2.orderedModifiers.length; y2++) {
                  if (c2.reset === true) {
                    c2.reset = false, y2 = -1;
                    continue;
                  }
                  var $2 = c2.orderedModifiers[y2], d2 = $2.fn, b2 = $2.options, w2 = b2 === void 0 ? {} : b2, O2 = $2.name;
                  typeof d2 == "function" && (c2 = d2({ state: c2, options: w2, name: O2, instance: v2 }) || c2);
                }
              }
            }
          }, update: ln(function() {
            return new Promise(function(p2) {
              v2.forceUpdate(), p2(c2);
            });
          }), destroy: function() {
            h2(), m2 = true;
          } };
          if (!$t(a2, s2))
            return v2;
          v2.setOptions(f2).then(function(p2) {
            !m2 && f2.onFirstUpdate && f2.onFirstUpdate(p2);
          });
          function l2() {
            c2.orderedModifiers.forEach(function(p2) {
              var g2 = p2.name, x2 = p2.options, y2 = x2 === void 0 ? {} : x2, $2 = p2.effect;
              if (typeof $2 == "function") {
                var d2 = $2({ state: c2, name: g2, instance: v2, options: y2 }), b2 = function() {
                };
                u2.push(d2 || b2);
              }
            });
          }
          function h2() {
            u2.forEach(function(p2) {
              return p2();
            }), u2 = [];
          }
          return v2;
        };
      }
      we();
      var mn = [Re, He, Me, Ae];
      we({ defaultModifiers: mn });
      var gn = [Re, He, Me, Ae, wt$1, vt$1, xt$1, pt$1, bt$1], yn = we({ defaultModifiers: gn });
      const usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
        const stateUpdater = {
          name: "updateState",
          enabled: true,
          phase: "write",
          fn: ({ state }) => {
            const derivedState = deriveState(state);
            Object.assign(states.value, derivedState);
          },
          requires: ["computeStyles"]
        };
        const options = computed(() => {
          const { onFirstUpdate, placement, strategy, modifiers } = unref(opts);
          return {
            onFirstUpdate,
            placement: placement || "bottom",
            strategy: strategy || "absolute",
            modifiers: [
              ...modifiers || [],
              stateUpdater,
              { name: "applyStyles", enabled: false }
            ]
          };
        });
        const instanceRef = shallowRef();
        const states = ref({
          styles: {
            popper: {
              position: unref(options).strategy,
              left: "0",
              top: "0"
            },
            arrow: {
              position: "absolute"
            }
          },
          attributes: {}
        });
        const destroy = () => {
          if (!instanceRef.value)
            return;
          instanceRef.value.destroy();
          instanceRef.value = void 0;
        };
        watch(options, (newOptions) => {
          const instance = unref(instanceRef);
          if (instance) {
            instance.setOptions(newOptions);
          }
        }, {
          deep: true
        });
        watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
          destroy();
          if (!referenceElement || !popperElement)
            return;
          instanceRef.value = yn(referenceElement, popperElement, unref(options));
        });
        onBeforeUnmount(() => {
          destroy();
        });
        return {
          state: computed(() => {
            var _a2;
            return { ...((_a2 = unref(instanceRef)) == null ? void 0 : _a2.state) || {} };
          }),
          styles: computed(() => unref(states).styles),
          attributes: computed(() => unref(states).attributes),
          update: () => {
            var _a2;
            return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.update();
          },
          forceUpdate: () => {
            var _a2;
            return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.forceUpdate();
          },
          instanceRef: computed(() => unref(instanceRef))
        };
      };
      function deriveState(state) {
        const elements = Object.keys(state.elements);
        const styles = fromPairs(elements.map((element) => [element, state.styles[element] || {}]));
        const attributes = fromPairs(elements.map((element) => [element, state.attributes[element]]));
        return {
          styles,
          attributes
        };
      }
      const useSameTarget = (handleClick) => {
        if (!handleClick) {
          return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
        }
        let mousedownTarget = false;
        let mouseupTarget = false;
        const onClick = (e2) => {
          if (mousedownTarget && mouseupTarget) {
            handleClick(e2);
          }
          mousedownTarget = mouseupTarget = false;
        };
        const onMousedown = (e2) => {
          mousedownTarget = e2.target === e2.currentTarget;
        };
        const onMouseup = (e2) => {
          mouseupTarget = e2.target === e2.currentTarget;
        };
        return { onClick, onMousedown, onMouseup };
      };
      function useTimeout() {
        let timeoutHandle;
        const registerTimeout = (fn2, delay) => {
          cancelTimeout();
          timeoutHandle = window.setTimeout(fn2, delay);
        };
        const cancelTimeout = () => window.clearTimeout(timeoutHandle);
        tryOnScopeDispose$1(() => cancelTimeout());
        return {
          registerTimeout,
          cancelTimeout
        };
      }
      const defaultIdInjection = {
        prefix: Math.floor(Math.random() * 1e4),
        current: 0
      };
      const ID_INJECTION_KEY = Symbol("elIdInjection");
      const useIdInjection = () => {
        return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
      };
      const useId = (deterministicId) => {
        const idInjection = useIdInjection();
        const namespace = useGetDerivedNamespace();
        const idRef = computed(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
        return idRef;
      };
      let registeredEscapeHandlers = [];
      const cachedHandler = (e2) => {
        const event = e2;
        if (event.key === EVENT_CODE.esc) {
          registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
        }
      };
      const useEscapeKeydown = (handler) => {
        onMounted(() => {
          if (registeredEscapeHandlers.length === 0) {
            document.addEventListener("keydown", cachedHandler);
          }
          if (isClient$1)
            registeredEscapeHandlers.push(handler);
        });
        onBeforeUnmount(() => {
          registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
          if (registeredEscapeHandlers.length === 0) {
            if (isClient$1)
              document.removeEventListener("keydown", cachedHandler);
          }
        });
      };
      let cachedContainer;
      const usePopperContainerId = () => {
        const namespace = useGetDerivedNamespace();
        const idInjection = useIdInjection();
        const id2 = computed(() => {
          return `${namespace.value}-popper-container-${idInjection.prefix}`;
        });
        const selector = computed(() => `#${id2.value}`);
        return {
          id: id2,
          selector
        };
      };
      const createContainer = (id2) => {
        const container = document.createElement("div");
        container.id = id2;
        document.body.appendChild(container);
        return container;
      };
      const usePopperContainer = () => {
        const { id: id2, selector } = usePopperContainerId();
        onBeforeMount(() => {
          if (!isClient$1)
            return;
          if (!cachedContainer && !document.body.querySelector(selector.value)) {
            cachedContainer = createContainer(id2.value);
          }
        });
        return {
          id: id2,
          selector
        };
      };
      const useDelayedToggleProps = buildProps({
        showAfter: {
          type: Number,
          default: 0
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        autoClose: {
          type: Number,
          default: 0
        }
      });
      const useDelayedToggle = ({
        showAfter,
        hideAfter,
        autoClose,
        open: open2,
        close: close2
      }) => {
        const { registerTimeout } = useTimeout();
        const {
          registerTimeout: registerTimeoutForAutoClose,
          cancelTimeout: cancelTimeoutForAutoClose
        } = useTimeout();
        const onOpen = (event) => {
          registerTimeout(() => {
            open2(event);
            const _autoClose = unref(autoClose);
            if (isNumber(_autoClose) && _autoClose > 0) {
              registerTimeoutForAutoClose(() => {
                close2(event);
              }, _autoClose);
            }
          }, unref(showAfter));
        };
        const onClose = (event) => {
          cancelTimeoutForAutoClose();
          registerTimeout(() => {
            close2(event);
          }, unref(hideAfter));
        };
        return {
          onOpen,
          onClose
        };
      };
      const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
      const useForwardRef = (forwardRef) => {
        const setForwardRef = (el) => {
          forwardRef.value = el;
        };
        provide(FORWARD_REF_INJECTION_KEY, {
          setForwardRef
        });
      };
      const useForwardRefDirective = (setForwardRef) => {
        return {
          mounted(el) {
            setForwardRef(el);
          },
          updated(el) {
            setForwardRef(el);
          },
          unmounted() {
            setForwardRef(null);
          }
        };
      };
      const zIndex = ref(0);
      const defaultInitialZIndex = 2e3;
      const zIndexContextKey = Symbol("zIndexContextKey");
      const useZIndex = (zIndexOverrides) => {
        const zIndexInjection = zIndexOverrides || inject(zIndexContextKey, void 0);
        const initialZIndex = computed(() => {
          const zIndexFromInjection = unref(zIndexInjection);
          return isNumber(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
        });
        const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
        const nextZIndex = () => {
          zIndex.value++;
          return currentZIndex.value;
        };
        return {
          initialZIndex,
          currentZIndex,
          nextZIndex
        };
      };
      function useCursor(input) {
        const selectionRef = ref();
        function recordCursor() {
          if (input.value == void 0)
            return;
          const { selectionStart, selectionEnd, value } = input.value;
          if (selectionStart == null || selectionEnd == null)
            return;
          const beforeTxt = value.slice(0, Math.max(0, selectionStart));
          const afterTxt = value.slice(Math.max(0, selectionEnd));
          selectionRef.value = {
            selectionStart,
            selectionEnd,
            value,
            beforeTxt,
            afterTxt
          };
        }
        function setCursor() {
          if (input.value == void 0 || selectionRef.value == void 0)
            return;
          const { value } = input.value;
          const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
          if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
            return;
          let startPos = value.length;
          if (value.endsWith(afterTxt)) {
            startPos = value.length - afterTxt.length;
          } else if (value.startsWith(beforeTxt)) {
            startPos = beforeTxt.length;
          } else {
            const beforeLastChar = beforeTxt[selectionStart - 1];
            const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
            if (newIndex !== -1) {
              startPos = newIndex + 1;
            }
          }
          input.value.setSelectionRange(startPos, startPos);
        }
        return [recordCursor, setCursor];
      }
      const getOrderedChildren = (vm, childComponentName, children) => {
        const nodes = flattedChildren(vm.subTree).filter((n2) => {
          var _a2;
          return isVNode(n2) && ((_a2 = n2.type) == null ? void 0 : _a2.name) === childComponentName && !!n2.component;
        });
        const uids = nodes.map((n2) => n2.component.uid);
        return uids.map((uid2) => children[uid2]).filter((p2) => !!p2);
      };
      const useOrderedChildren = (vm, childComponentName) => {
        const children = {};
        const orderedChildren = shallowRef([]);
        const addChild = (child) => {
          children[child.uid] = child;
          orderedChildren.value = getOrderedChildren(vm, childComponentName, children);
        };
        const removeChild = (uid2) => {
          delete children[uid2];
          orderedChildren.value = orderedChildren.value.filter((children2) => children2.uid !== uid2);
        };
        return {
          children: orderedChildren,
          addChild,
          removeChild
        };
      };
      const useSizeProp = buildProp({
        type: String,
        values: componentSizes,
        required: false
      });
      const SIZE_INJECTION_KEY = Symbol("size");
      const useGlobalSize = () => {
        const injectedSize = inject(SIZE_INJECTION_KEY, {});
        return computed(() => {
          return unref(injectedSize.size) || "";
        });
      };
      function useFocusController(target, { afterFocus, afterBlur } = {}) {
        const instance = getCurrentInstance();
        const { emit: emit2 } = instance;
        const wrapperRef = shallowRef();
        const isFocused = ref(false);
        const handleFocus = (event) => {
          if (isFocused.value)
            return;
          isFocused.value = true;
          emit2("focus", event);
          afterFocus == null ? void 0 : afterFocus();
        };
        const handleBlur = (event) => {
          var _a2;
          if (event.relatedTarget && ((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(event.relatedTarget)))
            return;
          isFocused.value = false;
          emit2("blur", event);
          afterBlur == null ? void 0 : afterBlur();
        };
        const handleClick = () => {
          var _a2;
          (_a2 = target.value) == null ? void 0 : _a2.focus();
        };
        watch(wrapperRef, (el) => {
          if (el) {
            el.setAttribute("role", "button");
            el.setAttribute("tabindex", "-1");
          }
        });
        useEventListener$1(wrapperRef, "click", handleClick);
        return {
          wrapperRef,
          isFocused,
          handleFocus,
          handleBlur
        };
      }
      const configProviderContextKey = Symbol();
      const globalConfig = ref();
      function useGlobalConfig(key, defaultValue = void 0) {
        const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
        if (key) {
          return computed(() => {
            var _a2, _b;
            return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
          });
        } else {
          return config;
        }
      }
      function useGlobalComponentSettings(block, sizeFallback) {
        const config = useGlobalConfig();
        const ns = useNamespace(block, computed(() => {
          var _a2;
          return ((_a2 = config.value) == null ? void 0 : _a2.namespace) || defaultNamespace;
        }));
        const locale = useLocale(computed(() => {
          var _a2;
          return (_a2 = config.value) == null ? void 0 : _a2.locale;
        }));
        const zIndex2 = useZIndex(computed(() => {
          var _a2;
          return ((_a2 = config.value) == null ? void 0 : _a2.zIndex) || defaultInitialZIndex;
        }));
        const size2 = computed(() => {
          var _a2;
          return unref(sizeFallback) || ((_a2 = config.value) == null ? void 0 : _a2.size) || "";
        });
        provideGlobalConfig(computed(() => unref(config) || {}));
        return {
          ns,
          locale,
          zIndex: zIndex2,
          size: size2
        };
      }
      const provideGlobalConfig = (config, app2, global2 = false) => {
        var _a2;
        const inSetup = !!getCurrentInstance();
        const oldConfig = inSetup ? useGlobalConfig() : void 0;
        const provideFn = (_a2 = app2 == null ? void 0 : app2.provide) != null ? _a2 : inSetup ? provide : void 0;
        if (!provideFn) {
          return;
        }
        const context2 = computed(() => {
          const cfg = unref(config);
          if (!(oldConfig == null ? void 0 : oldConfig.value))
            return cfg;
          return mergeConfig(oldConfig.value, cfg);
        });
        provideFn(configProviderContextKey, context2);
        provideFn(localeContextKey, computed(() => context2.value.locale));
        provideFn(namespaceContextKey, computed(() => context2.value.namespace));
        provideFn(zIndexContextKey, computed(() => context2.value.zIndex));
        provideFn(SIZE_INJECTION_KEY, {
          size: computed(() => context2.value.size || "")
        });
        if (global2 || !globalConfig.value) {
          globalConfig.value = context2.value;
        }
        return context2;
      };
      const mergeConfig = (a2, b2) => {
        var _a2;
        const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a2), ...keysOf(b2)])];
        const obj = {};
        for (const key of keys2) {
          obj[key] = (_a2 = b2[key]) != null ? _a2 : a2[key];
        }
        return obj;
      };
      const messageConfig = {};
      var _export_sfc$1 = (sfc, props2) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props2) {
          target[key] = val;
        }
        return target;
      };
      const iconProps = buildProps({
        size: {
          type: definePropType([Number, String])
        },
        color: {
          type: String
        }
      });
      const __default__$C = defineComponent({
        name: "ElIcon",
        inheritAttrs: false
      });
      const _sfc_main$13 = /* @__PURE__ */ defineComponent({
        ...__default__$C,
        props: iconProps,
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("icon");
          const style = computed(() => {
            const { size: size2, color } = props2;
            if (!size2 && !color)
              return {};
            return {
              fontSize: isUndefined(size2) ? void 0 : addUnit(size2),
              "--color": color
            };
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("i", mergeProps({
              class: unref(ns).b(),
              style: unref(style)
            }, _ctx.$attrs), [
              renderSlot(_ctx.$slots, "default")
            ], 16);
          };
        }
      });
      var Icon = /* @__PURE__ */ _export_sfc$1(_sfc_main$13, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
      const ElIcon = withInstall(Icon);
      const formContextKey = Symbol("formContextKey");
      const formItemContextKey = Symbol("formItemContextKey");
      const useFormSize = (fallback, ignore = {}) => {
        const emptyRef = ref(void 0);
        const size2 = ignore.prop ? emptyRef : useProp("size");
        const globalConfig2 = ignore.global ? emptyRef : useGlobalSize();
        const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
        const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
        return computed(() => size2.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
      };
      const useFormDisabled = (fallback) => {
        const disabled = useProp("disabled");
        const form = inject(formContextKey, void 0);
        return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
      };
      const useFormItem = () => {
        const form = inject(formContextKey, void 0);
        const formItem = inject(formItemContextKey, void 0);
        return {
          form,
          formItem
        };
      };
      const useFormItemInputId = (props2, {
        formItemContext,
        disableIdGeneration,
        disableIdManagement
      }) => {
        if (!disableIdGeneration) {
          disableIdGeneration = ref(false);
        }
        if (!disableIdManagement) {
          disableIdManagement = ref(false);
        }
        const inputId = ref();
        let idUnwatch = void 0;
        const isLabeledByFormItem = computed(() => {
          var _a2;
          return !!(!props2.label && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
        });
        onMounted(() => {
          idUnwatch = watch([toRef$1(props2, "id"), disableIdGeneration], ([id2, disableIdGeneration2]) => {
            const newId = id2 != null ? id2 : !disableIdGeneration2 ? useId().value : void 0;
            if (newId !== inputId.value) {
              if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
                inputId.value && formItemContext.removeInputId(inputId.value);
                if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                  formItemContext.addInputId(newId);
                }
              }
              inputId.value = newId;
            }
          }, { immediate: true });
        });
        onUnmounted(() => {
          idUnwatch && idUnwatch();
          if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
            inputId.value && formItemContext.removeInputId(inputId.value);
          }
        });
        return {
          isLabeledByFormItem,
          inputId
        };
      };
      const formMetaProps = buildProps({
        size: {
          type: String,
          values: componentSizes
        },
        disabled: Boolean
      });
      const formProps = buildProps({
        ...formMetaProps,
        model: Object,
        rules: {
          type: definePropType(Object)
        },
        labelPosition: {
          type: String,
          values: ["left", "right", "top"],
          default: "right"
        },
        requireAsteriskPosition: {
          type: String,
          values: ["left", "right"],
          default: "left"
        },
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        labelSuffix: {
          type: String,
          default: ""
        },
        inline: Boolean,
        inlineMessage: Boolean,
        statusIcon: Boolean,
        showMessage: {
          type: Boolean,
          default: true
        },
        validateOnRuleChange: {
          type: Boolean,
          default: true
        },
        hideRequiredAsterisk: Boolean,
        scrollToError: Boolean,
        scrollIntoViewOptions: {
          type: [Object, Boolean]
        }
      });
      const formEmits = {
        validate: (prop, isValid, message2) => (isArray$3(prop) || isString$2(prop)) && isBoolean(isValid) && isString$2(message2)
      };
      function useFormLabelWidth() {
        const potentialLabelWidthArr = ref([]);
        const autoLabelWidth = computed(() => {
          if (!potentialLabelWidthArr.value.length)
            return "0";
          const max = Math.max(...potentialLabelWidthArr.value);
          return max ? `${max}px` : "";
        });
        function getLabelWidthIndex(width) {
          const index = potentialLabelWidthArr.value.indexOf(width);
          if (index === -1 && autoLabelWidth.value === "0")
            ;
          return index;
        }
        function registerLabelWidth(val, oldVal) {
          if (val && oldVal) {
            const index = getLabelWidthIndex(oldVal);
            potentialLabelWidthArr.value.splice(index, 1, val);
          } else if (val) {
            potentialLabelWidthArr.value.push(val);
          }
        }
        function deregisterLabelWidth(val) {
          const index = getLabelWidthIndex(val);
          if (index > -1) {
            potentialLabelWidthArr.value.splice(index, 1);
          }
        }
        return {
          autoLabelWidth,
          registerLabelWidth,
          deregisterLabelWidth
        };
      }
      const filterFields = (fields, props2) => {
        const normalized = castArray(props2);
        return normalized.length > 0 ? fields.filter((field) => field.prop && normalized.includes(field.prop)) : fields;
      };
      const COMPONENT_NAME$7 = "ElForm";
      const __default__$B = defineComponent({
        name: COMPONENT_NAME$7
      });
      const _sfc_main$12 = /* @__PURE__ */ defineComponent({
        ...__default__$B,
        props: formProps,
        emits: formEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props2 = __props;
          const fields = [];
          const formSize = useFormSize();
          const ns = useNamespace("form");
          const formClasses = computed(() => {
            const { labelPosition, inline } = props2;
            return [
              ns.b(),
              ns.m(formSize.value || "default"),
              {
                [ns.m(`label-${labelPosition}`)]: labelPosition,
                [ns.m("inline")]: inline
              }
            ];
          });
          const addField = (field) => {
            fields.push(field);
          };
          const removeField = (field) => {
            if (field.prop) {
              fields.splice(fields.indexOf(field), 1);
            }
          };
          const resetFields = (properties = []) => {
            if (!props2.model) {
              return;
            }
            filterFields(fields, properties).forEach((field) => field.resetField());
          };
          const clearValidate = (props22 = []) => {
            filterFields(fields, props22).forEach((field) => field.clearValidate());
          };
          const isValidatable = computed(() => {
            const hasModel = !!props2.model;
            return hasModel;
          });
          const obtainValidateFields = (props22) => {
            if (fields.length === 0)
              return [];
            const filteredFields = filterFields(fields, props22);
            if (!filteredFields.length) {
              return [];
            }
            return filteredFields;
          };
          const validate = async (callback) => validateField(void 0, callback);
          const doValidateField = async (props22 = []) => {
            if (!isValidatable.value)
              return false;
            const fields2 = obtainValidateFields(props22);
            if (fields2.length === 0)
              return true;
            let validationErrors = {};
            for (const field of fields2) {
              try {
                await field.validate("");
              } catch (fields3) {
                validationErrors = {
                  ...validationErrors,
                  ...fields3
                };
              }
            }
            if (Object.keys(validationErrors).length === 0)
              return true;
            return Promise.reject(validationErrors);
          };
          const validateField = async (modelProps = [], callback) => {
            const shouldThrow = !isFunction$2(callback);
            try {
              const result = await doValidateField(modelProps);
              if (result === true) {
                callback == null ? void 0 : callback(result);
              }
              return result;
            } catch (e2) {
              if (e2 instanceof Error)
                throw e2;
              const invalidFields = e2;
              if (props2.scrollToError) {
                scrollToField(Object.keys(invalidFields)[0]);
              }
              callback == null ? void 0 : callback(false, invalidFields);
              return shouldThrow && Promise.reject(invalidFields);
            }
          };
          const scrollToField = (prop) => {
            var _a2;
            const field = filterFields(fields, prop)[0];
            if (field) {
              (_a2 = field.$el) == null ? void 0 : _a2.scrollIntoView(props2.scrollIntoViewOptions);
            }
          };
          watch(() => props2.rules, () => {
            if (props2.validateOnRuleChange) {
              validate().catch((err) => debugWarn());
            }
          }, { deep: true });
          provide(formContextKey, reactive({
            ...toRefs$1(props2),
            emit: emit2,
            resetFields,
            clearValidate,
            validateField,
            addField,
            removeField,
            ...useFormLabelWidth()
          }));
          expose({
            validate,
            validateField,
            resetFields,
            clearValidate,
            scrollToField
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("form", {
              class: normalizeClass(unref(formClasses))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Form = /* @__PURE__ */ _export_sfc$1(_sfc_main$12, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form.vue"]]);
      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o2) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
          return o3.__proto__ || Object.getPrototypeOf(o3);
        };
        return _getPrototypeOf(o2);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e2) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a2 = [null];
            a2.push.apply(a2, args2);
            var Constructor = Function.bind.apply(Parent2, a2);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn2) {
        return Function.toString.call(fn2).indexOf("[native code]") !== -1;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2))
            return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2))
              return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      var formatRegExp = /%[sdj%]/g;
      var warning = function warning2() {
      };
      if (typeof process !== "undefined" && process.env && false) {
        warning = function warning2(type2, errors) {
          if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
            if (errors.every(function(e2) {
              return typeof e2 === "string";
            })) {
              console.warn(type2, errors);
            }
          }
        };
      }
      function convertFieldsError(errors) {
        if (!errors || !errors.length)
          return null;
        var fields = {};
        errors.forEach(function(error) {
          var field = error.field;
          fields[field] = fields[field] || [];
          fields[field].push(error);
        });
        return fields;
      }
      function format(template) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var i2 = 0;
        var len = args.length;
        if (typeof template === "function") {
          return template.apply(null, args);
        }
        if (typeof template === "string") {
          var str = template.replace(formatRegExp, function(x2) {
            if (x2 === "%%") {
              return "%";
            }
            if (i2 >= len) {
              return x2;
            }
            switch (x2) {
              case "%s":
                return String(args[i2++]);
              case "%d":
                return Number(args[i2++]);
              case "%j":
                try {
                  return JSON.stringify(args[i2++]);
                } catch (_2) {
                  return "[Circular]";
                }
                break;
              default:
                return x2;
            }
          });
          return str;
        }
        return template;
      }
      function isNativeStringType(type2) {
        return type2 === "string" || type2 === "url" || type2 === "hex" || type2 === "email" || type2 === "date" || type2 === "pattern";
      }
      function isEmptyValue(value, type2) {
        if (value === void 0 || value === null) {
          return true;
        }
        if (type2 === "array" && Array.isArray(value) && !value.length) {
          return true;
        }
        if (isNativeStringType(type2) && typeof value === "string" && !value) {
          return true;
        }
        return false;
      }
      function asyncParallelArray(arr, func, callback) {
        var results = [];
        var total2 = 0;
        var arrLength = arr.length;
        function count(errors) {
          results.push.apply(results, errors || []);
          total2++;
          if (total2 === arrLength) {
            callback(results);
          }
        }
        arr.forEach(function(a2) {
          func(a2, count);
        });
      }
      function asyncSerialArray(arr, func, callback) {
        var index = 0;
        var arrLength = arr.length;
        function next(errors) {
          if (errors && errors.length) {
            callback(errors);
            return;
          }
          var original = index;
          index = index + 1;
          if (original < arrLength) {
            func(arr[original], next);
          } else {
            callback([]);
          }
        }
        next([]);
      }
      function flattenObjArr(objArr) {
        var ret = [];
        Object.keys(objArr).forEach(function(k2) {
          ret.push.apply(ret, objArr[k2] || []);
        });
        return ret;
      }
      var AsyncValidationError = /* @__PURE__ */ function(_Error) {
        _inheritsLoose(AsyncValidationError2, _Error);
        function AsyncValidationError2(errors, fields) {
          var _this;
          _this = _Error.call(this, "Async Validation Error") || this;
          _this.errors = errors;
          _this.fields = fields;
          return _this;
        }
        return AsyncValidationError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      function asyncMap(objArr, option, func, callback, source) {
        if (option.first) {
          var _pending = new Promise(function(resolve2, reject) {
            var next = function next2(errors) {
              callback(errors);
              return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source);
            };
            var flattenArr = flattenObjArr(objArr);
            asyncSerialArray(flattenArr, func, next);
          });
          _pending["catch"](function(e2) {
            return e2;
          });
          return _pending;
        }
        var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
        var objArrKeys = Object.keys(objArr);
        var objArrLength = objArrKeys.length;
        var total2 = 0;
        var results = [];
        var pending = new Promise(function(resolve2, reject) {
          var next = function next2(errors) {
            results.push.apply(results, errors);
            total2++;
            if (total2 === objArrLength) {
              callback(results);
              return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source);
            }
          };
          if (!objArrKeys.length) {
            callback(results);
            resolve2(source);
          }
          objArrKeys.forEach(function(key) {
            var arr = objArr[key];
            if (firstFields.indexOf(key) !== -1) {
              asyncSerialArray(arr, func, next);
            } else {
              asyncParallelArray(arr, func, next);
            }
          });
        });
        pending["catch"](function(e2) {
          return e2;
        });
        return pending;
      }
      function isErrorObj(obj) {
        return !!(obj && obj.message !== void 0);
      }
      function getValue(value, path) {
        var v2 = value;
        for (var i2 = 0; i2 < path.length; i2++) {
          if (v2 == void 0) {
            return v2;
          }
          v2 = v2[path[i2]];
        }
        return v2;
      }
      function complementError(rule, source) {
        return function(oe) {
          var fieldValue;
          if (rule.fullFields) {
            fieldValue = getValue(source, rule.fullFields);
          } else {
            fieldValue = source[oe.field || rule.fullField];
          }
          if (isErrorObj(oe)) {
            oe.field = oe.field || rule.fullField;
            oe.fieldValue = fieldValue;
            return oe;
          }
          return {
            message: typeof oe === "function" ? oe() : oe,
            fieldValue,
            field: oe.field || rule.fullField
          };
        };
      }
      function deepMerge(target, source) {
        if (source) {
          for (var s2 in source) {
            if (source.hasOwnProperty(s2)) {
              var value = source[s2];
              if (typeof value === "object" && typeof target[s2] === "object") {
                target[s2] = _extends({}, target[s2], value);
              } else {
                target[s2] = value;
              }
            }
          }
        }
        return target;
      }
      var required$1 = function required2(rule, value, source, errors, options, type2) {
        if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type2 || rule.type))) {
          errors.push(format(options.messages.required, rule.fullField));
        }
      };
      var whitespace = function whitespace2(rule, value, source, errors, options) {
        if (/^\s+$/.test(value) || value === "") {
          errors.push(format(options.messages.whitespace, rule.fullField));
        }
      };
      var urlReg;
      var getUrlRegex = function() {
        if (urlReg) {
          return urlReg;
        }
        var word = "[a-fA-F\\d:]";
        var b2 = function b3(options) {
          return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
        };
        var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
        var v6seg = "[a-fA-F\\d]{1,4}";
        var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
        var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
        var v4exact = new RegExp("^" + v4 + "$");
        var v6exact = new RegExp("^" + v6 + "$");
        var ip = function ip2(options) {
          return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
        };
        ip.v4 = function(options) {
          return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
        };
        ip.v6 = function(options) {
          return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
        };
        var protocol = "(?:(?:[a-z]+:)?//)";
        var auth = "(?:\\S+(?::\\S*)?@)?";
        var ipv4 = ip.v4().source;
        var ipv6 = ip.v6().source;
        var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
        var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
        var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
        var port = "(?::\\d{2,5})?";
        var path = '(?:[/?#][^\\s"]*)?';
        var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
        urlReg = new RegExp("(?:^" + regex + "$)", "i");
        return urlReg;
      };
      var pattern$2 = {
        // http://emailregex.com/
        email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
        // url: new RegExp(
        //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
        //   'i',
        // ),
        hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
      };
      var types = {
        integer: function integer2(value) {
          return types.number(value) && parseInt(value, 10) === value;
        },
        "float": function float(value) {
          return types.number(value) && !types.integer(value);
        },
        array: function array2(value) {
          return Array.isArray(value);
        },
        regexp: function regexp2(value) {
          if (value instanceof RegExp) {
            return true;
          }
          try {
            return !!new RegExp(value);
          } catch (e2) {
            return false;
          }
        },
        date: function date2(value) {
          return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
        },
        number: function number2(value) {
          if (isNaN(value)) {
            return false;
          }
          return typeof value === "number";
        },
        object: function object2(value) {
          return typeof value === "object" && !types.array(value);
        },
        method: function method2(value) {
          return typeof value === "function";
        },
        email: function email(value) {
          return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
        },
        url: function url(value) {
          return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
        },
        hex: function hex(value) {
          return typeof value === "string" && !!value.match(pattern$2.hex);
        }
      };
      var type$1 = function type2(rule, value, source, errors, options) {
        if (rule.required && value === void 0) {
          required$1(rule, value, source, errors, options);
          return;
        }
        var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
        var ruleType = rule.type;
        if (custom.indexOf(ruleType) > -1) {
          if (!types[ruleType](value)) {
            errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
          }
        } else if (ruleType && typeof value !== rule.type) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      };
      var range = function range2(rule, value, source, errors, options) {
        var len = typeof rule.len === "number";
        var min = typeof rule.min === "number";
        var max = typeof rule.max === "number";
        var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var val = value;
        var key = null;
        var num = typeof value === "number";
        var str = typeof value === "string";
        var arr = Array.isArray(value);
        if (num) {
          key = "number";
        } else if (str) {
          key = "string";
        } else if (arr) {
          key = "array";
        }
        if (!key) {
          return false;
        }
        if (arr) {
          val = value.length;
        }
        if (str) {
          val = value.replace(spRegexp, "_").length;
        }
        if (len) {
          if (val !== rule.len) {
            errors.push(format(options.messages[key].len, rule.fullField, rule.len));
          }
        } else if (min && !max && val < rule.min) {
          errors.push(format(options.messages[key].min, rule.fullField, rule.min));
        } else if (max && !min && val > rule.max) {
          errors.push(format(options.messages[key].max, rule.fullField, rule.max));
        } else if (min && max && (val < rule.min || val > rule.max)) {
          errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
        }
      };
      var ENUM$1 = "enum";
      var enumerable$1 = function enumerable2(rule, value, source, errors, options) {
        rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
        if (rule[ENUM$1].indexOf(value) === -1) {
          errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
        }
      };
      var pattern$1 = function pattern2(rule, value, source, errors, options) {
        if (rule.pattern) {
          if (rule.pattern instanceof RegExp) {
            rule.pattern.lastIndex = 0;
            if (!rule.pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          } else if (typeof rule.pattern === "string") {
            var _pattern = new RegExp(rule.pattern);
            if (!_pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          }
        }
      };
      var rules = {
        required: required$1,
        whitespace,
        type: type$1,
        range,
        "enum": enumerable$1,
        pattern: pattern$1
      };
      var string = function string2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "string");
          if (!isEmptyValue(value, "string")) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
            rules.pattern(rule, value, source, errors, options);
            if (rule.whitespace === true) {
              rules.whitespace(rule, value, source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var method = function method2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var number = function number2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (value === "") {
            value = void 0;
          }
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var _boolean = function _boolean2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var regexp = function regexp2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var integer = function integer2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var floatFn = function floatFn2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var array = function array2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if ((value === void 0 || value === null) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "array");
          if (value !== void 0 && value !== null) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var object = function object2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var ENUM = "enum";
      var enumerable = function enumerable2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules[ENUM](rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var pattern = function pattern2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "string")) {
            rules.pattern(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var date = function date2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "date") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "date")) {
            var dateObject;
            if (value instanceof Date) {
              dateObject = value;
            } else {
              dateObject = new Date(value);
            }
            rules.type(rule, dateObject, source, errors, options);
            if (dateObject) {
              rules.range(rule, dateObject.getTime(), source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var required = function required2(rule, value, callback, source, options) {
        var errors = [];
        var type2 = Array.isArray(value) ? "array" : typeof value;
        rules.required(rule, value, source, errors, options, type2);
        callback(errors);
      };
      var type = function type2(rule, value, callback, source, options) {
        var ruleType = rule.type;
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, ruleType) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, ruleType);
          if (!isEmptyValue(value, ruleType)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var any = function any2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
        }
        callback(errors);
      };
      var validators = {
        string,
        method,
        number,
        "boolean": _boolean,
        regexp,
        integer,
        "float": floatFn,
        array,
        object,
        "enum": enumerable,
        pattern,
        date,
        url: type,
        hex: type,
        email: type,
        required,
        any
      };
      function newMessages() {
        return {
          "default": "Validation error on field %s",
          required: "%s is required",
          "enum": "%s must be one of %s",
          whitespace: "%s cannot be empty",
          date: {
            format: "%s date %s is invalid for format %s",
            parse: "%s date could not be parsed, %s is invalid ",
            invalid: "%s date %s is invalid"
          },
          types: {
            string: "%s is not a %s",
            method: "%s is not a %s (function)",
            array: "%s is not an %s",
            object: "%s is not an %s",
            number: "%s is not a %s",
            date: "%s is not a %s",
            "boolean": "%s is not a %s",
            integer: "%s is not an %s",
            "float": "%s is not a %s",
            regexp: "%s is not a valid %s",
            email: "%s is not a valid %s",
            url: "%s is not a valid %s",
            hex: "%s is not a valid %s"
          },
          string: {
            len: "%s must be exactly %s characters",
            min: "%s must be at least %s characters",
            max: "%s cannot be longer than %s characters",
            range: "%s must be between %s and %s characters"
          },
          number: {
            len: "%s must equal %s",
            min: "%s cannot be less than %s",
            max: "%s cannot be greater than %s",
            range: "%s must be between %s and %s"
          },
          array: {
            len: "%s must be exactly %s in length",
            min: "%s cannot be less than %s in length",
            max: "%s cannot be greater than %s in length",
            range: "%s must be between %s and %s in length"
          },
          pattern: {
            mismatch: "%s value %s does not match pattern %s"
          },
          clone: function clone2() {
            var cloned = JSON.parse(JSON.stringify(this));
            cloned.clone = this.clone;
            return cloned;
          }
        };
      }
      var messages = newMessages();
      var Schema = /* @__PURE__ */ function() {
        function Schema2(descriptor) {
          this.rules = null;
          this._messages = messages;
          this.define(descriptor);
        }
        var _proto = Schema2.prototype;
        _proto.define = function define(rules2) {
          var _this = this;
          if (!rules2) {
            throw new Error("Cannot configure a schema with no rules");
          }
          if (typeof rules2 !== "object" || Array.isArray(rules2)) {
            throw new Error("Rules must be an object");
          }
          this.rules = {};
          Object.keys(rules2).forEach(function(name) {
            var item = rules2[name];
            _this.rules[name] = Array.isArray(item) ? item : [item];
          });
        };
        _proto.messages = function messages2(_messages) {
          if (_messages) {
            this._messages = deepMerge(newMessages(), _messages);
          }
          return this._messages;
        };
        _proto.validate = function validate(source_, o2, oc) {
          var _this2 = this;
          if (o2 === void 0) {
            o2 = {};
          }
          if (oc === void 0) {
            oc = function oc2() {
            };
          }
          var source = source_;
          var options = o2;
          var callback = oc;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          if (!this.rules || Object.keys(this.rules).length === 0) {
            if (callback) {
              callback(null, source);
            }
            return Promise.resolve(source);
          }
          function complete(results) {
            var errors = [];
            var fields = {};
            function add2(e2) {
              if (Array.isArray(e2)) {
                var _errors;
                errors = (_errors = errors).concat.apply(_errors, e2);
              } else {
                errors.push(e2);
              }
            }
            for (var i2 = 0; i2 < results.length; i2++) {
              add2(results[i2]);
            }
            if (!errors.length) {
              callback(null, source);
            } else {
              fields = convertFieldsError(errors);
              callback(errors, fields);
            }
          }
          if (options.messages) {
            var messages$1 = this.messages();
            if (messages$1 === messages) {
              messages$1 = newMessages();
            }
            deepMerge(messages$1, options.messages);
            options.messages = messages$1;
          } else {
            options.messages = this.messages();
          }
          var series = {};
          var keys2 = options.keys || Object.keys(this.rules);
          keys2.forEach(function(z2) {
            var arr = _this2.rules[z2];
            var value = source[z2];
            arr.forEach(function(r2) {
              var rule = r2;
              if (typeof rule.transform === "function") {
                if (source === source_) {
                  source = _extends({}, source);
                }
                value = source[z2] = rule.transform(value);
              }
              if (typeof rule === "function") {
                rule = {
                  validator: rule
                };
              } else {
                rule = _extends({}, rule);
              }
              rule.validator = _this2.getValidationMethod(rule);
              if (!rule.validator) {
                return;
              }
              rule.field = z2;
              rule.fullField = rule.fullField || z2;
              rule.type = _this2.getType(rule);
              series[z2] = series[z2] || [];
              series[z2].push({
                rule,
                value,
                source,
                field: z2
              });
            });
          });
          var errorFields = {};
          return asyncMap(series, options, function(data, doIt) {
            var rule = data.rule;
            var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
            deep = deep && (rule.required || !rule.required && data.value);
            rule.field = data.field;
            function addFullField(key, schema) {
              return _extends({}, schema, {
                fullField: rule.fullField + "." + key,
                fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
              });
            }
            function cb(e2) {
              if (e2 === void 0) {
                e2 = [];
              }
              var errorList = Array.isArray(e2) ? e2 : [e2];
              if (!options.suppressWarning && errorList.length) {
                Schema2.warning("async-validator:", errorList);
              }
              if (errorList.length && rule.message !== void 0) {
                errorList = [].concat(rule.message);
              }
              var filledErrors = errorList.map(complementError(rule, source));
              if (options.first && filledErrors.length) {
                errorFields[rule.field] = 1;
                return doIt(filledErrors);
              }
              if (!deep) {
                doIt(filledErrors);
              } else {
                if (rule.required && !data.value) {
                  if (rule.message !== void 0) {
                    filledErrors = [].concat(rule.message).map(complementError(rule, source));
                  } else if (options.error) {
                    filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                  }
                  return doIt(filledErrors);
                }
                var fieldsSchema = {};
                if (rule.defaultField) {
                  Object.keys(data.value).map(function(key) {
                    fieldsSchema[key] = rule.defaultField;
                  });
                }
                fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
                var paredFieldsSchema = {};
                Object.keys(fieldsSchema).forEach(function(field) {
                  var fieldSchema = fieldsSchema[field];
                  var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                  paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                });
                var schema = new Schema2(paredFieldsSchema);
                schema.messages(options.messages);
                if (data.rule.options) {
                  data.rule.options.messages = options.messages;
                  data.rule.options.error = options.error;
                }
                schema.validate(data.value, data.rule.options || options, function(errs) {
                  var finalErrors = [];
                  if (filledErrors && filledErrors.length) {
                    finalErrors.push.apply(finalErrors, filledErrors);
                  }
                  if (errs && errs.length) {
                    finalErrors.push.apply(finalErrors, errs);
                  }
                  doIt(finalErrors.length ? finalErrors : null);
                });
              }
            }
            var res;
            if (rule.asyncValidator) {
              res = rule.asyncValidator(rule, data.value, cb, data.source, options);
            } else if (rule.validator) {
              try {
                res = rule.validator(rule, data.value, cb, data.source, options);
              } catch (error) {
                console.error == null ? void 0 : console.error(error);
                if (!options.suppressValidatorError) {
                  setTimeout(function() {
                    throw error;
                  }, 0);
                }
                cb(error.message);
              }
              if (res === true) {
                cb();
              } else if (res === false) {
                cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
              } else if (res instanceof Array) {
                cb(res);
              } else if (res instanceof Error) {
                cb(res.message);
              }
            }
            if (res && res.then) {
              res.then(function() {
                return cb();
              }, function(e2) {
                return cb(e2);
              });
            }
          }, function(results) {
            complete(results);
          }, source);
        };
        _proto.getType = function getType2(rule) {
          if (rule.type === void 0 && rule.pattern instanceof RegExp) {
            rule.type = "pattern";
          }
          if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
            throw new Error(format("Unknown rule type %s", rule.type));
          }
          return rule.type || "string";
        };
        _proto.getValidationMethod = function getValidationMethod(rule) {
          if (typeof rule.validator === "function") {
            return rule.validator;
          }
          var keys2 = Object.keys(rule);
          var messageIndex = keys2.indexOf("message");
          if (messageIndex !== -1) {
            keys2.splice(messageIndex, 1);
          }
          if (keys2.length === 1 && keys2[0] === "required") {
            return validators.required;
          }
          return validators[this.getType(rule)] || void 0;
        };
        return Schema2;
      }();
      Schema.register = function register(type2, validator) {
        if (typeof validator !== "function") {
          throw new Error("Cannot register a validator by type, validator is not a function");
        }
        validators[type2] = validator;
      };
      Schema.warning = warning;
      Schema.messages = messages;
      Schema.validators = validators;
      const formItemValidateStates = [
        "",
        "error",
        "validating",
        "success"
      ];
      const formItemProps = buildProps({
        label: String,
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        prop: {
          type: definePropType([String, Array])
        },
        required: {
          type: Boolean,
          default: void 0
        },
        rules: {
          type: definePropType([Object, Array])
        },
        error: String,
        validateStatus: {
          type: String,
          values: formItemValidateStates
        },
        for: String,
        inlineMessage: {
          type: [String, Boolean],
          default: ""
        },
        showMessage: {
          type: Boolean,
          default: true
        },
        size: {
          type: String,
          values: componentSizes
        }
      });
      const COMPONENT_NAME$6 = "ElLabelWrap";
      var FormLabelWrap = defineComponent({
        name: COMPONENT_NAME$6,
        props: {
          isAutoWidth: Boolean,
          updateAll: Boolean
        },
        setup(props2, {
          slots
        }) {
          const formContext = inject(formContextKey, void 0);
          const formItemContext = inject(formItemContextKey);
          if (!formItemContext)
            throwError(COMPONENT_NAME$6, "usage: <el-form-item><label-wrap /></el-form-item>");
          const ns = useNamespace("form");
          const el = ref();
          const computedWidth = ref(0);
          const getLabelWidth = () => {
            var _a2;
            if ((_a2 = el.value) == null ? void 0 : _a2.firstElementChild) {
              const width = window.getComputedStyle(el.value.firstElementChild).width;
              return Math.ceil(Number.parseFloat(width));
            } else {
              return 0;
            }
          };
          const updateLabelWidth = (action = "update") => {
            nextTick(() => {
              if (slots.default && props2.isAutoWidth) {
                if (action === "update") {
                  computedWidth.value = getLabelWidth();
                } else if (action === "remove") {
                  formContext == null ? void 0 : formContext.deregisterLabelWidth(computedWidth.value);
                }
              }
            });
          };
          const updateLabelWidthFn = () => updateLabelWidth("update");
          onMounted(() => {
            updateLabelWidthFn();
          });
          onBeforeUnmount(() => {
            updateLabelWidth("remove");
          });
          onUpdated(() => updateLabelWidthFn());
          watch(computedWidth, (val, oldVal) => {
            if (props2.updateAll) {
              formContext == null ? void 0 : formContext.registerLabelWidth(val, oldVal);
            }
          });
          useResizeObserver(computed(() => {
            var _a2, _b;
            return (_b = (_a2 = el.value) == null ? void 0 : _a2.firstElementChild) != null ? _b : null;
          }), updateLabelWidthFn);
          return () => {
            var _a2, _b;
            if (!slots)
              return null;
            const {
              isAutoWidth
            } = props2;
            if (isAutoWidth) {
              const autoLabelWidth = formContext == null ? void 0 : formContext.autoLabelWidth;
              const hasLabel = formItemContext == null ? void 0 : formItemContext.hasLabel;
              const style = {};
              if (hasLabel && autoLabelWidth && autoLabelWidth !== "auto") {
                const marginWidth = Math.max(0, Number.parseInt(autoLabelWidth, 10) - computedWidth.value);
                const marginPosition = formContext.labelPosition === "left" ? "marginRight" : "marginLeft";
                if (marginWidth) {
                  style[marginPosition] = `${marginWidth}px`;
                }
              }
              return createVNode("div", {
                "ref": el,
                "class": [ns.be("item", "label-wrap")],
                "style": style
              }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
            } else {
              return createVNode(Fragment, {
                "ref": el
              }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
            }
          };
        }
      });
      const _hoisted_1$P = ["role", "aria-labelledby"];
      const __default__$A = defineComponent({
        name: "ElFormItem"
      });
      const _sfc_main$11 = /* @__PURE__ */ defineComponent({
        ...__default__$A,
        props: formItemProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const slots = useSlots();
          const formContext = inject(formContextKey, void 0);
          const parentFormItemContext = inject(formItemContextKey, void 0);
          const _size = useFormSize(void 0, { formItem: false });
          const ns = useNamespace("form-item");
          const labelId = useId().value;
          const inputIds = ref([]);
          const validateState = ref("");
          const validateStateDebounced = refDebounced(validateState, 100);
          const validateMessage = ref("");
          const formItemRef = ref();
          let initialValue = void 0;
          let isResettingField = false;
          const labelStyle = computed(() => {
            if ((formContext == null ? void 0 : formContext.labelPosition) === "top") {
              return {};
            }
            const labelWidth = addUnit(props2.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (labelWidth)
              return { width: labelWidth };
            return {};
          });
          const contentStyle = computed(() => {
            if ((formContext == null ? void 0 : formContext.labelPosition) === "top" || (formContext == null ? void 0 : formContext.inline)) {
              return {};
            }
            if (!props2.label && !props2.labelWidth && isNested) {
              return {};
            }
            const labelWidth = addUnit(props2.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (!props2.label && !slots.label) {
              return { marginLeft: labelWidth };
            }
            return {};
          });
          const formItemClasses = computed(() => [
            ns.b(),
            ns.m(_size.value),
            ns.is("error", validateState.value === "error"),
            ns.is("validating", validateState.value === "validating"),
            ns.is("success", validateState.value === "success"),
            ns.is("required", isRequired.value || props2.required),
            ns.is("no-asterisk", formContext == null ? void 0 : formContext.hideRequiredAsterisk),
            (formContext == null ? void 0 : formContext.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
            { [ns.m("feedback")]: formContext == null ? void 0 : formContext.statusIcon }
          ]);
          const _inlineMessage = computed(() => isBoolean(props2.inlineMessage) ? props2.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);
          const validateClasses = computed(() => [
            ns.e("error"),
            { [ns.em("error", "inline")]: _inlineMessage.value }
          ]);
          const propString = computed(() => {
            if (!props2.prop)
              return "";
            return isString$2(props2.prop) ? props2.prop : props2.prop.join(".");
          });
          const hasLabel = computed(() => {
            return !!(props2.label || slots.label);
          });
          const labelFor = computed(() => {
            return props2.for || inputIds.value.length === 1 ? inputIds.value[0] : void 0;
          });
          const isGroup = computed(() => {
            return !labelFor.value && hasLabel.value;
          });
          const isNested = !!parentFormItemContext;
          const fieldValue = computed(() => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props2.prop) {
              return;
            }
            return getProp(model, props2.prop).value;
          });
          const normalizedRules = computed(() => {
            const { required: required2 } = props2;
            const rules2 = [];
            if (props2.rules) {
              rules2.push(...castArray(props2.rules));
            }
            const formRules = formContext == null ? void 0 : formContext.rules;
            if (formRules && props2.prop) {
              const _rules = getProp(formRules, props2.prop).value;
              if (_rules) {
                rules2.push(...castArray(_rules));
              }
            }
            if (required2 !== void 0) {
              const requiredRules = rules2.map((rule, i2) => [rule, i2]).filter(([rule]) => Object.keys(rule).includes("required"));
              if (requiredRules.length > 0) {
                for (const [rule, i2] of requiredRules) {
                  if (rule.required === required2)
                    continue;
                  rules2[i2] = { ...rule, required: required2 };
                }
              } else {
                rules2.push({ required: required2 });
              }
            }
            return rules2;
          });
          const validateEnabled = computed(() => normalizedRules.value.length > 0);
          const getFilteredRule = (trigger2) => {
            const rules2 = normalizedRules.value;
            return rules2.filter((rule) => {
              if (!rule.trigger || !trigger2)
                return true;
              if (Array.isArray(rule.trigger)) {
                return rule.trigger.includes(trigger2);
              } else {
                return rule.trigger === trigger2;
              }
            }).map(({ trigger: trigger22, ...rule }) => rule);
          };
          const isRequired = computed(() => normalizedRules.value.some((rule) => rule.required));
          const shouldShowError = computed(() => {
            var _a2;
            return validateStateDebounced.value === "error" && props2.showMessage && ((_a2 = formContext == null ? void 0 : formContext.showMessage) != null ? _a2 : true);
          });
          const currentLabel = computed(() => `${props2.label || ""}${(formContext == null ? void 0 : formContext.labelSuffix) || ""}`);
          const setValidationState = (state) => {
            validateState.value = state;
          };
          const onValidationFailed = (error) => {
            var _a2, _b;
            const { errors, fields } = error;
            if (!errors || !fields) {
              console.error(error);
            }
            setValidationState("error");
            validateMessage.value = errors ? (_b = (_a2 = errors == null ? void 0 : errors[0]) == null ? void 0 : _a2.message) != null ? _b : `${props2.prop} is required` : "";
            formContext == null ? void 0 : formContext.emit("validate", props2.prop, false, validateMessage.value);
          };
          const onValidationSucceeded = () => {
            setValidationState("success");
            formContext == null ? void 0 : formContext.emit("validate", props2.prop, true, "");
          };
          const doValidate = async (rules2) => {
            const modelName = propString.value;
            const validator = new Schema({
              [modelName]: rules2
            });
            return validator.validate({ [modelName]: fieldValue.value }, { firstFields: true }).then(() => {
              onValidationSucceeded();
              return true;
            }).catch((err) => {
              onValidationFailed(err);
              return Promise.reject(err);
            });
          };
          const validate = async (trigger2, callback) => {
            if (isResettingField || !props2.prop) {
              return false;
            }
            const hasCallback = isFunction$2(callback);
            if (!validateEnabled.value) {
              callback == null ? void 0 : callback(false);
              return false;
            }
            const rules2 = getFilteredRule(trigger2);
            if (rules2.length === 0) {
              callback == null ? void 0 : callback(true);
              return true;
            }
            setValidationState("validating");
            return doValidate(rules2).then(() => {
              callback == null ? void 0 : callback(true);
              return true;
            }).catch((err) => {
              const { fields } = err;
              callback == null ? void 0 : callback(false, fields);
              return hasCallback ? false : Promise.reject(fields);
            });
          };
          const clearValidate = () => {
            setValidationState("");
            validateMessage.value = "";
            isResettingField = false;
          };
          const resetField = async () => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props2.prop)
              return;
            const computedValue = getProp(model, props2.prop);
            isResettingField = true;
            computedValue.value = clone(initialValue);
            await nextTick();
            clearValidate();
            isResettingField = false;
          };
          const addInputId = (id2) => {
            if (!inputIds.value.includes(id2)) {
              inputIds.value.push(id2);
            }
          };
          const removeInputId = (id2) => {
            inputIds.value = inputIds.value.filter((listId) => listId !== id2);
          };
          watch(() => props2.error, (val) => {
            validateMessage.value = val || "";
            setValidationState(val ? "error" : "");
          }, { immediate: true });
          watch(() => props2.validateStatus, (val) => setValidationState(val || ""));
          const context2 = reactive({
            ...toRefs$1(props2),
            $el: formItemRef,
            size: _size,
            validateState,
            labelId,
            inputIds,
            isGroup,
            hasLabel,
            addInputId,
            removeInputId,
            resetField,
            clearValidate,
            validate
          });
          provide(formItemContextKey, context2);
          onMounted(() => {
            if (props2.prop) {
              formContext == null ? void 0 : formContext.addField(context2);
              initialValue = clone(fieldValue.value);
            }
          });
          onBeforeUnmount(() => {
            formContext == null ? void 0 : formContext.removeField(context2);
          });
          expose({
            size: _size,
            validateMessage,
            validateState,
            validate,
            clearValidate,
            resetField
          });
          return (_ctx, _cache) => {
            var _a2;
            return openBlock(), createElementBlock("div", {
              ref_key: "formItemRef",
              ref: formItemRef,
              class: normalizeClass(unref(formItemClasses)),
              role: unref(isGroup) ? "group" : void 0,
              "aria-labelledby": unref(isGroup) ? unref(labelId) : void 0
            }, [
              createVNode(unref(FormLabelWrap), {
                "is-auto-width": unref(labelStyle).width === "auto",
                "update-all": ((_a2 = unref(formContext)) == null ? void 0 : _a2.labelWidth) === "auto"
              }, {
                default: withCtx(() => [
                  unref(hasLabel) ? (openBlock(), createBlock(resolveDynamicComponent(unref(labelFor) ? "label" : "div"), {
                    key: 0,
                    id: unref(labelId),
                    for: unref(labelFor),
                    class: normalizeClass(unref(ns).e("label")),
                    style: normalizeStyle(unref(labelStyle))
                  }, {
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "label", { label: unref(currentLabel) }, () => [
                        createTextVNode(toDisplayString(unref(currentLabel)), 1)
                      ])
                    ]),
                    _: 3
                  }, 8, ["id", "for", "class", "style"])) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["is-auto-width", "update-all"]),
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).e("content")),
                style: normalizeStyle(unref(contentStyle))
              }, [
                renderSlot(_ctx.$slots, "default"),
                createVNode(TransitionGroup, {
                  name: `${unref(ns).namespace.value}-zoom-in-top`
                }, {
                  default: withCtx(() => [
                    unref(shouldShowError) ? renderSlot(_ctx.$slots, "error", {
                      key: 0,
                      error: validateMessage.value
                    }, () => [
                      createBaseVNode("div", {
                        class: normalizeClass(unref(validateClasses))
                      }, toDisplayString(validateMessage.value), 3)
                    ]) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["name"])
              ], 6)
            ], 10, _hoisted_1$P);
          };
        }
      });
      var FormItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$11, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form-item.vue"]]);
      const ElForm = withInstall(Form, {
        FormItem
      });
      const ElFormItem = withNoopInstall(FormItem);
      let hiddenTextarea = void 0;
      const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  ${isFirefox() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
      const CONTEXT_STYLE = [
        "letter-spacing",
        "line-height",
        "padding-top",
        "padding-bottom",
        "font-family",
        "font-weight",
        "font-size",
        "text-rendering",
        "text-transform",
        "width",
        "text-indent",
        "padding-left",
        "padding-right",
        "border-width",
        "box-sizing"
      ];
      function calculateNodeStyling(targetElement) {
        const style = window.getComputedStyle(targetElement);
        const boxSizing = style.getPropertyValue("box-sizing");
        const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
        const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
        const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
        return { contextStyle, paddingSize, borderSize, boxSizing };
      }
      function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
        var _a2;
        if (!hiddenTextarea) {
          hiddenTextarea = document.createElement("textarea");
          document.body.appendChild(hiddenTextarea);
        }
        const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
        hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
        hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
        let height = hiddenTextarea.scrollHeight;
        const result = {};
        if (boxSizing === "border-box") {
          height = height + borderSize;
        } else if (boxSizing === "content-box") {
          height = height - paddingSize;
        }
        hiddenTextarea.value = "";
        const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (isNumber(minRows)) {
          let minHeight = singleRowHeight * minRows;
          if (boxSizing === "border-box") {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
          result.minHeight = `${minHeight}px`;
        }
        if (isNumber(maxRows)) {
          let maxHeight = singleRowHeight * maxRows;
          if (boxSizing === "border-box") {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          height = Math.min(maxHeight, height);
        }
        result.height = `${height}px`;
        (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
        hiddenTextarea = void 0;
        return result;
      }
      const inputProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        size: useSizeProp,
        disabled: Boolean,
        modelValue: {
          type: definePropType([
            String,
            Number,
            Object
          ]),
          default: ""
        },
        type: {
          type: String,
          default: "text"
        },
        resize: {
          type: String,
          values: ["none", "both", "horizontal", "vertical"]
        },
        autosize: {
          type: definePropType([Boolean, Object]),
          default: false
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        formatter: {
          type: Function
        },
        parser: {
          type: Function
        },
        placeholder: {
          type: String
        },
        form: {
          type: String
        },
        readonly: {
          type: Boolean,
          default: false
        },
        clearable: {
          type: Boolean,
          default: false
        },
        showPassword: {
          type: Boolean,
          default: false
        },
        showWordLimit: {
          type: Boolean,
          default: false
        },
        suffixIcon: {
          type: iconPropType
        },
        prefixIcon: {
          type: iconPropType
        },
        containerRole: {
          type: String,
          default: void 0
        },
        label: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        inputStyle: {
          type: definePropType([Object, Array, String]),
          default: () => mutable({})
        }
      });
      const inputEmits = {
        [UPDATE_MODEL_EVENT]: (value) => isString$2(value),
        input: (value) => isString$2(value),
        change: (value) => isString$2(value),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true,
        mouseleave: (evt) => evt instanceof MouseEvent,
        mouseenter: (evt) => evt instanceof MouseEvent,
        keydown: (evt) => evt instanceof Event,
        compositionstart: (evt) => evt instanceof CompositionEvent,
        compositionupdate: (evt) => evt instanceof CompositionEvent,
        compositionend: (evt) => evt instanceof CompositionEvent
      };
      const _hoisted_1$O = ["role"];
      const _hoisted_2$D = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form"];
      const _hoisted_3$u = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form"];
      const __default__$z = defineComponent({
        name: "ElInput",
        inheritAttrs: false
      });
      const _sfc_main$10 = /* @__PURE__ */ defineComponent({
        ...__default__$z,
        props: inputProps,
        emits: inputEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props2 = __props;
          const rawAttrs = useAttrs$1();
          const slots = useSlots();
          const containerAttrs = computed(() => {
            const comboBoxAttrs = {};
            if (props2.containerRole === "combobox") {
              comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
              comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
              comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
            }
            return comboBoxAttrs;
          });
          const containerKls = computed(() => [
            props2.type === "textarea" ? nsTextarea.b() : nsInput.b(),
            nsInput.m(inputSize.value),
            nsInput.is("disabled", inputDisabled.value),
            nsInput.is("exceed", inputExceed.value),
            {
              [nsInput.b("group")]: slots.prepend || slots.append,
              [nsInput.bm("group", "append")]: slots.append,
              [nsInput.bm("group", "prepend")]: slots.prepend,
              [nsInput.m("prefix")]: slots.prefix || props2.prefixIcon,
              [nsInput.m("suffix")]: slots.suffix || props2.suffixIcon || props2.clearable || props2.showPassword,
              [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value
            },
            rawAttrs.class
          ]);
          const wrapperKls = computed(() => [
            nsInput.e("wrapper"),
            nsInput.is("focus", isFocused.value)
          ]);
          const attrs = useAttrs({
            excludeKeys: computed(() => {
              return Object.keys(containerAttrs.value);
            })
          });
          const { form, formItem } = useFormItem();
          const { inputId } = useFormItemInputId(props2, {
            formItemContext: formItem
          });
          const inputSize = useFormSize();
          const inputDisabled = useFormDisabled();
          const nsInput = useNamespace("input");
          const nsTextarea = useNamespace("textarea");
          const input = shallowRef();
          const textarea = shallowRef();
          const hovering = ref(false);
          const isComposing = ref(false);
          const passwordVisible = ref(false);
          const countStyle = ref();
          const textareaCalcStyle = shallowRef(props2.inputStyle);
          const _ref = computed(() => input.value || textarea.value);
          const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
            afterBlur() {
              var _a2;
              if (props2.validateEvent) {
                (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn());
              }
            }
          });
          const needStatusIcon = computed(() => {
            var _a2;
            return (_a2 = form == null ? void 0 : form.statusIcon) != null ? _a2 : false;
          });
          const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
          const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
          const passwordIcon = computed(() => passwordVisible.value ? view_default : hide_default);
          const containerStyle = computed(() => [
            rawAttrs.style,
            props2.inputStyle
          ]);
          const textareaStyle = computed(() => [
            props2.inputStyle,
            textareaCalcStyle.value,
            { resize: props2.resize }
          ]);
          const nativeInputValue = computed(() => isNil(props2.modelValue) ? "" : String(props2.modelValue));
          const showClear = computed(() => props2.clearable && !inputDisabled.value && !props2.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
          const showPwdVisible = computed(() => props2.showPassword && !inputDisabled.value && !props2.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || isFocused.value));
          const isWordLimitVisible = computed(() => props2.showWordLimit && !!attrs.value.maxlength && (props2.type === "text" || props2.type === "textarea") && !inputDisabled.value && !props2.readonly && !props2.showPassword);
          const textLength = computed(() => nativeInputValue.value.length);
          const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(attrs.value.maxlength));
          const suffixVisible = computed(() => !!slots.suffix || !!props2.suffixIcon || showClear.value || props2.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
          const [recordCursor, setCursor] = useCursor(input);
          useResizeObserver(textarea, (entries) => {
            onceInitSizeTextarea();
            if (!isWordLimitVisible.value || props2.resize !== "both")
              return;
            const entry = entries[0];
            const { width } = entry.contentRect;
            countStyle.value = {
              right: `calc(100% - ${width + 15 + 6}px)`
            };
          });
          const resizeTextarea = () => {
            const { type: type2, autosize } = props2;
            if (!isClient$1 || type2 !== "textarea" || !textarea.value)
              return;
            if (autosize) {
              const minRows = isObject$1(autosize) ? autosize.minRows : void 0;
              const maxRows = isObject$1(autosize) ? autosize.maxRows : void 0;
              const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
              textareaCalcStyle.value = {
                overflowY: "hidden",
                ...textareaStyle2
              };
              nextTick(() => {
                textarea.value.offsetHeight;
                textareaCalcStyle.value = textareaStyle2;
              });
            } else {
              textareaCalcStyle.value = {
                minHeight: calcTextareaHeight(textarea.value).minHeight
              };
            }
          };
          const createOnceInitResize = (resizeTextarea2) => {
            let isInit = false;
            return () => {
              var _a2;
              if (isInit || !props2.autosize)
                return;
              const isElHidden = ((_a2 = textarea.value) == null ? void 0 : _a2.offsetParent) === null;
              if (!isElHidden) {
                resizeTextarea2();
                isInit = true;
              }
            };
          };
          const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
          const setNativeInputValue = () => {
            const input2 = _ref.value;
            const formatterValue = props2.formatter ? props2.formatter(nativeInputValue.value) : nativeInputValue.value;
            if (!input2 || input2.value === formatterValue)
              return;
            input2.value = formatterValue;
          };
          const handleInput = async (event) => {
            recordCursor();
            let { value } = event.target;
            if (props2.formatter) {
              value = props2.parser ? props2.parser(value) : value;
            }
            if (isComposing.value)
              return;
            if (value === nativeInputValue.value) {
              setNativeInputValue();
              return;
            }
            emit2(UPDATE_MODEL_EVENT, value);
            emit2("input", value);
            await nextTick();
            setNativeInputValue();
            setCursor();
          };
          const handleChange = (event) => {
            emit2("change", event.target.value);
          };
          const handleCompositionStart = (event) => {
            emit2("compositionstart", event);
            isComposing.value = true;
          };
          const handleCompositionUpdate = (event) => {
            var _a2;
            emit2("compositionupdate", event);
            const text = (_a2 = event.target) == null ? void 0 : _a2.value;
            const lastCharacter = text[text.length - 1] || "";
            isComposing.value = !isKorean(lastCharacter);
          };
          const handleCompositionEnd = (event) => {
            emit2("compositionend", event);
            if (isComposing.value) {
              isComposing.value = false;
              handleInput(event);
            }
          };
          const handlePasswordVisible = () => {
            passwordVisible.value = !passwordVisible.value;
            focus();
          };
          const focus = async () => {
            var _a2;
            await nextTick();
            (_a2 = _ref.value) == null ? void 0 : _a2.focus();
          };
          const blur = () => {
            var _a2;
            return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
          };
          const handleMouseLeave = (evt) => {
            hovering.value = false;
            emit2("mouseleave", evt);
          };
          const handleMouseEnter = (evt) => {
            hovering.value = true;
            emit2("mouseenter", evt);
          };
          const handleKeydown = (evt) => {
            emit2("keydown", evt);
          };
          const select = () => {
            var _a2;
            (_a2 = _ref.value) == null ? void 0 : _a2.select();
          };
          const clear2 = () => {
            emit2(UPDATE_MODEL_EVENT, "");
            emit2("change", "");
            emit2("clear");
            emit2("input", "");
          };
          watch(() => props2.modelValue, () => {
            var _a2;
            nextTick(() => resizeTextarea());
            if (props2.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
            }
          });
          watch(nativeInputValue, () => setNativeInputValue());
          watch(() => props2.type, async () => {
            await nextTick();
            setNativeInputValue();
            resizeTextarea();
          });
          onMounted(() => {
            if (!props2.formatter && props2.parser)
              ;
            setNativeInputValue();
            nextTick(resizeTextarea);
          });
          expose({
            input,
            textarea,
            ref: _ref,
            textareaStyle,
            autosize: toRef$1(props2, "autosize"),
            focus,
            blur,
            select,
            clear: clear2,
            resizeTextarea
          });
          return (_ctx, _cache) => {
            return withDirectives((openBlock(), createElementBlock("div", mergeProps(unref(containerAttrs), {
              class: unref(containerKls),
              style: unref(containerStyle),
              role: _ctx.containerRole,
              onMouseenter: handleMouseEnter,
              onMouseleave: handleMouseLeave
            }), [
              createCommentVNode(" input "),
              _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createCommentVNode(" prepend slot "),
                _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(nsInput).be("group", "prepend"))
                }, [
                  renderSlot(_ctx.$slots, "prepend")
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  ref_key: "wrapperRef",
                  ref: wrapperRef,
                  class: normalizeClass(unref(wrapperKls))
                }, [
                  createCommentVNode(" prefix slot "),
                  _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(nsInput).e("prefix"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(nsInput).e("prefix-inner"))
                    }, [
                      renderSlot(_ctx.$slots, "prefix"),
                      _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass(unref(nsInput).e("icon"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true),
                  createBaseVNode("input", mergeProps({
                    id: unref(inputId),
                    ref_key: "input",
                    ref: input,
                    class: unref(nsInput).e("inner")
                  }, unref(attrs), {
                    type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                    disabled: unref(inputDisabled),
                    formatter: _ctx.formatter,
                    parser: _ctx.parser,
                    readonly: _ctx.readonly,
                    autocomplete: _ctx.autocomplete,
                    tabindex: _ctx.tabindex,
                    "aria-label": _ctx.label,
                    placeholder: _ctx.placeholder,
                    style: _ctx.inputStyle,
                    form: props2.form,
                    onCompositionstart: handleCompositionStart,
                    onCompositionupdate: handleCompositionUpdate,
                    onCompositionend: handleCompositionEnd,
                    onInput: handleInput,
                    onFocus: _cache[0] || (_cache[0] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                    onBlur: _cache[1] || (_cache[1] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                    onChange: handleChange,
                    onKeydown: handleKeydown
                  }), null, 16, _hoisted_2$D),
                  createCommentVNode(" suffix slot "),
                  unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(unref(nsInput).e("suffix"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(nsInput).e("suffix-inner"))
                    }, [
                      !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        renderSlot(_ctx.$slots, "suffix"),
                        _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                          key: 0,
                          class: normalizeClass(unref(nsInput).e("icon"))
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : createCommentVNode("v-if", true)
                      ], 64)) : createCommentVNode("v-if", true),
                      unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 1,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                        onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                        onClick: clear2
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(circle_close_default))
                        ]),
                        _: 1
                      }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                      unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 2,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                        onClick: handlePasswordVisible
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true),
                      unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                        key: 3,
                        class: normalizeClass(unref(nsInput).e("count"))
                      }, [
                        createBaseVNode("span", {
                          class: normalizeClass(unref(nsInput).e("count-inner"))
                        }, toDisplayString(unref(textLength)) + " / " + toDisplayString(unref(attrs).maxlength), 3)
                      ], 2)) : createCommentVNode("v-if", true),
                      unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 4,
                        class: normalizeClass([
                          unref(nsInput).e("icon"),
                          unref(nsInput).e("validateIcon"),
                          unref(nsInput).is("loading", unref(validateState) === "validating")
                        ])
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true)
                ], 2),
                createCommentVNode(" append slot "),
                _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(nsInput).be("group", "append"))
                }, [
                  renderSlot(_ctx.$slots, "append")
                ], 2)) : createCommentVNode("v-if", true)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createCommentVNode(" textarea "),
                createBaseVNode("textarea", mergeProps({
                  id: unref(inputId),
                  ref_key: "textarea",
                  ref: textarea,
                  class: unref(nsTextarea).e("inner")
                }, unref(attrs), {
                  tabindex: _ctx.tabindex,
                  disabled: unref(inputDisabled),
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  style: unref(textareaStyle),
                  "aria-label": _ctx.label,
                  placeholder: _ctx.placeholder,
                  form: props2.form,
                  onCompositionstart: handleCompositionStart,
                  onCompositionupdate: handleCompositionUpdate,
                  onCompositionend: handleCompositionEnd,
                  onInput: handleInput,
                  onFocus: _cache[2] || (_cache[2] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                  onBlur: _cache[3] || (_cache[3] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, _hoisted_3$u),
                unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  style: normalizeStyle(countStyle.value),
                  class: normalizeClass(unref(nsInput).e("count"))
                }, toDisplayString(unref(textLength)) + " / " + toDisplayString(unref(attrs).maxlength), 7)) : createCommentVNode("v-if", true)
              ], 64))
            ], 16, _hoisted_1$O)), [
              [vShow, _ctx.type !== "hidden"]
            ]);
          };
        }
      });
      var Input = /* @__PURE__ */ _export_sfc$1(_sfc_main$10, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
      const ElInput = withInstall(Input);
      const GAP = 4;
      const BAR_MAP = {
        vertical: {
          offset: "offsetHeight",
          scroll: "scrollTop",
          scrollSize: "scrollHeight",
          size: "height",
          key: "vertical",
          axis: "Y",
          client: "clientY",
          direction: "top"
        },
        horizontal: {
          offset: "offsetWidth",
          scroll: "scrollLeft",
          scrollSize: "scrollWidth",
          size: "width",
          key: "horizontal",
          axis: "X",
          client: "clientX",
          direction: "left"
        }
      };
      const renderThumbStyle$1 = ({
        move,
        size: size2,
        bar
      }) => ({
        [bar.size]: size2,
        transform: `translate${bar.axis}(${move}%)`
      });
      const scrollbarContextKey = Symbol("scrollbarContextKey");
      const thumbProps = buildProps({
        vertical: Boolean,
        size: String,
        move: Number,
        ratio: {
          type: Number,
          required: true
        },
        always: Boolean
      });
      const COMPONENT_NAME$5 = "Thumb";
      const _sfc_main$$ = /* @__PURE__ */ defineComponent({
        __name: "thumb",
        props: thumbProps,
        setup(__props) {
          const props2 = __props;
          const scrollbar = inject(scrollbarContextKey);
          const ns = useNamespace("scrollbar");
          if (!scrollbar)
            throwError(COMPONENT_NAME$5, "can not inject scrollbar context");
          const instance = ref();
          const thumb = ref();
          const thumbState = ref({});
          const visible = ref(false);
          let cursorDown = false;
          let cursorLeave = false;
          let originalOnSelectStart = isClient$1 ? document.onselectstart : null;
          const bar = computed(() => BAR_MAP[props2.vertical ? "vertical" : "horizontal"]);
          const thumbStyle = computed(() => renderThumbStyle$1({
            size: props2.size,
            move: props2.move,
            bar: bar.value
          }));
          const offsetRatio = computed(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props2.ratio / thumb.value[bar.value.offset]);
          const clickThumbHandler = (e2) => {
            var _a2;
            e2.stopPropagation();
            if (e2.ctrlKey || [1, 2].includes(e2.button))
              return;
            (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
            startDrag(e2);
            const el = e2.currentTarget;
            if (!el)
              return;
            thumbState.value[bar.value.axis] = el[bar.value.offset] - (e2[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
          };
          const clickTrackHandler = (e2) => {
            if (!thumb.value || !instance.value || !scrollbar.wrapElement)
              return;
            const offset = Math.abs(e2.target.getBoundingClientRect()[bar.value.direction] - e2[bar.value.client]);
            const thumbHalf = thumb.value[bar.value.offset] / 2;
            const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const startDrag = (e2) => {
            e2.stopImmediatePropagation();
            cursorDown = true;
            document.addEventListener("mousemove", mouseMoveDocumentHandler);
            document.addEventListener("mouseup", mouseUpDocumentHandler);
            originalOnSelectStart = document.onselectstart;
            document.onselectstart = () => false;
          };
          const mouseMoveDocumentHandler = (e2) => {
            if (!instance.value || !thumb.value)
              return;
            if (cursorDown === false)
              return;
            const prevPage = thumbState.value[bar.value.axis];
            if (!prevPage)
              return;
            const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e2[bar.value.client]) * -1;
            const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
            const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const mouseUpDocumentHandler = () => {
            cursorDown = false;
            thumbState.value[bar.value.axis] = 0;
            document.removeEventListener("mousemove", mouseMoveDocumentHandler);
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
            restoreOnselectstart();
            if (cursorLeave)
              visible.value = false;
          };
          const mouseMoveScrollbarHandler = () => {
            cursorLeave = false;
            visible.value = !!props2.size;
          };
          const mouseLeaveScrollbarHandler = () => {
            cursorLeave = true;
            visible.value = cursorDown;
          };
          onBeforeUnmount(() => {
            restoreOnselectstart();
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
          });
          const restoreOnselectstart = () => {
            if (document.onselectstart !== originalOnSelectStart)
              document.onselectstart = originalOnSelectStart;
          };
          useEventListener$1(toRef$1(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
          useEventListener$1(toRef$1(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  ref_key: "instance",
                  ref: instance,
                  class: normalizeClass([unref(ns).e("bar"), unref(ns).is(unref(bar).key)]),
                  onMousedown: clickTrackHandler
                }, [
                  createBaseVNode("div", {
                    ref_key: "thumb",
                    ref: thumb,
                    class: normalizeClass(unref(ns).e("thumb")),
                    style: normalizeStyle(unref(thumbStyle)),
                    onMousedown: clickThumbHandler
                  }, null, 38)
                ], 34), [
                  [vShow, _ctx.always || visible.value]
                ])
              ]),
              _: 1
            }, 8, ["name"]);
          };
        }
      });
      var Thumb = /* @__PURE__ */ _export_sfc$1(_sfc_main$$, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
      const barProps = buildProps({
        always: {
          type: Boolean,
          default: true
        },
        width: String,
        height: String,
        ratioX: {
          type: Number,
          default: 1
        },
        ratioY: {
          type: Number,
          default: 1
        }
      });
      const _sfc_main$_ = /* @__PURE__ */ defineComponent({
        __name: "bar",
        props: barProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const moveX = ref(0);
          const moveY = ref(0);
          const handleScroll = (wrap) => {
            if (wrap) {
              const offsetHeight = wrap.offsetHeight - GAP;
              const offsetWidth = wrap.offsetWidth - GAP;
              moveY.value = wrap.scrollTop * 100 / offsetHeight * props2.ratioY;
              moveX.value = wrap.scrollLeft * 100 / offsetWidth * props2.ratioX;
            }
          };
          expose({
            handleScroll
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(Thumb, {
                move: moveX.value,
                ratio: _ctx.ratioX,
                size: _ctx.width,
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"]),
              createVNode(Thumb, {
                move: moveY.value,
                ratio: _ctx.ratioY,
                size: _ctx.height,
                vertical: "",
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"])
            ], 64);
          };
        }
      });
      var Bar = /* @__PURE__ */ _export_sfc$1(_sfc_main$_, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
      const scrollbarProps = buildProps({
        height: {
          type: [String, Number],
          default: ""
        },
        maxHeight: {
          type: [String, Number],
          default: ""
        },
        native: {
          type: Boolean,
          default: false
        },
        wrapStyle: {
          type: definePropType([String, Object, Array]),
          default: ""
        },
        wrapClass: {
          type: [String, Array],
          default: ""
        },
        viewClass: {
          type: [String, Array],
          default: ""
        },
        viewStyle: {
          type: [String, Array, Object],
          default: ""
        },
        noresize: Boolean,
        tag: {
          type: String,
          default: "div"
        },
        always: Boolean,
        minSize: {
          type: Number,
          default: 20
        }
      });
      const scrollbarEmits = {
        scroll: ({
          scrollTop,
          scrollLeft
        }) => [scrollTop, scrollLeft].every(isNumber)
      };
      const COMPONENT_NAME$4 = "ElScrollbar";
      const __default__$y = defineComponent({
        name: COMPONENT_NAME$4
      });
      const _sfc_main$Z = /* @__PURE__ */ defineComponent({
        ...__default__$y,
        props: scrollbarProps,
        emits: scrollbarEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props2 = __props;
          const ns = useNamespace("scrollbar");
          let stopResizeObserver = void 0;
          let stopResizeListener = void 0;
          const scrollbarRef = ref();
          const wrapRef = ref();
          const resizeRef = ref();
          const sizeWidth = ref("0");
          const sizeHeight = ref("0");
          const barRef = ref();
          const ratioY = ref(1);
          const ratioX = ref(1);
          const style = computed(() => {
            const style2 = {};
            if (props2.height)
              style2.height = addUnit(props2.height);
            if (props2.maxHeight)
              style2.maxHeight = addUnit(props2.maxHeight);
            return [props2.wrapStyle, style2];
          });
          const wrapKls = computed(() => {
            return [
              props2.wrapClass,
              ns.e("wrap"),
              { [ns.em("wrap", "hidden-default")]: !props2.native }
            ];
          });
          const resizeKls = computed(() => {
            return [ns.e("view"), props2.viewClass];
          });
          const handleScroll = () => {
            var _a2;
            if (wrapRef.value) {
              (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
              emit2("scroll", {
                scrollTop: wrapRef.value.scrollTop,
                scrollLeft: wrapRef.value.scrollLeft
              });
            }
          };
          function scrollTo(arg1, arg2) {
            if (isObject$1(arg1)) {
              wrapRef.value.scrollTo(arg1);
            } else if (isNumber(arg1) && isNumber(arg2)) {
              wrapRef.value.scrollTo(arg1, arg2);
            }
          }
          const setScrollTop = (value) => {
            if (!isNumber(value)) {
              return;
            }
            wrapRef.value.scrollTop = value;
          };
          const setScrollLeft = (value) => {
            if (!isNumber(value)) {
              return;
            }
            wrapRef.value.scrollLeft = value;
          };
          const update = () => {
            if (!wrapRef.value)
              return;
            const offsetHeight = wrapRef.value.offsetHeight - GAP;
            const offsetWidth = wrapRef.value.offsetWidth - GAP;
            const originalHeight = offsetHeight ** 2 / wrapRef.value.scrollHeight;
            const originalWidth = offsetWidth ** 2 / wrapRef.value.scrollWidth;
            const height = Math.max(originalHeight, props2.minSize);
            const width = Math.max(originalWidth, props2.minSize);
            ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
            ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
            sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
            sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
          };
          watch(() => props2.noresize, (noresize) => {
            if (noresize) {
              stopResizeObserver == null ? void 0 : stopResizeObserver();
              stopResizeListener == null ? void 0 : stopResizeListener();
            } else {
              ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update));
              stopResizeListener = useEventListener$1("resize", update);
            }
          }, { immediate: true });
          watch(() => [props2.maxHeight, props2.height], () => {
            if (!props2.native)
              nextTick(() => {
                var _a2;
                update();
                if (wrapRef.value) {
                  (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
                }
              });
          });
          provide(scrollbarContextKey, reactive({
            scrollbarElement: scrollbarRef,
            wrapElement: wrapRef
          }));
          onMounted(() => {
            if (!props2.native)
              nextTick(() => {
                update();
              });
          });
          onUpdated(() => update());
          expose({
            wrapRef,
            update,
            scrollTo,
            setScrollTop,
            setScrollLeft,
            handleScroll
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "scrollbarRef",
              ref: scrollbarRef,
              class: normalizeClass(unref(ns).b())
            }, [
              createBaseVNode("div", {
                ref_key: "wrapRef",
                ref: wrapRef,
                class: normalizeClass(unref(wrapKls)),
                style: normalizeStyle(unref(style)),
                onScroll: handleScroll
              }, [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
                  ref_key: "resizeRef",
                  ref: resizeRef,
                  class: normalizeClass(unref(resizeKls)),
                  style: normalizeStyle(_ctx.viewStyle)
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["class", "style"]))
              ], 38),
              !_ctx.native ? (openBlock(), createBlock(Bar, {
                key: 0,
                ref_key: "barRef",
                ref: barRef,
                height: sizeHeight.value,
                width: sizeWidth.value,
                always: _ctx.always,
                "ratio-x": ratioX.value,
                "ratio-y": ratioY.value
              }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"])) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Scrollbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$Z, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);
      const ElScrollbar = withInstall(Scrollbar);
      const POPPER_INJECTION_KEY = Symbol("popper");
      const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
      const roleTypes = [
        "dialog",
        "grid",
        "group",
        "listbox",
        "menu",
        "navigation",
        "tooltip",
        "tree"
      ];
      const popperProps = buildProps({
        role: {
          type: String,
          values: roleTypes,
          default: "tooltip"
        }
      });
      const __default__$x = defineComponent({
        name: "ElPopper",
        inheritAttrs: false
      });
      const _sfc_main$Y = /* @__PURE__ */ defineComponent({
        ...__default__$x,
        props: popperProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const triggerRef2 = ref();
          const popperInstanceRef = ref();
          const contentRef = ref();
          const referenceRef = ref();
          const role = computed(() => props2.role);
          const popperProvides = {
            triggerRef: triggerRef2,
            popperInstanceRef,
            contentRef,
            referenceRef,
            role
          };
          expose(popperProvides);
          provide(POPPER_INJECTION_KEY, popperProvides);
          return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
          };
        }
      });
      var Popper = /* @__PURE__ */ _export_sfc$1(_sfc_main$Y, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
      const popperArrowProps = buildProps({
        arrowOffset: {
          type: Number,
          default: 5
        }
      });
      const __default__$w = defineComponent({
        name: "ElPopperArrow",
        inheritAttrs: false
      });
      const _sfc_main$X = /* @__PURE__ */ defineComponent({
        ...__default__$w,
        props: popperArrowProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const ns = useNamespace("popper");
          const { arrowOffset, arrowRef, arrowStyle } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
          watch(() => props2.arrowOffset, (val) => {
            arrowOffset.value = val;
          });
          onBeforeUnmount(() => {
            arrowRef.value = void 0;
          });
          expose({
            arrowRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              ref_key: "arrowRef",
              ref: arrowRef,
              class: normalizeClass(unref(ns).e("arrow")),
              style: normalizeStyle(unref(arrowStyle)),
              "data-popper-arrow": ""
            }, null, 6);
          };
        }
      });
      var ElPopperArrow = /* @__PURE__ */ _export_sfc$1(_sfc_main$X, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
      const NAME = "ElOnlyChild";
      const OnlyChild = defineComponent({
        name: NAME,
        setup(_2, {
          slots,
          attrs
        }) {
          var _a2;
          const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
          const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
          return () => {
            var _a22;
            const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
            if (!defaultSlot)
              return null;
            if (defaultSlot.length > 1) {
              return null;
            }
            const firstLegitNode = findFirstLegitChild(defaultSlot);
            if (!firstLegitNode) {
              return null;
            }
            return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
          };
        }
      });
      function findFirstLegitChild(node) {
        if (!node)
          return null;
        const children = node;
        for (const child of children) {
          if (isObject$1(child)) {
            switch (child.type) {
              case Comment:
                continue;
              case Text:
              case "svg":
                return wrapTextContent(child);
              case Fragment:
                return findFirstLegitChild(child.children);
              default:
                return child;
            }
          }
          return wrapTextContent(child);
        }
        return null;
      }
      function wrapTextContent(s2) {
        const ns = useNamespace("only-child");
        return createVNode("span", {
          "class": ns.e("content")
        }, [s2]);
      }
      const popperTriggerProps = buildProps({
        virtualRef: {
          type: definePropType(Object)
        },
        virtualTriggering: Boolean,
        onMouseenter: {
          type: definePropType(Function)
        },
        onMouseleave: {
          type: definePropType(Function)
        },
        onClick: {
          type: definePropType(Function)
        },
        onKeydown: {
          type: definePropType(Function)
        },
        onFocus: {
          type: definePropType(Function)
        },
        onBlur: {
          type: definePropType(Function)
        },
        onContextmenu: {
          type: definePropType(Function)
        },
        id: String,
        open: Boolean
      });
      const __default__$v = defineComponent({
        name: "ElPopperTrigger",
        inheritAttrs: false
      });
      const _sfc_main$W = /* @__PURE__ */ defineComponent({
        ...__default__$v,
        props: popperTriggerProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const { role, triggerRef: triggerRef2 } = inject(POPPER_INJECTION_KEY, void 0);
          useForwardRef(triggerRef2);
          const ariaControls = computed(() => {
            return ariaHaspopup.value ? props2.id : void 0;
          });
          const ariaDescribedby = computed(() => {
            if (role && role.value === "tooltip") {
              return props2.open && props2.id ? props2.id : void 0;
            }
            return void 0;
          });
          const ariaHaspopup = computed(() => {
            if (role && role.value !== "tooltip") {
              return role.value;
            }
            return void 0;
          });
          const ariaExpanded = computed(() => {
            return ariaHaspopup.value ? `${props2.open}` : void 0;
          });
          let virtualTriggerAriaStopWatch = void 0;
          onMounted(() => {
            watch(() => props2.virtualRef, (virtualEl) => {
              if (virtualEl) {
                triggerRef2.value = unrefElement$1(virtualEl);
              }
            }, {
              immediate: true
            });
            watch(triggerRef2, (el, prevEl) => {
              virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
              virtualTriggerAriaStopWatch = void 0;
              if (isElement(el)) {
                [
                  "onMouseenter",
                  "onMouseleave",
                  "onClick",
                  "onKeydown",
                  "onFocus",
                  "onBlur",
                  "onContextmenu"
                ].forEach((eventName) => {
                  var _a2;
                  const handler = props2[eventName];
                  if (handler) {
                    el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                    (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                  }
                });
                virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                  [
                    "aria-controls",
                    "aria-describedby",
                    "aria-haspopup",
                    "aria-expanded"
                  ].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (isElement(prevEl)) {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key) => prevEl.removeAttribute(key));
              }
            }, {
              immediate: true
            });
          });
          onBeforeUnmount(() => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
          });
          expose({
            triggerRef: triggerRef2
          });
          return (_ctx, _cache) => {
            return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
              "aria-controls": unref(ariaControls),
              "aria-describedby": unref(ariaDescribedby),
              "aria-expanded": unref(ariaExpanded),
              "aria-haspopup": unref(ariaHaspopup)
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
          };
        }
      });
      var ElPopperTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$W, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
      const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
      const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
      const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
      const FOCUS_AFTER_TRAPPED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const FOCUSOUT_PREVENTED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
      const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
      const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
      const focusReason = ref();
      const lastUserFocusTimestamp = ref(0);
      const lastAutomatedFocusTimestamp = ref(0);
      let focusReasonUserCount = 0;
      const obtainAllFocusableElements = (element) => {
        const nodes = [];
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (node) => {
            const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
            if (node.disabled || node.hidden || isHiddenInput)
              return NodeFilter.FILTER_SKIP;
            return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          }
        });
        while (walker.nextNode())
          nodes.push(walker.currentNode);
        return nodes;
      };
      const getVisibleElement = (elements, container) => {
        for (const element of elements) {
          if (!isHidden(element, container))
            return element;
        }
      };
      const isHidden = (element, container) => {
        if (getComputedStyle(element).visibility === "hidden")
          return true;
        while (element) {
          if (container && element === container)
            return false;
          if (getComputedStyle(element).display === "none")
            return true;
          element = element.parentElement;
        }
        return false;
      };
      const getEdges = (container) => {
        const focusable = obtainAllFocusableElements(container);
        const first = getVisibleElement(focusable, container);
        const last = getVisibleElement(focusable.reverse(), container);
        return [first, last];
      };
      const isSelectable = (element) => {
        return element instanceof HTMLInputElement && "select" in element;
      };
      const tryFocus = (element, shouldSelect) => {
        if (element && element.focus) {
          const prevFocusedElement = document.activeElement;
          element.focus({ preventScroll: true });
          lastAutomatedFocusTimestamp.value = window.performance.now();
          if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
            element.select();
          }
        }
      };
      function removeFromStack(list, item) {
        const copy = [...list];
        const idx = list.indexOf(item);
        if (idx !== -1) {
          copy.splice(idx, 1);
        }
        return copy;
      }
      const createFocusableStack = () => {
        let stack = [];
        const push = (layer) => {
          const currentLayer = stack[0];
          if (currentLayer && layer !== currentLayer) {
            currentLayer.pause();
          }
          stack = removeFromStack(stack, layer);
          stack.unshift(layer);
        };
        const remove2 = (layer) => {
          var _a2, _b;
          stack = removeFromStack(stack, layer);
          (_b = (_a2 = stack[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
        };
        return {
          push,
          remove: remove2
        };
      };
      const focusFirstDescendant = (elements, shouldSelect = false) => {
        const prevFocusedElement = document.activeElement;
        for (const element of elements) {
          tryFocus(element, shouldSelect);
          if (document.activeElement !== prevFocusedElement)
            return;
        }
      };
      const focusableStack = createFocusableStack();
      const isFocusCausedByUserEvent = () => {
        return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
      };
      const notifyFocusReasonPointer = () => {
        focusReason.value = "pointer";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const notifyFocusReasonKeydown = () => {
        focusReason.value = "keyboard";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const useFocusReason = () => {
        onMounted(() => {
          if (focusReasonUserCount === 0) {
            document.addEventListener("mousedown", notifyFocusReasonPointer);
            document.addEventListener("touchstart", notifyFocusReasonPointer);
            document.addEventListener("keydown", notifyFocusReasonKeydown);
          }
          focusReasonUserCount++;
        });
        onBeforeUnmount(() => {
          focusReasonUserCount--;
          if (focusReasonUserCount <= 0) {
            document.removeEventListener("mousedown", notifyFocusReasonPointer);
            document.removeEventListener("touchstart", notifyFocusReasonPointer);
            document.removeEventListener("keydown", notifyFocusReasonKeydown);
          }
        });
        return {
          focusReason,
          lastUserFocusTimestamp,
          lastAutomatedFocusTimestamp
        };
      };
      const createFocusOutPreventedEvent = (detail) => {
        return new CustomEvent(FOCUSOUT_PREVENTED, {
          ...FOCUSOUT_PREVENTED_OPTS,
          detail
        });
      };
      const _sfc_main$V = defineComponent({
        name: "ElFocusTrap",
        inheritAttrs: false,
        props: {
          loop: Boolean,
          trapped: Boolean,
          focusTrapEl: Object,
          focusStartEl: {
            type: [Object, String],
            default: "first"
          }
        },
        emits: [
          ON_TRAP_FOCUS_EVT,
          ON_RELEASE_FOCUS_EVT,
          "focusin",
          "focusout",
          "focusout-prevented",
          "release-requested"
        ],
        setup(props2, { emit: emit2 }) {
          const forwardRef = ref();
          let lastFocusBeforeTrapped;
          let lastFocusAfterTrapped;
          const { focusReason: focusReason2 } = useFocusReason();
          useEscapeKeydown((event) => {
            if (props2.trapped && !focusLayer.paused) {
              emit2("release-requested", event);
            }
          });
          const focusLayer = {
            paused: false,
            pause() {
              this.paused = true;
            },
            resume() {
              this.paused = false;
            }
          };
          const onKeydown = (e2) => {
            if (!props2.loop && !props2.trapped)
              return;
            if (focusLayer.paused)
              return;
            const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e2;
            const { loop } = props2;
            const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
            const currentFocusingEl = document.activeElement;
            if (isTabbing && currentFocusingEl) {
              const container = currentTarget;
              const [first, last] = getEdges(container);
              const isTabbable = first && last;
              if (!isTabbable) {
                if (currentFocusingEl === container) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e2.preventDefault();
                  }
                }
              } else {
                if (!shiftKey && currentFocusingEl === last) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e2.preventDefault();
                    if (loop)
                      tryFocus(first, true);
                  }
                } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e2.preventDefault();
                    if (loop)
                      tryFocus(last, true);
                  }
                }
              }
            }
          };
          provide(FOCUS_TRAP_INJECTION_KEY, {
            focusTrapRef: forwardRef,
            onKeydown
          });
          watch(() => props2.focusTrapEl, (focusTrapEl) => {
            if (focusTrapEl) {
              forwardRef.value = focusTrapEl;
            }
          }, { immediate: true });
          watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
            if (forwardRef2) {
              forwardRef2.addEventListener("keydown", onKeydown);
              forwardRef2.addEventListener("focusin", onFocusIn);
              forwardRef2.addEventListener("focusout", onFocusOut);
            }
            if (oldForwardRef) {
              oldForwardRef.removeEventListener("keydown", onKeydown);
              oldForwardRef.removeEventListener("focusin", onFocusIn);
              oldForwardRef.removeEventListener("focusout", onFocusOut);
            }
          });
          const trapOnFocus = (e2) => {
            emit2(ON_TRAP_FOCUS_EVT, e2);
          };
          const releaseOnFocus = (e2) => emit2(ON_RELEASE_FOCUS_EVT, e2);
          const onFocusIn = (e2) => {
            const trapContainer = unref(forwardRef);
            if (!trapContainer)
              return;
            const target = e2.target;
            const relatedTarget = e2.relatedTarget;
            const isFocusedInTrap = target && trapContainer.contains(target);
            if (!props2.trapped) {
              const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
              if (!isPrevFocusedInTrap) {
                lastFocusBeforeTrapped = relatedTarget;
              }
            }
            if (isFocusedInTrap)
              emit2("focusin", e2);
            if (focusLayer.paused)
              return;
            if (props2.trapped) {
              if (isFocusedInTrap) {
                lastFocusAfterTrapped = target;
              } else {
                tryFocus(lastFocusAfterTrapped, true);
              }
            }
          };
          const onFocusOut = (e2) => {
            const trapContainer = unref(forwardRef);
            if (focusLayer.paused || !trapContainer)
              return;
            if (props2.trapped) {
              const relatedTarget = e2.relatedTarget;
              if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
                setTimeout(() => {
                  if (!focusLayer.paused && props2.trapped) {
                    const focusoutPreventedEvent = createFocusOutPreventedEvent({
                      focusReason: focusReason2.value
                    });
                    emit2("focusout-prevented", focusoutPreventedEvent);
                    if (!focusoutPreventedEvent.defaultPrevented) {
                      tryFocus(lastFocusAfterTrapped, true);
                    }
                  }
                }, 0);
              }
            } else {
              const target = e2.target;
              const isFocusedInTrap = target && trapContainer.contains(target);
              if (!isFocusedInTrap)
                emit2("focusout", e2);
            }
          };
          async function startTrap() {
            await nextTick();
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              focusableStack.push(focusLayer);
              const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
              lastFocusBeforeTrapped = prevFocusedElement;
              const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
              if (!isPrevFocusContained) {
                const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
                trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
                trapContainer.dispatchEvent(focusEvent);
                if (!focusEvent.defaultPrevented) {
                  nextTick(() => {
                    let focusStartEl = props2.focusStartEl;
                    if (!isString$2(focusStartEl)) {
                      tryFocus(focusStartEl);
                      if (document.activeElement !== focusStartEl) {
                        focusStartEl = "first";
                      }
                    }
                    if (focusStartEl === "first") {
                      focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                    }
                    if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                      tryFocus(trapContainer);
                    }
                  });
                }
              }
            }
          }
          function stopTrap() {
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
              const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
                ...FOCUS_AFTER_TRAPPED_OPTS,
                detail: {
                  focusReason: focusReason2.value
                }
              });
              trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              trapContainer.dispatchEvent(releasedEvent);
              if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
                tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
              }
              trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus);
              focusableStack.remove(focusLayer);
            }
          }
          onMounted(() => {
            if (props2.trapped) {
              startTrap();
            }
            watch(() => props2.trapped, (trapped) => {
              if (trapped) {
                startTrap();
              } else {
                stopTrap();
              }
            });
          });
          onBeforeUnmount(() => {
            if (props2.trapped) {
              stopTrap();
            }
          });
          return {
            onKeydown
          };
        }
      });
      function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
      }
      var ElFocusTrap = /* @__PURE__ */ _export_sfc$1(_sfc_main$V, [["render", _sfc_render$h], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);
      const POSITIONING_STRATEGIES = ["fixed", "absolute"];
      const popperCoreConfigProps = buildProps({
        boundariesPadding: {
          type: Number,
          default: 0
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: void 0
        },
        gpuAcceleration: {
          type: Boolean,
          default: true
        },
        offset: {
          type: Number,
          default: 12
        },
        placement: {
          type: String,
          values: Ee,
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        strategy: {
          type: String,
          values: POSITIONING_STRATEGIES,
          default: "absolute"
        }
      });
      const popperContentProps = buildProps({
        ...popperCoreConfigProps,
        id: String,
        style: {
          type: definePropType([String, Array, Object])
        },
        className: {
          type: definePropType([String, Array, Object])
        },
        effect: {
          type: String,
          default: "dark"
        },
        visible: Boolean,
        enterable: {
          type: Boolean,
          default: true
        },
        pure: Boolean,
        focusOnShow: {
          type: Boolean,
          default: false
        },
        trapping: {
          type: Boolean,
          default: false
        },
        popperClass: {
          type: definePropType([String, Array, Object])
        },
        popperStyle: {
          type: definePropType([String, Array, Object])
        },
        referenceEl: {
          type: definePropType(Object)
        },
        triggerTargetEl: {
          type: definePropType(Object)
        },
        stopPopperMouseEvent: {
          type: Boolean,
          default: true
        },
        ariaLabel: {
          type: String,
          default: void 0
        },
        virtualTriggering: Boolean,
        zIndex: Number
      });
      const popperContentEmits = {
        mouseenter: (evt) => evt instanceof MouseEvent,
        mouseleave: (evt) => evt instanceof MouseEvent,
        focus: () => true,
        blur: () => true,
        close: () => true
      };
      const buildPopperOptions = (props2, modifiers = []) => {
        const { placement, strategy, popperOptions } = props2;
        const options = {
          placement,
          strategy,
          ...popperOptions,
          modifiers: [...genModifiers(props2), ...modifiers]
        };
        deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
        return options;
      };
      const unwrapMeasurableEl = ($el) => {
        if (!isClient$1)
          return;
        return unrefElement$1($el);
      };
      function genModifiers(options) {
        const { offset, gpuAcceleration, fallbackPlacements } = options;
        return [
          {
            name: "offset",
            options: {
              offset: [0, offset != null ? offset : 12]
            }
          },
          {
            name: "preventOverflow",
            options: {
              padding: {
                top: 2,
                bottom: 2,
                left: 5,
                right: 5
              }
            }
          },
          {
            name: "flip",
            options: {
              padding: 5,
              fallbackPlacements
            }
          },
          {
            name: "computeStyles",
            options: {
              gpuAcceleration
            }
          }
        ];
      }
      function deriveExtraModifiers(options, modifiers) {
        if (modifiers) {
          options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
        }
      }
      const DEFAULT_ARROW_OFFSET = 0;
      const usePopperContent = (props2) => {
        const { popperInstanceRef, contentRef, triggerRef: triggerRef2, role } = inject(POPPER_INJECTION_KEY, void 0);
        const arrowRef = ref();
        const arrowOffset = ref();
        const eventListenerModifier = computed(() => {
          return {
            name: "eventListeners",
            enabled: !!props2.visible
          };
        });
        const arrowModifier = computed(() => {
          var _a2;
          const arrowEl = unref(arrowRef);
          const offset = (_a2 = unref(arrowOffset)) != null ? _a2 : DEFAULT_ARROW_OFFSET;
          return {
            name: "arrow",
            enabled: !isUndefined$1(arrowEl),
            options: {
              element: arrowEl,
              padding: offset
            }
          };
        });
        const options = computed(() => {
          return {
            onFirstUpdate: () => {
              update();
            },
            ...buildPopperOptions(props2, [
              unref(arrowModifier),
              unref(eventListenerModifier)
            ])
          };
        });
        const computedReference = computed(() => unwrapMeasurableEl(props2.referenceEl) || unref(triggerRef2));
        const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options);
        watch(instanceRef, (instance) => popperInstanceRef.value = instance);
        onMounted(() => {
          watch(() => {
            var _a2;
            return (_a2 = unref(computedReference)) == null ? void 0 : _a2.getBoundingClientRect();
          }, () => {
            update();
          });
        });
        return {
          attributes,
          arrowRef,
          contentRef,
          instanceRef,
          state,
          styles,
          role,
          forceUpdate,
          update
        };
      };
      const usePopperContentDOM = (props2, {
        attributes,
        styles,
        role
      }) => {
        const { nextZIndex } = useZIndex();
        const ns = useNamespace("popper");
        const contentAttrs = computed(() => unref(attributes).popper);
        const contentZIndex = ref(props2.zIndex || nextZIndex());
        const contentClass = computed(() => [
          ns.b(),
          ns.is("pure", props2.pure),
          ns.is(props2.effect),
          props2.popperClass
        ]);
        const contentStyle = computed(() => {
          return [
            { zIndex: unref(contentZIndex) },
            unref(styles).popper,
            props2.popperStyle || {}
          ];
        });
        const ariaModal = computed(() => role.value === "dialog" ? "false" : void 0);
        const arrowStyle = computed(() => unref(styles).arrow || {});
        const updateZIndex = () => {
          contentZIndex.value = props2.zIndex || nextZIndex();
        };
        return {
          ariaModal,
          arrowStyle,
          contentAttrs,
          contentClass,
          contentStyle,
          contentZIndex,
          updateZIndex
        };
      };
      const usePopperContentFocusTrap = (props2, emit2) => {
        const trapped = ref(false);
        const focusStartRef = ref();
        const onFocusAfterTrapped = () => {
          emit2("focus");
        };
        const onFocusAfterReleased = (event) => {
          var _a2;
          if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) !== "pointer") {
            focusStartRef.value = "first";
            emit2("blur");
          }
        };
        const onFocusInTrap = (event) => {
          if (props2.visible && !trapped.value) {
            if (event.target) {
              focusStartRef.value = event.target;
            }
            trapped.value = true;
          }
        };
        const onFocusoutPrevented = (event) => {
          if (!props2.trapping) {
            if (event.detail.focusReason === "pointer") {
              event.preventDefault();
            }
            trapped.value = false;
          }
        };
        const onReleaseRequested = () => {
          trapped.value = false;
          emit2("close");
        };
        return {
          focusStartRef,
          trapped,
          onFocusAfterReleased,
          onFocusAfterTrapped,
          onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        };
      };
      const __default__$u = defineComponent({
        name: "ElPopperContent"
      });
      const _sfc_main$U = /* @__PURE__ */ defineComponent({
        ...__default__$u,
        props: popperContentProps,
        emits: popperContentEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props2 = __props;
          const {
            focusStartRef,
            trapped,
            onFocusAfterReleased,
            onFocusAfterTrapped,
            onFocusInTrap,
            onFocusoutPrevented,
            onReleaseRequested
          } = usePopperContentFocusTrap(props2, emit2);
          const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props2);
          const {
            ariaModal,
            arrowStyle,
            contentAttrs,
            contentClass,
            contentStyle,
            updateZIndex
          } = usePopperContentDOM(props2, {
            styles,
            attributes,
            role
          });
          const formItemContext = inject(formItemContextKey, void 0);
          const arrowOffset = ref();
          provide(POPPER_CONTENT_INJECTION_KEY, {
            arrowStyle,
            arrowRef,
            arrowOffset
          });
          if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) {
            provide(formItemContextKey, {
              ...formItemContext,
              addInputId: NOOP,
              removeInputId: NOOP
            });
          }
          let triggerTargetAriaStopWatch = void 0;
          const updatePopper = (shouldUpdateZIndex = true) => {
            update();
            shouldUpdateZIndex && updateZIndex();
          };
          const togglePopperAlive = () => {
            updatePopper(false);
            if (props2.visible && props2.focusOnShow) {
              trapped.value = true;
            } else if (props2.visible === false) {
              trapped.value = false;
            }
          };
          onMounted(() => {
            watch(() => props2.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
              triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
              triggerTargetAriaStopWatch = void 0;
              const el = unref(triggerTargetEl || contentRef.value);
              const prevEl = unref(prevTriggerTargetEl || contentRef.value);
              if (isElement(el)) {
                triggerTargetAriaStopWatch = watch([role, () => props2.ariaLabel, ariaModal, () => props2.id], (watches) => {
                  ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (prevEl !== el && isElement(prevEl)) {
                ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                  prevEl.removeAttribute(key);
                });
              }
            }, { immediate: true });
            watch(() => props2.visible, togglePopperAlive, { immediate: true });
          });
          onBeforeUnmount(() => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
          });
          expose({
            popperContentRef: contentRef,
            popperInstanceRef: instanceRef,
            updatePopper,
            contentStyle
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", mergeProps({
              ref_key: "contentRef",
              ref: contentRef
            }, unref(contentAttrs), {
              style: unref(contentStyle),
              class: unref(contentClass),
              tabindex: "-1",
              onMouseenter: _cache[0] || (_cache[0] = (e2) => _ctx.$emit("mouseenter", e2)),
              onMouseleave: _cache[1] || (_cache[1] = (e2) => _ctx.$emit("mouseleave", e2))
            }), [
              createVNode(unref(ElFocusTrap), {
                trapped: unref(trapped),
                "trap-on-focus-in": true,
                "focus-trap-el": unref(contentRef),
                "focus-start-el": unref(focusStartRef),
                onFocusAfterTrapped: unref(onFocusAfterTrapped),
                onFocusAfterReleased: unref(onFocusAfterReleased),
                onFocusin: unref(onFocusInTrap),
                onFocusoutPrevented: unref(onFocusoutPrevented),
                onReleaseRequested: unref(onReleaseRequested)
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
            ], 16);
          };
        }
      });
      var ElPopperContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$U, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
      const ElPopper = withInstall(Popper);
      const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
      const useTooltipContentProps = buildProps({
        ...useDelayedToggleProps,
        ...popperContentProps,
        appendTo: {
          type: definePropType([String, Object])
        },
        content: {
          type: String,
          default: ""
        },
        rawContent: {
          type: Boolean,
          default: false
        },
        persistent: Boolean,
        ariaLabel: String,
        visible: {
          type: definePropType(Boolean),
          default: null
        },
        transition: String,
        teleported: {
          type: Boolean,
          default: true
        },
        disabled: Boolean
      });
      const useTooltipTriggerProps = buildProps({
        ...popperTriggerProps,
        disabled: Boolean,
        trigger: {
          type: definePropType([String, Array]),
          default: "hover"
        },
        triggerKeys: {
          type: definePropType(Array),
          default: () => [EVENT_CODE.enter, EVENT_CODE.space]
        }
      });
      const {
        useModelToggleProps: useTooltipModelToggleProps,
        useModelToggleEmits: useTooltipModelToggleEmits,
        useModelToggle: useTooltipModelToggle
      } = createModelToggleComposable("visible");
      const useTooltipProps = buildProps({
        ...popperProps,
        ...useTooltipModelToggleProps,
        ...useTooltipContentProps,
        ...useTooltipTriggerProps,
        ...popperArrowProps,
        showArrow: {
          type: Boolean,
          default: true
        }
      });
      const tooltipEmits = [
        ...useTooltipModelToggleEmits,
        "before-show",
        "before-hide",
        "show",
        "hide",
        "open",
        "close"
      ];
      const isTriggerType = (trigger2, type2) => {
        if (isArray$3(trigger2)) {
          return trigger2.includes(type2);
        }
        return trigger2 === type2;
      };
      const whenTrigger = (trigger2, type2, handler) => {
        return (e2) => {
          isTriggerType(unref(trigger2), type2) && handler(e2);
        };
      };
      const __default__$t = defineComponent({
        name: "ElTooltipTrigger"
      });
      const _sfc_main$T = /* @__PURE__ */ defineComponent({
        ...__default__$t,
        props: useTooltipTriggerProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const ns = useNamespace("tooltip");
          const { controlled, id: id2, open: open2, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const triggerRef2 = ref(null);
          const stopWhenControlledOrDisabled = () => {
            if (unref(controlled) || props2.disabled) {
              return true;
            }
          };
          const trigger2 = toRef$1(props2, "trigger");
          const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onOpen));
          const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onClose));
          const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "click", (e2) => {
            if (e2.button === 0) {
              onToggle(e2);
            }
          }));
          const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onOpen));
          const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onClose));
          const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "contextmenu", (e2) => {
            e2.preventDefault();
            onToggle(e2);
          }));
          const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e2) => {
            const { code } = e2;
            if (props2.triggerKeys.includes(code)) {
              e2.preventDefault();
              onToggle(e2);
            }
          });
          expose({
            triggerRef: triggerRef2
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopperTrigger), {
              id: unref(id2),
              "virtual-ref": _ctx.virtualRef,
              open: unref(open2),
              "virtual-triggering": _ctx.virtualTriggering,
              class: normalizeClass(unref(ns).e("trigger")),
              onBlur: unref(onBlur),
              onClick: unref(onClick),
              onContextmenu: unref(onContextMenu),
              onFocus: unref(onFocus),
              onMouseenter: unref(onMouseenter),
              onMouseleave: unref(onMouseleave),
              onKeydown: unref(onKeydown)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
          };
        }
      });
      var ElTooltipTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$T, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
      const __default__$s = defineComponent({
        name: "ElTooltipContent",
        inheritAttrs: false
      });
      const _sfc_main$S = /* @__PURE__ */ defineComponent({
        ...__default__$s,
        props: useTooltipContentProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const { selector } = usePopperContainerId();
          const ns = useNamespace("tooltip");
          const contentRef = ref(null);
          const destroyed = ref(false);
          const {
            controlled,
            id: id2,
            open: open2,
            trigger: trigger2,
            onClose,
            onOpen,
            onShow,
            onHide,
            onBeforeShow,
            onBeforeHide
          } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const transitionClass = computed(() => {
            return props2.transition || `${ns.namespace.value}-fade-in-linear`;
          });
          const persistentRef = computed(() => {
            return props2.persistent;
          });
          onBeforeUnmount(() => {
            destroyed.value = true;
          });
          const shouldRender = computed(() => {
            return unref(persistentRef) ? true : unref(open2);
          });
          const shouldShow = computed(() => {
            return props2.disabled ? false : unref(open2);
          });
          const appendTo = computed(() => {
            return props2.appendTo || selector.value;
          });
          const contentStyle = computed(() => {
            var _a2;
            return (_a2 = props2.style) != null ? _a2 : {};
          });
          const ariaHidden = computed(() => !unref(open2));
          const onTransitionLeave = () => {
            onHide();
          };
          const stopWhenControlled = () => {
            if (unref(controlled))
              return true;
          };
          const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
            if (props2.enterable && unref(trigger2) === "hover") {
              onOpen();
            }
          });
          const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
            if (unref(trigger2) === "hover") {
              onClose();
            }
          });
          const onBeforeEnter = () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            onBeforeShow == null ? void 0 : onBeforeShow();
          };
          const onBeforeLeave = () => {
            onBeforeHide == null ? void 0 : onBeforeHide();
          };
          const onAfterShow = () => {
            onShow();
            stopHandle = onClickOutside(computed(() => {
              var _a2;
              return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
            }), () => {
              if (unref(controlled))
                return;
              const $trigger = unref(trigger2);
              if ($trigger !== "hover") {
                onClose();
              }
            });
          };
          const onBlur = () => {
            if (!props2.virtualTriggering) {
              onClose();
            }
          };
          let stopHandle;
          watch(() => unref(open2), (val) => {
            if (!val) {
              stopHandle == null ? void 0 : stopHandle();
            }
          }, {
            flush: "post"
          });
          watch(() => props2.content, () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          });
          expose({
            contentRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              disabled: !_ctx.teleported,
              to: unref(appendTo)
            }, [
              createVNode(Transition, {
                name: unref(transitionClass),
                onAfterLeave: onTransitionLeave,
                onBeforeEnter,
                onAfterEnter: onAfterShow,
                onBeforeLeave
              }, {
                default: withCtx(() => [
                  unref(shouldRender) ? withDirectives((openBlock(), createBlock(unref(ElPopperContent), mergeProps({
                    key: 0,
                    id: unref(id2),
                    ref_key: "contentRef",
                    ref: contentRef
                  }, _ctx.$attrs, {
                    "aria-label": _ctx.ariaLabel,
                    "aria-hidden": unref(ariaHidden),
                    "boundaries-padding": _ctx.boundariesPadding,
                    "fallback-placements": _ctx.fallbackPlacements,
                    "gpu-acceleration": _ctx.gpuAcceleration,
                    offset: _ctx.offset,
                    placement: _ctx.placement,
                    "popper-options": _ctx.popperOptions,
                    strategy: _ctx.strategy,
                    effect: _ctx.effect,
                    enterable: _ctx.enterable,
                    pure: _ctx.pure,
                    "popper-class": _ctx.popperClass,
                    "popper-style": [_ctx.popperStyle, unref(contentStyle)],
                    "reference-el": _ctx.referenceEl,
                    "trigger-target-el": _ctx.triggerTargetEl,
                    visible: unref(shouldShow),
                    "z-index": _ctx.zIndex,
                    onMouseenter: unref(onContentEnter),
                    onMouseleave: unref(onContentLeave),
                    onBlur,
                    onClose: unref(onClose)
                  }), {
                    default: withCtx(() => [
                      !destroyed.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                    ]),
                    _: 3
                  }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
                    [vShow, unref(shouldShow)]
                  ]) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["name"])
            ], 8, ["disabled", "to"]);
          };
        }
      });
      var ElTooltipContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$S, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
      const _hoisted_1$N = ["innerHTML"];
      const _hoisted_2$C = { key: 1 };
      const __default__$r = defineComponent({
        name: "ElTooltip"
      });
      const _sfc_main$R = /* @__PURE__ */ defineComponent({
        ...__default__$r,
        props: useTooltipProps,
        emits: tooltipEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props2 = __props;
          usePopperContainer();
          const id2 = useId();
          const popperRef = ref();
          const contentRef = ref();
          const updatePopper = () => {
            var _a2;
            const popperComponent = unref(popperRef);
            if (popperComponent) {
              (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
            }
          };
          const open2 = ref(false);
          const toggleReason = ref();
          const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
            indicator: open2,
            toggleReason
          });
          const { onOpen, onClose } = useDelayedToggle({
            showAfter: toRef$1(props2, "showAfter"),
            hideAfter: toRef$1(props2, "hideAfter"),
            autoClose: toRef$1(props2, "autoClose"),
            open: show,
            close: hide
          });
          const controlled = computed(() => isBoolean(props2.visible) && !hasUpdateHandler.value);
          provide(TOOLTIP_INJECTION_KEY, {
            controlled,
            id: id2,
            open: readonly(open2),
            trigger: toRef$1(props2, "trigger"),
            onOpen: (event) => {
              onOpen(event);
            },
            onClose: (event) => {
              onClose(event);
            },
            onToggle: (event) => {
              if (unref(open2)) {
                onClose(event);
              } else {
                onOpen(event);
              }
            },
            onShow: () => {
              emit2("show", toggleReason.value);
            },
            onHide: () => {
              emit2("hide", toggleReason.value);
            },
            onBeforeShow: () => {
              emit2("before-show", toggleReason.value);
            },
            onBeforeHide: () => {
              emit2("before-hide", toggleReason.value);
            },
            updatePopper
          });
          watch(() => props2.disabled, (disabled) => {
            if (disabled && open2.value) {
              open2.value = false;
            }
          });
          const isFocusInsideContent = () => {
            var _a2, _b;
            const popperContent = (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.contentRef) == null ? void 0 : _b.popperContentRef;
            return popperContent && popperContent.contains(document.activeElement);
          };
          onDeactivated(() => open2.value && hide());
          expose({
            popperRef,
            contentRef,
            isFocusInsideContent,
            updatePopper,
            onOpen,
            onClose,
            hide
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopper), {
              ref_key: "popperRef",
              ref: popperRef,
              role: _ctx.role
            }, {
              default: withCtx(() => [
                createVNode(ElTooltipTrigger, {
                  disabled: _ctx.disabled,
                  trigger: _ctx.trigger,
                  "trigger-keys": _ctx.triggerKeys,
                  "virtual-ref": _ctx.virtualRef,
                  "virtual-triggering": _ctx.virtualTriggering
                }, {
                  default: withCtx(() => [
                    _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
                createVNode(ElTooltipContent, {
                  ref_key: "contentRef",
                  ref: contentRef,
                  "aria-label": _ctx.ariaLabel,
                  "boundaries-padding": _ctx.boundariesPadding,
                  content: _ctx.content,
                  disabled: _ctx.disabled,
                  effect: _ctx.effect,
                  enterable: _ctx.enterable,
                  "fallback-placements": _ctx.fallbackPlacements,
                  "hide-after": _ctx.hideAfter,
                  "gpu-acceleration": _ctx.gpuAcceleration,
                  offset: _ctx.offset,
                  persistent: _ctx.persistent,
                  "popper-class": _ctx.popperClass,
                  "popper-style": _ctx.popperStyle,
                  placement: _ctx.placement,
                  "popper-options": _ctx.popperOptions,
                  pure: _ctx.pure,
                  "raw-content": _ctx.rawContent,
                  "reference-el": _ctx.referenceEl,
                  "trigger-target-el": _ctx.triggerTargetEl,
                  "show-after": _ctx.showAfter,
                  strategy: _ctx.strategy,
                  teleported: _ctx.teleported,
                  transition: _ctx.transition,
                  "virtual-triggering": _ctx.virtualTriggering,
                  "z-index": _ctx.zIndex,
                  "append-to": _ctx.appendTo
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "content", {}, () => [
                      _ctx.rawContent ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        innerHTML: _ctx.content
                      }, null, 8, _hoisted_1$N)) : (openBlock(), createElementBlock("span", _hoisted_2$C, toDisplayString(_ctx.content), 1))
                    ]),
                    _ctx.showArrow ? (openBlock(), createBlock(unref(ElPopperArrow), {
                      key: 0,
                      "arrow-offset": _ctx.arrowOffset
                    }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
              ]),
              _: 3
            }, 8, ["role"]);
          };
        }
      });
      var Tooltip = /* @__PURE__ */ _export_sfc$1(_sfc_main$R, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
      const ElTooltip = withInstall(Tooltip);
      const badgeProps = buildProps({
        value: {
          type: [String, Number],
          default: ""
        },
        max: {
          type: Number,
          default: 99
        },
        isDot: Boolean,
        hidden: Boolean,
        type: {
          type: String,
          values: ["primary", "success", "warning", "info", "danger"],
          default: "danger"
        }
      });
      const _hoisted_1$M = ["textContent"];
      const __default__$q = defineComponent({
        name: "ElBadge"
      });
      const _sfc_main$Q = /* @__PURE__ */ defineComponent({
        ...__default__$q,
        props: badgeProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const ns = useNamespace("badge");
          const content = computed(() => {
            if (props2.isDot)
              return "";
            if (isNumber(props2.value) && isNumber(props2.max)) {
              return props2.max < props2.value ? `${props2.max}+` : `${props2.value}`;
            }
            return `${props2.value}`;
          });
          expose({
            content
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b())
            }, [
              renderSlot(_ctx.$slots, "default"),
              createVNode(Transition, {
                name: `${unref(ns).namespace.value}-zoom-in-center`,
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createBaseVNode("sup", {
                    class: normalizeClass([
                      unref(ns).e("content"),
                      unref(ns).em("content", _ctx.type),
                      unref(ns).is("fixed", !!_ctx.$slots.default),
                      unref(ns).is("dot", _ctx.isDot)
                    ]),
                    textContent: toDisplayString(unref(content))
                  }, null, 10, _hoisted_1$M), [
                    [vShow, !_ctx.hidden && (unref(content) || _ctx.isDot)]
                  ])
                ]),
                _: 1
              }, 8, ["name"])
            ], 2);
          };
        }
      });
      var Badge = /* @__PURE__ */ _export_sfc$1(_sfc_main$Q, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]);
      const ElBadge = withInstall(Badge);
      const buttonGroupContextKey = Symbol("buttonGroupContextKey");
      const useButton = (props2, emit2) => {
        useDeprecated({
          from: "type.text",
          replacement: "link",
          version: "3.0.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
        }, computed(() => props2.type === "text"));
        const buttonGroupContext = inject(buttonGroupContextKey, void 0);
        const globalConfig2 = useGlobalConfig("button");
        const { form } = useFormItem();
        const _size = useFormSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
        const _disabled = useFormDisabled();
        const _ref = ref();
        const slots = useSlots();
        const _type = computed(() => props2.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
        const autoInsertSpace = computed(() => {
          var _a2, _b, _c;
          return (_c = (_b = props2.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
        });
        const _props = computed(() => {
          if (props2.tag === "button") {
            return {
              ariaDisabled: _disabled.value || props2.loading,
              disabled: _disabled.value || props2.loading,
              autofocus: props2.autofocus,
              type: props2.nativeType
            };
          }
          return {};
        });
        const shouldAddSpace = computed(() => {
          var _a2;
          const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
          if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
            const slot = defaultSlot[0];
            if ((slot == null ? void 0 : slot.type) === Text) {
              const text = slot.children;
              return /^\p{Unified_Ideograph}{2}$/u.test(text.trim());
            }
          }
          return false;
        });
        const handleClick = (evt) => {
          if (props2.nativeType === "reset") {
            form == null ? void 0 : form.resetFields();
          }
          emit2("click", evt);
        };
        return {
          _disabled,
          _size,
          _type,
          _ref,
          _props,
          shouldAddSpace,
          handleClick
        };
      };
      const buttonTypes = [
        "default",
        "primary",
        "success",
        "warning",
        "info",
        "danger",
        "text",
        ""
      ];
      const buttonNativeTypes = ["button", "submit", "reset"];
      const buttonProps = buildProps({
        size: useSizeProp,
        disabled: Boolean,
        type: {
          type: String,
          values: buttonTypes,
          default: ""
        },
        icon: {
          type: iconPropType
        },
        nativeType: {
          type: String,
          values: buttonNativeTypes,
          default: "button"
        },
        loading: Boolean,
        loadingIcon: {
          type: iconPropType,
          default: () => loading_default
        },
        plain: Boolean,
        text: Boolean,
        link: Boolean,
        bg: Boolean,
        autofocus: Boolean,
        round: Boolean,
        circle: Boolean,
        color: String,
        dark: Boolean,
        autoInsertSpace: {
          type: Boolean,
          default: void 0
        },
        tag: {
          type: definePropType([String, Object]),
          default: "button"
        }
      });
      const buttonEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      function bound01(n2, max) {
        if (isOnePointZero(n2)) {
          n2 = "100%";
        }
        var isPercent2 = isPercentage(n2);
        n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
        if (isPercent2) {
          n2 = parseInt(String(n2 * max), 10) / 100;
        }
        if (Math.abs(n2 - max) < 1e-6) {
          return 1;
        }
        if (max === 360) {
          n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
        } else {
          n2 = n2 % max / parseFloat(String(max));
        }
        return n2;
      }
      function clamp01(val) {
        return Math.min(1, Math.max(0, val));
      }
      function isOnePointZero(n2) {
        return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
      }
      function isPercentage(n2) {
        return typeof n2 === "string" && n2.indexOf("%") !== -1;
      }
      function boundAlpha(a2) {
        a2 = parseFloat(a2);
        if (isNaN(a2) || a2 < 0 || a2 > 1) {
          a2 = 1;
        }
        return a2;
      }
      function convertToPercentage(n2) {
        if (n2 <= 1) {
          return "".concat(Number(n2) * 100, "%");
        }
        return n2;
      }
      function pad2(c2) {
        return c2.length === 1 ? "0" + c2 : String(c2);
      }
      function rgbToRgb(r2, g2, b2) {
        return {
          r: bound01(r2, 255) * 255,
          g: bound01(g2, 255) * 255,
          b: bound01(b2, 255) * 255
        };
      }
      function rgbToHsl(r2, g2, b2) {
        r2 = bound01(r2, 255);
        g2 = bound01(g2, 255);
        b2 = bound01(b2, 255);
        var max = Math.max(r2, g2, b2);
        var min = Math.min(r2, g2, b2);
        var h2 = 0;
        var s2 = 0;
        var l2 = (max + min) / 2;
        if (max === min) {
          s2 = 0;
          h2 = 0;
        } else {
          var d2 = max - min;
          s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
          switch (max) {
            case r2:
              h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
              break;
            case g2:
              h2 = (b2 - r2) / d2 + 2;
              break;
            case b2:
              h2 = (r2 - g2) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s: s2, l: l2 };
      }
      function hue2rgb(p2, q2, t2) {
        if (t2 < 0) {
          t2 += 1;
        }
        if (t2 > 1) {
          t2 -= 1;
        }
        if (t2 < 1 / 6) {
          return p2 + (q2 - p2) * (6 * t2);
        }
        if (t2 < 1 / 2) {
          return q2;
        }
        if (t2 < 2 / 3) {
          return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
        }
        return p2;
      }
      function hslToRgb(h2, s2, l2) {
        var r2;
        var g2;
        var b2;
        h2 = bound01(h2, 360);
        s2 = bound01(s2, 100);
        l2 = bound01(l2, 100);
        if (s2 === 0) {
          g2 = l2;
          b2 = l2;
          r2 = l2;
        } else {
          var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
          var p2 = 2 * l2 - q2;
          r2 = hue2rgb(p2, q2, h2 + 1 / 3);
          g2 = hue2rgb(p2, q2, h2);
          b2 = hue2rgb(p2, q2, h2 - 1 / 3);
        }
        return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
      }
      function rgbToHsv(r2, g2, b2) {
        r2 = bound01(r2, 255);
        g2 = bound01(g2, 255);
        b2 = bound01(b2, 255);
        var max = Math.max(r2, g2, b2);
        var min = Math.min(r2, g2, b2);
        var h2 = 0;
        var v2 = max;
        var d2 = max - min;
        var s2 = max === 0 ? 0 : d2 / max;
        if (max === min) {
          h2 = 0;
        } else {
          switch (max) {
            case r2:
              h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
              break;
            case g2:
              h2 = (b2 - r2) / d2 + 2;
              break;
            case b2:
              h2 = (r2 - g2) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s: s2, v: v2 };
      }
      function hsvToRgb(h2, s2, v2) {
        h2 = bound01(h2, 360) * 6;
        s2 = bound01(s2, 100);
        v2 = bound01(v2, 100);
        var i2 = Math.floor(h2);
        var f2 = h2 - i2;
        var p2 = v2 * (1 - s2);
        var q2 = v2 * (1 - f2 * s2);
        var t2 = v2 * (1 - (1 - f2) * s2);
        var mod = i2 % 6;
        var r2 = [v2, q2, p2, p2, t2, v2][mod];
        var g2 = [t2, v2, v2, q2, p2, p2][mod];
        var b2 = [p2, p2, t2, v2, v2, q2][mod];
        return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
      }
      function rgbToHex(r2, g2, b2, allow3Char) {
        var hex = [
          pad2(Math.round(r2).toString(16)),
          pad2(Math.round(g2).toString(16)),
          pad2(Math.round(b2).toString(16))
        ];
        if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToHex(r2, g2, b2, a2, allow4Char) {
        var hex = [
          pad2(Math.round(r2).toString(16)),
          pad2(Math.round(g2).toString(16)),
          pad2(Math.round(b2).toString(16)),
          pad2(convertDecimalToHex(a2))
        ];
        if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }
        return hex.join("");
      }
      function convertDecimalToHex(d2) {
        return Math.round(parseFloat(d2) * 255).toString(16);
      }
      function convertHexToDecimal(h2) {
        return parseIntFromHex(h2) / 255;
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function numberInputToObject(color) {
        return {
          r: color >> 16,
          g: (color & 65280) >> 8,
          b: color & 255
        };
      }
      var names = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        goldenrod: "#daa520",
        gold: "#ffd700",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavenderblush: "#fff0f5",
        lavender: "#e6e6fa",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
      };
      function inputToRGB(color) {
        var rgb = { r: 0, g: 0, b: 0 };
        var a2 = 1;
        var s2 = null;
        var v2 = null;
        var l2 = null;
        var ok = false;
        var format2 = false;
        if (typeof color === "string") {
          color = stringInputToObject(color);
        }
        if (typeof color === "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s2 = convertToPercentage(color.s);
            v2 = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s2, v2);
            ok = true;
            format2 = "hsv";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s2 = convertToPercentage(color.s);
            l2 = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s2, l2);
            ok = true;
            format2 = "hsl";
          }
          if (Object.prototype.hasOwnProperty.call(color, "a")) {
            a2 = color.a;
          }
        }
        a2 = boundAlpha(a2);
        return {
          ok,
          format: color.format || format2,
          r: Math.min(255, Math.max(rgb.r, 0)),
          g: Math.min(255, Math.max(rgb.g, 0)),
          b: Math.min(255, Math.max(rgb.b, 0)),
          a: a2
        };
      }
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var matchers = {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
      function stringInputToObject(color) {
        color = color.trim().toLowerCase();
        if (color.length === 0) {
          return false;
        }
        var named = false;
        if (names[color]) {
          color = names[color];
          named = true;
        } else if (color === "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match = matchers.rgb.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3] };
        }
        match = matchers.rgba.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        match = matchers.hsl.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3] };
        }
        match = matchers.hsla.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        match = matchers.hsv.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3] };
        }
        match = matchers.hsva.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        match = matchers.hex8.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex6.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
          };
        }
        match = matchers.hex4.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            a: convertHexToDecimal(match[4] + match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex3.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            format: named ? "name" : "hex"
          };
        }
        return false;
      }
      function isValidCSSUnit(color) {
        return Boolean(matchers.CSS_UNIT.exec(String(color)));
      }
      var TinyColor = (
        /** @class */
        function() {
          function TinyColor2(color, opts) {
            if (color === void 0) {
              color = "";
            }
            if (opts === void 0) {
              opts = {};
            }
            var _a2;
            if (color instanceof TinyColor2) {
              return color;
            }
            if (typeof color === "number") {
              color = numberInputToObject(color);
            }
            this.originalInput = color;
            var rgb = inputToRGB(color);
            this.originalInput = color;
            this.r = rgb.r;
            this.g = rgb.g;
            this.b = rgb.b;
            this.a = rgb.a;
            this.roundA = Math.round(100 * this.a) / 100;
            this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
            this.gradientType = opts.gradientType;
            if (this.r < 1) {
              this.r = Math.round(this.r);
            }
            if (this.g < 1) {
              this.g = Math.round(this.g);
            }
            if (this.b < 1) {
              this.b = Math.round(this.b);
            }
            this.isValid = rgb.ok;
          }
          TinyColor2.prototype.isDark = function() {
            return this.getBrightness() < 128;
          };
          TinyColor2.prototype.isLight = function() {
            return !this.isDark();
          };
          TinyColor2.prototype.getBrightness = function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
          };
          TinyColor2.prototype.getLuminance = function() {
            var rgb = this.toRgb();
            var R2;
            var G2;
            var B2;
            var RsRGB = rgb.r / 255;
            var GsRGB = rgb.g / 255;
            var BsRGB = rgb.b / 255;
            if (RsRGB <= 0.03928) {
              R2 = RsRGB / 12.92;
            } else {
              R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
            }
            if (GsRGB <= 0.03928) {
              G2 = GsRGB / 12.92;
            } else {
              G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
            }
            if (BsRGB <= 0.03928) {
              B2 = BsRGB / 12.92;
            } else {
              B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
          };
          TinyColor2.prototype.getAlpha = function() {
            return this.a;
          };
          TinyColor2.prototype.setAlpha = function(alpha) {
            this.a = boundAlpha(alpha);
            this.roundA = Math.round(100 * this.a) / 100;
            return this;
          };
          TinyColor2.prototype.isMonochrome = function() {
            var s2 = this.toHsl().s;
            return s2 === 0;
          };
          TinyColor2.prototype.toHsv = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
          };
          TinyColor2.prototype.toHsvString = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            var h2 = Math.round(hsv.h * 360);
            var s2 = Math.round(hsv.s * 100);
            var v2 = Math.round(hsv.v * 100);
            return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHsl = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
          };
          TinyColor2.prototype.toHslString = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            var h2 = Math.round(hsl.h * 360);
            var s2 = Math.round(hsl.s * 100);
            var l2 = Math.round(hsl.l * 100);
            return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHex = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return rgbToHex(this.r, this.g, this.b, allow3Char);
          };
          TinyColor2.prototype.toHexString = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return "#" + this.toHex(allow3Char);
          };
          TinyColor2.prototype.toHex8 = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
          };
          TinyColor2.prototype.toHex8String = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return "#" + this.toHex8(allow4Char);
          };
          TinyColor2.prototype.toHexShortString = function(allowShortChar) {
            if (allowShortChar === void 0) {
              allowShortChar = false;
            }
            return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
          };
          TinyColor2.prototype.toRgb = function() {
            return {
              r: Math.round(this.r),
              g: Math.round(this.g),
              b: Math.round(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toRgbString = function() {
            var r2 = Math.round(this.r);
            var g2 = Math.round(this.g);
            var b2 = Math.round(this.b);
            return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toPercentageRgb = function() {
            var fmt = function(x2) {
              return "".concat(Math.round(bound01(x2, 255) * 100), "%");
            };
            return {
              r: fmt(this.r),
              g: fmt(this.g),
              b: fmt(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toPercentageRgbString = function() {
            var rnd = function(x2) {
              return Math.round(bound01(x2, 255) * 100);
            };
            return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toName = function() {
            if (this.a === 0) {
              return "transparent";
            }
            if (this.a < 1) {
              return false;
            }
            var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
            for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
              var _b = _a2[_i], key = _b[0], value = _b[1];
              if (hex === value) {
                return key;
              }
            }
            return false;
          };
          TinyColor2.prototype.toString = function(format2) {
            var formatSet = Boolean(format2);
            format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
            var formattedString = false;
            var hasAlpha = this.a < 1 && this.a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
            if (needsAlphaFormat) {
              if (format2 === "name" && this.a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format2 === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format2 === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format2 === "hex" || format2 === "hex6") {
              formattedString = this.toHexString();
            }
            if (format2 === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format2 === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format2 === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format2 === "name") {
              formattedString = this.toName();
            }
            if (format2 === "hsl") {
              formattedString = this.toHslString();
            }
            if (format2 === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          };
          TinyColor2.prototype.toNumber = function() {
            return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
          };
          TinyColor2.prototype.clone = function() {
            return new TinyColor2(this.toString());
          };
          TinyColor2.prototype.lighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.brighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var rgb = this.toRgb();
            rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
            rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
            rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
            return new TinyColor2(rgb);
          };
          TinyColor2.prototype.darken = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.tint = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("white", amount);
          };
          TinyColor2.prototype.shade = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("black", amount);
          };
          TinyColor2.prototype.desaturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.saturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.greyscale = function() {
            return this.desaturate(100);
          };
          TinyColor2.prototype.spin = function(amount) {
            var hsl = this.toHsl();
            var hue = (hsl.h + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.mix = function(color, amount) {
            if (amount === void 0) {
              amount = 50;
            }
            var rgb1 = this.toRgb();
            var rgb2 = new TinyColor2(color).toRgb();
            var p2 = amount / 100;
            var rgba = {
              r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
              g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
              b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
              a: (rgb2.a - rgb1.a) * p2 + rgb1.a
            };
            return new TinyColor2(rgba);
          };
          TinyColor2.prototype.analogous = function(results, slices) {
            if (results === void 0) {
              results = 6;
            }
            if (slices === void 0) {
              slices = 30;
            }
            var hsl = this.toHsl();
            var part = 360 / slices;
            var ret = [this];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
              hsl.h = (hsl.h + part) % 360;
              ret.push(new TinyColor2(hsl));
            }
            return ret;
          };
          TinyColor2.prototype.complement = function() {
            var hsl = this.toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.monochromatic = function(results) {
            if (results === void 0) {
              results = 6;
            }
            var hsv = this.toHsv();
            var h2 = hsv.h;
            var s2 = hsv.s;
            var v2 = hsv.v;
            var res = [];
            var modification = 1 / results;
            while (results--) {
              res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
              v2 = (v2 + modification) % 1;
            }
            return res;
          };
          TinyColor2.prototype.splitcomplement = function() {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            return [
              this,
              new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
              new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
            ];
          };
          TinyColor2.prototype.onBackground = function(background) {
            var fg = this.toRgb();
            var bg = new TinyColor2(background).toRgb();
            var alpha = fg.a + bg.a * (1 - fg.a);
            return new TinyColor2({
              r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
              g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
              b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
              a: alpha
            });
          };
          TinyColor2.prototype.triad = function() {
            return this.polyad(3);
          };
          TinyColor2.prototype.tetrad = function() {
            return this.polyad(4);
          };
          TinyColor2.prototype.polyad = function(n2) {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            var result = [this];
            var increment = 360 / n2;
            for (var i2 = 1; i2 < n2; i2++) {
              result.push(new TinyColor2({ h: (h2 + i2 * increment) % 360, s: hsl.s, l: hsl.l }));
            }
            return result;
          };
          TinyColor2.prototype.equals = function(color) {
            return this.toRgbString() === new TinyColor2(color).toRgbString();
          };
          return TinyColor2;
        }()
      );
      function darken(color, amount = 20) {
        return color.mix("#141414", amount).toString();
      }
      function useButtonCustomStyle(props2) {
        const _disabled = useFormDisabled();
        const ns = useNamespace("button");
        return computed(() => {
          let styles = {};
          const buttonColor = props2.color;
          if (buttonColor) {
            const color = new TinyColor(buttonColor);
            const activeBgColor = props2.dark ? color.tint(20).toString() : darken(color, 20);
            if (props2.plain) {
              styles = ns.cssVarBlock({
                "bg-color": props2.dark ? darken(color, 90) : color.tint(90).toString(),
                "text-color": buttonColor,
                "border-color": props2.dark ? darken(color, 50) : color.tint(50).toString(),
                "hover-text-color": `var(${ns.cssVarName("color-white")})`,
                "hover-bg-color": buttonColor,
                "hover-border-color": buttonColor,
                "active-bg-color": activeBgColor,
                "active-text-color": `var(${ns.cssVarName("color-white")})`,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                styles[ns.cssVarBlockName("disabled-bg-color")] = props2.dark ? darken(color, 90) : color.tint(90).toString();
                styles[ns.cssVarBlockName("disabled-text-color")] = props2.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-border-color")] = props2.dark ? darken(color, 80) : color.tint(80).toString();
              }
            } else {
              const hoverBgColor = props2.dark ? darken(color, 30) : color.tint(30).toString();
              const textColor = color.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
              styles = ns.cssVarBlock({
                "bg-color": buttonColor,
                "text-color": textColor,
                "border-color": buttonColor,
                "hover-bg-color": hoverBgColor,
                "hover-text-color": textColor,
                "hover-border-color": hoverBgColor,
                "active-bg-color": activeBgColor,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                const disabledButtonColor = props2.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
                styles[ns.cssVarBlockName("disabled-text-color")] = props2.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
                styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
              }
            }
          }
          return styles;
        });
      }
      const __default__$p = defineComponent({
        name: "ElButton"
      });
      const _sfc_main$P = /* @__PURE__ */ defineComponent({
        ...__default__$p,
        props: buttonProps,
        emits: buttonEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props2 = __props;
          const buttonStyle = useButtonCustomStyle(props2);
          const ns = useNamespace("button");
          const { _ref, _size, _type, _disabled, _props, shouldAddSpace, handleClick } = useButton(props2, emit2);
          expose({
            ref: _ref,
            size: _size,
            type: _type,
            disabled: _disabled,
            shouldAddSpace
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({
              ref_key: "_ref",
              ref: _ref
            }, unref(_props), {
              class: [
                unref(ns).b(),
                unref(ns).m(unref(_type)),
                unref(ns).m(unref(_size)),
                unref(ns).is("disabled", unref(_disabled)),
                unref(ns).is("loading", _ctx.loading),
                unref(ns).is("plain", _ctx.plain),
                unref(ns).is("round", _ctx.round),
                unref(ns).is("circle", _ctx.circle),
                unref(ns).is("text", _ctx.text),
                unref(ns).is("link", _ctx.link),
                unref(ns).is("has-bg", _ctx.bg)
              ],
              style: unref(buttonStyle),
              onClick: unref(handleClick)
            }), {
              default: withCtx(() => [
                _ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass(unref(ns).is("loading"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"]))
                ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                  default: withCtx(() => [
                    _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
                  ]),
                  _: 3
                })) : createCommentVNode("v-if", true),
                _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                  key: 2,
                  class: normalizeClass({ [unref(ns).em("text", "expand")]: unref(shouldAddSpace) })
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["class", "style", "onClick"]);
          };
        }
      });
      var Button = /* @__PURE__ */ _export_sfc$1(_sfc_main$P, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
      const buttonGroupProps = {
        size: buttonProps.size,
        type: buttonProps.type
      };
      const __default__$o = defineComponent({
        name: "ElButtonGroup"
      });
      const _sfc_main$O = /* @__PURE__ */ defineComponent({
        ...__default__$o,
        props: buttonGroupProps,
        setup(__props) {
          const props2 = __props;
          provide(buttonGroupContextKey, reactive({
            size: toRef$1(props2, "size"),
            type: toRef$1(props2, "type")
          }));
          const ns = useNamespace("button");
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(`${unref(ns).b("group")}`)
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var ButtonGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$O, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
      const ElButton = withInstall(Button, {
        ButtonGroup
      });
      const ElButtonGroup$1 = withNoopInstall(ButtonGroup);
      const nodeList = /* @__PURE__ */ new Map();
      let startClick;
      if (isClient$1) {
        document.addEventListener("mousedown", (e2) => startClick = e2);
        document.addEventListener("mouseup", (e2) => {
          for (const handlers of nodeList.values()) {
            for (const { documentHandler } of handlers) {
              documentHandler(e2, startClick);
            }
          }
        });
      }
      function createDocumentHandler(el, binding) {
        let excludes = [];
        if (Array.isArray(binding.arg)) {
          excludes = binding.arg;
        } else if (isElement(binding.arg)) {
          excludes.push(binding.arg);
        }
        return function(mouseup, mousedown) {
          const popperRef = binding.instance.popperRef;
          const mouseUpTarget = mouseup.target;
          const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
          const isBound = !binding || !binding.instance;
          const isTargetExists = !mouseUpTarget || !mouseDownTarget;
          const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
          const isSelf = el === mouseUpTarget;
          const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
          const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
          if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
            return;
          }
          binding.value(mouseup, mousedown);
        };
      }
      const ClickOutside = {
        beforeMount(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          nodeList.get(el).push({
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          });
        },
        updated(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          const handlers = nodeList.get(el);
          const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
          const newHandler = {
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          };
          if (oldHandlerIndex >= 0) {
            handlers.splice(oldHandlerIndex, 1, newHandler);
          } else {
            handlers.push(newHandler);
          }
        },
        unmounted(el) {
          nodeList.delete(el);
        }
      };
      const REPEAT_INTERVAL = 100;
      const REPEAT_DELAY = 600;
      const vRepeatClick = {
        beforeMount(el, binding) {
          const value = binding.value;
          const { interval = REPEAT_INTERVAL, delay = REPEAT_DELAY } = isFunction$2(value) ? {} : value;
          let intervalId;
          let delayId;
          const handler = () => isFunction$2(value) ? value() : value.handler();
          const clear2 = () => {
            if (delayId) {
              clearTimeout(delayId);
              delayId = void 0;
            }
            if (intervalId) {
              clearInterval(intervalId);
              intervalId = void 0;
            }
          };
          el.addEventListener("mousedown", (evt) => {
            if (evt.button !== 0)
              return;
            clear2();
            handler();
            document.addEventListener("mouseup", () => clear2(), {
              once: true
            });
            delayId = setTimeout(() => {
              intervalId = setInterval(() => {
                handler();
              }, interval);
            }, delay);
          });
        }
      };
      const FOCUSABLE_CHILDREN = "_trap-focus-children";
      const FOCUS_STACK = [];
      const FOCUS_HANDLER = (e2) => {
        if (FOCUS_STACK.length === 0)
          return;
        const focusableElement = FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN];
        if (focusableElement.length > 0 && e2.code === EVENT_CODE.tab) {
          if (focusableElement.length === 1) {
            e2.preventDefault();
            if (document.activeElement !== focusableElement[0]) {
              focusableElement[0].focus();
            }
            return;
          }
          const goingBackward = e2.shiftKey;
          const isFirst = e2.target === focusableElement[0];
          const isLast = e2.target === focusableElement[focusableElement.length - 1];
          if (isFirst && goingBackward) {
            e2.preventDefault();
            focusableElement[focusableElement.length - 1].focus();
          }
          if (isLast && !goingBackward) {
            e2.preventDefault();
            focusableElement[0].focus();
          }
        }
      };
      const TrapFocus = {
        beforeMount(el) {
          el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
          FOCUS_STACK.push(el);
          if (FOCUS_STACK.length <= 1) {
            document.addEventListener("keydown", FOCUS_HANDLER);
          }
        },
        updated(el) {
          nextTick(() => {
            el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
          });
        },
        unmounted() {
          FOCUS_STACK.shift();
          if (FOCUS_STACK.length === 0) {
            document.removeEventListener("keydown", FOCUS_HANDLER);
          }
        }
      };
      const checkboxProps = {
        modelValue: {
          type: [Number, String, Boolean],
          default: void 0
        },
        label: {
          type: [String, Boolean, Number, Object]
        },
        indeterminate: Boolean,
        disabled: Boolean,
        checked: Boolean,
        name: {
          type: String,
          default: void 0
        },
        trueLabel: {
          type: [String, Number],
          default: void 0
        },
        falseLabel: {
          type: [String, Number],
          default: void 0
        },
        id: {
          type: String,
          default: void 0
        },
        controls: {
          type: String,
          default: void 0
        },
        border: Boolean,
        size: useSizeProp,
        tabindex: [String, Number],
        validateEvent: {
          type: Boolean,
          default: true
        }
      };
      const checkboxEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isString$2(val) || isNumber(val) || isBoolean(val),
        change: (val) => isString$2(val) || isNumber(val) || isBoolean(val)
      };
      const checkboxGroupContextKey = Symbol("checkboxGroupContextKey");
      const useCheckboxDisabled = ({
        model,
        isChecked
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isLimitDisabled = computed(() => {
          var _a2, _b;
          const max = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value;
          const min = (_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value;
          return !isUndefined(max) && model.value.length >= max && !isChecked.value || !isUndefined(min) && model.value.length <= min && isChecked.value;
        });
        const isDisabled = useFormDisabled(computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value));
        return {
          isDisabled,
          isLimitDisabled
        };
      };
      const useCheckboxEvent = (props2, {
        model,
        isLimitExceeded,
        hasOwnLabel,
        isDisabled,
        isLabeledByFormItem
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const { formItem } = useFormItem();
        const { emit: emit2 } = getCurrentInstance();
        function getLabeledValue(value) {
          var _a2, _b;
          return value === props2.trueLabel || value === true ? (_a2 = props2.trueLabel) != null ? _a2 : true : (_b = props2.falseLabel) != null ? _b : false;
        }
        function emitChangeEvent(checked, e2) {
          emit2("change", getLabeledValue(checked), e2);
        }
        function handleChange(e2) {
          if (isLimitExceeded.value)
            return;
          const target = e2.target;
          emit2("change", getLabeledValue(target.checked), e2);
        }
        async function onClickRoot(e2) {
          if (isLimitExceeded.value)
            return;
          if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
            const eventTargets = e2.composedPath();
            const hasLabel = eventTargets.some((item) => item.tagName === "LABEL");
            if (!hasLabel) {
              model.value = getLabeledValue([false, props2.falseLabel].includes(model.value));
              await nextTick();
              emitChangeEvent(model.value, e2);
            }
          }
        }
        const validateEvent = computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.validateEvent) || props2.validateEvent);
        watch(() => props2.modelValue, () => {
          if (validateEvent.value) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        });
        return {
          handleChange,
          onClickRoot
        };
      };
      const useCheckboxModel = (props2) => {
        const selfModel = ref(false);
        const { emit: emit2 } = getCurrentInstance();
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isGroup = computed(() => isUndefined(checkboxGroup) === false);
        const isLimitExceeded = ref(false);
        const model = computed({
          get() {
            var _a2, _b;
            return isGroup.value ? (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a2.value : (_b = props2.modelValue) != null ? _b : selfModel.value;
          },
          set(val) {
            var _a2, _b;
            if (isGroup.value && isArray$3(val)) {
              isLimitExceeded.value = ((_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value);
              isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));
            } else {
              emit2(UPDATE_MODEL_EVENT, val);
              selfModel.value = val;
            }
          }
        });
        return {
          model,
          isGroup,
          isLimitExceeded
        };
      };
      const useCheckboxStatus = (props2, slots, { model }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isFocused = ref(false);
        const isChecked = computed(() => {
          const value = model.value;
          if (isBoolean(value)) {
            return value;
          } else if (isArray$3(value)) {
            if (isObject$1(props2.label)) {
              return value.map(toRaw).some((o2) => isEqual$1(o2, props2.label));
            } else {
              return value.map(toRaw).includes(props2.label);
            }
          } else if (value !== null && value !== void 0) {
            return value === props2.trueLabel;
          } else {
            return !!value;
          }
        });
        const checkboxButtonSize = useFormSize(computed(() => {
          var _a2;
          return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
        }), {
          prop: true
        });
        const checkboxSize = useFormSize(computed(() => {
          var _a2;
          return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
        }));
        const hasOwnLabel = computed(() => {
          return !!(slots.default || props2.label);
        });
        return {
          checkboxButtonSize,
          isChecked,
          isFocused,
          checkboxSize,
          hasOwnLabel
        };
      };
      const setStoreValue = (props2, { model }) => {
        function addToStore() {
          if (isArray$3(model.value) && !model.value.includes(props2.label)) {
            model.value.push(props2.label);
          } else {
            model.value = props2.trueLabel || true;
          }
        }
        props2.checked && addToStore();
      };
      const useCheckbox = (props2, slots) => {
        const { formItem: elFormItem2 } = useFormItem();
        const { model, isGroup, isLimitExceeded } = useCheckboxModel(props2);
        const {
          isFocused,
          isChecked,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel
        } = useCheckboxStatus(props2, slots, { model });
        const { isDisabled } = useCheckboxDisabled({ model, isChecked });
        const { inputId, isLabeledByFormItem } = useFormItemInputId(props2, {
          formItemContext: elFormItem2,
          disableIdGeneration: hasOwnLabel,
          disableIdManagement: isGroup
        });
        const { handleChange, onClickRoot } = useCheckboxEvent(props2, {
          model,
          isLimitExceeded,
          hasOwnLabel,
          isDisabled,
          isLabeledByFormItem
        });
        setStoreValue(props2, { model });
        return {
          inputId,
          isLabeledByFormItem,
          isChecked,
          isDisabled,
          isFocused,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          model,
          handleChange,
          onClickRoot
        };
      };
      const _hoisted_1$L = ["tabindex", "role", "aria-checked"];
      const _hoisted_2$B = ["id", "aria-hidden", "name", "tabindex", "disabled", "true-value", "false-value"];
      const _hoisted_3$t = ["id", "aria-hidden", "disabled", "value", "name", "tabindex"];
      const __default__$n = defineComponent({
        name: "ElCheckbox"
      });
      const _sfc_main$N = /* @__PURE__ */ defineComponent({
        ...__default__$n,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props2 = __props;
          const slots = useSlots();
          const {
            inputId,
            isLabeledByFormItem,
            isChecked,
            isDisabled,
            isFocused,
            checkboxSize,
            hasOwnLabel,
            model,
            handleChange,
            onClickRoot
          } = useCheckbox(props2, slots);
          const ns = useNamespace("checkbox");
          const compKls = computed(() => {
            return [
              ns.b(),
              ns.m(checkboxSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("bordered", props2.border),
              ns.is("checked", isChecked.value)
            ];
          });
          const spanKls = computed(() => {
            return [
              ns.e("input"),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("indeterminate", props2.indeterminate),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(!unref(hasOwnLabel) && unref(isLabeledByFormItem) ? "span" : "label"), {
              class: normalizeClass(unref(compKls)),
              "aria-controls": _ctx.indeterminate ? _ctx.controls : null,
              onClick: unref(onClickRoot)
            }, {
              default: withCtx(() => [
                createBaseVNode("span", {
                  class: normalizeClass(unref(spanKls)),
                  tabindex: _ctx.indeterminate ? 0 : void 0,
                  role: _ctx.indeterminate ? "checkbox" : void 0,
                  "aria-checked": _ctx.indeterminate ? "mixed" : void 0
                }, [
                  _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                    key: 0,
                    id: unref(inputId),
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
                    class: normalizeClass(unref(ns).e("original")),
                    type: "checkbox",
                    "aria-hidden": _ctx.indeterminate ? "true" : "false",
                    name: _ctx.name,
                    tabindex: _ctx.tabindex,
                    disabled: unref(isDisabled),
                    "true-value": _ctx.trueLabel,
                    "false-value": _ctx.falseLabel,
                    onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                    onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
                    onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false)
                  }, null, 42, _hoisted_2$B)), [
                    [vModelCheckbox, unref(model)]
                  ]) : withDirectives((openBlock(), createElementBlock("input", {
                    key: 1,
                    id: unref(inputId),
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isRef(model) ? model.value = $event : null),
                    class: normalizeClass(unref(ns).e("original")),
                    type: "checkbox",
                    "aria-hidden": _ctx.indeterminate ? "true" : "false",
                    disabled: unref(isDisabled),
                    value: _ctx.label,
                    name: _ctx.name,
                    tabindex: _ctx.tabindex,
                    onChange: _cache[5] || (_cache[5] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                    onFocus: _cache[6] || (_cache[6] = ($event) => isFocused.value = true),
                    onBlur: _cache[7] || (_cache[7] = ($event) => isFocused.value = false)
                  }, null, 42, _hoisted_3$t)), [
                    [vModelCheckbox, unref(model)]
                  ]),
                  createBaseVNode("span", {
                    class: normalizeClass(unref(ns).e("inner"))
                  }, null, 2)
                ], 10, _hoisted_1$L),
                unref(hasOwnLabel) ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("label"))
                }, [
                  renderSlot(_ctx.$slots, "default"),
                  !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createTextVNode(toDisplayString(_ctx.label), 1)
                  ], 64)) : createCommentVNode("v-if", true)
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["class", "aria-controls", "onClick"]);
          };
        }
      });
      var Checkbox = /* @__PURE__ */ _export_sfc$1(_sfc_main$N, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);
      const _hoisted_1$K = ["name", "tabindex", "disabled", "true-value", "false-value"];
      const _hoisted_2$A = ["name", "tabindex", "disabled", "value"];
      const __default__$m = defineComponent({
        name: "ElCheckboxButton"
      });
      const _sfc_main$M = /* @__PURE__ */ defineComponent({
        ...__default__$m,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props2 = __props;
          const slots = useSlots();
          const {
            isFocused,
            isChecked,
            isDisabled,
            checkboxButtonSize,
            model,
            handleChange
          } = useCheckbox(props2, slots);
          const checkboxGroup = inject(checkboxGroupContextKey, void 0);
          const ns = useNamespace("checkbox");
          const activeStyle = computed(() => {
            var _a2, _b, _c, _d;
            const fillValue = (_b = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a2.value) != null ? _b : "";
            return {
              backgroundColor: fillValue,
              borderColor: fillValue,
              color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
              boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
            };
          });
          const labelKls = computed(() => {
            return [
              ns.b("button"),
              ns.bm("button", checkboxButtonSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("label", {
              class: normalizeClass(unref(labelKls))
            }, [
              _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                key: 0,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                "true-value": _ctx.trueLabel,
                "false-value": _ctx.falseLabel,
                onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
                onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false)
              }, null, 42, _hoisted_1$K)), [
                [vModelCheckbox, unref(model)]
              ]) : withDirectives((openBlock(), createElementBlock("input", {
                key: 1,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isRef(model) ? model.value = $event : null),
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                value: _ctx.label,
                onChange: _cache[5] || (_cache[5] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                onFocus: _cache[6] || (_cache[6] = ($event) => isFocused.value = true),
                onBlur: _cache[7] || (_cache[7] = ($event) => isFocused.value = false)
              }, null, 42, _hoisted_2$A)), [
                [vModelCheckbox, unref(model)]
              ]),
              _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
                key: 2,
                class: normalizeClass(unref(ns).be("button", "inner")),
                style: normalizeStyle(unref(isChecked) ? unref(activeStyle) : void 0)
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.label), 1)
                ])
              ], 6)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var CheckboxButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$M, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);
      const checkboxGroupProps = buildProps({
        modelValue: {
          type: definePropType(Array),
          default: () => []
        },
        disabled: Boolean,
        min: Number,
        max: Number,
        size: useSizeProp,
        label: String,
        fill: String,
        textColor: String,
        tag: {
          type: String,
          default: "div"
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const checkboxGroupEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isArray$3(val),
        change: (val) => isArray$3(val)
      };
      const __default__$l = defineComponent({
        name: "ElCheckboxGroup"
      });
      const _sfc_main$L = /* @__PURE__ */ defineComponent({
        ...__default__$l,
        props: checkboxGroupProps,
        emits: checkboxGroupEmits,
        setup(__props, { emit: emit2 }) {
          const props2 = __props;
          const ns = useNamespace("checkbox");
          const { formItem } = useFormItem();
          const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props2, {
            formItemContext: formItem
          });
          const changeEvent = async (value) => {
            emit2(UPDATE_MODEL_EVENT, value);
            await nextTick();
            emit2("change", value);
          };
          const modelValue = computed({
            get() {
              return props2.modelValue;
            },
            set(val) {
              changeEvent(val);
            }
          });
          provide(checkboxGroupContextKey, {
            ...pick$1(toRefs$1(props2), [
              "size",
              "min",
              "max",
              "disabled",
              "validateEvent",
              "fill",
              "textColor"
            ]),
            modelValue,
            changeEvent
          });
          watch(() => props2.modelValue, () => {
            if (props2.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
          });
          return (_ctx, _cache) => {
            var _a2;
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              id: unref(groupId),
              class: normalizeClass(unref(ns).b("group")),
              role: "group",
              "aria-label": !unref(isLabeledByFormItem) ? _ctx.label || "checkbox-group" : void 0,
              "aria-labelledby": unref(isLabeledByFormItem) ? (_a2 = unref(formItem)) == null ? void 0 : _a2.labelId : void 0
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
          };
        }
      });
      var CheckboxGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$L, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);
      const ElCheckbox = withInstall(Checkbox, {
        CheckboxButton,
        CheckboxGroup
      });
      withNoopInstall(CheckboxButton);
      withNoopInstall(CheckboxGroup);
      const tagProps = buildProps({
        type: {
          type: String,
          values: ["success", "info", "warning", "danger", ""],
          default: ""
        },
        closable: Boolean,
        disableTransitions: Boolean,
        hit: Boolean,
        color: {
          type: String,
          default: ""
        },
        size: {
          type: String,
          values: componentSizes,
          default: ""
        },
        effect: {
          type: String,
          values: ["dark", "light", "plain"],
          default: "light"
        },
        round: Boolean
      });
      const tagEmits = {
        close: (evt) => evt instanceof MouseEvent,
        click: (evt) => evt instanceof MouseEvent
      };
      const __default__$k = defineComponent({
        name: "ElTag"
      });
      const _sfc_main$K = /* @__PURE__ */ defineComponent({
        ...__default__$k,
        props: tagProps,
        emits: tagEmits,
        setup(__props, { emit: emit2 }) {
          const props2 = __props;
          const tagSize = useFormSize();
          const ns = useNamespace("tag");
          const containerKls = computed(() => {
            const { type: type2, hit, effect, closable, round } = props2;
            return [
              ns.b(),
              ns.is("closable", closable),
              ns.m(type2),
              ns.m(tagSize.value),
              ns.m(effect),
              ns.is("hit", hit),
              ns.is("round", round)
            ];
          });
          const handleClose = (event) => {
            emit2("close", event);
          };
          const handleClick = (event) => {
            emit2("click", event);
          };
          return (_ctx, _cache) => {
            return _ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(unref(containerKls)),
              style: normalizeStyle({ backgroundColor: _ctx.color }),
              onClick: handleClick
            }, [
              createBaseVNode("span", {
                class: normalizeClass(unref(ns).e("content"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2),
              _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                key: 0,
                class: normalizeClass(unref(ns).e("close")),
                onClick: withModifiers(handleClose, ["stop"])
              }, {
                default: withCtx(() => [
                  createVNode(unref(close_default))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
            ], 6)) : (openBlock(), createBlock(Transition, {
              key: 1,
              name: `${unref(ns).namespace.value}-zoom-in-center`,
              appear: ""
            }, {
              default: withCtx(() => [
                createBaseVNode("span", {
                  class: normalizeClass(unref(containerKls)),
                  style: normalizeStyle({ backgroundColor: _ctx.color }),
                  onClick: handleClick
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(ns).e("content"))
                  }, [
                    renderSlot(_ctx.$slots, "default")
                  ], 2),
                  _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).e("close")),
                    onClick: withModifiers(handleClose, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(close_default))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ], 6)
              ]),
              _: 3
            }, 8, ["name"]));
          };
        }
      });
      var Tag = /* @__PURE__ */ _export_sfc$1(_sfc_main$K, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);
      const ElTag = withInstall(Tag);
      const __default__$j = defineComponent({
        name: "ElContainer"
      });
      const _sfc_main$J = /* @__PURE__ */ defineComponent({
        ...__default__$j,
        props: {
          direction: {
            type: String
          }
        },
        setup(__props) {
          const props2 = __props;
          const slots = useSlots();
          const ns = useNamespace("container");
          const isVertical = computed(() => {
            if (props2.direction === "vertical") {
              return true;
            } else if (props2.direction === "horizontal") {
              return false;
            }
            if (slots && slots.default) {
              const vNodes = slots.default();
              return vNodes.some((vNode) => {
                const tag = vNode.type.name;
                return tag === "ElHeader" || tag === "ElFooter";
              });
            } else {
              return false;
            }
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("section", {
              class: normalizeClass([unref(ns).b(), unref(ns).is("vertical", unref(isVertical))])
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Container = /* @__PURE__ */ _export_sfc$1(_sfc_main$J, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/container.vue"]]);
      const __default__$i = defineComponent({
        name: "ElAside"
      });
      const _sfc_main$I = /* @__PURE__ */ defineComponent({
        ...__default__$i,
        props: {
          width: {
            type: String,
            default: null
          }
        },
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("aside");
          const style = computed(() => props2.width ? ns.cssVarBlock({ width: props2.width }) : {});
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("aside", {
              class: normalizeClass(unref(ns).b()),
              style: normalizeStyle(unref(style))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 6);
          };
        }
      });
      var Aside = /* @__PURE__ */ _export_sfc$1(_sfc_main$I, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/aside.vue"]]);
      const __default__$h = defineComponent({
        name: "ElFooter"
      });
      const _sfc_main$H = /* @__PURE__ */ defineComponent({
        ...__default__$h,
        props: {
          height: {
            type: String,
            default: null
          }
        },
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("footer");
          const style = computed(() => props2.height ? ns.cssVarBlock({ height: props2.height }) : {});
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("footer", {
              class: normalizeClass(unref(ns).b()),
              style: normalizeStyle(unref(style))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 6);
          };
        }
      });
      var Footer = /* @__PURE__ */ _export_sfc$1(_sfc_main$H, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/footer.vue"]]);
      const __default__$g = defineComponent({
        name: "ElHeader"
      });
      const _sfc_main$G = /* @__PURE__ */ defineComponent({
        ...__default__$g,
        props: {
          height: {
            type: String,
            default: null
          }
        },
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("header");
          const style = computed(() => {
            return props2.height ? ns.cssVarBlock({
              height: props2.height
            }) : {};
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("header", {
              class: normalizeClass(unref(ns).b()),
              style: normalizeStyle(unref(style))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 6);
          };
        }
      });
      var Header = /* @__PURE__ */ _export_sfc$1(_sfc_main$G, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/header.vue"]]);
      const __default__$f = defineComponent({
        name: "ElMain"
      });
      const _sfc_main$F = /* @__PURE__ */ defineComponent({
        ...__default__$f,
        setup(__props) {
          const ns = useNamespace("main");
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("main", {
              class: normalizeClass(unref(ns).b())
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Main = /* @__PURE__ */ _export_sfc$1(_sfc_main$F, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/main.vue"]]);
      const ElContainer = withInstall(Container, {
        Aside,
        Footer,
        Header,
        Main
      });
      const ElAside = withNoopInstall(Aside);
      withNoopInstall(Footer);
      withNoopInstall(Header);
      const ElMain = withNoopInstall(Main);
      const overlayProps = buildProps({
        mask: {
          type: Boolean,
          default: true
        },
        customMaskEvent: {
          type: Boolean,
          default: false
        },
        overlayClass: {
          type: definePropType([
            String,
            Array,
            Object
          ])
        },
        zIndex: {
          type: definePropType([String, Number])
        }
      });
      const overlayEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      const BLOCK = "overlay";
      var Overlay = defineComponent({
        name: "ElOverlay",
        props: overlayProps,
        emits: overlayEmits,
        setup(props2, { slots, emit: emit2 }) {
          const ns = useNamespace(BLOCK);
          const onMaskClick = (e2) => {
            emit2("click", e2);
          };
          const { onClick, onMousedown, onMouseup } = useSameTarget(props2.customMaskEvent ? void 0 : onMaskClick);
          return () => {
            return props2.mask ? createVNode("div", {
              class: [ns.b(), props2.overlayClass],
              style: {
                zIndex: props2.zIndex
              },
              onClick,
              onMousedown,
              onMouseup
            }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h$1("div", {
              class: props2.overlayClass,
              style: {
                zIndex: props2.zIndex,
                position: "fixed",
                top: "0px",
                right: "0px",
                bottom: "0px",
                left: "0px"
              }
            }, [renderSlot(slots, "default")]);
          };
        }
      });
      const ElOverlay = Overlay;
      const dialogInjectionKey = Symbol("dialogInjectionKey");
      const dialogContentProps = buildProps({
        center: {
          type: Boolean,
          default: false
        },
        alignCenter: {
          type: Boolean,
          default: false
        },
        closeIcon: {
          type: iconPropType
        },
        customClass: {
          type: String,
          default: ""
        },
        draggable: {
          type: Boolean,
          default: false
        },
        fullscreen: {
          type: Boolean,
          default: false
        },
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        }
      });
      const dialogContentEmits = {
        close: () => true
      };
      const _hoisted_1$J = ["aria-label"];
      const _hoisted_2$z = ["id"];
      const __default__$e = defineComponent({ name: "ElDialogContent" });
      const _sfc_main$E = /* @__PURE__ */ defineComponent({
        ...__default__$e,
        props: dialogContentProps,
        emits: dialogContentEmits,
        setup(__props) {
          const props2 = __props;
          const { t: t2 } = useLocale();
          const { Close } = CloseComponents;
          const { dialogRef, headerRef, bodyId, ns, style } = inject(dialogInjectionKey);
          const { focusTrapRef } = inject(FOCUS_TRAP_INJECTION_KEY);
          const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
          const draggable = computed(() => props2.draggable);
          useDraggable$1(dialogRef, headerRef, draggable);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref: unref(composedDialogRef),
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).is("fullscreen", _ctx.fullscreen),
                unref(ns).is("draggable", unref(draggable)),
                unref(ns).is("align-center", _ctx.alignCenter),
                { [unref(ns).m("center")]: _ctx.center },
                _ctx.customClass
              ]),
              style: normalizeStyle(unref(style)),
              tabindex: "-1"
            }, [
              createBaseVNode("header", {
                ref_key: "headerRef",
                ref: headerRef,
                class: normalizeClass(unref(ns).e("header"))
              }, [
                renderSlot(_ctx.$slots, "header", {}, () => [
                  createBaseVNode("span", {
                    role: "heading",
                    class: normalizeClass(unref(ns).e("title"))
                  }, toDisplayString(_ctx.title), 3)
                ]),
                _ctx.showClose ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  "aria-label": unref(t2)("el.dialog.close"),
                  class: normalizeClass(unref(ns).e("headerbtn")),
                  type: "button",
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
                }, [
                  createVNode(unref(ElIcon), {
                    class: normalizeClass(unref(ns).e("close"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon || unref(Close))))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ], 10, _hoisted_1$J)) : createCommentVNode("v-if", true)
              ], 2),
              createBaseVNode("div", {
                id: unref(bodyId),
                class: normalizeClass(unref(ns).e("body"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 10, _hoisted_2$z),
              _ctx.$slots.footer ? (openBlock(), createElementBlock("footer", {
                key: 0,
                class: normalizeClass(unref(ns).e("footer"))
              }, [
                renderSlot(_ctx.$slots, "footer")
              ], 2)) : createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var ElDialogContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$E, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog-content.vue"]]);
      const dialogProps = buildProps({
        ...dialogContentProps,
        appendToBody: {
          type: Boolean,
          default: false
        },
        beforeClose: {
          type: definePropType(Function)
        },
        destroyOnClose: {
          type: Boolean,
          default: false
        },
        closeOnClickModal: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        lockScroll: {
          type: Boolean,
          default: true
        },
        modal: {
          type: Boolean,
          default: true
        },
        openDelay: {
          type: Number,
          default: 0
        },
        closeDelay: {
          type: Number,
          default: 0
        },
        top: {
          type: String
        },
        modelValue: {
          type: Boolean,
          default: false
        },
        modalClass: String,
        width: {
          type: [String, Number]
        },
        zIndex: {
          type: Number
        },
        trapFocus: {
          type: Boolean,
          default: false
        }
      });
      const dialogEmits = {
        open: () => true,
        opened: () => true,
        close: () => true,
        closed: () => true,
        [UPDATE_MODEL_EVENT]: (value) => isBoolean(value),
        openAutoFocus: () => true,
        closeAutoFocus: () => true
      };
      const useDialog = (props2, targetRef) => {
        const instance = getCurrentInstance();
        const emit2 = instance.emit;
        const { nextZIndex } = useZIndex();
        let lastPosition = "";
        const titleId = useId();
        const bodyId = useId();
        const visible = ref(false);
        const closed = ref(false);
        const rendered = ref(false);
        const zIndex2 = ref(props2.zIndex || nextZIndex());
        let openTimer = void 0;
        let closeTimer = void 0;
        const namespace = useGlobalConfig("namespace", defaultNamespace);
        const style = computed(() => {
          const style2 = {};
          const varPrefix = `--${namespace.value}-dialog`;
          if (!props2.fullscreen) {
            if (props2.top) {
              style2[`${varPrefix}-margin-top`] = props2.top;
            }
            if (props2.width) {
              style2[`${varPrefix}-width`] = addUnit(props2.width);
            }
          }
          return style2;
        });
        const overlayDialogStyle = computed(() => {
          if (props2.alignCenter) {
            return { display: "flex" };
          }
          return {};
        });
        function afterEnter() {
          emit2("opened");
        }
        function afterLeave() {
          emit2("closed");
          emit2(UPDATE_MODEL_EVENT, false);
          if (props2.destroyOnClose) {
            rendered.value = false;
          }
        }
        function beforeLeave() {
          emit2("close");
        }
        function open2() {
          closeTimer == null ? void 0 : closeTimer();
          openTimer == null ? void 0 : openTimer();
          if (props2.openDelay && props2.openDelay > 0) {
            ({ stop: openTimer } = useTimeoutFn$1(() => doOpen(), props2.openDelay));
          } else {
            doOpen();
          }
        }
        function close2() {
          openTimer == null ? void 0 : openTimer();
          closeTimer == null ? void 0 : closeTimer();
          if (props2.closeDelay && props2.closeDelay > 0) {
            ({ stop: closeTimer } = useTimeoutFn$1(() => doClose(), props2.closeDelay));
          } else {
            doClose();
          }
        }
        function handleClose() {
          function hide(shouldCancel) {
            if (shouldCancel)
              return;
            closed.value = true;
            visible.value = false;
          }
          if (props2.beforeClose) {
            props2.beforeClose(hide);
          } else {
            close2();
          }
        }
        function onModalClick() {
          if (props2.closeOnClickModal) {
            handleClose();
          }
        }
        function doOpen() {
          if (!isClient$1)
            return;
          visible.value = true;
        }
        function doClose() {
          visible.value = false;
        }
        function onOpenAutoFocus() {
          emit2("openAutoFocus");
        }
        function onCloseAutoFocus() {
          emit2("closeAutoFocus");
        }
        function onFocusoutPrevented(event) {
          var _a2;
          if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) === "pointer") {
            event.preventDefault();
          }
        }
        if (props2.lockScroll) {
          useLockscreen(visible);
        }
        function onCloseRequested() {
          if (props2.closeOnPressEscape) {
            handleClose();
          }
        }
        watch(() => props2.modelValue, (val) => {
          if (val) {
            closed.value = false;
            open2();
            rendered.value = true;
            zIndex2.value = props2.zIndex ? zIndex2.value++ : nextZIndex();
            nextTick(() => {
              emit2("open");
              if (targetRef.value) {
                targetRef.value.scrollTop = 0;
              }
            });
          } else {
            if (visible.value) {
              close2();
            }
          }
        });
        watch(() => props2.fullscreen, (val) => {
          if (!targetRef.value)
            return;
          if (val) {
            lastPosition = targetRef.value.style.transform;
            targetRef.value.style.transform = "";
          } else {
            targetRef.value.style.transform = lastPosition;
          }
        });
        onMounted(() => {
          if (props2.modelValue) {
            visible.value = true;
            rendered.value = true;
            open2();
          }
        });
        return {
          afterEnter,
          afterLeave,
          beforeLeave,
          handleClose,
          onModalClick,
          close: close2,
          doClose,
          onOpenAutoFocus,
          onCloseAutoFocus,
          onCloseRequested,
          onFocusoutPrevented,
          titleId,
          bodyId,
          closed,
          style,
          overlayDialogStyle,
          rendered,
          visible,
          zIndex: zIndex2
        };
      };
      const _hoisted_1$I = ["aria-label", "aria-labelledby", "aria-describedby"];
      const __default__$d = defineComponent({
        name: "ElDialog",
        inheritAttrs: false
      });
      const _sfc_main$D = /* @__PURE__ */ defineComponent({
        ...__default__$d,
        props: dialogProps,
        emits: dialogEmits,
        setup(__props, { expose }) {
          const props2 = __props;
          const slots = useSlots();
          useDeprecated({
            scope: "el-dialog",
            from: "the title slot",
            replacement: "the header slot",
            version: "3.0.0",
            ref: "https://element-plus.org/en-US/component/dialog.html#slots"
          }, computed(() => !!slots.title));
          useDeprecated({
            scope: "el-dialog",
            from: "custom-class",
            replacement: "class",
            version: "2.3.0",
            ref: "https://element-plus.org/en-US/component/dialog.html#attributes",
            type: "Attribute"
          }, computed(() => !!props2.customClass));
          const ns = useNamespace("dialog");
          const dialogRef = ref();
          const headerRef = ref();
          const dialogContentRef = ref();
          const {
            visible,
            titleId,
            bodyId,
            style,
            overlayDialogStyle,
            rendered,
            zIndex: zIndex2,
            afterEnter,
            afterLeave,
            beforeLeave,
            handleClose,
            onModalClick,
            onOpenAutoFocus,
            onCloseAutoFocus,
            onCloseRequested,
            onFocusoutPrevented
          } = useDialog(props2, dialogRef);
          provide(dialogInjectionKey, {
            dialogRef,
            headerRef,
            bodyId,
            ns,
            rendered,
            style
          });
          const overlayEvent = useSameTarget(onModalClick);
          const draggable = computed(() => props2.draggable && !props2.fullscreen);
          expose({
            visible,
            dialogContentRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              to: "body",
              disabled: !_ctx.appendToBody
            }, [
              createVNode(Transition, {
                name: "dialog-fade",
                onAfterEnter: unref(afterEnter),
                onAfterLeave: unref(afterLeave),
                onBeforeLeave: unref(beforeLeave),
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createVNode(unref(ElOverlay), {
                    "custom-mask-event": "",
                    mask: _ctx.modal,
                    "overlay-class": _ctx.modalClass,
                    "z-index": unref(zIndex2)
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        role: "dialog",
                        "aria-modal": "true",
                        "aria-label": _ctx.title || void 0,
                        "aria-labelledby": !_ctx.title ? unref(titleId) : void 0,
                        "aria-describedby": unref(bodyId),
                        class: normalizeClass(`${unref(ns).namespace.value}-overlay-dialog`),
                        style: normalizeStyle(unref(overlayDialogStyle)),
                        onClick: _cache[0] || (_cache[0] = (...args) => unref(overlayEvent).onClick && unref(overlayEvent).onClick(...args)),
                        onMousedown: _cache[1] || (_cache[1] = (...args) => unref(overlayEvent).onMousedown && unref(overlayEvent).onMousedown(...args)),
                        onMouseup: _cache[2] || (_cache[2] = (...args) => unref(overlayEvent).onMouseup && unref(overlayEvent).onMouseup(...args))
                      }, [
                        createVNode(unref(ElFocusTrap), {
                          loop: "",
                          trapped: unref(visible),
                          "focus-start-el": "container",
                          onFocusAfterTrapped: unref(onOpenAutoFocus),
                          onFocusAfterReleased: unref(onCloseAutoFocus),
                          onFocusoutPrevented: unref(onFocusoutPrevented),
                          onReleaseRequested: unref(onCloseRequested)
                        }, {
                          default: withCtx(() => [
                            unref(rendered) ? (openBlock(), createBlock(ElDialogContent, mergeProps({
                              key: 0,
                              ref_key: "dialogContentRef",
                              ref: dialogContentRef
                            }, _ctx.$attrs, {
                              "custom-class": _ctx.customClass,
                              center: _ctx.center,
                              "align-center": _ctx.alignCenter,
                              "close-icon": _ctx.closeIcon,
                              draggable: unref(draggable),
                              fullscreen: _ctx.fullscreen,
                              "show-close": _ctx.showClose,
                              title: _ctx.title,
                              onClose: unref(handleClose)
                            }), createSlots({
                              header: withCtx(() => [
                                !_ctx.$slots.title ? renderSlot(_ctx.$slots, "header", {
                                  key: 0,
                                  close: unref(handleClose),
                                  titleId: unref(titleId),
                                  titleClass: unref(ns).e("title")
                                }) : renderSlot(_ctx.$slots, "title", { key: 1 })
                              ]),
                              default: withCtx(() => [
                                renderSlot(_ctx.$slots, "default")
                              ]),
                              _: 2
                            }, [
                              _ctx.$slots.footer ? {
                                name: "footer",
                                fn: withCtx(() => [
                                  renderSlot(_ctx.$slots, "footer")
                                ])
                              } : void 0
                            ]), 1040, ["custom-class", "center", "align-center", "close-icon", "draggable", "fullscreen", "show-close", "title", "onClose"])) : createCommentVNode("v-if", true)
                          ]),
                          _: 3
                        }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                      ], 46, _hoisted_1$I)
                    ]),
                    _: 3
                  }, 8, ["mask", "overlay-class", "z-index"]), [
                    [vShow, unref(visible)]
                  ])
                ]),
                _: 3
              }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
            ], 8, ["disabled"]);
          };
        }
      });
      var Dialog = /* @__PURE__ */ _export_sfc$1(_sfc_main$D, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog.vue"]]);
      const ElDialog = withInstall(Dialog);
      const _sfc_main$C = /* @__PURE__ */ defineComponent({
        inheritAttrs: false
      });
      function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default");
      }
      var Collection = /* @__PURE__ */ _export_sfc$1(_sfc_main$C, [["render", _sfc_render$g], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);
      const _sfc_main$B = /* @__PURE__ */ defineComponent({
        name: "ElCollectionItem",
        inheritAttrs: false
      });
      function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default");
      }
      var CollectionItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$B, [["render", _sfc_render$f], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);
      const COLLECTION_ITEM_SIGN = `data-el-collection-item`;
      const createCollectionWithScope = (name) => {
        const COLLECTION_NAME = `El${name}Collection`;
        const COLLECTION_ITEM_NAME = `${COLLECTION_NAME}Item`;
        const COLLECTION_INJECTION_KEY2 = Symbol(COLLECTION_NAME);
        const COLLECTION_ITEM_INJECTION_KEY2 = Symbol(COLLECTION_ITEM_NAME);
        const ElCollection2 = {
          ...Collection,
          name: COLLECTION_NAME,
          setup() {
            const collectionRef = ref(null);
            const itemMap = /* @__PURE__ */ new Map();
            const getItems = () => {
              const collectionEl = unref(collectionRef);
              if (!collectionEl)
                return [];
              const orderedNodes = Array.from(collectionEl.querySelectorAll(`[${COLLECTION_ITEM_SIGN}]`));
              const items = [...itemMap.values()];
              return items.sort((a2, b2) => orderedNodes.indexOf(a2.ref) - orderedNodes.indexOf(b2.ref));
            };
            provide(COLLECTION_INJECTION_KEY2, {
              itemMap,
              getItems,
              collectionRef
            });
          }
        };
        const ElCollectionItem2 = {
          ...CollectionItem,
          name: COLLECTION_ITEM_NAME,
          setup(_2, { attrs }) {
            const collectionItemRef = ref(null);
            const collectionInjection = inject(COLLECTION_INJECTION_KEY2, void 0);
            provide(COLLECTION_ITEM_INJECTION_KEY2, {
              collectionItemRef
            });
            onMounted(() => {
              const collectionItemEl = unref(collectionItemRef);
              if (collectionItemEl) {
                collectionInjection.itemMap.set(collectionItemEl, {
                  ref: collectionItemEl,
                  ...attrs
                });
              }
            });
            onBeforeUnmount(() => {
              const collectionItemEl = unref(collectionItemRef);
              collectionInjection.itemMap.delete(collectionItemEl);
            });
          }
        };
        return {
          COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY2,
          COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY2,
          ElCollection: ElCollection2,
          ElCollectionItem: ElCollectionItem2
        };
      };
      const rovingFocusGroupProps = buildProps({
        style: { type: definePropType([String, Array, Object]) },
        currentTabId: {
          type: definePropType(String)
        },
        defaultCurrentTabId: String,
        loop: Boolean,
        dir: {
          type: String,
          values: ["ltr", "rtl"],
          default: "ltr"
        },
        orientation: {
          type: definePropType(String)
        },
        onBlur: Function,
        onFocus: Function,
        onMousedown: Function
      });
      const {
        ElCollection: ElCollection$1,
        ElCollectionItem: ElCollectionItem$1,
        COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY$1,
        COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY$1
      } = createCollectionWithScope("RovingFocusGroup");
      const ROVING_FOCUS_GROUP_INJECTION_KEY = Symbol("elRovingFocusGroup");
      const ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY = Symbol("elRovingFocusGroupItem");
      const MAP_KEY_TO_FOCUS_INTENT = {
        ArrowLeft: "prev",
        ArrowUp: "prev",
        ArrowRight: "next",
        ArrowDown: "next",
        PageUp: "first",
        Home: "first",
        PageDown: "last",
        End: "last"
      };
      const getDirectionAwareKey = (key, dir) => {
        if (dir !== "rtl")
          return key;
        switch (key) {
          case EVENT_CODE.right:
            return EVENT_CODE.left;
          case EVENT_CODE.left:
            return EVENT_CODE.right;
          default:
            return key;
        }
      };
      const getFocusIntent = (event, orientation, dir) => {
        const key = getDirectionAwareKey(event.key, dir);
        if (orientation === "vertical" && [EVENT_CODE.left, EVENT_CODE.right].includes(key))
          return void 0;
        if (orientation === "horizontal" && [EVENT_CODE.up, EVENT_CODE.down].includes(key))
          return void 0;
        return MAP_KEY_TO_FOCUS_INTENT[key];
      };
      const reorderArray = (array2, atIdx) => {
        return array2.map((_2, idx) => array2[(idx + atIdx) % array2.length]);
      };
      const focusFirst = (elements) => {
        const { activeElement: prevActive } = document;
        for (const element of elements) {
          if (element === prevActive)
            return;
          element.focus();
          if (prevActive !== document.activeElement)
            return;
        }
      };
      const CURRENT_TAB_ID_CHANGE_EVT = "currentTabIdChange";
      const ENTRY_FOCUS_EVT = "rovingFocusGroup.entryFocus";
      const EVT_OPTS = { bubbles: false, cancelable: true };
      const _sfc_main$A = defineComponent({
        name: "ElRovingFocusGroupImpl",
        inheritAttrs: false,
        props: rovingFocusGroupProps,
        emits: [CURRENT_TAB_ID_CHANGE_EVT, "entryFocus"],
        setup(props2, { emit: emit2 }) {
          var _a2;
          const currentTabbedId = ref((_a2 = props2.currentTabId || props2.defaultCurrentTabId) != null ? _a2 : null);
          const isBackingOut = ref(false);
          const isClickFocus = ref(false);
          const rovingFocusGroupRef = ref(null);
          const { getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
          const rovingFocusGroupRootStyle = computed(() => {
            return [
              {
                outline: "none"
              },
              props2.style
            ];
          });
          const onItemFocus = (tabbedId) => {
            emit2(CURRENT_TAB_ID_CHANGE_EVT, tabbedId);
          };
          const onItemShiftTab = () => {
            isBackingOut.value = true;
          };
          const onMousedown = composeEventHandlers((e2) => {
            var _a22;
            (_a22 = props2.onMousedown) == null ? void 0 : _a22.call(props2, e2);
          }, () => {
            isClickFocus.value = true;
          });
          const onFocus = composeEventHandlers((e2) => {
            var _a22;
            (_a22 = props2.onFocus) == null ? void 0 : _a22.call(props2, e2);
          }, (e2) => {
            const isKeyboardFocus = !unref(isClickFocus);
            const { target, currentTarget } = e2;
            if (target === currentTarget && isKeyboardFocus && !unref(isBackingOut)) {
              const entryFocusEvt = new Event(ENTRY_FOCUS_EVT, EVT_OPTS);
              currentTarget == null ? void 0 : currentTarget.dispatchEvent(entryFocusEvt);
              if (!entryFocusEvt.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === unref(currentTabbedId));
                const candidates = [activeItem, currentItem, ...items].filter(Boolean);
                const candidateNodes = candidates.map((item) => item.ref);
                focusFirst(candidateNodes);
              }
            }
            isClickFocus.value = false;
          });
          const onBlur = composeEventHandlers((e2) => {
            var _a22;
            (_a22 = props2.onBlur) == null ? void 0 : _a22.call(props2, e2);
          }, () => {
            isBackingOut.value = false;
          });
          const handleEntryFocus = (...args) => {
            emit2("entryFocus", ...args);
          };
          provide(ROVING_FOCUS_GROUP_INJECTION_KEY, {
            currentTabbedId: readonly(currentTabbedId),
            loop: toRef$1(props2, "loop"),
            tabIndex: computed(() => {
              return unref(isBackingOut) ? -1 : 0;
            }),
            rovingFocusGroupRef,
            rovingFocusGroupRootStyle,
            orientation: toRef$1(props2, "orientation"),
            dir: toRef$1(props2, "dir"),
            onItemFocus,
            onItemShiftTab,
            onBlur,
            onFocus,
            onMousedown
          });
          watch(() => props2.currentTabId, (val) => {
            currentTabbedId.value = val != null ? val : null;
          });
          useEventListener$1(rovingFocusGroupRef, ENTRY_FOCUS_EVT, handleEntryFocus);
        }
      });
      function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default");
      }
      var ElRovingFocusGroupImpl = /* @__PURE__ */ _export_sfc$1(_sfc_main$A, [["render", _sfc_render$e], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group-impl.vue"]]);
      const _sfc_main$z = defineComponent({
        name: "ElRovingFocusGroup",
        components: {
          ElFocusGroupCollection: ElCollection$1,
          ElRovingFocusGroupImpl
        }
      });
      function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_roving_focus_group_impl = resolveComponent("el-roving-focus-group-impl");
        const _component_el_focus_group_collection = resolveComponent("el-focus-group-collection");
        return openBlock(), createBlock(_component_el_focus_group_collection, null, {
          default: withCtx(() => [
            createVNode(_component_el_roving_focus_group_impl, normalizeProps(guardReactiveProps(_ctx.$attrs)), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        });
      }
      var ElRovingFocusGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$z, [["render", _sfc_render$d], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group.vue"]]);
      const _sfc_main$y = defineComponent({
        components: {
          ElRovingFocusCollectionItem: ElCollectionItem$1
        },
        props: {
          focusable: {
            type: Boolean,
            default: true
          },
          active: {
            type: Boolean,
            default: false
          }
        },
        emits: ["mousedown", "focus", "keydown"],
        setup(props2, { emit: emit2 }) {
          const { currentTabbedId, loop, onItemFocus, onItemShiftTab } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
          const { getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
          const id2 = useId();
          const rovingFocusGroupItemRef = ref(null);
          const handleMousedown = composeEventHandlers((e2) => {
            emit2("mousedown", e2);
          }, (e2) => {
            if (!props2.focusable) {
              e2.preventDefault();
            } else {
              onItemFocus(unref(id2));
            }
          });
          const handleFocus = composeEventHandlers((e2) => {
            emit2("focus", e2);
          }, () => {
            onItemFocus(unref(id2));
          });
          const handleKeydown = composeEventHandlers((e2) => {
            emit2("keydown", e2);
          }, (e2) => {
            const { key, shiftKey, target, currentTarget } = e2;
            if (key === EVENT_CODE.tab && shiftKey) {
              onItemShiftTab();
              return;
            }
            if (target !== currentTarget)
              return;
            const focusIntent = getFocusIntent(e2);
            if (focusIntent) {
              e2.preventDefault();
              const items = getItems().filter((item) => item.focusable);
              let elements = items.map((item) => item.ref);
              switch (focusIntent) {
                case "last": {
                  elements.reverse();
                  break;
                }
                case "prev":
                case "next": {
                  if (focusIntent === "prev") {
                    elements.reverse();
                  }
                  const currentIdx = elements.indexOf(currentTarget);
                  elements = loop.value ? reorderArray(elements, currentIdx + 1) : elements.slice(currentIdx + 1);
                  break;
                }
              }
              nextTick(() => {
                focusFirst(elements);
              });
            }
          });
          const isCurrentTab = computed(() => currentTabbedId.value === unref(id2));
          provide(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, {
            rovingFocusGroupItemRef,
            tabIndex: computed(() => unref(isCurrentTab) ? 0 : -1),
            handleMousedown,
            handleFocus,
            handleKeydown
          });
          return {
            id: id2,
            handleKeydown,
            handleFocus,
            handleMousedown
          };
        }
      });
      function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_roving_focus_collection_item = resolveComponent("el-roving-focus-collection-item");
        return openBlock(), createBlock(_component_el_roving_focus_collection_item, {
          id: _ctx.id,
          focusable: _ctx.focusable,
          active: _ctx.active
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "focusable", "active"]);
      }
      var ElRovingFocusItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$y, [["render", _sfc_render$c], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-item.vue"]]);
      const dropdownProps = buildProps({
        trigger: useTooltipTriggerProps.trigger,
        effect: {
          ...useTooltipContentProps.effect,
          default: "light"
        },
        type: {
          type: definePropType(String)
        },
        placement: {
          type: definePropType(String),
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        id: String,
        size: {
          type: String,
          default: ""
        },
        splitButton: Boolean,
        hideOnClick: {
          type: Boolean,
          default: true
        },
        loop: {
          type: Boolean,
          default: true
        },
        showTimeout: {
          type: Number,
          default: 150
        },
        hideTimeout: {
          type: Number,
          default: 150
        },
        tabindex: {
          type: definePropType([Number, String]),
          default: 0
        },
        maxHeight: {
          type: definePropType([Number, String]),
          default: ""
        },
        popperClass: {
          type: String,
          default: ""
        },
        disabled: {
          type: Boolean,
          default: false
        },
        role: {
          type: String,
          default: "menu"
        },
        buttonProps: {
          type: definePropType(Object)
        },
        teleported: useTooltipContentProps.teleported
      });
      const dropdownItemProps = buildProps({
        command: {
          type: [Object, String, Number],
          default: () => ({})
        },
        disabled: Boolean,
        divided: Boolean,
        textValue: String,
        icon: {
          type: iconPropType
        }
      });
      const dropdownMenuProps = buildProps({
        onKeydown: { type: definePropType(Function) }
      });
      const FIRST_KEYS = [
        EVENT_CODE.down,
        EVENT_CODE.pageDown,
        EVENT_CODE.home
      ];
      const LAST_KEYS = [EVENT_CODE.up, EVENT_CODE.pageUp, EVENT_CODE.end];
      const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
      const {
        ElCollection,
        ElCollectionItem,
        COLLECTION_INJECTION_KEY,
        COLLECTION_ITEM_INJECTION_KEY
      } = createCollectionWithScope("Dropdown");
      const DROPDOWN_INJECTION_KEY = Symbol("elDropdown");
      const { ButtonGroup: ElButtonGroup } = ElButton;
      const _sfc_main$x = defineComponent({
        name: "ElDropdown",
        components: {
          ElButton,
          ElButtonGroup,
          ElScrollbar,
          ElDropdownCollection: ElCollection,
          ElTooltip,
          ElRovingFocusGroup,
          ElOnlyChild: OnlyChild,
          ElIcon,
          ArrowDown: arrow_down_default
        },
        props: dropdownProps,
        emits: ["visible-change", "click", "command"],
        setup(props2, { emit: emit2 }) {
          const _instance = getCurrentInstance();
          const ns = useNamespace("dropdown");
          const { t: t2 } = useLocale();
          const triggeringElementRef = ref();
          const referenceElementRef = ref();
          const popperRef = ref(null);
          const contentRef = ref(null);
          const scrollbar = ref(null);
          const currentTabId = ref(null);
          const isUsingKeyboard = ref(false);
          const triggerKeys = [EVENT_CODE.enter, EVENT_CODE.space, EVENT_CODE.down];
          const wrapStyle = computed(() => ({
            maxHeight: addUnit(props2.maxHeight)
          }));
          const dropdownTriggerKls = computed(() => [ns.m(dropdownSize.value)]);
          const defaultTriggerId = useId().value;
          const triggerId = computed(() => {
            return props2.id || defaultTriggerId;
          });
          watch([triggeringElementRef, toRef$1(props2, "trigger")], ([triggeringElement, trigger2], [prevTriggeringElement]) => {
            var _a2, _b, _c;
            const triggerArray = isArray$3(trigger2) ? trigger2 : [trigger2];
            if ((_a2 = prevTriggeringElement == null ? void 0 : prevTriggeringElement.$el) == null ? void 0 : _a2.removeEventListener) {
              prevTriggeringElement.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
            }
            if ((_b = triggeringElement == null ? void 0 : triggeringElement.$el) == null ? void 0 : _b.removeEventListener) {
              triggeringElement.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
            }
            if (((_c = triggeringElement == null ? void 0 : triggeringElement.$el) == null ? void 0 : _c.addEventListener) && triggerArray.includes("hover")) {
              triggeringElement.$el.addEventListener("pointerenter", onAutofocusTriggerEnter);
            }
          }, { immediate: true });
          onBeforeUnmount(() => {
            var _a2, _b;
            if ((_b = (_a2 = triggeringElementRef.value) == null ? void 0 : _a2.$el) == null ? void 0 : _b.removeEventListener) {
              triggeringElementRef.value.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
            }
          });
          function handleClick() {
            handleClose();
          }
          function handleClose() {
            var _a2;
            (_a2 = popperRef.value) == null ? void 0 : _a2.onClose();
          }
          function handleOpen() {
            var _a2;
            (_a2 = popperRef.value) == null ? void 0 : _a2.onOpen();
          }
          const dropdownSize = useFormSize();
          function commandHandler(...args) {
            emit2("command", ...args);
          }
          function onAutofocusTriggerEnter() {
            var _a2, _b;
            (_b = (_a2 = triggeringElementRef.value) == null ? void 0 : _a2.$el) == null ? void 0 : _b.focus();
          }
          function onItemEnter() {
          }
          function onItemLeave() {
            const contentEl = unref(contentRef);
            contentEl == null ? void 0 : contentEl.focus();
            currentTabId.value = null;
          }
          function handleCurrentTabIdChange(id2) {
            currentTabId.value = id2;
          }
          function handleEntryFocus(e2) {
            if (!isUsingKeyboard.value) {
              e2.preventDefault();
              e2.stopImmediatePropagation();
            }
          }
          function handleBeforeShowTooltip() {
            emit2("visible-change", true);
          }
          function handleShowTooltip(event) {
            if ((event == null ? void 0 : event.type) === "keydown") {
              contentRef.value.focus();
            }
          }
          function handleBeforeHideTooltip() {
            emit2("visible-change", false);
          }
          provide(DROPDOWN_INJECTION_KEY, {
            contentRef,
            role: computed(() => props2.role),
            triggerId,
            isUsingKeyboard,
            onItemEnter,
            onItemLeave
          });
          provide("elDropdown", {
            instance: _instance,
            dropdownSize,
            handleClick,
            commandHandler,
            trigger: toRef$1(props2, "trigger"),
            hideOnClick: toRef$1(props2, "hideOnClick")
          });
          const onFocusAfterTrapped = (e2) => {
            var _a2, _b;
            e2.preventDefault();
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2, {
              preventScroll: true
            });
          };
          const handlerMainButtonClick = (event) => {
            emit2("click", event);
          };
          return {
            t: t2,
            ns,
            scrollbar,
            wrapStyle,
            dropdownTriggerKls,
            dropdownSize,
            triggerId,
            triggerKeys,
            currentTabId,
            handleCurrentTabIdChange,
            handlerMainButtonClick,
            handleEntryFocus,
            handleClose,
            handleOpen,
            handleBeforeShowTooltip,
            handleShowTooltip,
            handleBeforeHideTooltip,
            onFocusAfterTrapped,
            popperRef,
            contentRef,
            triggeringElementRef,
            referenceElementRef
          };
        }
      });
      function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
        var _a2;
        const _component_el_dropdown_collection = resolveComponent("el-dropdown-collection");
        const _component_el_roving_focus_group = resolveComponent("el-roving-focus-group");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_el_only_child = resolveComponent("el-only-child");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _component_el_button = resolveComponent("el-button");
        const _component_arrow_down = resolveComponent("arrow-down");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_button_group = resolveComponent("el-button-group");
        return openBlock(), createElementBlock("div", {
          class: normalizeClass([_ctx.ns.b(), _ctx.ns.is("disabled", _ctx.disabled)])
        }, [
          createVNode(_component_el_tooltip, {
            ref: "popperRef",
            role: _ctx.role,
            effect: _ctx.effect,
            "fallback-placements": ["bottom", "top"],
            "popper-options": _ctx.popperOptions,
            "gpu-acceleration": false,
            "hide-after": _ctx.trigger === "hover" ? _ctx.hideTimeout : 0,
            "manual-mode": true,
            placement: _ctx.placement,
            "popper-class": [_ctx.ns.e("popper"), _ctx.popperClass],
            "reference-element": (_a2 = _ctx.referenceElementRef) == null ? void 0 : _a2.$el,
            trigger: _ctx.trigger,
            "trigger-keys": _ctx.triggerKeys,
            "trigger-target-el": _ctx.contentRef,
            "show-after": _ctx.trigger === "hover" ? _ctx.showTimeout : 0,
            "stop-popper-mouse-event": false,
            "virtual-ref": _ctx.triggeringElementRef,
            "virtual-triggering": _ctx.splitButton,
            disabled: _ctx.disabled,
            transition: `${_ctx.ns.namespace.value}-zoom-in-top`,
            teleported: _ctx.teleported,
            pure: "",
            persistent: "",
            onBeforeShow: _ctx.handleBeforeShowTooltip,
            onShow: _ctx.handleShowTooltip,
            onBeforeHide: _ctx.handleBeforeHideTooltip
          }, createSlots({
            content: withCtx(() => [
              createVNode(_component_el_scrollbar, {
                ref: "scrollbar",
                "wrap-style": _ctx.wrapStyle,
                tag: "div",
                "view-class": _ctx.ns.e("list")
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_roving_focus_group, {
                    loop: _ctx.loop,
                    "current-tab-id": _ctx.currentTabId,
                    orientation: "horizontal",
                    onCurrentTabIdChange: _ctx.handleCurrentTabIdChange,
                    onEntryFocus: _ctx.handleEntryFocus
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_el_dropdown_collection, null, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "dropdown")
                        ]),
                        _: 3
                      })
                    ]),
                    _: 3
                  }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"])
                ]),
                _: 3
              }, 8, ["wrap-style", "view-class"])
            ]),
            _: 2
          }, [
            !_ctx.splitButton ? {
              name: "default",
              fn: withCtx(() => [
                createVNode(_component_el_only_child, {
                  id: _ctx.triggerId,
                  ref: "triggeringElementRef",
                  role: "button",
                  tabindex: _ctx.tabindex
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["id", "tabindex"])
              ])
            } : void 0
          ]), 1032, ["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "teleported", "onBeforeShow", "onShow", "onBeforeHide"]),
          _ctx.splitButton ? (openBlock(), createBlock(_component_el_button_group, { key: 0 }, {
            default: withCtx(() => [
              createVNode(_component_el_button, mergeProps({ ref: "referenceElementRef" }, _ctx.buttonProps, {
                size: _ctx.dropdownSize,
                type: _ctx.type,
                disabled: _ctx.disabled,
                tabindex: _ctx.tabindex,
                onClick: _ctx.handlerMainButtonClick
              }), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 16, ["size", "type", "disabled", "tabindex", "onClick"]),
              createVNode(_component_el_button, mergeProps({
                id: _ctx.triggerId,
                ref: "triggeringElementRef"
              }, _ctx.buttonProps, {
                role: "button",
                size: _ctx.dropdownSize,
                type: _ctx.type,
                class: _ctx.ns.e("caret-button"),
                disabled: _ctx.disabled,
                tabindex: _ctx.tabindex,
                "aria-label": _ctx.t("el.dropdown.toggleDropdown")
              }), {
                default: withCtx(() => [
                  createVNode(_component_el_icon, {
                    class: normalizeClass(_ctx.ns.e("icon"))
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_arrow_down)
                    ]),
                    _: 1
                  }, 8, ["class"])
                ]),
                _: 1
              }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])
            ]),
            _: 3
          })) : createCommentVNode("v-if", true)
        ], 2);
      }
      var Dropdown = /* @__PURE__ */ _export_sfc$1(_sfc_main$x, [["render", _sfc_render$b], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown.vue"]]);
      const _sfc_main$w = defineComponent({
        name: "DropdownItemImpl",
        components: {
          ElIcon
        },
        props: dropdownItemProps,
        emits: ["pointermove", "pointerleave", "click", "clickimpl"],
        setup(_2, { emit: emit2 }) {
          const ns = useNamespace("dropdown");
          const { role: menuRole } = inject(DROPDOWN_INJECTION_KEY, void 0);
          const { collectionItemRef: dropdownCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY, void 0);
          const { collectionItemRef: rovingFocusCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY$1, void 0);
          const {
            rovingFocusGroupItemRef,
            tabIndex,
            handleFocus,
            handleKeydown: handleItemKeydown,
            handleMousedown
          } = inject(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, void 0);
          const itemRef = composeRefs(dropdownCollectionItemRef, rovingFocusCollectionItemRef, rovingFocusGroupItemRef);
          const role = computed(() => {
            if (menuRole.value === "menu") {
              return "menuitem";
            } else if (menuRole.value === "navigation") {
              return "link";
            }
            return "button";
          });
          const handleKeydown = composeEventHandlers((e2) => {
            const { code } = e2;
            if (code === EVENT_CODE.enter || code === EVENT_CODE.space) {
              e2.preventDefault();
              e2.stopImmediatePropagation();
              emit2("clickimpl", e2);
              return true;
            }
          }, handleItemKeydown);
          return {
            ns,
            itemRef,
            dataset: {
              [COLLECTION_ITEM_SIGN]: ""
            },
            role,
            tabIndex,
            handleFocus,
            handleKeydown,
            handleMousedown
          };
        }
      });
      const _hoisted_1$H = ["aria-disabled", "tabindex", "role"];
      function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_icon = resolveComponent("el-icon");
        return openBlock(), createElementBlock(Fragment, null, [
          _ctx.divided ? (openBlock(), createElementBlock("li", mergeProps({
            key: 0,
            role: "separator",
            class: _ctx.ns.bem("menu", "item", "divided")
          }, _ctx.$attrs), null, 16)) : createCommentVNode("v-if", true),
          createBaseVNode("li", mergeProps({ ref: _ctx.itemRef }, { ..._ctx.dataset, ..._ctx.$attrs }, {
            "aria-disabled": _ctx.disabled,
            class: [_ctx.ns.be("menu", "item"), _ctx.ns.is("disabled", _ctx.disabled)],
            tabindex: _ctx.tabIndex,
            role: _ctx.role,
            onClick: _cache[0] || (_cache[0] = (e2) => _ctx.$emit("clickimpl", e2)),
            onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
            onKeydown: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args), ["self"])),
            onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.handleMousedown && _ctx.handleMousedown(...args)),
            onPointermove: _cache[4] || (_cache[4] = (e2) => _ctx.$emit("pointermove", e2)),
            onPointerleave: _cache[5] || (_cache[5] = (e2) => _ctx.$emit("pointerleave", e2))
          }), [
            _ctx.icon ? (openBlock(), createBlock(_component_el_icon, { key: 0 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
              ]),
              _: 1
            })) : createCommentVNode("v-if", true),
            renderSlot(_ctx.$slots, "default")
          ], 16, _hoisted_1$H)
        ], 64);
      }
      var ElDropdownItemImpl = /* @__PURE__ */ _export_sfc$1(_sfc_main$w, [["render", _sfc_render$a], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item-impl.vue"]]);
      const useDropdown = () => {
        const elDropdown2 = inject("elDropdown", {});
        const _elDropdownSize = computed(() => elDropdown2 == null ? void 0 : elDropdown2.dropdownSize);
        return {
          elDropdown: elDropdown2,
          _elDropdownSize
        };
      };
      const _sfc_main$v = defineComponent({
        name: "ElDropdownItem",
        components: {
          ElDropdownCollectionItem: ElCollectionItem,
          ElRovingFocusItem,
          ElDropdownItemImpl
        },
        inheritAttrs: false,
        props: dropdownItemProps,
        emits: ["pointermove", "pointerleave", "click"],
        setup(props2, { emit: emit2, attrs }) {
          const { elDropdown: elDropdown2 } = useDropdown();
          const _instance = getCurrentInstance();
          const itemRef = ref(null);
          const textContent = computed(() => {
            var _a2, _b;
            return (_b = (_a2 = unref(itemRef)) == null ? void 0 : _a2.textContent) != null ? _b : "";
          });
          const { onItemEnter, onItemLeave } = inject(DROPDOWN_INJECTION_KEY, void 0);
          const handlePointerMove = composeEventHandlers((e2) => {
            emit2("pointermove", e2);
            return e2.defaultPrevented;
          }, whenMouse((e2) => {
            if (props2.disabled) {
              onItemLeave(e2);
              return;
            }
            const target = e2.currentTarget;
            if (target === document.activeElement || target.contains(document.activeElement)) {
              return;
            }
            onItemEnter(e2);
            if (!e2.defaultPrevented) {
              target == null ? void 0 : target.focus();
            }
          }));
          const handlePointerLeave = composeEventHandlers((e2) => {
            emit2("pointerleave", e2);
            return e2.defaultPrevented;
          }, whenMouse((e2) => {
            onItemLeave(e2);
          }));
          const handleClick = composeEventHandlers((e2) => {
            if (props2.disabled) {
              return;
            }
            emit2("click", e2);
            return e2.type !== "keydown" && e2.defaultPrevented;
          }, (e2) => {
            var _a2, _b, _c;
            if (props2.disabled) {
              e2.stopImmediatePropagation();
              return;
            }
            if ((_a2 = elDropdown2 == null ? void 0 : elDropdown2.hideOnClick) == null ? void 0 : _a2.value) {
              (_b = elDropdown2.handleClick) == null ? void 0 : _b.call(elDropdown2);
            }
            (_c = elDropdown2.commandHandler) == null ? void 0 : _c.call(elDropdown2, props2.command, _instance, e2);
          });
          const propsAndAttrs = computed(() => {
            return { ...props2, ...attrs };
          });
          return {
            handleClick,
            handlePointerMove,
            handlePointerLeave,
            textContent,
            propsAndAttrs
          };
        }
      });
      function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
        var _a2;
        const _component_el_dropdown_item_impl = resolveComponent("el-dropdown-item-impl");
        const _component_el_roving_focus_item = resolveComponent("el-roving-focus-item");
        const _component_el_dropdown_collection_item = resolveComponent("el-dropdown-collection-item");
        return openBlock(), createBlock(_component_el_dropdown_collection_item, {
          disabled: _ctx.disabled,
          "text-value": (_a2 = _ctx.textValue) != null ? _a2 : _ctx.textContent
        }, {
          default: withCtx(() => [
            createVNode(_component_el_roving_focus_item, {
              focusable: !_ctx.disabled
            }, {
              default: withCtx(() => [
                createVNode(_component_el_dropdown_item_impl, mergeProps(_ctx.propsAndAttrs, {
                  onPointerleave: _ctx.handlePointerLeave,
                  onPointermove: _ctx.handlePointerMove,
                  onClickimpl: _ctx.handleClick
                }), {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])
              ]),
              _: 3
            }, 8, ["focusable"])
          ]),
          _: 3
        }, 8, ["disabled", "text-value"]);
      }
      var DropdownItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["render", _sfc_render$9], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item.vue"]]);
      const _sfc_main$u = defineComponent({
        name: "ElDropdownMenu",
        props: dropdownMenuProps,
        setup(props2) {
          const ns = useNamespace("dropdown");
          const { _elDropdownSize } = useDropdown();
          const size2 = _elDropdownSize.value;
          const { focusTrapRef, onKeydown } = inject(FOCUS_TRAP_INJECTION_KEY, void 0);
          const { contentRef, role, triggerId } = inject(DROPDOWN_INJECTION_KEY, void 0);
          const { collectionRef: dropdownCollectionRef, getItems } = inject(COLLECTION_INJECTION_KEY, void 0);
          const {
            rovingFocusGroupRef,
            rovingFocusGroupRootStyle,
            tabIndex,
            onBlur,
            onFocus,
            onMousedown
          } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
          const { collectionRef: rovingFocusGroupCollectionRef } = inject(COLLECTION_INJECTION_KEY$1, void 0);
          const dropdownKls = computed(() => {
            return [ns.b("menu"), ns.bm("menu", size2 == null ? void 0 : size2.value)];
          });
          const dropdownListWrapperRef = composeRefs(contentRef, dropdownCollectionRef, focusTrapRef, rovingFocusGroupRef, rovingFocusGroupCollectionRef);
          const composedKeydown = composeEventHandlers((e2) => {
            var _a2;
            (_a2 = props2.onKeydown) == null ? void 0 : _a2.call(props2, e2);
          }, (e2) => {
            const { currentTarget, code, target } = e2;
            currentTarget.contains(target);
            if (EVENT_CODE.tab === code) {
              e2.stopImmediatePropagation();
            }
            e2.preventDefault();
            if (target !== unref(contentRef))
              return;
            if (!FIRST_LAST_KEYS.includes(code))
              return;
            const items = getItems().filter((item) => !item.disabled);
            const targets = items.map((item) => item.ref);
            if (LAST_KEYS.includes(code)) {
              targets.reverse();
            }
            focusFirst(targets);
          });
          const handleKeydown = (e2) => {
            composedKeydown(e2);
            onKeydown(e2);
          };
          return {
            size: size2,
            rovingFocusGroupRootStyle,
            tabIndex,
            dropdownKls,
            role,
            triggerId,
            dropdownListWrapperRef,
            handleKeydown,
            onBlur,
            onFocus,
            onMousedown
          };
        }
      });
      const _hoisted_1$G = ["role", "aria-labelledby"];
      function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("ul", {
          ref: _ctx.dropdownListWrapperRef,
          class: normalizeClass(_ctx.dropdownKls),
          style: normalizeStyle(_ctx.rovingFocusGroupRootStyle),
          tabindex: -1,
          role: _ctx.role,
          "aria-labelledby": _ctx.triggerId,
          onBlur: _cache[0] || (_cache[0] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
          onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
          onKeydown: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args), ["self"])),
          onMousedown: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.onMousedown && _ctx.onMousedown(...args), ["self"]))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 46, _hoisted_1$G);
      }
      var DropdownMenu = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["render", _sfc_render$8], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-menu.vue"]]);
      const ElDropdown = withInstall(Dropdown, {
        DropdownItem,
        DropdownMenu
      });
      const ElDropdownItem = withNoopInstall(DropdownItem);
      const ElDropdownMenu = withNoopInstall(DropdownMenu);
      const imageViewerProps = buildProps({
        urlList: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        zIndex: {
          type: Number
        },
        initialIndex: {
          type: Number,
          default: 0
        },
        infinite: {
          type: Boolean,
          default: true
        },
        hideOnClickModal: Boolean,
        teleported: Boolean,
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        zoomRate: {
          type: Number,
          default: 1.2
        }
      });
      const imageViewerEmits = {
        close: () => true,
        switch: (index) => isNumber(index)
      };
      const _hoisted_1$F = ["src"];
      const __default__$c = defineComponent({
        name: "ElImageViewer"
      });
      const _sfc_main$t = /* @__PURE__ */ defineComponent({
        ...__default__$c,
        props: imageViewerProps,
        emits: imageViewerEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props2 = __props;
          const modes = {
            CONTAIN: {
              name: "contain",
              icon: markRaw(full_screen_default)
            },
            ORIGINAL: {
              name: "original",
              icon: markRaw(scale_to_original_default)
            }
          };
          const { t: t2 } = useLocale();
          const ns = useNamespace("image-viewer");
          const { nextZIndex } = useZIndex();
          const wrapper = ref();
          const imgRefs = ref([]);
          const scopeEventListener = effectScope();
          const loading2 = ref(true);
          const activeIndex = ref(props2.initialIndex);
          const mode = shallowRef(modes.CONTAIN);
          const transform = ref({
            scale: 1,
            deg: 0,
            offsetX: 0,
            offsetY: 0,
            enableTransition: false
          });
          const isSingle = computed(() => {
            const { urlList } = props2;
            return urlList.length <= 1;
          });
          const isFirst = computed(() => {
            return activeIndex.value === 0;
          });
          const isLast = computed(() => {
            return activeIndex.value === props2.urlList.length - 1;
          });
          const currentImg = computed(() => {
            return props2.urlList[activeIndex.value];
          });
          const arrowPrevKls = computed(() => [
            ns.e("btn"),
            ns.e("prev"),
            ns.is("disabled", !props2.infinite && isFirst.value)
          ]);
          const arrowNextKls = computed(() => [
            ns.e("btn"),
            ns.e("next"),
            ns.is("disabled", !props2.infinite && isLast.value)
          ]);
          const imgStyle = computed(() => {
            const { scale, deg, offsetX, offsetY, enableTransition } = transform.value;
            let translateX = offsetX / scale;
            let translateY = offsetY / scale;
            switch (deg % 360) {
              case 90:
              case -270:
                [translateX, translateY] = [translateY, -translateX];
                break;
              case 180:
              case -180:
                [translateX, translateY] = [-translateX, -translateY];
                break;
              case 270:
              case -90:
                [translateX, translateY] = [-translateY, translateX];
                break;
            }
            const style = {
              transform: `scale(${scale}) rotate(${deg}deg) translate(${translateX}px, ${translateY}px)`,
              transition: enableTransition ? "transform .3s" : ""
            };
            if (mode.value.name === modes.CONTAIN.name) {
              style.maxWidth = style.maxHeight = "100%";
            }
            return style;
          });
          const computedZIndex = computed(() => {
            return isNumber(props2.zIndex) ? props2.zIndex : nextZIndex();
          });
          function hide() {
            unregisterEventListener();
            emit2("close");
          }
          function registerEventListener() {
            const keydownHandler = throttle((e2) => {
              switch (e2.code) {
                case EVENT_CODE.esc:
                  props2.closeOnPressEscape && hide();
                  break;
                case EVENT_CODE.space:
                  toggleMode();
                  break;
                case EVENT_CODE.left:
                  prev();
                  break;
                case EVENT_CODE.up:
                  handleActions("zoomIn");
                  break;
                case EVENT_CODE.right:
                  next();
                  break;
                case EVENT_CODE.down:
                  handleActions("zoomOut");
                  break;
              }
            });
            const mousewheelHandler = throttle((e2) => {
              const delta = e2.deltaY || e2.deltaX;
              handleActions(delta < 0 ? "zoomIn" : "zoomOut", {
                zoomRate: props2.zoomRate,
                enableTransition: false
              });
            });
            scopeEventListener.run(() => {
              useEventListener$1(document, "keydown", keydownHandler);
              useEventListener$1(document, "wheel", mousewheelHandler);
            });
          }
          function unregisterEventListener() {
            scopeEventListener.stop();
          }
          function handleImgLoad() {
            loading2.value = false;
          }
          function handleImgError(e2) {
            loading2.value = false;
            e2.target.alt = t2("el.image.error");
          }
          function handleMouseDown(e2) {
            if (loading2.value || e2.button !== 0 || !wrapper.value)
              return;
            transform.value.enableTransition = false;
            const { offsetX, offsetY } = transform.value;
            const startX = e2.pageX;
            const startY = e2.pageY;
            const dragHandler = throttle((ev) => {
              transform.value = {
                ...transform.value,
                offsetX: offsetX + ev.pageX - startX,
                offsetY: offsetY + ev.pageY - startY
              };
            });
            const removeMousemove = useEventListener$1(document, "mousemove", dragHandler);
            useEventListener$1(document, "mouseup", () => {
              removeMousemove();
            });
            e2.preventDefault();
          }
          function reset() {
            transform.value = {
              scale: 1,
              deg: 0,
              offsetX: 0,
              offsetY: 0,
              enableTransition: false
            };
          }
          function toggleMode() {
            if (loading2.value)
              return;
            const modeNames = keysOf(modes);
            const modeValues = Object.values(modes);
            const currentMode = mode.value.name;
            const index = modeValues.findIndex((i2) => i2.name === currentMode);
            const nextIndex = (index + 1) % modeNames.length;
            mode.value = modes[modeNames[nextIndex]];
            reset();
          }
          function setActiveItem(index) {
            const len = props2.urlList.length;
            activeIndex.value = (index + len) % len;
          }
          function prev() {
            if (isFirst.value && !props2.infinite)
              return;
            setActiveItem(activeIndex.value - 1);
          }
          function next() {
            if (isLast.value && !props2.infinite)
              return;
            setActiveItem(activeIndex.value + 1);
          }
          function handleActions(action, options = {}) {
            if (loading2.value)
              return;
            const { zoomRate, rotateDeg, enableTransition } = {
              zoomRate: props2.zoomRate,
              rotateDeg: 90,
              enableTransition: true,
              ...options
            };
            switch (action) {
              case "zoomOut":
                if (transform.value.scale > 0.2) {
                  transform.value.scale = Number.parseFloat((transform.value.scale / zoomRate).toFixed(3));
                }
                break;
              case "zoomIn":
                if (transform.value.scale < 7) {
                  transform.value.scale = Number.parseFloat((transform.value.scale * zoomRate).toFixed(3));
                }
                break;
              case "clockwise":
                transform.value.deg += rotateDeg;
                break;
              case "anticlockwise":
                transform.value.deg -= rotateDeg;
                break;
            }
            transform.value.enableTransition = enableTransition;
          }
          watch(currentImg, () => {
            nextTick(() => {
              const $img = imgRefs.value[0];
              if (!($img == null ? void 0 : $img.complete)) {
                loading2.value = true;
              }
            });
          });
          watch(activeIndex, (val) => {
            reset();
            emit2("switch", val);
          });
          onMounted(() => {
            var _a2, _b;
            registerEventListener();
            (_b = (_a2 = wrapper.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          });
          expose({
            setActiveItem
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              to: "body",
              disabled: !_ctx.teleported
            }, [
              createVNode(Transition, {
                name: "viewer-fade",
                appear: ""
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", {
                    ref_key: "wrapper",
                    ref: wrapper,
                    tabindex: -1,
                    class: normalizeClass(unref(ns).e("wrapper")),
                    style: normalizeStyle({ zIndex: unref(computedZIndex) })
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(unref(ns).e("mask")),
                      onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.hideOnClickModal && hide(), ["self"]))
                    }, null, 2),
                    createCommentVNode(" CLOSE "),
                    createBaseVNode("span", {
                      class: normalizeClass([unref(ns).e("btn"), unref(ns).e("close")]),
                      onClick: hide
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(close_default))
                        ]),
                        _: 1
                      })
                    ], 2),
                    createCommentVNode(" ARROW "),
                    !unref(isSingle) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createBaseVNode("span", {
                        class: normalizeClass(unref(arrowPrevKls)),
                        onClick: prev
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(arrow_left_default))
                          ]),
                          _: 1
                        })
                      ], 2),
                      createBaseVNode("span", {
                        class: normalizeClass(unref(arrowNextKls)),
                        onClick: next
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(arrow_right_default))
                          ]),
                          _: 1
                        })
                      ], 2)
                    ], 64)) : createCommentVNode("v-if", true),
                    createCommentVNode(" ACTIONS "),
                    createBaseVNode("div", {
                      class: normalizeClass([unref(ns).e("btn"), unref(ns).e("actions")])
                    }, [
                      createBaseVNode("div", {
                        class: normalizeClass(unref(ns).e("actions__inner"))
                      }, [
                        createVNode(unref(ElIcon), {
                          onClick: _cache[1] || (_cache[1] = ($event) => handleActions("zoomOut"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(zoom_out_default))
                          ]),
                          _: 1
                        }),
                        createVNode(unref(ElIcon), {
                          onClick: _cache[2] || (_cache[2] = ($event) => handleActions("zoomIn"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(zoom_in_default))
                          ]),
                          _: 1
                        }),
                        createBaseVNode("i", {
                          class: normalizeClass(unref(ns).e("actions__divider"))
                        }, null, 2),
                        createVNode(unref(ElIcon), { onClick: toggleMode }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(unref(mode).icon)))
                          ]),
                          _: 1
                        }),
                        createBaseVNode("i", {
                          class: normalizeClass(unref(ns).e("actions__divider"))
                        }, null, 2),
                        createVNode(unref(ElIcon), {
                          onClick: _cache[3] || (_cache[3] = ($event) => handleActions("anticlockwise"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(refresh_left_default))
                          ]),
                          _: 1
                        }),
                        createVNode(unref(ElIcon), {
                          onClick: _cache[4] || (_cache[4] = ($event) => handleActions("clockwise"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(refresh_right_default))
                          ]),
                          _: 1
                        })
                      ], 2)
                    ], 2),
                    createCommentVNode(" CANVAS "),
                    createBaseVNode("div", {
                      class: normalizeClass(unref(ns).e("canvas"))
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.urlList, (url, i2) => {
                        return withDirectives((openBlock(), createElementBlock("img", {
                          ref_for: true,
                          ref: (el) => imgRefs.value[i2] = el,
                          key: url,
                          src: url,
                          style: normalizeStyle(unref(imgStyle)),
                          class: normalizeClass(unref(ns).e("img")),
                          onLoad: handleImgLoad,
                          onError: handleImgError,
                          onMousedown: handleMouseDown
                        }, null, 46, _hoisted_1$F)), [
                          [vShow, i2 === activeIndex.value]
                        ]);
                      }), 128))
                    ], 2),
                    renderSlot(_ctx.$slots, "default")
                  ], 6)
                ]),
                _: 3
              })
            ], 8, ["disabled"]);
          };
        }
      });
      var ImageViewer = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image-viewer/src/image-viewer.vue"]]);
      const ElImageViewer = withInstall(ImageViewer);
      const imageProps = buildProps({
        hideOnClickModal: Boolean,
        src: {
          type: String,
          default: ""
        },
        fit: {
          type: String,
          values: ["", "contain", "cover", "fill", "none", "scale-down"],
          default: ""
        },
        loading: {
          type: String,
          values: ["eager", "lazy"]
        },
        lazy: Boolean,
        scrollContainer: {
          type: definePropType([String, Object])
        },
        previewSrcList: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        previewTeleported: Boolean,
        zIndex: {
          type: Number
        },
        initialIndex: {
          type: Number,
          default: 0
        },
        infinite: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        zoomRate: {
          type: Number,
          default: 1.2
        }
      });
      const imageEmits = {
        load: (evt) => evt instanceof Event,
        error: (evt) => evt instanceof Event,
        switch: (val) => isNumber(val),
        close: () => true,
        show: () => true
      };
      const _hoisted_1$E = ["src", "loading"];
      const _hoisted_2$y = { key: 0 };
      const __default__$b = defineComponent({
        name: "ElImage",
        inheritAttrs: false
      });
      const _sfc_main$s = /* @__PURE__ */ defineComponent({
        ...__default__$b,
        props: imageProps,
        emits: imageEmits,
        setup(__props, { emit: emit2 }) {
          const props2 = __props;
          let prevOverflow = "";
          const { t: t2 } = useLocale();
          const ns = useNamespace("image");
          const rawAttrs = useAttrs$1();
          const attrs = useAttrs();
          const imageSrc = ref();
          const hasLoadError = ref(false);
          const isLoading = ref(true);
          const showViewer = ref(false);
          const container = ref();
          const _scrollContainer = ref();
          const supportLoading = isClient$1 && "loading" in HTMLImageElement.prototype;
          let stopScrollListener;
          let stopWheelListener;
          const imageKls = computed(() => [
            ns.e("inner"),
            preview.value && ns.e("preview"),
            isLoading.value && ns.is("loading")
          ]);
          const containerStyle = computed(() => rawAttrs.style);
          const imageStyle = computed(() => {
            const { fit } = props2;
            if (isClient$1 && fit) {
              return { objectFit: fit };
            }
            return {};
          });
          const preview = computed(() => {
            const { previewSrcList } = props2;
            return Array.isArray(previewSrcList) && previewSrcList.length > 0;
          });
          const imageIndex = computed(() => {
            const { previewSrcList, initialIndex } = props2;
            let previewIndex = initialIndex;
            if (initialIndex > previewSrcList.length - 1) {
              previewIndex = 0;
            }
            return previewIndex;
          });
          const isManual = computed(() => {
            if (props2.loading === "eager")
              return false;
            return !supportLoading && props2.loading === "lazy" || props2.lazy;
          });
          const loadImage = () => {
            if (!isClient$1)
              return;
            isLoading.value = true;
            hasLoadError.value = false;
            imageSrc.value = props2.src;
          };
          function handleLoad(event) {
            isLoading.value = false;
            hasLoadError.value = false;
            emit2("load", event);
          }
          function handleError2(event) {
            isLoading.value = false;
            hasLoadError.value = true;
            emit2("error", event);
          }
          function handleLazyLoad() {
            if (isInContainer(container.value, _scrollContainer.value)) {
              loadImage();
              removeLazyLoadListener();
            }
          }
          const lazyLoadHandler = useThrottleFn(handleLazyLoad, 200, true);
          async function addLazyLoadListener() {
            var _a2;
            if (!isClient$1)
              return;
            await nextTick();
            const { scrollContainer } = props2;
            if (isElement(scrollContainer)) {
              _scrollContainer.value = scrollContainer;
            } else if (isString$2(scrollContainer) && scrollContainer !== "") {
              _scrollContainer.value = (_a2 = document.querySelector(scrollContainer)) != null ? _a2 : void 0;
            } else if (container.value) {
              _scrollContainer.value = getScrollContainer(container.value);
            }
            if (_scrollContainer.value) {
              stopScrollListener = useEventListener$1(_scrollContainer, "scroll", lazyLoadHandler);
              setTimeout(() => handleLazyLoad(), 100);
            }
          }
          function removeLazyLoadListener() {
            if (!isClient$1 || !_scrollContainer.value || !lazyLoadHandler)
              return;
            stopScrollListener == null ? void 0 : stopScrollListener();
            _scrollContainer.value = void 0;
          }
          function wheelHandler(e2) {
            if (!e2.ctrlKey)
              return;
            if (e2.deltaY < 0) {
              e2.preventDefault();
              return false;
            } else if (e2.deltaY > 0) {
              e2.preventDefault();
              return false;
            }
          }
          function clickHandler() {
            if (!preview.value)
              return;
            stopWheelListener = useEventListener$1("wheel", wheelHandler, {
              passive: false
            });
            prevOverflow = document.body.style.overflow;
            document.body.style.overflow = "hidden";
            showViewer.value = true;
            emit2("show");
          }
          function closeViewer() {
            stopWheelListener == null ? void 0 : stopWheelListener();
            document.body.style.overflow = prevOverflow;
            showViewer.value = false;
            emit2("close");
          }
          function switchViewer(val) {
            emit2("switch", val);
          }
          watch(() => props2.src, () => {
            if (isManual.value) {
              isLoading.value = true;
              hasLoadError.value = false;
              removeLazyLoadListener();
              addLazyLoadListener();
            } else {
              loadImage();
            }
          });
          onMounted(() => {
            if (isManual.value) {
              addLazyLoadListener();
            } else {
              loadImage();
            }
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "container",
              ref: container,
              class: normalizeClass([unref(ns).b(), _ctx.$attrs.class]),
              style: normalizeStyle(unref(containerStyle))
            }, [
              hasLoadError.value ? renderSlot(_ctx.$slots, "error", { key: 0 }, () => [
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).e("error"))
                }, toDisplayString(unref(t2)("el.image.error")), 3)
              ]) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                imageSrc.value !== void 0 ? (openBlock(), createElementBlock("img", mergeProps({ key: 0 }, unref(attrs), {
                  src: imageSrc.value,
                  loading: _ctx.loading,
                  style: unref(imageStyle),
                  class: unref(imageKls),
                  onClick: clickHandler,
                  onLoad: handleLoad,
                  onError: handleError2
                }), null, 16, _hoisted_1$E)) : createCommentVNode("v-if", true),
                isLoading.value ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(ns).e("wrapper"))
                }, [
                  renderSlot(_ctx.$slots, "placeholder", {}, () => [
                    createBaseVNode("div", {
                      class: normalizeClass(unref(ns).e("placeholder"))
                    }, null, 2)
                  ])
                ], 2)) : createCommentVNode("v-if", true)
              ], 64)),
              unref(preview) ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                showViewer.value ? (openBlock(), createBlock(unref(ElImageViewer), {
                  key: 0,
                  "z-index": _ctx.zIndex,
                  "initial-index": unref(imageIndex),
                  infinite: _ctx.infinite,
                  "zoom-rate": _ctx.zoomRate,
                  "url-list": _ctx.previewSrcList,
                  "hide-on-click-modal": _ctx.hideOnClickModal,
                  teleported: _ctx.previewTeleported,
                  "close-on-press-escape": _ctx.closeOnPressEscape,
                  onClose: closeViewer,
                  onSwitch: switchViewer
                }, {
                  default: withCtx(() => [
                    _ctx.$slots.viewer ? (openBlock(), createElementBlock("div", _hoisted_2$y, [
                      renderSlot(_ctx.$slots, "viewer")
                    ])) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["z-index", "initial-index", "infinite", "zoom-rate", "url-list", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : createCommentVNode("v-if", true)
              ], 64)) : createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var Image$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image/src/image.vue"]]);
      const ElImage = withInstall(Image$1);
      const inputNumberProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        step: {
          type: Number,
          default: 1
        },
        stepStrictly: Boolean,
        max: {
          type: Number,
          default: Number.POSITIVE_INFINITY
        },
        min: {
          type: Number,
          default: Number.NEGATIVE_INFINITY
        },
        modelValue: Number,
        readonly: Boolean,
        disabled: Boolean,
        size: useSizeProp,
        controls: {
          type: Boolean,
          default: true
        },
        controlsPosition: {
          type: String,
          default: "",
          values: ["", "right"]
        },
        valueOnClear: {
          type: [String, Number, null],
          validator: (val) => val === null || isNumber(val) || ["min", "max"].includes(val),
          default: null
        },
        name: String,
        label: String,
        placeholder: String,
        precision: {
          type: Number,
          validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const inputNumberEmits = {
        [CHANGE_EVENT]: (cur, prev) => prev !== cur,
        blur: (e2) => e2 instanceof FocusEvent,
        focus: (e2) => e2 instanceof FocusEvent,
        [INPUT_EVENT]: (val) => isNumber(val) || isNil(val),
        [UPDATE_MODEL_EVENT]: (val) => isNumber(val) || isNil(val)
      };
      const _hoisted_1$D = ["aria-label", "onKeydown"];
      const _hoisted_2$x = ["aria-label", "onKeydown"];
      const __default__$a = defineComponent({
        name: "ElInputNumber"
      });
      const _sfc_main$r = /* @__PURE__ */ defineComponent({
        ...__default__$a,
        props: inputNumberProps,
        emits: inputNumberEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props2 = __props;
          const { t: t2 } = useLocale();
          const ns = useNamespace("input-number");
          const input = ref();
          const data = reactive({
            currentValue: props2.modelValue,
            userInput: null
          });
          const { formItem } = useFormItem();
          const minDisabled = computed(() => isNumber(props2.modelValue) && props2.modelValue <= props2.min);
          const maxDisabled = computed(() => isNumber(props2.modelValue) && props2.modelValue >= props2.max);
          const numPrecision = computed(() => {
            const stepPrecision = getPrecision(props2.step);
            if (!isUndefined(props2.precision)) {
              if (stepPrecision > props2.precision)
                ;
              return props2.precision;
            } else {
              return Math.max(getPrecision(props2.modelValue), stepPrecision);
            }
          });
          const controlsAtRight = computed(() => {
            return props2.controls && props2.controlsPosition === "right";
          });
          const inputNumberSize = useFormSize();
          const inputNumberDisabled = useFormDisabled();
          const displayValue = computed(() => {
            if (data.userInput !== null) {
              return data.userInput;
            }
            let currentValue = data.currentValue;
            if (isNil(currentValue))
              return "";
            if (isNumber(currentValue)) {
              if (Number.isNaN(currentValue))
                return "";
              if (!isUndefined(props2.precision)) {
                currentValue = currentValue.toFixed(props2.precision);
              }
            }
            return currentValue;
          });
          const toPrecision = (num, pre) => {
            if (isUndefined(pre))
              pre = numPrecision.value;
            if (pre === 0)
              return Math.round(num);
            let snum = String(num);
            const pointPos = snum.indexOf(".");
            if (pointPos === -1)
              return num;
            const nums = snum.replace(".", "").split("");
            const datum = nums[pointPos + pre];
            if (!datum)
              return num;
            const length = snum.length;
            if (snum.charAt(length - 1) === "5") {
              snum = `${snum.slice(0, Math.max(0, length - 1))}6`;
            }
            return Number.parseFloat(Number(snum).toFixed(pre));
          };
          const getPrecision = (value) => {
            if (isNil(value))
              return 0;
            const valueString = value.toString();
            const dotPosition = valueString.indexOf(".");
            let precision = 0;
            if (dotPosition !== -1) {
              precision = valueString.length - dotPosition - 1;
            }
            return precision;
          };
          const ensurePrecision = (val, coefficient = 1) => {
            if (!isNumber(val))
              return data.currentValue;
            return toPrecision(val + props2.step * coefficient);
          };
          const increase = () => {
            if (props2.readonly || inputNumberDisabled.value || maxDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value);
            setCurrentValue(newVal);
            emit2(INPUT_EVENT, data.currentValue);
          };
          const decrease = () => {
            if (props2.readonly || inputNumberDisabled.value || minDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value, -1);
            setCurrentValue(newVal);
            emit2(INPUT_EVENT, data.currentValue);
          };
          const verifyValue = (value, update) => {
            const { max, min, step, precision, stepStrictly, valueOnClear } = props2;
            if (max < min) {
              throwError("InputNumber", "min should not be greater than max.");
            }
            let newVal = Number(value);
            if (isNil(value) || Number.isNaN(newVal)) {
              return null;
            }
            if (value === "") {
              if (valueOnClear === null) {
                return null;
              }
              newVal = isString$2(valueOnClear) ? { min, max }[valueOnClear] : valueOnClear;
            }
            if (stepStrictly) {
              newVal = toPrecision(Math.round(newVal / step) * step, precision);
            }
            if (!isUndefined(precision)) {
              newVal = toPrecision(newVal, precision);
            }
            if (newVal > max || newVal < min) {
              newVal = newVal > max ? max : min;
              update && emit2(UPDATE_MODEL_EVENT, newVal);
            }
            return newVal;
          };
          const setCurrentValue = (value, emitChange = true) => {
            var _a2;
            const oldVal = data.currentValue;
            const newVal = verifyValue(value);
            if (!emitChange) {
              emit2(UPDATE_MODEL_EVENT, newVal);
              return;
            }
            if (oldVal === newVal)
              return;
            data.userInput = null;
            emit2(UPDATE_MODEL_EVENT, newVal);
            emit2(CHANGE_EVENT, newVal, oldVal);
            if (props2.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
            }
            data.currentValue = newVal;
          };
          const handleInput = (value) => {
            data.userInput = value;
            const newVal = value === "" ? null : Number(value);
            emit2(INPUT_EVENT, newVal);
            setCurrentValue(newVal, false);
          };
          const handleInputChange = (value) => {
            const newVal = value !== "" ? Number(value) : "";
            if (isNumber(newVal) && !Number.isNaN(newVal) || value === "") {
              setCurrentValue(newVal);
            }
            data.userInput = null;
          };
          const focus = () => {
            var _a2, _b;
            (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          };
          const blur = () => {
            var _a2, _b;
            (_b = (_a2 = input.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
          };
          const handleFocus = (event) => {
            emit2("focus", event);
          };
          const handleBlur = (event) => {
            var _a2;
            emit2("blur", event);
            if (props2.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn());
            }
          };
          watch(() => props2.modelValue, (value) => {
            const userInput = verifyValue(data.userInput);
            const newValue = verifyValue(value, true);
            if (!isNumber(userInput) && (!userInput || userInput !== newValue)) {
              data.currentValue = newValue;
              data.userInput = null;
            }
          }, { immediate: true });
          onMounted(() => {
            var _a2;
            const { min, max, modelValue } = props2;
            const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
            innerInput.setAttribute("role", "spinbutton");
            if (Number.isFinite(max)) {
              innerInput.setAttribute("aria-valuemax", String(max));
            } else {
              innerInput.removeAttribute("aria-valuemax");
            }
            if (Number.isFinite(min)) {
              innerInput.setAttribute("aria-valuemin", String(min));
            } else {
              innerInput.removeAttribute("aria-valuemin");
            }
            innerInput.setAttribute("aria-valuenow", String(data.currentValue));
            innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
            if (!isNumber(modelValue) && modelValue != null) {
              let val = Number(modelValue);
              if (Number.isNaN(val)) {
                val = null;
              }
              emit2(UPDATE_MODEL_EVENT, val);
            }
          });
          onUpdated(() => {
            var _a2;
            const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
            innerInput == null ? void 0 : innerInput.setAttribute("aria-valuenow", `${data.currentValue}`);
          });
          expose({
            focus,
            blur
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).m(unref(inputNumberSize)),
                unref(ns).is("disabled", unref(inputNumberDisabled)),
                unref(ns).is("without-controls", !_ctx.controls),
                unref(ns).is("controls-right", unref(controlsAtRight))
              ]),
              onDragstart: _cache[1] || (_cache[1] = withModifiers(() => {
              }, ["prevent"]))
            }, [
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 0,
                role: "button",
                "aria-label": unref(t2)("el.inputNumber.decrease"),
                class: normalizeClass([unref(ns).e("decrease"), unref(ns).is("disabled", unref(minDisabled))]),
                onKeydown: withKeys(decrease, ["enter"])
              }, [
                createVNode(unref(ElIcon), null, {
                  default: withCtx(() => [
                    unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_down_default), { key: 0 })) : (openBlock(), createBlock(unref(minus_default), { key: 1 }))
                  ]),
                  _: 1
                })
              ], 42, _hoisted_1$D)), [
                [unref(vRepeatClick), decrease]
              ]) : createCommentVNode("v-if", true),
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 1,
                role: "button",
                "aria-label": unref(t2)("el.inputNumber.increase"),
                class: normalizeClass([unref(ns).e("increase"), unref(ns).is("disabled", unref(maxDisabled))]),
                onKeydown: withKeys(increase, ["enter"])
              }, [
                createVNode(unref(ElIcon), null, {
                  default: withCtx(() => [
                    unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_up_default), { key: 0 })) : (openBlock(), createBlock(unref(plus_default), { key: 1 }))
                  ]),
                  _: 1
                })
              ], 42, _hoisted_2$x)), [
                [unref(vRepeatClick), increase]
              ]) : createCommentVNode("v-if", true),
              createVNode(unref(ElInput), {
                id: _ctx.id,
                ref_key: "input",
                ref: input,
                type: "number",
                step: _ctx.step,
                "model-value": unref(displayValue),
                placeholder: _ctx.placeholder,
                readonly: _ctx.readonly,
                disabled: unref(inputNumberDisabled),
                size: unref(inputNumberSize),
                max: _ctx.max,
                min: _ctx.min,
                name: _ctx.name,
                label: _ctx.label,
                "validate-event": false,
                onWheel: _cache[0] || (_cache[0] = withModifiers(() => {
                }, ["prevent"])),
                onKeydown: [
                  withKeys(withModifiers(increase, ["prevent"]), ["up"]),
                  withKeys(withModifiers(decrease, ["prevent"]), ["down"])
                ],
                onBlur: handleBlur,
                onFocus: handleFocus,
                onInput: handleInput,
                onChange: handleInputChange
              }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])
            ], 34);
          };
        }
      });
      var InputNumber = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input-number/src/input-number.vue"]]);
      const ElInputNumber = withInstall(InputNumber);
      const selectGroupKey = Symbol("ElSelectGroup");
      const selectKey = Symbol("ElSelect");
      function useOption$1(props2, states) {
        const select = inject(selectKey);
        const selectGroup = inject(selectGroupKey, { disabled: false });
        const isObject2 = computed(() => {
          return Object.prototype.toString.call(props2.value).toLowerCase() === "[object object]";
        });
        const itemSelected = computed(() => {
          if (!select.props.multiple) {
            return isEqual2(props2.value, select.props.modelValue);
          } else {
            return contains(select.props.modelValue, props2.value);
          }
        });
        const limitReached = computed(() => {
          if (select.props.multiple) {
            const modelValue = select.props.modelValue || [];
            return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
          } else {
            return false;
          }
        });
        const currentLabel = computed(() => {
          return props2.label || (isObject2.value ? "" : props2.value);
        });
        const currentValue = computed(() => {
          return props2.value || props2.label || "";
        });
        const isDisabled = computed(() => {
          return props2.disabled || states.groupDisabled || limitReached.value;
        });
        const instance = getCurrentInstance();
        const contains = (arr = [], target) => {
          if (!isObject2.value) {
            return arr && arr.includes(target);
          } else {
            const valueKey = select.props.valueKey;
            return arr && arr.some((item) => {
              return toRaw(get(item, valueKey)) === get(target, valueKey);
            });
          }
        };
        const isEqual2 = (a2, b2) => {
          if (!isObject2.value) {
            return a2 === b2;
          } else {
            const { valueKey } = select.props;
            return get(a2, valueKey) === get(b2, valueKey);
          }
        };
        const hoverItem = () => {
          if (!props2.disabled && !selectGroup.disabled) {
            select.hoverIndex = select.optionsArray.indexOf(instance.proxy);
          }
        };
        watch(() => currentLabel.value, () => {
          if (!props2.created && !select.props.remote)
            select.setSelected();
        });
        watch(() => props2.value, (val, oldVal) => {
          const { remote, valueKey } = select.props;
          if (!Object.is(val, oldVal)) {
            select.onOptionDestroy(oldVal, instance.proxy);
            select.onOptionCreate(instance.proxy);
          }
          if (!props2.created && !remote) {
            if (valueKey && typeof val === "object" && typeof oldVal === "object" && val[valueKey] === oldVal[valueKey]) {
              return;
            }
            select.setSelected();
          }
        });
        watch(() => selectGroup.disabled, () => {
          states.groupDisabled = selectGroup.disabled;
        }, { immediate: true });
        const { queryChange } = toRaw(select);
        watch(queryChange, (changes) => {
          const { query } = unref(changes);
          const regexp2 = new RegExp(escapeStringRegexp(query), "i");
          states.visible = regexp2.test(currentLabel.value) || props2.created;
          if (!states.visible) {
            select.filteredOptionsCount--;
          }
        }, { immediate: true });
        return {
          select,
          currentLabel,
          currentValue,
          itemSelected,
          isDisabled,
          hoverItem
        };
      }
      const _sfc_main$q = defineComponent({
        name: "ElOption",
        componentName: "ElOption",
        props: {
          value: {
            required: true,
            type: [String, Number, Boolean, Object]
          },
          label: [String, Number],
          created: Boolean,
          disabled: {
            type: Boolean,
            default: false
          }
        },
        setup(props2) {
          const ns = useNamespace("select");
          const containerKls = computed(() => [
            ns.be("dropdown", "item"),
            ns.is("disabled", unref(isDisabled)),
            {
              selected: unref(itemSelected),
              hover: unref(hover)
            }
          ]);
          const states = reactive({
            index: -1,
            groupDisabled: false,
            visible: true,
            hitState: false,
            hover: false
          });
          const { currentLabel, itemSelected, isDisabled, select, hoverItem } = useOption$1(props2, states);
          const { visible, hover } = toRefs$1(states);
          const vm = getCurrentInstance().proxy;
          select.onOptionCreate(vm);
          onBeforeUnmount(() => {
            const key = vm.value;
            const { selected } = select;
            const selectedOptions = select.props.multiple ? selected : [selected];
            const doesSelected = selectedOptions.some((item) => {
              return item.value === vm.value;
            });
            nextTick(() => {
              if (select.cachedOptions.get(key) === vm && !doesSelected) {
                select.cachedOptions.delete(key);
              }
            });
            select.onOptionDestroy(key, vm);
          });
          function selectOptionClick() {
            if (props2.disabled !== true && states.groupDisabled !== true) {
              select.handleOptionSelect(vm);
            }
          }
          return {
            ns,
            containerKls,
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            visible,
            hover,
            selectOptionClick,
            states
          };
        }
      });
      function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
        return withDirectives((openBlock(), createElementBlock("li", {
          class: normalizeClass(_ctx.containerKls),
          onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createBaseVNode("span", null, toDisplayString(_ctx.currentLabel), 1)
          ])
        ], 34)), [
          [vShow, _ctx.visible]
        ]);
      }
      var Option = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["render", _sfc_render$7], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);
      const _sfc_main$p = defineComponent({
        name: "ElSelectDropdown",
        componentName: "ElSelectDropdown",
        setup() {
          const select = inject(selectKey);
          const ns = useNamespace("select");
          const popperClass = computed(() => select.props.popperClass);
          const isMultiple = computed(() => select.props.multiple);
          const isFitInputWidth = computed(() => select.props.fitInputWidth);
          const minWidth = ref("");
          function updateMinWidth() {
            var _a2;
            minWidth.value = `${(_a2 = select.selectWrapper) == null ? void 0 : _a2.offsetWidth}px`;
          }
          onMounted(() => {
            updateMinWidth();
            useResizeObserver(select.selectWrapper, updateMinWidth);
          });
          return {
            ns,
            minWidth,
            popperClass,
            isMultiple,
            isFitInputWidth
          };
        }
      });
      function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
          style: normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 6);
      }
      var ElSelectMenu$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["render", _sfc_render$6], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);
      function useSelectStates(props2) {
        const { t: t2 } = useLocale();
        return reactive({
          options: /* @__PURE__ */ new Map(),
          cachedOptions: /* @__PURE__ */ new Map(),
          createdLabel: null,
          createdSelected: false,
          selected: props2.multiple ? [] : {},
          inputLength: 20,
          inputWidth: 0,
          optionsCount: 0,
          filteredOptionsCount: 0,
          visible: false,
          selectedLabel: "",
          hoverIndex: -1,
          query: "",
          previousQuery: null,
          inputHovering: false,
          cachedPlaceHolder: "",
          currentPlaceholder: t2("el.select.placeholder"),
          menuVisibleOnFocus: false,
          isOnComposition: false,
          prefixWidth: 11,
          mouseEnter: false
        });
      }
      let ignoreFocusEvent = false;
      const useSelect$1 = (props2, states, ctx) => {
        const { t: t2 } = useLocale();
        const ns = useNamespace("select");
        useDeprecated({
          from: "suffixTransition",
          replacement: "override style scheme",
          version: "2.3.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
        }, computed(() => props2.suffixTransition === false));
        const reference = ref(null);
        const input = ref(null);
        const iOSInput = ref(null);
        const tooltipRef = ref(null);
        const tagTooltipRef = ref(null);
        const tags = ref(null);
        const selectWrapper = ref(null);
        const scrollbar = ref(null);
        const hoverOption = ref(-1);
        const queryChange = shallowRef({ query: "" });
        const groupQueryChange = shallowRef("");
        const optionList = ref([]);
        let originClientHeight = 0;
        const { form, formItem } = useFormItem();
        const readonly2 = computed(() => !props2.filterable || props2.multiple || !states.visible);
        const selectDisabled = computed(() => props2.disabled || (form == null ? void 0 : form.disabled));
        const showClose = computed(() => {
          const hasValue = props2.multiple ? Array.isArray(props2.modelValue) && props2.modelValue.length > 0 : props2.modelValue !== void 0 && props2.modelValue !== null && props2.modelValue !== "";
          const criteria = props2.clearable && !selectDisabled.value && states.inputHovering && hasValue;
          return criteria;
        });
        const iconComponent = computed(() => props2.remote && props2.filterable && !props2.remoteShowSuffix ? "" : props2.suffixIcon);
        const iconReverse = computed(() => ns.is("reverse", iconComponent.value && states.visible && props2.suffixTransition));
        const debounce$1 = computed(() => props2.remote ? 300 : 0);
        const emptyText = computed(() => {
          if (props2.loading) {
            return props2.loadingText || t2("el.select.loading");
          } else {
            if (props2.remote && states.query === "" && states.options.size === 0)
              return false;
            if (props2.filterable && states.query && states.options.size > 0 && states.filteredOptionsCount === 0) {
              return props2.noMatchText || t2("el.select.noMatch");
            }
            if (states.options.size === 0) {
              return props2.noDataText || t2("el.select.noData");
            }
          }
          return null;
        });
        const optionsArray = computed(() => {
          const list = Array.from(states.options.values());
          const newList = [];
          optionList.value.forEach((item) => {
            const index = list.findIndex((i2) => i2.currentLabel === item);
            if (index > -1) {
              newList.push(list[index]);
            }
          });
          return newList.length ? newList : list;
        });
        const cachedOptionsArray = computed(() => Array.from(states.cachedOptions.values()));
        const showNewOption = computed(() => {
          const hasExistingOption = optionsArray.value.filter((option) => {
            return !option.created;
          }).some((option) => {
            return option.currentLabel === states.query;
          });
          return props2.filterable && props2.allowCreate && states.query !== "" && !hasExistingOption;
        });
        const selectSize = useFormSize();
        const collapseTagSize = computed(() => ["small"].includes(selectSize.value) ? "small" : "default");
        const dropMenuVisible = computed({
          get() {
            return states.visible && emptyText.value !== false;
          },
          set(val) {
            states.visible = val;
          }
        });
        watch([() => selectDisabled.value, () => selectSize.value, () => form == null ? void 0 : form.size], () => {
          nextTick(() => {
            resetInputHeight();
          });
        });
        watch(() => props2.placeholder, (val) => {
          states.cachedPlaceHolder = states.currentPlaceholder = val;
          const hasValue = props2.multiple && Array.isArray(props2.modelValue) && props2.modelValue.length > 0;
          if (hasValue) {
            states.currentPlaceholder = "";
          }
        });
        watch(() => props2.modelValue, (val, oldVal) => {
          if (props2.multiple) {
            resetInputHeight();
            if (val && val.length > 0 || input.value && states.query !== "") {
              states.currentPlaceholder = "";
            } else {
              states.currentPlaceholder = states.cachedPlaceHolder;
            }
            if (props2.filterable && !props2.reserveKeyword) {
              states.query = "";
              handleQueryChange(states.query);
            }
          }
          setSelected();
          if (props2.filterable && !props2.multiple) {
            states.inputLength = 20;
          }
          if (!isEqual$1(val, oldVal) && props2.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        }, {
          flush: "post",
          deep: true
        });
        watch(() => states.visible, (val) => {
          var _a2, _b, _c, _d, _e;
          if (!val) {
            if (props2.filterable) {
              if (isFunction$2(props2.filterMethod)) {
                props2.filterMethod("");
              }
              if (isFunction$2(props2.remoteMethod)) {
                props2.remoteMethod("");
              }
            }
            input.value && input.value.blur();
            states.query = "";
            states.previousQuery = null;
            states.selectedLabel = "";
            states.inputLength = 20;
            states.menuVisibleOnFocus = false;
            resetHoverIndex();
            nextTick(() => {
              if (input.value && input.value.value === "" && states.selected.length === 0) {
                states.currentPlaceholder = states.cachedPlaceHolder;
              }
            });
            if (!props2.multiple) {
              if (states.selected) {
                if (props2.filterable && props2.allowCreate && states.createdSelected && states.createdLabel) {
                  states.selectedLabel = states.createdLabel;
                } else {
                  states.selectedLabel = states.selected.currentLabel;
                }
                if (props2.filterable)
                  states.query = states.selectedLabel;
              }
              if (props2.filterable) {
                states.currentPlaceholder = states.cachedPlaceHolder;
              }
            }
          } else {
            (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            if (props2.filterable) {
              states.filteredOptionsCount = states.optionsCount;
              states.query = props2.remote ? "" : states.selectedLabel;
              (_d = (_c = iOSInput.value) == null ? void 0 : _c.focus) == null ? void 0 : _d.call(_c);
              if (props2.multiple) {
                (_e = input.value) == null ? void 0 : _e.focus();
              } else {
                if (states.selectedLabel) {
                  states.currentPlaceholder = `${states.selectedLabel}`;
                  states.selectedLabel = "";
                }
              }
              handleQueryChange(states.query);
              if (!props2.multiple && !props2.remote) {
                queryChange.value.query = "";
                triggerRef(queryChange);
                triggerRef(groupQueryChange);
              }
            }
          }
          ctx.emit("visible-change", val);
        });
        watch(() => states.options.entries(), () => {
          var _a2, _b, _c;
          if (!isClient$1)
            return;
          (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          if (props2.multiple) {
            resetInputHeight();
          }
          const inputs = ((_c = selectWrapper.value) == null ? void 0 : _c.querySelectorAll("input")) || [];
          if (!Array.from(inputs).includes(document.activeElement)) {
            setSelected();
          }
          if (props2.defaultFirstOption && (props2.filterable || props2.remote) && states.filteredOptionsCount) {
            checkDefaultFirstOption();
          }
        }, {
          flush: "post"
        });
        watch(() => states.hoverIndex, (val) => {
          if (isNumber(val) && val > -1) {
            hoverOption.value = optionsArray.value[val] || {};
          } else {
            hoverOption.value = {};
          }
          optionsArray.value.forEach((option) => {
            option.hover = hoverOption.value === option;
          });
        });
        const resetInputHeight = () => {
          nextTick(() => {
            var _a2, _b;
            if (!reference.value)
              return;
            const input2 = reference.value.$el.querySelector("input");
            originClientHeight = originClientHeight || (input2.clientHeight > 0 ? input2.clientHeight + 2 : 0);
            const _tags = tags.value;
            const gotSize = getComponentSize(selectSize.value || (form == null ? void 0 : form.size));
            const sizeInMap = selectSize.value || gotSize === originClientHeight || originClientHeight <= 0 ? gotSize : originClientHeight;
            const isElHidden = input2.offsetParent === null;
            !isElHidden && (input2.style.height = `${(states.selected.length === 0 ? sizeInMap : Math.max(_tags ? _tags.clientHeight + (_tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap)) - 2}px`);
            if (states.visible && emptyText.value !== false) {
              (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            }
          });
        };
        const handleQueryChange = async (val) => {
          if (states.previousQuery === val || states.isOnComposition)
            return;
          if (states.previousQuery === null && (isFunction$2(props2.filterMethod) || isFunction$2(props2.remoteMethod))) {
            states.previousQuery = val;
            return;
          }
          states.previousQuery = val;
          nextTick(() => {
            var _a2, _b;
            if (states.visible)
              (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          });
          states.hoverIndex = -1;
          if (props2.multiple && props2.filterable) {
            nextTick(() => {
              const length = input.value.value.length * 15 + 20;
              states.inputLength = props2.collapseTags ? Math.min(50, length) : length;
              managePlaceholder();
              resetInputHeight();
            });
          }
          if (props2.remote && isFunction$2(props2.remoteMethod)) {
            states.hoverIndex = -1;
            props2.remoteMethod(val);
          } else if (isFunction$2(props2.filterMethod)) {
            props2.filterMethod(val);
            triggerRef(groupQueryChange);
          } else {
            states.filteredOptionsCount = states.optionsCount;
            queryChange.value.query = val;
            triggerRef(queryChange);
            triggerRef(groupQueryChange);
          }
          if (props2.defaultFirstOption && (props2.filterable || props2.remote) && states.filteredOptionsCount) {
            await nextTick();
            checkDefaultFirstOption();
          }
        };
        const managePlaceholder = () => {
          if (states.currentPlaceholder !== "") {
            states.currentPlaceholder = input.value.value ? "" : states.cachedPlaceHolder;
          }
        };
        const checkDefaultFirstOption = () => {
          const optionsInDropdown = optionsArray.value.filter((n2) => n2.visible && !n2.disabled && !n2.states.groupDisabled);
          const userCreatedOption = optionsInDropdown.find((n2) => n2.created);
          const firstOriginOption = optionsInDropdown[0];
          states.hoverIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
        };
        const setSelected = () => {
          var _a2;
          if (!props2.multiple) {
            const option = getOption(props2.modelValue);
            if ((_a2 = option.props) == null ? void 0 : _a2.created) {
              states.createdLabel = option.props.value;
              states.createdSelected = true;
            } else {
              states.createdSelected = false;
            }
            states.selectedLabel = option.currentLabel;
            states.selected = option;
            if (props2.filterable)
              states.query = states.selectedLabel;
            return;
          } else {
            states.selectedLabel = "";
          }
          const result = [];
          if (Array.isArray(props2.modelValue)) {
            props2.modelValue.forEach((value) => {
              result.push(getOption(value));
            });
          }
          states.selected = result;
          nextTick(() => {
            resetInputHeight();
          });
        };
        const getOption = (value) => {
          let option;
          const isObjectValue = toRawType(value).toLowerCase() === "object";
          const isNull = toRawType(value).toLowerCase() === "null";
          const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
          for (let i2 = states.cachedOptions.size - 1; i2 >= 0; i2--) {
            const cachedOption = cachedOptionsArray.value[i2];
            const isEqualValue = isObjectValue ? get(cachedOption.value, props2.valueKey) === get(value, props2.valueKey) : cachedOption.value === value;
            if (isEqualValue) {
              option = {
                value,
                currentLabel: cachedOption.currentLabel,
                isDisabled: cachedOption.isDisabled
              };
              break;
            }
          }
          if (option)
            return option;
          const label = isObjectValue ? value.label : !isNull && !isUndefined2 ? value : "";
          const newOption = {
            value,
            currentLabel: label
          };
          if (props2.multiple) {
            newOption.hitState = false;
          }
          return newOption;
        };
        const resetHoverIndex = () => {
          setTimeout(() => {
            const valueKey = props2.valueKey;
            if (!props2.multiple) {
              states.hoverIndex = optionsArray.value.findIndex((item) => {
                return getValueKey(item) === getValueKey(states.selected);
              });
            } else {
              if (states.selected.length > 0) {
                states.hoverIndex = Math.min.apply(null, states.selected.map((selected) => {
                  return optionsArray.value.findIndex((item) => {
                    return get(item, valueKey) === get(selected, valueKey);
                  });
                }));
              } else {
                states.hoverIndex = -1;
              }
            }
          }, 300);
        };
        const handleResize = () => {
          var _a2, _b;
          resetInputWidth();
          (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          props2.multiple && resetInputHeight();
        };
        const resetInputWidth = () => {
          var _a2;
          states.inputWidth = (_a2 = reference.value) == null ? void 0 : _a2.$el.offsetWidth;
        };
        const onInputChange = () => {
          if (props2.filterable && states.query !== states.selectedLabel) {
            states.query = states.selectedLabel;
            handleQueryChange(states.query);
          }
        };
        const debouncedOnInputChange = debounce(() => {
          onInputChange();
        }, debounce$1.value);
        const debouncedQueryChange = debounce((e2) => {
          handleQueryChange(e2.target.value);
        }, debounce$1.value);
        const emitChange = (val) => {
          if (!isEqual$1(props2.modelValue, val)) {
            ctx.emit(CHANGE_EVENT, val);
          }
        };
        const deletePrevTag = (e2) => {
          if (e2.code === EVENT_CODE.delete)
            return;
          if (e2.target.value.length <= 0 && !toggleLastOptionHitState()) {
            const value = props2.modelValue.slice();
            value.pop();
            ctx.emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
          }
          if (e2.target.value.length === 1 && props2.modelValue.length === 0) {
            states.currentPlaceholder = states.cachedPlaceHolder;
          }
        };
        const deleteTag = (event, tag) => {
          const index = states.selected.indexOf(tag);
          if (index > -1 && !selectDisabled.value) {
            const value = props2.modelValue.slice();
            value.splice(index, 1);
            ctx.emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            ctx.emit("remove-tag", tag.value);
          }
          event.stopPropagation();
        };
        const deleteSelected = (event) => {
          event.stopPropagation();
          const value = props2.multiple ? [] : "";
          if (!isString$2(value)) {
            for (const item of states.selected) {
              if (item.isDisabled)
                value.push(item.value);
            }
          }
          ctx.emit(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          states.hoverIndex = -1;
          states.visible = false;
          ctx.emit("clear");
        };
        const handleOptionSelect = (option) => {
          var _a2;
          if (props2.multiple) {
            const value = (props2.modelValue || []).slice();
            const optionIndex = getValueIndex(value, option.value);
            if (optionIndex > -1) {
              value.splice(optionIndex, 1);
            } else if (props2.multipleLimit <= 0 || value.length < props2.multipleLimit) {
              value.push(option.value);
            }
            ctx.emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            if (option.created) {
              states.query = "";
              handleQueryChange("");
              states.inputLength = 20;
            }
            if (props2.filterable)
              (_a2 = input.value) == null ? void 0 : _a2.focus();
          } else {
            ctx.emit(UPDATE_MODEL_EVENT, option.value);
            emitChange(option.value);
            states.visible = false;
          }
          setSoftFocus();
          if (states.visible)
            return;
          nextTick(() => {
            scrollToOption(option);
          });
        };
        const getValueIndex = (arr = [], value) => {
          if (!isObject$1(value))
            return arr.indexOf(value);
          const valueKey = props2.valueKey;
          let index = -1;
          arr.some((item, i2) => {
            if (toRaw(get(item, valueKey)) === get(value, valueKey)) {
              index = i2;
              return true;
            }
            return false;
          });
          return index;
        };
        const setSoftFocus = () => {
          const _input = input.value || reference.value;
          if (_input) {
            _input == null ? void 0 : _input.focus();
          }
        };
        const scrollToOption = (option) => {
          var _a2, _b, _c, _d, _e;
          const targetOption = Array.isArray(option) ? option[0] : option;
          let target = null;
          if (targetOption == null ? void 0 : targetOption.value) {
            const options = optionsArray.value.filter((item) => item.value === targetOption.value);
            if (options.length > 0) {
              target = options[0].$el;
            }
          }
          if (tooltipRef.value && target) {
            const menu = (_d = (_c = (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${ns.be("dropdown", "wrap")}`);
            if (menu) {
              scrollIntoView(menu, target);
            }
          }
          (_e = scrollbar.value) == null ? void 0 : _e.handleScroll();
        };
        const onOptionCreate = (vm) => {
          states.optionsCount++;
          states.filteredOptionsCount++;
          states.options.set(vm.value, vm);
          states.cachedOptions.set(vm.value, vm);
        };
        const onOptionDestroy = (key, vm) => {
          if (states.options.get(key) === vm) {
            states.optionsCount--;
            states.filteredOptionsCount--;
            states.options.delete(key);
          }
        };
        const resetInputState = (e2) => {
          if (e2.code !== EVENT_CODE.backspace)
            toggleLastOptionHitState(false);
          states.inputLength = input.value.value.length * 15 + 20;
          resetInputHeight();
        };
        const toggleLastOptionHitState = (hit) => {
          if (!Array.isArray(states.selected))
            return;
          const option = states.selected[states.selected.length - 1];
          if (!option)
            return;
          if (hit === true || hit === false) {
            option.hitState = hit;
            return hit;
          }
          option.hitState = !option.hitState;
          return option.hitState;
        };
        const handleComposition = (event) => {
          const text = event.target.value;
          if (event.type === "compositionend") {
            states.isOnComposition = false;
            nextTick(() => handleQueryChange(text));
          } else {
            const lastCharacter = text[text.length - 1] || "";
            states.isOnComposition = !isKorean(lastCharacter);
          }
        };
        const handleMenuEnter = () => {
          nextTick(() => scrollToOption(states.selected));
        };
        const handleFocus = (event) => {
          if (!ignoreFocusEvent) {
            if (props2.automaticDropdown || props2.filterable) {
              if (props2.filterable && !states.visible) {
                states.menuVisibleOnFocus = true;
              }
              states.visible = true;
            }
            ctx.emit("focus", event);
          } else {
            ignoreFocusEvent = false;
          }
        };
        const blur = () => {
          var _a2, _b, _c;
          states.visible = false;
          (_a2 = reference.value) == null ? void 0 : _a2.blur();
          (_c = (_b = iOSInput.value) == null ? void 0 : _b.blur) == null ? void 0 : _c.call(_b);
        };
        const handleBlur = (event) => {
          setTimeout(() => {
            var _a2;
            if ((_a2 = tooltipRef.value) == null ? void 0 : _a2.isFocusInsideContent()) {
              ignoreFocusEvent = true;
              return;
            }
            states.visible && handleClose();
            ctx.emit("blur", event);
          });
        };
        const handleClearClick = (event) => {
          deleteSelected(event);
        };
        const handleClose = () => {
          states.visible = false;
        };
        const handleKeydownEscape = (event) => {
          if (states.visible) {
            event.preventDefault();
            event.stopPropagation();
            states.visible = false;
          }
        };
        const toggleMenu = (e2) => {
          var _a2;
          if (e2 && !states.mouseEnter) {
            return;
          }
          if (!selectDisabled.value) {
            if (states.menuVisibleOnFocus) {
              states.menuVisibleOnFocus = false;
            } else {
              if (!tooltipRef.value || !tooltipRef.value.isFocusInsideContent()) {
                states.visible = !states.visible;
              }
            }
            if (states.visible) {
              (_a2 = input.value || reference.value) == null ? void 0 : _a2.focus();
            }
          }
        };
        const selectOption = () => {
          if (!states.visible) {
            toggleMenu();
          } else {
            if (optionsArray.value[states.hoverIndex]) {
              handleOptionSelect(optionsArray.value[states.hoverIndex]);
            }
          }
        };
        const getValueKey = (item) => {
          return isObject$1(item.value) ? get(item.value, props2.valueKey) : item.value;
        };
        const optionsAllDisabled = computed(() => optionsArray.value.filter((option) => option.visible).every((option) => option.disabled));
        const showTagList = computed(() => states.selected.slice(0, props2.maxCollapseTags));
        const collapseTagList = computed(() => states.selected.slice(props2.maxCollapseTags));
        const navigateOptions = (direction2) => {
          if (!states.visible) {
            states.visible = true;
            return;
          }
          if (states.options.size === 0 || states.filteredOptionsCount === 0)
            return;
          if (states.isOnComposition)
            return;
          if (!optionsAllDisabled.value) {
            if (direction2 === "next") {
              states.hoverIndex++;
              if (states.hoverIndex === states.options.size) {
                states.hoverIndex = 0;
              }
            } else if (direction2 === "prev") {
              states.hoverIndex--;
              if (states.hoverIndex < 0) {
                states.hoverIndex = states.options.size - 1;
              }
            }
            const option = optionsArray.value[states.hoverIndex];
            if (option.disabled === true || option.states.groupDisabled === true || !option.visible) {
              navigateOptions(direction2);
            }
            nextTick(() => scrollToOption(hoverOption.value));
          }
        };
        const handleMouseEnter = () => {
          states.mouseEnter = true;
        };
        const handleMouseLeave = () => {
          states.mouseEnter = false;
        };
        const handleDeleteTooltipTag = (event, tag) => {
          var _a2, _b;
          deleteTag(event, tag);
          (_b = (_a2 = tagTooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        };
        return {
          optionList,
          optionsArray,
          selectSize,
          handleResize,
          debouncedOnInputChange,
          debouncedQueryChange,
          deletePrevTag,
          deleteTag,
          deleteSelected,
          handleOptionSelect,
          scrollToOption,
          readonly: readonly2,
          resetInputHeight,
          showClose,
          iconComponent,
          iconReverse,
          showNewOption,
          collapseTagSize,
          setSelected,
          managePlaceholder,
          selectDisabled,
          emptyText,
          toggleLastOptionHitState,
          resetInputState,
          handleComposition,
          onOptionCreate,
          onOptionDestroy,
          handleMenuEnter,
          handleFocus,
          blur,
          handleBlur,
          handleClearClick,
          handleClose,
          handleKeydownEscape,
          toggleMenu,
          selectOption,
          getValueKey,
          navigateOptions,
          handleDeleteTooltipTag,
          dropMenuVisible,
          queryChange,
          groupQueryChange,
          showTagList,
          collapseTagList,
          reference,
          input,
          iOSInput,
          tooltipRef,
          tagTooltipRef,
          tags,
          selectWrapper,
          scrollbar,
          handleMouseEnter,
          handleMouseLeave
        };
      };
      var ElOptions = defineComponent({
        name: "ElOptions",
        emits: ["update-options"],
        setup(_2, { slots, emit: emit2 }) {
          let cachedOptions = [];
          function isSameOptions(a2, b2) {
            if (a2.length !== b2.length)
              return false;
            for (const [index] of a2.entries()) {
              if (a2[index] != b2[index]) {
                return false;
              }
            }
            return true;
          }
          return () => {
            var _a2, _b;
            const children = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
            const filteredOptions = [];
            function filterOptions(children2) {
              if (!Array.isArray(children2))
                return;
              children2.forEach((item) => {
                var _a22, _b2, _c, _d;
                const name = (_a22 = (item == null ? void 0 : item.type) || {}) == null ? void 0 : _a22.name;
                if (name === "ElOptionGroup") {
                  filterOptions(!isString$2(item.children) && !Array.isArray(item.children) && isFunction$2((_b2 = item.children) == null ? void 0 : _b2.default) ? (_c = item.children) == null ? void 0 : _c.default() : item.children);
                } else if (name === "ElOption") {
                  filteredOptions.push((_d = item.props) == null ? void 0 : _d.label);
                } else if (Array.isArray(item.children)) {
                  filterOptions(item.children);
                }
              });
            }
            if (children.length) {
              filterOptions((_b = children[0]) == null ? void 0 : _b.children);
            }
            if (!isSameOptions(filteredOptions, cachedOptions)) {
              cachedOptions = filteredOptions;
              emit2("update-options", filteredOptions);
            }
            return children;
          };
        }
      });
      const COMPONENT_NAME$3 = "ElSelect";
      const _sfc_main$o = defineComponent({
        name: COMPONENT_NAME$3,
        componentName: COMPONENT_NAME$3,
        components: {
          ElInput,
          ElSelectMenu: ElSelectMenu$1,
          ElOption: Option,
          ElOptions,
          ElTag,
          ElScrollbar,
          ElTooltip,
          ElIcon
        },
        directives: { ClickOutside },
        props: {
          name: String,
          id: String,
          modelValue: {
            type: [Array, String, Number, Boolean, Object],
            default: void 0
          },
          autocomplete: {
            type: String,
            default: "off"
          },
          automaticDropdown: Boolean,
          size: {
            type: String,
            validator: isValidComponentSize
          },
          effect: {
            type: String,
            default: "light"
          },
          disabled: Boolean,
          clearable: Boolean,
          filterable: Boolean,
          allowCreate: Boolean,
          loading: Boolean,
          popperClass: {
            type: String,
            default: ""
          },
          popperOptions: {
            type: Object,
            default: () => ({})
          },
          remote: Boolean,
          loadingText: String,
          noMatchText: String,
          noDataText: String,
          remoteMethod: Function,
          filterMethod: Function,
          multiple: Boolean,
          multipleLimit: {
            type: Number,
            default: 0
          },
          placeholder: {
            type: String
          },
          defaultFirstOption: Boolean,
          reserveKeyword: {
            type: Boolean,
            default: true
          },
          valueKey: {
            type: String,
            default: "value"
          },
          collapseTags: Boolean,
          collapseTagsTooltip: {
            type: Boolean,
            default: false
          },
          maxCollapseTags: {
            type: Number,
            default: 1
          },
          teleported: useTooltipContentProps.teleported,
          persistent: {
            type: Boolean,
            default: true
          },
          clearIcon: {
            type: iconPropType,
            default: circle_close_default
          },
          fitInputWidth: {
            type: Boolean,
            default: false
          },
          suffixIcon: {
            type: iconPropType,
            default: arrow_down_default
          },
          tagType: { ...tagProps.type, default: "info" },
          validateEvent: {
            type: Boolean,
            default: true
          },
          remoteShowSuffix: {
            type: Boolean,
            default: false
          },
          suffixTransition: {
            type: Boolean,
            default: true
          },
          placement: {
            type: String,
            values: Ee,
            default: "bottom-start"
          }
        },
        emits: [
          UPDATE_MODEL_EVENT,
          CHANGE_EVENT,
          "remove-tag",
          "clear",
          "visible-change",
          "focus",
          "blur"
        ],
        setup(props2, ctx) {
          const nsSelect = useNamespace("select");
          const nsInput = useNamespace("input");
          const { t: t2 } = useLocale();
          const states = useSelectStates(props2);
          const {
            optionList,
            optionsArray,
            selectSize,
            readonly: readonly2,
            handleResize,
            collapseTagSize,
            debouncedOnInputChange,
            debouncedQueryChange,
            deletePrevTag,
            deleteTag,
            deleteSelected,
            handleOptionSelect,
            scrollToOption,
            setSelected,
            resetInputHeight,
            managePlaceholder,
            showClose,
            selectDisabled,
            iconComponent,
            iconReverse,
            showNewOption,
            emptyText,
            toggleLastOptionHitState,
            resetInputState,
            handleComposition,
            onOptionCreate,
            onOptionDestroy,
            handleMenuEnter,
            handleFocus,
            blur,
            handleBlur,
            handleClearClick,
            handleClose,
            handleKeydownEscape,
            toggleMenu,
            selectOption,
            getValueKey,
            navigateOptions,
            handleDeleteTooltipTag,
            dropMenuVisible,
            reference,
            input,
            iOSInput,
            tooltipRef,
            tagTooltipRef,
            tags,
            selectWrapper,
            scrollbar,
            queryChange,
            groupQueryChange,
            handleMouseEnter,
            handleMouseLeave,
            showTagList,
            collapseTagList
          } = useSelect$1(props2, states, ctx);
          const { focus } = useFocus(reference);
          const {
            inputWidth,
            selected,
            inputLength,
            filteredOptionsCount,
            visible,
            selectedLabel,
            hoverIndex,
            query,
            inputHovering,
            currentPlaceholder,
            menuVisibleOnFocus,
            isOnComposition,
            options,
            cachedOptions,
            optionsCount,
            prefixWidth
          } = toRefs$1(states);
          const wrapperKls = computed(() => {
            const classList = [nsSelect.b()];
            const _selectSize = unref(selectSize);
            if (_selectSize) {
              classList.push(nsSelect.m(_selectSize));
            }
            if (props2.disabled) {
              classList.push(nsSelect.m("disabled"));
            }
            return classList;
          });
          const tagsKls = computed(() => [
            nsSelect.e("tags"),
            nsSelect.is("disabled", unref(selectDisabled))
          ]);
          const tagWrapperKls = computed(() => [
            nsSelect.b("tags-wrapper"),
            { "has-prefix": unref(prefixWidth) && unref(selected).length }
          ]);
          const inputKls = computed(() => [
            nsSelect.e("input"),
            nsSelect.is(unref(selectSize)),
            nsSelect.is("disabled", unref(selectDisabled))
          ]);
          const iOSInputKls = computed(() => [
            nsSelect.e("input"),
            nsSelect.is(unref(selectSize)),
            nsSelect.em("input", "iOS")
          ]);
          const scrollbarKls = computed(() => [
            nsSelect.is("empty", !props2.allowCreate && Boolean(unref(query)) && unref(filteredOptionsCount) === 0)
          ]);
          const selectTagsStyle = computed(() => ({
            maxWidth: `${unref(inputWidth) - 32}px`,
            width: "100%"
          }));
          const tagTextStyle = computed(() => {
            const maxWidth = unref(inputWidth) > 123 ? unref(inputWidth) - 123 : unref(inputWidth) - 75;
            return { maxWidth: `${maxWidth}px` };
          });
          const inputStyle = computed(() => ({
            marginLeft: `${unref(prefixWidth)}px`,
            flexGrow: 1,
            width: `${unref(inputLength) / (unref(inputWidth) - 32)}%`,
            maxWidth: `${unref(inputWidth) - 42}px`
          }));
          provide(selectKey, reactive({
            props: props2,
            options,
            optionsArray,
            cachedOptions,
            optionsCount,
            filteredOptionsCount,
            hoverIndex,
            handleOptionSelect,
            onOptionCreate,
            onOptionDestroy,
            selectWrapper,
            selected,
            setSelected,
            queryChange,
            groupQueryChange
          }));
          onMounted(() => {
            states.cachedPlaceHolder = currentPlaceholder.value = props2.placeholder || (() => t2("el.select.placeholder"));
            if (props2.multiple && Array.isArray(props2.modelValue) && props2.modelValue.length > 0) {
              currentPlaceholder.value = "";
            }
            useResizeObserver(selectWrapper, handleResize);
            if (props2.remote && props2.multiple) {
              resetInputHeight();
            }
            nextTick(() => {
              const refEl = reference.value && reference.value.$el;
              if (!refEl)
                return;
              inputWidth.value = refEl.getBoundingClientRect().width;
              if (ctx.slots.prefix) {
                const prefix = refEl.querySelector(`.${nsInput.e("prefix")}`);
                prefixWidth.value = Math.max(prefix.getBoundingClientRect().width + 11, 30);
              }
            });
            setSelected();
          });
          if (props2.multiple && !Array.isArray(props2.modelValue)) {
            ctx.emit(UPDATE_MODEL_EVENT, []);
          }
          if (!props2.multiple && Array.isArray(props2.modelValue)) {
            ctx.emit(UPDATE_MODEL_EVENT, "");
          }
          const popperPaneRef = computed(() => {
            var _a2, _b;
            return (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
          });
          const onOptionsRendered = (v2) => {
            optionList.value = v2;
          };
          return {
            isIOS,
            onOptionsRendered,
            prefixWidth,
            selectSize,
            readonly: readonly2,
            handleResize,
            collapseTagSize,
            debouncedOnInputChange,
            debouncedQueryChange,
            deletePrevTag,
            deleteTag,
            handleDeleteTooltipTag,
            deleteSelected,
            handleOptionSelect,
            scrollToOption,
            inputWidth,
            selected,
            inputLength,
            filteredOptionsCount,
            visible,
            selectedLabel,
            hoverIndex,
            query,
            inputHovering,
            currentPlaceholder,
            menuVisibleOnFocus,
            isOnComposition,
            options,
            resetInputHeight,
            managePlaceholder,
            showClose,
            selectDisabled,
            iconComponent,
            iconReverse,
            showNewOption,
            emptyText,
            toggleLastOptionHitState,
            resetInputState,
            handleComposition,
            handleMenuEnter,
            handleFocus,
            blur,
            handleBlur,
            handleClearClick,
            handleClose,
            handleKeydownEscape,
            toggleMenu,
            selectOption,
            getValueKey,
            navigateOptions,
            dropMenuVisible,
            focus,
            reference,
            input,
            iOSInput,
            tooltipRef,
            popperPaneRef,
            tags,
            selectWrapper,
            scrollbar,
            wrapperKls,
            tagsKls,
            tagWrapperKls,
            inputKls,
            iOSInputKls,
            scrollbarKls,
            selectTagsStyle,
            nsSelect,
            tagTextStyle,
            inputStyle,
            handleMouseEnter,
            handleMouseLeave,
            showTagList,
            collapseTagList,
            tagTooltipRef
          };
        }
      });
      const _hoisted_1$C = ["disabled", "autocomplete"];
      const _hoisted_2$w = ["disabled"];
      const _hoisted_3$s = { style: { "height": "100%", "display": "flex", "justify-content": "center", "align-items": "center" } };
      function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_tag = resolveComponent("el-tag");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_input = resolveComponent("el-input");
        const _component_el_option = resolveComponent("el-option");
        const _component_el_options = resolveComponent("el-options");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_el_select_menu = resolveComponent("el-select-menu");
        const _directive_click_outside = resolveDirective("click-outside");
        return withDirectives((openBlock(), createElementBlock("div", {
          ref: "selectWrapper",
          class: normalizeClass(_ctx.wrapperKls),
          onMouseenter: _cache[21] || (_cache[21] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
          onMouseleave: _cache[22] || (_cache[22] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
          onClick: _cache[23] || (_cache[23] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
        }, [
          createVNode(_component_el_tooltip, {
            ref: "tooltipRef",
            visible: _ctx.dropMenuVisible,
            placement: _ctx.placement,
            teleported: _ctx.teleported,
            "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
            "popper-options": _ctx.popperOptions,
            "fallback-placements": ["bottom-start", "top-start", "right", "left"],
            effect: _ctx.effect,
            pure: "",
            trigger: "click",
            transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
            "stop-popper-mouse-event": false,
            "gpu-acceleration": false,
            persistent: _ctx.persistent,
            onShow: _ctx.handleMenuEnter
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                class: "select-trigger",
                onMouseenter: _cache[19] || (_cache[19] = ($event) => _ctx.inputHovering = true),
                onMouseleave: _cache[20] || (_cache[20] = ($event) => _ctx.inputHovering = false)
              }, [
                _ctx.multiple ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref: "tags",
                  class: normalizeClass(_ctx.tagsKls),
                  style: normalizeStyle(_ctx.selectTagsStyle)
                }, [
                  _ctx.collapseTags && _ctx.selected.length ? (openBlock(), createBlock(Transition, {
                    key: 0,
                    onAfterLeave: _ctx.resetInputHeight
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("span", {
                        class: normalizeClass(_ctx.tagWrapperKls)
                      }, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showTagList, (item) => {
                          return openBlock(), createBlock(_component_el_tag, {
                            key: _ctx.getValueKey(item),
                            closable: !_ctx.selectDisabled && !item.isDisabled,
                            size: _ctx.collapseTagSize,
                            hit: item.hitState,
                            type: _ctx.tagType,
                            "disable-transitions": "",
                            onClose: ($event) => _ctx.deleteTag($event, item)
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", {
                                class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                                style: normalizeStyle(_ctx.tagTextStyle)
                              }, toDisplayString(item.currentLabel), 7)
                            ]),
                            _: 2
                          }, 1032, ["closable", "size", "hit", "type", "onClose"]);
                        }), 128)),
                        _ctx.selected.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tag, {
                          key: 0,
                          closable: false,
                          size: _ctx.collapseTagSize,
                          type: _ctx.tagType,
                          "disable-transitions": ""
                        }, {
                          default: withCtx(() => [
                            _ctx.collapseTagsTooltip ? (openBlock(), createBlock(_component_el_tooltip, {
                              key: 0,
                              ref: "tagTooltipRef",
                              disabled: _ctx.dropMenuVisible,
                              "fallback-placements": ["bottom", "top", "right", "left"],
                              effect: _ctx.effect,
                              placement: "bottom",
                              teleported: _ctx.teleported
                            }, {
                              default: withCtx(() => [
                                createBaseVNode("span", {
                                  class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                }, "+ " + toDisplayString(_ctx.selected.length - _ctx.maxCollapseTags), 3)
                              ]),
                              content: withCtx(() => [
                                createBaseVNode("div", {
                                  class: normalizeClass(_ctx.nsSelect.e("collapse-tags"))
                                }, [
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapseTagList, (item) => {
                                    return openBlock(), createElementBlock("div", {
                                      key: _ctx.getValueKey(item),
                                      class: normalizeClass(_ctx.nsSelect.e("collapse-tag"))
                                    }, [
                                      createVNode(_component_el_tag, {
                                        class: "in-tooltip",
                                        closable: !_ctx.selectDisabled && !item.isDisabled,
                                        size: _ctx.collapseTagSize,
                                        hit: item.hitState,
                                        type: _ctx.tagType,
                                        "disable-transitions": "",
                                        style: { margin: "2px" },
                                        onClose: ($event) => _ctx.handleDeleteTooltipTag($event, item)
                                      }, {
                                        default: withCtx(() => [
                                          createBaseVNode("span", {
                                            class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                                            style: normalizeStyle({
                                              maxWidth: _ctx.inputWidth - 75 + "px"
                                            })
                                          }, toDisplayString(item.currentLabel), 7)
                                        ]),
                                        _: 2
                                      }, 1032, ["closable", "size", "hit", "type", "onClose"])
                                    ], 2);
                                  }), 128))
                                ], 2)
                              ]),
                              _: 1
                            }, 8, ["disabled", "effect", "teleported"])) : (openBlock(), createElementBlock("span", {
                              key: 1,
                              class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                            }, "+ " + toDisplayString(_ctx.selected.length - _ctx.maxCollapseTags), 3))
                          ]),
                          _: 1
                        }, 8, ["size", "type"])) : createCommentVNode("v-if", true)
                      ], 2)
                    ]),
                    _: 1
                  }, 8, ["onAfterLeave"])) : createCommentVNode("v-if", true),
                  !_ctx.collapseTags ? (openBlock(), createBlock(Transition, {
                    key: 1,
                    onAfterLeave: _ctx.resetInputHeight
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("span", {
                        class: normalizeClass(_ctx.tagWrapperKls),
                        style: normalizeStyle(_ctx.prefixWidth && _ctx.selected.length ? { marginLeft: `${_ctx.prefixWidth}px` } : "")
                      }, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.selected, (item) => {
                          return openBlock(), createBlock(_component_el_tag, {
                            key: _ctx.getValueKey(item),
                            closable: !_ctx.selectDisabled && !item.isDisabled,
                            size: _ctx.collapseTagSize,
                            hit: item.hitState,
                            type: _ctx.tagType,
                            "disable-transitions": "",
                            onClose: ($event) => _ctx.deleteTag($event, item)
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", {
                                class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                                style: normalizeStyle({ maxWidth: _ctx.inputWidth - 75 + "px" })
                              }, toDisplayString(item.currentLabel), 7)
                            ]),
                            _: 2
                          }, 1032, ["closable", "size", "hit", "type", "onClose"]);
                        }), 128))
                      ], 6)
                    ]),
                    _: 1
                  }, 8, ["onAfterLeave"])) : createCommentVNode("v-if", true),
                  _ctx.filterable && !_ctx.selectDisabled ? withDirectives((openBlock(), createElementBlock("input", {
                    key: 2,
                    ref: "input",
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.query = $event),
                    type: "text",
                    class: normalizeClass(_ctx.inputKls),
                    disabled: _ctx.selectDisabled,
                    autocomplete: _ctx.autocomplete,
                    style: normalizeStyle(_ctx.inputStyle),
                    onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                    onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                    onKeyup: _cache[3] || (_cache[3] = (...args) => _ctx.managePlaceholder && _ctx.managePlaceholder(...args)),
                    onKeydown: [
                      _cache[4] || (_cache[4] = (...args) => _ctx.resetInputState && _ctx.resetInputState(...args)),
                      _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["prevent"]), ["down"])),
                      _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["prevent"]), ["up"])),
                      _cache[7] || (_cache[7] = withKeys((...args) => _ctx.handleKeydownEscape && _ctx.handleKeydownEscape(...args), ["esc"])),
                      _cache[8] || (_cache[8] = withKeys(withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                      _cache[9] || (_cache[9] = withKeys((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["delete"])),
                      _cache[10] || (_cache[10] = withKeys(($event) => _ctx.visible = false, ["tab"]))
                    ],
                    onCompositionstart: _cache[11] || (_cache[11] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                    onCompositionupdate: _cache[12] || (_cache[12] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                    onCompositionend: _cache[13] || (_cache[13] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                    onInput: _cache[14] || (_cache[14] = (...args) => _ctx.debouncedQueryChange && _ctx.debouncedQueryChange(...args))
                  }, null, 46, _hoisted_1$C)), [
                    [vModelText, _ctx.query]
                  ]) : createCommentVNode("v-if", true)
                ], 6)) : createCommentVNode("v-if", true),
                createCommentVNode(" fix: https://github.com/element-plus/element-plus/issues/11415 "),
                _ctx.isIOS && !_ctx.multiple && _ctx.filterable && _ctx.readonly ? (openBlock(), createElementBlock("input", {
                  key: 1,
                  ref: "iOSInput",
                  class: normalizeClass(_ctx.iOSInputKls),
                  disabled: _ctx.selectDisabled,
                  type: "text"
                }, null, 10, _hoisted_2$w)) : createCommentVNode("v-if", true),
                createVNode(_component_el_input, {
                  id: _ctx.id,
                  ref: "reference",
                  modelValue: _ctx.selectedLabel,
                  "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => _ctx.selectedLabel = $event),
                  type: "text",
                  placeholder: typeof _ctx.currentPlaceholder === "function" ? _ctx.currentPlaceholder() : _ctx.currentPlaceholder,
                  name: _ctx.name,
                  autocomplete: _ctx.autocomplete,
                  size: _ctx.selectSize,
                  disabled: _ctx.selectDisabled,
                  readonly: _ctx.readonly,
                  "validate-event": false,
                  class: normalizeClass([_ctx.nsSelect.is("focus", _ctx.visible)]),
                  tabindex: _ctx.multiple && _ctx.filterable ? -1 : void 0,
                  onFocus: _ctx.handleFocus,
                  onBlur: _ctx.handleBlur,
                  onInput: _ctx.debouncedOnInputChange,
                  onPaste: _ctx.debouncedOnInputChange,
                  onCompositionstart: _ctx.handleComposition,
                  onCompositionupdate: _ctx.handleComposition,
                  onCompositionend: _ctx.handleComposition,
                  onKeydown: [
                    _cache[16] || (_cache[16] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                    _cache[17] || (_cache[17] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                    withKeys(withModifiers(_ctx.selectOption, ["stop", "prevent"]), ["enter"]),
                    withKeys(_ctx.handleKeydownEscape, ["esc"]),
                    _cache[18] || (_cache[18] = withKeys(($event) => _ctx.visible = false, ["tab"]))
                  ]
                }, createSlots({
                  suffix: withCtx(() => [
                    _ctx.iconComponent && !_ctx.showClose ? (openBlock(), createBlock(_component_el_icon, {
                      key: 0,
                      class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true),
                    _ctx.showClose && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                      key: 1,
                      class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
                      onClick: _ctx.handleClearClick
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 2
                }, [
                  _ctx.$slots.prefix ? {
                    name: "prefix",
                    fn: withCtx(() => [
                      createBaseVNode("div", _hoisted_3$s, [
                        renderSlot(_ctx.$slots, "prefix")
                      ])
                    ])
                  } : void 0
                ]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])
              ], 32)
            ]),
            content: withCtx(() => [
              createVNode(_component_el_select_menu, null, {
                default: withCtx(() => [
                  withDirectives(createVNode(_component_el_scrollbar, {
                    ref: "scrollbar",
                    tag: "ul",
                    "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
                    "view-class": _ctx.nsSelect.be("dropdown", "list"),
                    class: normalizeClass(_ctx.scrollbarKls)
                  }, {
                    default: withCtx(() => [
                      _ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
                        key: 0,
                        value: _ctx.query,
                        created: true
                      }, null, 8, ["value"])) : createCommentVNode("v-if", true),
                      createVNode(_component_el_options, { onUpdateOptions: _ctx.onOptionsRendered }, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "default")
                        ]),
                        _: 3
                      }, 8, ["onUpdateOptions"])
                    ]),
                    _: 3
                  }, 8, ["wrap-class", "view-class", "class"]), [
                    [vShow, _ctx.options.size > 0 && !_ctx.loading]
                  ]),
                  _ctx.emptyText && (!_ctx.allowCreate || _ctx.loading || _ctx.allowCreate && _ctx.options.size === 0) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    _ctx.$slots.empty ? renderSlot(_ctx.$slots, "empty", { key: 0 }) : (openBlock(), createElementBlock("p", {
                      key: 1,
                      class: normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                    }, toDisplayString(_ctx.emptyText), 3))
                  ], 64)) : createCommentVNode("v-if", true)
                ]),
                _: 3
              })
            ]),
            _: 3
          }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onShow"])
        ], 34)), [
          [_directive_click_outside, _ctx.handleClose, _ctx.popperPaneRef]
        ]);
      }
      var Select$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["render", _sfc_render$5], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);
      const _sfc_main$n = defineComponent({
        name: "ElOptionGroup",
        componentName: "ElOptionGroup",
        props: {
          label: String,
          disabled: {
            type: Boolean,
            default: false
          }
        },
        setup(props2) {
          const ns = useNamespace("select");
          const visible = ref(true);
          const instance = getCurrentInstance();
          const children = ref([]);
          provide(selectGroupKey, reactive({
            ...toRefs$1(props2)
          }));
          const select = inject(selectKey);
          onMounted(() => {
            children.value = flattedChildren2(instance.subTree);
          });
          const flattedChildren2 = (node) => {
            const children2 = [];
            if (Array.isArray(node.children)) {
              node.children.forEach((child) => {
                var _a2;
                if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
                  children2.push(child.component.proxy);
                } else if ((_a2 = child.children) == null ? void 0 : _a2.length) {
                  children2.push(...flattedChildren2(child));
                }
              });
            }
            return children2;
          };
          const { groupQueryChange } = toRaw(select);
          watch(groupQueryChange, () => {
            visible.value = children.value.some((option) => option.visible === true);
          }, { flush: "post" });
          return {
            visible,
            ns
          };
        }
      });
      function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
        return withDirectives((openBlock(), createElementBlock("ul", {
          class: normalizeClass(_ctx.ns.be("group", "wrap"))
        }, [
          createBaseVNode("li", {
            class: normalizeClass(_ctx.ns.be("group", "title"))
          }, toDisplayString(_ctx.label), 3),
          createBaseVNode("li", null, [
            createBaseVNode("ul", {
              class: normalizeClass(_ctx.ns.b("group"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)
          ])
        ], 2)), [
          [vShow, _ctx.visible]
        ]);
      }
      var OptionGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["render", _sfc_render$4], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);
      const ElSelect = withInstall(Select$1, {
        Option,
        OptionGroup
      });
      const ElOption = withNoopInstall(Option);
      withNoopInstall(OptionGroup);
      const progressProps = buildProps({
        type: {
          type: String,
          default: "line",
          values: ["line", "circle", "dashboard"]
        },
        percentage: {
          type: Number,
          default: 0,
          validator: (val) => val >= 0 && val <= 100
        },
        status: {
          type: String,
          default: "",
          values: ["", "success", "exception", "warning"]
        },
        indeterminate: {
          type: Boolean,
          default: false
        },
        duration: {
          type: Number,
          default: 3
        },
        strokeWidth: {
          type: Number,
          default: 6
        },
        strokeLinecap: {
          type: definePropType(String),
          default: "round"
        },
        textInside: {
          type: Boolean,
          default: false
        },
        width: {
          type: Number,
          default: 126
        },
        showText: {
          type: Boolean,
          default: true
        },
        color: {
          type: definePropType([
            String,
            Array,
            Function
          ]),
          default: ""
        },
        striped: Boolean,
        stripedFlow: Boolean,
        format: {
          type: definePropType(Function),
          default: (percentage) => `${percentage}%`
        }
      });
      const _hoisted_1$B = ["aria-valuenow"];
      const _hoisted_2$v = { viewBox: "0 0 100 100" };
      const _hoisted_3$r = ["d", "stroke", "stroke-linecap", "stroke-width"];
      const _hoisted_4$a = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"];
      const _hoisted_5$5 = { key: 0 };
      const __default__$9 = defineComponent({
        name: "ElProgress"
      });
      const _sfc_main$m = /* @__PURE__ */ defineComponent({
        ...__default__$9,
        props: progressProps,
        setup(__props) {
          const props2 = __props;
          const STATUS_COLOR_MAP = {
            success: "#13ce66",
            exception: "#ff4949",
            warning: "#e6a23c",
            default: "#20a0ff"
          };
          const ns = useNamespace("progress");
          const barStyle = computed(() => ({
            width: `${props2.percentage}%`,
            animationDuration: `${props2.duration}s`,
            backgroundColor: getCurrentColor(props2.percentage)
          }));
          const relativeStrokeWidth = computed(() => (props2.strokeWidth / props2.width * 100).toFixed(1));
          const radius = computed(() => {
            if (["circle", "dashboard"].includes(props2.type)) {
              return Number.parseInt(`${50 - Number.parseFloat(relativeStrokeWidth.value) / 2}`, 10);
            }
            return 0;
          });
          const trackPath = computed(() => {
            const r2 = radius.value;
            const isDashboard = props2.type === "dashboard";
            return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r2}
          a ${r2} ${r2} 0 1 1 0 ${isDashboard ? "-" : ""}${r2 * 2}
          a ${r2} ${r2} 0 1 1 0 ${isDashboard ? "" : "-"}${r2 * 2}
          `;
          });
          const perimeter = computed(() => 2 * Math.PI * radius.value);
          const rate = computed(() => props2.type === "dashboard" ? 0.75 : 1);
          const strokeDashoffset = computed(() => {
            const offset = -1 * perimeter.value * (1 - rate.value) / 2;
            return `${offset}px`;
          });
          const trailPathStyle = computed(() => ({
            strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
            strokeDashoffset: strokeDashoffset.value
          }));
          const circlePathStyle = computed(() => ({
            strokeDasharray: `${perimeter.value * rate.value * (props2.percentage / 100)}px, ${perimeter.value}px`,
            strokeDashoffset: strokeDashoffset.value,
            transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
          }));
          const stroke = computed(() => {
            let ret;
            if (props2.color) {
              ret = getCurrentColor(props2.percentage);
            } else {
              ret = STATUS_COLOR_MAP[props2.status] || STATUS_COLOR_MAP.default;
            }
            return ret;
          });
          const statusIcon = computed(() => {
            if (props2.status === "warning") {
              return warning_filled_default;
            }
            if (props2.type === "line") {
              return props2.status === "success" ? circle_check_default : circle_close_default;
            } else {
              return props2.status === "success" ? check_default : close_default;
            }
          });
          const progressTextSize = computed(() => {
            return props2.type === "line" ? 12 + props2.strokeWidth * 0.4 : props2.width * 0.111111 + 2;
          });
          const content = computed(() => props2.format(props2.percentage));
          function getColors(color) {
            const span = 100 / color.length;
            const seriesColors = color.map((seriesColor, index) => {
              if (isString$2(seriesColor)) {
                return {
                  color: seriesColor,
                  percentage: (index + 1) * span
                };
              }
              return seriesColor;
            });
            return seriesColors.sort((a2, b2) => a2.percentage - b2.percentage);
          }
          const getCurrentColor = (percentage) => {
            var _a2;
            const { color } = props2;
            if (isFunction$2(color)) {
              return color(percentage);
            } else if (isString$2(color)) {
              return color;
            } else {
              const colors = getColors(color);
              for (const color2 of colors) {
                if (color2.percentage > percentage)
                  return color2.color;
              }
              return (_a2 = colors[colors.length - 1]) == null ? void 0 : _a2.color;
            }
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).m(_ctx.type),
                unref(ns).is(_ctx.status),
                {
                  [unref(ns).m("without-text")]: !_ctx.showText,
                  [unref(ns).m("text-inside")]: _ctx.textInside
                }
              ]),
              role: "progressbar",
              "aria-valuenow": _ctx.percentage,
              "aria-valuemin": "0",
              "aria-valuemax": "100"
            }, [
              _ctx.type === "line" ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).b("bar"))
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).be("bar", "outer")),
                  style: normalizeStyle({ height: `${_ctx.strokeWidth}px` })
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass([
                      unref(ns).be("bar", "inner"),
                      { [unref(ns).bem("bar", "inner", "indeterminate")]: _ctx.indeterminate },
                      { [unref(ns).bem("bar", "inner", "striped")]: _ctx.striped },
                      { [unref(ns).bem("bar", "inner", "striped-flow")]: _ctx.stripedFlow }
                    ]),
                    style: normalizeStyle(unref(barStyle))
                  }, [
                    (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass(unref(ns).be("bar", "innerText"))
                    }, [
                      renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                        createBaseVNode("span", null, toDisplayString(unref(content)), 1)
                      ])
                    ], 2)) : createCommentVNode("v-if", true)
                  ], 6)
                ], 6)
              ], 2)) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).b("circle")),
                style: normalizeStyle({ height: `${_ctx.width}px`, width: `${_ctx.width}px` })
              }, [
                (openBlock(), createElementBlock("svg", _hoisted_2$v, [
                  createBaseVNode("path", {
                    class: normalizeClass(unref(ns).be("circle", "track")),
                    d: unref(trackPath),
                    stroke: `var(${unref(ns).cssVarName("fill-color-light")}, #e5e9f2)`,
                    "stroke-linecap": _ctx.strokeLinecap,
                    "stroke-width": unref(relativeStrokeWidth),
                    fill: "none",
                    style: normalizeStyle(unref(trailPathStyle))
                  }, null, 14, _hoisted_3$r),
                  createBaseVNode("path", {
                    class: normalizeClass(unref(ns).be("circle", "path")),
                    d: unref(trackPath),
                    stroke: unref(stroke),
                    fill: "none",
                    opacity: _ctx.percentage ? 1 : 0,
                    "stroke-linecap": _ctx.strokeLinecap,
                    "stroke-width": unref(relativeStrokeWidth),
                    style: normalizeStyle(unref(circlePathStyle))
                  }, null, 14, _hoisted_4$a)
                ]))
              ], 6)),
              (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? (openBlock(), createElementBlock("div", {
                key: 2,
                class: normalizeClass(unref(ns).e("text")),
                style: normalizeStyle({ fontSize: `${unref(progressTextSize)}px` })
              }, [
                renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                  !_ctx.status ? (openBlock(), createElementBlock("span", _hoisted_5$5, toDisplayString(unref(content)), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(statusIcon))))
                    ]),
                    _: 1
                  }))
                ])
              ], 6)) : createCommentVNode("v-if", true)
            ], 10, _hoisted_1$B);
          };
        }
      });
      var Progress = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]);
      const ElProgress = withInstall(Progress);
      var safeIsNaN = Number.isNaN || function ponyfill(value) {
        return typeof value === "number" && value !== value;
      };
      function isEqual(first, second) {
        if (first === second) {
          return true;
        }
        if (safeIsNaN(first) && safeIsNaN(second)) {
          return true;
        }
        return false;
      }
      function areInputsEqual(newInputs, lastInputs) {
        if (newInputs.length !== lastInputs.length) {
          return false;
        }
        for (var i2 = 0; i2 < newInputs.length; i2++) {
          if (!isEqual(newInputs[i2], lastInputs[i2])) {
            return false;
          }
        }
        return true;
      }
      function memoizeOne(resultFn, isEqual2) {
        if (isEqual2 === void 0) {
          isEqual2 = areInputsEqual;
        }
        var cache2 = null;
        function memoized() {
          var newArgs = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
          }
          if (cache2 && cache2.lastThis === this && isEqual2(newArgs, cache2.lastArgs)) {
            return cache2.lastResult;
          }
          var lastResult = resultFn.apply(this, newArgs);
          cache2 = {
            lastResult,
            lastArgs: newArgs,
            lastThis: this
          };
          return lastResult;
        }
        memoized.clear = function clear2() {
          cache2 = null;
        };
        return memoized;
      }
      const useCache = () => {
        const vm = getCurrentInstance();
        const props2 = vm.proxy.$props;
        return computed(() => {
          const _getItemStyleCache = (_2, __, ___) => ({});
          return props2.perfMode ? memoize(_getItemStyleCache) : memoizeOne(_getItemStyleCache);
        });
      };
      const DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;
      const ITEM_RENDER_EVT = "itemRendered";
      const SCROLL_EVT = "scroll";
      const FORWARD = "forward";
      const BACKWARD = "backward";
      const AUTO_ALIGNMENT = "auto";
      const SMART_ALIGNMENT = "smart";
      const START_ALIGNMENT = "start";
      const CENTERED_ALIGNMENT = "center";
      const END_ALIGNMENT = "end";
      const HORIZONTAL = "horizontal";
      const VERTICAL = "vertical";
      const LTR = "ltr";
      const RTL = "rtl";
      const RTL_OFFSET_NAG = "negative";
      const RTL_OFFSET_POS_ASC = "positive-ascending";
      const RTL_OFFSET_POS_DESC = "positive-descending";
      const ScrollbarDirKey = {
        [HORIZONTAL]: "left",
        [VERTICAL]: "top"
      };
      const SCROLLBAR_MIN_SIZE = 20;
      const LayoutKeys = {
        [HORIZONTAL]: "deltaX",
        [VERTICAL]: "deltaY"
      };
      const useWheel = ({ atEndEdge, atStartEdge, layout: layout2 }, onWheelDelta) => {
        let frameHandle;
        let offset = 0;
        const hasReachedEdge = (offset2) => {
          const edgeReached = offset2 < 0 && atStartEdge.value || offset2 > 0 && atEndEdge.value;
          return edgeReached;
        };
        const onWheel = (e2) => {
          cAF(frameHandle);
          const newOffset = e2[LayoutKeys[layout2.value]];
          if (hasReachedEdge(offset) && hasReachedEdge(offset + newOffset))
            return;
          offset += newOffset;
          if (!isFirefox()) {
            e2.preventDefault();
          }
          frameHandle = rAF(() => {
            onWheelDelta(offset);
            offset = 0;
          });
        };
        return {
          hasReachedEdge,
          onWheel
        };
      };
      const itemSize$1 = buildProp({
        type: definePropType([Number, Function]),
        required: true
      });
      const estimatedItemSize = buildProp({
        type: Number
      });
      const cache = buildProp({
        type: Number,
        default: 2
      });
      const direction = buildProp({
        type: String,
        values: ["ltr", "rtl"],
        default: "ltr"
      });
      const initScrollOffset = buildProp({
        type: Number,
        default: 0
      });
      const total = buildProp({
        type: Number,
        required: true
      });
      const layout = buildProp({
        type: String,
        values: ["horizontal", "vertical"],
        default: VERTICAL
      });
      const virtualizedProps = buildProps({
        className: {
          type: String,
          default: ""
        },
        containerElement: {
          type: definePropType([String, Object]),
          default: "div"
        },
        data: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        direction,
        height: {
          type: [String, Number],
          required: true
        },
        innerElement: {
          type: [String, Object],
          default: "div"
        },
        style: {
          type: definePropType([Object, String, Array])
        },
        useIsScrolling: {
          type: Boolean,
          default: false
        },
        width: {
          type: [Number, String],
          required: false
        },
        perfMode: {
          type: Boolean,
          default: true
        },
        scrollbarAlwaysOn: {
          type: Boolean,
          default: false
        }
      });
      const virtualizedListProps = buildProps({
        cache,
        estimatedItemSize,
        layout,
        initScrollOffset,
        total,
        itemSize: itemSize$1,
        ...virtualizedProps
      });
      const scrollbarSize = {
        type: Number,
        default: 6
      };
      const startGap = { type: Number, default: 0 };
      const endGap = { type: Number, default: 2 };
      buildProps({
        columnCache: cache,
        columnWidth: itemSize$1,
        estimatedColumnWidth: estimatedItemSize,
        estimatedRowHeight: estimatedItemSize,
        initScrollLeft: initScrollOffset,
        initScrollTop: initScrollOffset,
        itemKey: {
          type: definePropType(Function),
          default: ({
            columnIndex,
            rowIndex
          }) => `${rowIndex}:${columnIndex}`
        },
        rowCache: cache,
        rowHeight: itemSize$1,
        totalColumn: total,
        totalRow: total,
        hScrollbarSize: scrollbarSize,
        vScrollbarSize: scrollbarSize,
        scrollbarStartGap: startGap,
        scrollbarEndGap: endGap,
        role: String,
        ...virtualizedProps
      });
      const virtualizedScrollbarProps = buildProps({
        alwaysOn: Boolean,
        class: String,
        layout,
        total,
        ratio: {
          type: Number,
          required: true
        },
        clientSize: {
          type: Number,
          required: true
        },
        scrollFrom: {
          type: Number,
          required: true
        },
        scrollbarSize,
        startGap,
        endGap,
        visible: Boolean
      });
      const getScrollDir = (prev, cur) => prev < cur ? FORWARD : BACKWARD;
      const isHorizontal = (dir) => dir === LTR || dir === RTL || dir === HORIZONTAL;
      let cachedRTLResult = null;
      function getRTLOffsetType(recalculate = false) {
        if (cachedRTLResult === null || recalculate) {
          const outerDiv = document.createElement("div");
          const outerStyle = outerDiv.style;
          outerStyle.width = "50px";
          outerStyle.height = "50px";
          outerStyle.overflow = "scroll";
          outerStyle.direction = "rtl";
          const innerDiv = document.createElement("div");
          const innerStyle = innerDiv.style;
          innerStyle.width = "100px";
          innerStyle.height = "100px";
          outerDiv.appendChild(innerDiv);
          document.body.appendChild(outerDiv);
          if (outerDiv.scrollLeft > 0) {
            cachedRTLResult = RTL_OFFSET_POS_DESC;
          } else {
            outerDiv.scrollLeft = 1;
            if (outerDiv.scrollLeft === 0) {
              cachedRTLResult = RTL_OFFSET_NAG;
            } else {
              cachedRTLResult = RTL_OFFSET_POS_ASC;
            }
          }
          document.body.removeChild(outerDiv);
          return cachedRTLResult;
        }
        return cachedRTLResult;
      }
      function renderThumbStyle({ move, size: size2, bar }, layout2) {
        const style = {};
        const translate2 = `translate${bar.axis}(${move}px)`;
        style[bar.size] = size2;
        style.transform = translate2;
        style.msTransform = translate2;
        style.webkitTransform = translate2;
        if (layout2 === "horizontal") {
          style.height = "100%";
        } else {
          style.width = "100%";
        }
        return style;
      }
      const ScrollBar = defineComponent({
        name: "ElVirtualScrollBar",
        props: virtualizedScrollbarProps,
        emits: ["scroll", "start-move", "stop-move"],
        setup(props2, { emit: emit2 }) {
          const GAP2 = computed(() => props2.startGap + props2.endGap);
          const nsVirtualScrollbar = useNamespace("virtual-scrollbar");
          const nsScrollbar = useNamespace("scrollbar");
          const trackRef = ref();
          const thumbRef = ref();
          let frameHandle = null;
          let onselectstartStore = null;
          const state = reactive({
            isDragging: false,
            traveled: 0
          });
          const bar = computed(() => BAR_MAP[props2.layout]);
          const trackSize = computed(() => props2.clientSize - unref(GAP2));
          const trackStyle = computed(() => ({
            position: "absolute",
            width: `${HORIZONTAL === props2.layout ? trackSize.value : props2.scrollbarSize}px`,
            height: `${HORIZONTAL === props2.layout ? props2.scrollbarSize : trackSize.value}px`,
            [ScrollbarDirKey[props2.layout]]: "2px",
            right: "2px",
            bottom: "2px",
            borderRadius: "4px"
          }));
          const thumbSize = computed(() => {
            const ratio = props2.ratio;
            const clientSize = props2.clientSize;
            if (ratio >= 100) {
              return Number.POSITIVE_INFINITY;
            }
            if (ratio >= 50) {
              return ratio * clientSize / 100;
            }
            const SCROLLBAR_MAX_SIZE = clientSize / 3;
            return Math.floor(Math.min(Math.max(ratio * clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));
          });
          const thumbStyle = computed(() => {
            if (!Number.isFinite(thumbSize.value)) {
              return {
                display: "none"
              };
            }
            const thumb = `${thumbSize.value}px`;
            const style = renderThumbStyle({
              bar: bar.value,
              size: thumb,
              move: state.traveled
            }, props2.layout);
            return style;
          });
          const totalSteps = computed(() => Math.floor(props2.clientSize - thumbSize.value - unref(GAP2)));
          const attachEvents = () => {
            window.addEventListener("mousemove", onMouseMove);
            window.addEventListener("mouseup", onMouseUp);
            const thumbEl = unref(thumbRef);
            if (!thumbEl)
              return;
            onselectstartStore = document.onselectstart;
            document.onselectstart = () => false;
            thumbEl.addEventListener("touchmove", onMouseMove);
            thumbEl.addEventListener("touchend", onMouseUp);
          };
          const detachEvents = () => {
            window.removeEventListener("mousemove", onMouseMove);
            window.removeEventListener("mouseup", onMouseUp);
            document.onselectstart = onselectstartStore;
            onselectstartStore = null;
            const thumbEl = unref(thumbRef);
            if (!thumbEl)
              return;
            thumbEl.removeEventListener("touchmove", onMouseMove);
            thumbEl.removeEventListener("touchend", onMouseUp);
          };
          const onThumbMouseDown = (e2) => {
            e2.stopImmediatePropagation();
            if (e2.ctrlKey || [1, 2].includes(e2.button)) {
              return;
            }
            state.isDragging = true;
            state[bar.value.axis] = e2.currentTarget[bar.value.offset] - (e2[bar.value.client] - e2.currentTarget.getBoundingClientRect()[bar.value.direction]);
            emit2("start-move");
            attachEvents();
          };
          const onMouseUp = () => {
            state.isDragging = false;
            state[bar.value.axis] = 0;
            emit2("stop-move");
            detachEvents();
          };
          const onMouseMove = (e2) => {
            const { isDragging } = state;
            if (!isDragging)
              return;
            if (!thumbRef.value || !trackRef.value)
              return;
            const prevPage = state[bar.value.axis];
            if (!prevPage)
              return;
            cAF(frameHandle);
            const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e2[bar.value.client]) * -1;
            const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;
            const distance = offset - thumbClickPosition;
            frameHandle = rAF(() => {
              state.traveled = Math.max(props2.startGap, Math.min(distance, totalSteps.value));
              emit2("scroll", distance, totalSteps.value);
            });
          };
          const clickTrackHandler = (e2) => {
            const offset = Math.abs(e2.target.getBoundingClientRect()[bar.value.direction] - e2[bar.value.client]);
            const thumbHalf = thumbRef.value[bar.value.offset] / 2;
            const distance = offset - thumbHalf;
            state.traveled = Math.max(0, Math.min(distance, totalSteps.value));
            emit2("scroll", distance, totalSteps.value);
          };
          watch(() => props2.scrollFrom, (v2) => {
            if (state.isDragging)
              return;
            state.traveled = Math.ceil(v2 * totalSteps.value);
          });
          onBeforeUnmount(() => {
            detachEvents();
          });
          return () => {
            return h$1("div", {
              role: "presentation",
              ref: trackRef,
              class: [
                nsVirtualScrollbar.b(),
                props2.class,
                (props2.alwaysOn || state.isDragging) && "always-on"
              ],
              style: trackStyle.value,
              onMousedown: withModifiers(clickTrackHandler, ["stop", "prevent"]),
              onTouchstartPrevent: onThumbMouseDown
            }, h$1("div", {
              ref: thumbRef,
              class: nsScrollbar.e("thumb"),
              style: thumbStyle.value,
              onMousedown: onThumbMouseDown
            }, []));
          };
        }
      });
      const createList = ({
        name,
        getOffset,
        getItemSize,
        getItemOffset,
        getEstimatedTotalSize: getEstimatedTotalSize2,
        getStartIndexForOffset,
        getStopIndexForStartIndex,
        initCache,
        clearCache,
        validateProps
      }) => {
        return defineComponent({
          name: name != null ? name : "ElVirtualList",
          props: virtualizedListProps,
          emits: [ITEM_RENDER_EVT, SCROLL_EVT],
          setup(props2, { emit: emit2, expose }) {
            validateProps(props2);
            const instance = getCurrentInstance();
            const ns = useNamespace("vl");
            const dynamicSizeCache = ref(initCache(props2, instance));
            const getItemStyleCache = useCache();
            const windowRef = ref();
            const innerRef = ref();
            const scrollbarRef = ref();
            const states = ref({
              isScrolling: false,
              scrollDir: "forward",
              scrollOffset: isNumber(props2.initScrollOffset) ? props2.initScrollOffset : 0,
              updateRequested: false,
              isScrollbarDragging: false,
              scrollbarAlwaysOn: props2.scrollbarAlwaysOn
            });
            const itemsToRender = computed(() => {
              const { total: total2, cache: cache2 } = props2;
              const { isScrolling, scrollDir, scrollOffset } = unref(states);
              if (total2 === 0) {
                return [0, 0, 0, 0];
              }
              const startIndex = getStartIndexForOffset(props2, scrollOffset, unref(dynamicSizeCache));
              const stopIndex = getStopIndexForStartIndex(props2, startIndex, scrollOffset, unref(dynamicSizeCache));
              const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache2) : 1;
              const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache2) : 1;
              return [
                Math.max(0, startIndex - cacheBackward),
                Math.max(0, Math.min(total2 - 1, stopIndex + cacheForward)),
                startIndex,
                stopIndex
              ];
            });
            const estimatedTotalSize = computed(() => getEstimatedTotalSize2(props2, unref(dynamicSizeCache)));
            const _isHorizontal = computed(() => isHorizontal(props2.layout));
            const windowStyle = computed(() => [
              {
                position: "relative",
                [`overflow-${_isHorizontal.value ? "x" : "y"}`]: "scroll",
                WebkitOverflowScrolling: "touch",
                willChange: "transform"
              },
              {
                direction: props2.direction,
                height: isNumber(props2.height) ? `${props2.height}px` : props2.height,
                width: isNumber(props2.width) ? `${props2.width}px` : props2.width
              },
              props2.style
            ]);
            const innerStyle = computed(() => {
              const size2 = unref(estimatedTotalSize);
              const horizontal = unref(_isHorizontal);
              return {
                height: horizontal ? "100%" : `${size2}px`,
                pointerEvents: unref(states).isScrolling ? "none" : void 0,
                width: horizontal ? `${size2}px` : "100%"
              };
            });
            const clientSize = computed(() => _isHorizontal.value ? props2.width : props2.height);
            const { onWheel } = useWheel({
              atStartEdge: computed(() => states.value.scrollOffset <= 0),
              atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),
              layout: computed(() => props2.layout)
            }, (offset) => {
              var _a2, _b;
              (_b = (_a2 = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a2);
              scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));
            });
            const emitEvents = () => {
              const { total: total2 } = props2;
              if (total2 > 0) {
                const [cacheStart, cacheEnd, visibleStart, visibleEnd] = unref(itemsToRender);
                emit2(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);
              }
              const { scrollDir, scrollOffset, updateRequested } = unref(states);
              emit2(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);
            };
            const scrollVertically = (e2) => {
              const { clientHeight, scrollHeight, scrollTop } = e2.currentTarget;
              const _states = unref(states);
              if (_states.scrollOffset === scrollTop) {
                return;
              }
              const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
              states.value = {
                ..._states,
                isScrolling: true,
                scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),
                scrollOffset,
                updateRequested: false
              };
              nextTick(resetIsScrolling);
            };
            const scrollHorizontally = (e2) => {
              const { clientWidth, scrollLeft, scrollWidth } = e2.currentTarget;
              const _states = unref(states);
              if (_states.scrollOffset === scrollLeft) {
                return;
              }
              const { direction: direction2 } = props2;
              let scrollOffset = scrollLeft;
              if (direction2 === RTL) {
                switch (getRTLOffsetType()) {
                  case RTL_OFFSET_NAG: {
                    scrollOffset = -scrollLeft;
                    break;
                  }
                  case RTL_OFFSET_POS_DESC: {
                    scrollOffset = scrollWidth - clientWidth - scrollLeft;
                    break;
                  }
                }
              }
              scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
              states.value = {
                ..._states,
                isScrolling: true,
                scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),
                scrollOffset,
                updateRequested: false
              };
              nextTick(resetIsScrolling);
            };
            const onScroll = (e2) => {
              unref(_isHorizontal) ? scrollHorizontally(e2) : scrollVertically(e2);
              emitEvents();
            };
            const onScrollbarScroll = (distanceToGo, totalSteps) => {
              const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;
              scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));
            };
            const scrollTo = (offset) => {
              offset = Math.max(offset, 0);
              if (offset === unref(states).scrollOffset) {
                return;
              }
              states.value = {
                ...unref(states),
                scrollOffset: offset,
                scrollDir: getScrollDir(unref(states).scrollOffset, offset),
                updateRequested: true
              };
              nextTick(resetIsScrolling);
            };
            const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {
              const { scrollOffset } = unref(states);
              idx = Math.max(0, Math.min(idx, props2.total - 1));
              scrollTo(getOffset(props2, idx, alignment, scrollOffset, unref(dynamicSizeCache)));
            };
            const getItemStyle = (idx) => {
              const { direction: direction2, itemSize: itemSize2, layout: layout2 } = props2;
              const itemStyleCache = getItemStyleCache.value(clearCache && itemSize2, clearCache && layout2, clearCache && direction2);
              let style;
              if (hasOwn(itemStyleCache, String(idx))) {
                style = itemStyleCache[idx];
              } else {
                const offset = getItemOffset(props2, idx, unref(dynamicSizeCache));
                const size2 = getItemSize(props2, idx, unref(dynamicSizeCache));
                const horizontal = unref(_isHorizontal);
                const isRtl = direction2 === RTL;
                const offsetHorizontal = horizontal ? offset : 0;
                itemStyleCache[idx] = style = {
                  position: "absolute",
                  left: isRtl ? void 0 : `${offsetHorizontal}px`,
                  right: isRtl ? `${offsetHorizontal}px` : void 0,
                  top: !horizontal ? `${offset}px` : 0,
                  height: !horizontal ? `${size2}px` : "100%",
                  width: horizontal ? `${size2}px` : "100%"
                };
              }
              return style;
            };
            const resetIsScrolling = () => {
              states.value.isScrolling = false;
              nextTick(() => {
                getItemStyleCache.value(-1, null, null);
              });
            };
            const resetScrollTop = () => {
              const window2 = windowRef.value;
              if (window2) {
                window2.scrollTop = 0;
              }
            };
            onMounted(() => {
              if (!isClient$1)
                return;
              const { initScrollOffset: initScrollOffset2 } = props2;
              const windowElement = unref(windowRef);
              if (isNumber(initScrollOffset2) && windowElement) {
                if (unref(_isHorizontal)) {
                  windowElement.scrollLeft = initScrollOffset2;
                } else {
                  windowElement.scrollTop = initScrollOffset2;
                }
              }
              emitEvents();
            });
            onUpdated(() => {
              const { direction: direction2, layout: layout2 } = props2;
              const { scrollOffset, updateRequested } = unref(states);
              const windowElement = unref(windowRef);
              if (updateRequested && windowElement) {
                if (layout2 === HORIZONTAL) {
                  if (direction2 === RTL) {
                    switch (getRTLOffsetType()) {
                      case RTL_OFFSET_NAG: {
                        windowElement.scrollLeft = -scrollOffset;
                        break;
                      }
                      case RTL_OFFSET_POS_ASC: {
                        windowElement.scrollLeft = scrollOffset;
                        break;
                      }
                      default: {
                        const { clientWidth, scrollWidth } = windowElement;
                        windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                        break;
                      }
                    }
                  } else {
                    windowElement.scrollLeft = scrollOffset;
                  }
                } else {
                  windowElement.scrollTop = scrollOffset;
                }
              }
            });
            const api = {
              ns,
              clientSize,
              estimatedTotalSize,
              windowStyle,
              windowRef,
              innerRef,
              innerStyle,
              itemsToRender,
              scrollbarRef,
              states,
              getItemStyle,
              onScroll,
              onScrollbarScroll,
              onWheel,
              scrollTo,
              scrollToItem,
              resetScrollTop
            };
            expose({
              windowRef,
              innerRef,
              getItemStyleCache,
              scrollTo,
              scrollToItem,
              resetScrollTop,
              states
            });
            return api;
          },
          render(ctx) {
            var _a2;
            const {
              $slots,
              className,
              clientSize,
              containerElement,
              data,
              getItemStyle,
              innerElement,
              itemsToRender,
              innerStyle,
              layout: layout2,
              total: total2,
              onScroll,
              onScrollbarScroll,
              onWheel,
              states,
              useIsScrolling,
              windowStyle,
              ns
            } = ctx;
            const [start, end2] = itemsToRender;
            const Container2 = resolveDynamicComponent(containerElement);
            const Inner = resolveDynamicComponent(innerElement);
            const children = [];
            if (total2 > 0) {
              for (let i2 = start; i2 <= end2; i2++) {
                children.push((_a2 = $slots.default) == null ? void 0 : _a2.call($slots, {
                  data,
                  key: i2,
                  index: i2,
                  isScrolling: useIsScrolling ? states.isScrolling : void 0,
                  style: getItemStyle(i2)
                }));
              }
            }
            const InnerNode = [
              h$1(Inner, {
                style: innerStyle,
                ref: "innerRef"
              }, !isString$2(Inner) ? {
                default: () => children
              } : children)
            ];
            const scrollbar = h$1(ScrollBar, {
              ref: "scrollbarRef",
              clientSize,
              layout: layout2,
              onScroll: onScrollbarScroll,
              ratio: clientSize * 100 / this.estimatedTotalSize,
              scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),
              total: total2
            });
            const listContainer = h$1(Container2, {
              class: [ns.e("window"), className],
              style: windowStyle,
              onScroll,
              onWheel,
              ref: "windowRef",
              key: 0
            }, !isString$2(Container2) ? { default: () => [InnerNode] } : [InnerNode]);
            return h$1("div", {
              key: 0,
              class: [ns.e("wrapper"), states.scrollbarAlwaysOn ? "always-on" : ""]
            }, [listContainer, scrollbar]);
          }
        });
      };
      const FixedSizeList = createList({
        name: "ElFixedSizeList",
        getItemOffset: ({ itemSize: itemSize2 }, index) => index * itemSize2,
        getItemSize: ({ itemSize: itemSize2 }) => itemSize2,
        getEstimatedTotalSize: ({ total: total2, itemSize: itemSize2 }) => itemSize2 * total2,
        getOffset: ({ height, total: total2, itemSize: itemSize2, layout: layout2, width }, index, alignment, scrollOffset) => {
          const size2 = isHorizontal(layout2) ? width : height;
          const lastItemOffset = Math.max(0, total2 * itemSize2 - size2);
          const maxOffset = Math.min(lastItemOffset, index * itemSize2);
          const minOffset = Math.max(0, (index + 1) * itemSize2 - size2);
          if (alignment === SMART_ALIGNMENT) {
            if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
              alignment = AUTO_ALIGNMENT;
            } else {
              alignment = CENTERED_ALIGNMENT;
            }
          }
          switch (alignment) {
            case START_ALIGNMENT: {
              return maxOffset;
            }
            case END_ALIGNMENT: {
              return minOffset;
            }
            case CENTERED_ALIGNMENT: {
              const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
              if (middleOffset < Math.ceil(size2 / 2)) {
                return 0;
              } else if (middleOffset > lastItemOffset + Math.floor(size2 / 2)) {
                return lastItemOffset;
              } else {
                return middleOffset;
              }
            }
            case AUTO_ALIGNMENT:
            default: {
              if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
                return scrollOffset;
              } else if (scrollOffset < minOffset) {
                return minOffset;
              } else {
                return maxOffset;
              }
            }
          }
        },
        getStartIndexForOffset: ({ total: total2, itemSize: itemSize2 }, offset) => Math.max(0, Math.min(total2 - 1, Math.floor(offset / itemSize2))),
        getStopIndexForStartIndex: ({ height, total: total2, itemSize: itemSize2, layout: layout2, width }, startIndex, scrollOffset) => {
          const offset = startIndex * itemSize2;
          const size2 = isHorizontal(layout2) ? width : height;
          const numVisibleItems = Math.ceil((size2 + scrollOffset - offset) / itemSize2);
          return Math.max(0, Math.min(total2 - 1, startIndex + numVisibleItems - 1));
        },
        initCache() {
          return void 0;
        },
        clearCache: true,
        validateProps() {
        }
      });
      const getItemFromCache = (props2, index, listCache) => {
        const { itemSize: itemSize2 } = props2;
        const { items, lastVisitedIndex } = listCache;
        if (index > lastVisitedIndex) {
          let offset = 0;
          if (lastVisitedIndex >= 0) {
            const item = items[lastVisitedIndex];
            offset = item.offset + item.size;
          }
          for (let i2 = lastVisitedIndex + 1; i2 <= index; i2++) {
            const size2 = itemSize2(i2);
            items[i2] = {
              offset,
              size: size2
            };
            offset += size2;
          }
          listCache.lastVisitedIndex = index;
        }
        return items[index];
      };
      const findItem = (props2, listCache, offset) => {
        const { items, lastVisitedIndex } = listCache;
        const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;
        if (lastVisitedOffset >= offset) {
          return bs(props2, listCache, 0, lastVisitedIndex, offset);
        }
        return es(props2, listCache, Math.max(0, lastVisitedIndex), offset);
      };
      const bs = (props2, listCache, low, high, offset) => {
        while (low <= high) {
          const mid = low + Math.floor((high - low) / 2);
          const currentOffset = getItemFromCache(props2, mid, listCache).offset;
          if (currentOffset === offset) {
            return mid;
          } else if (currentOffset < offset) {
            low = mid + 1;
          } else if (currentOffset > offset) {
            high = mid - 1;
          }
        }
        return Math.max(0, low - 1);
      };
      const es = (props2, listCache, index, offset) => {
        const { total: total2 } = props2;
        let exponent = 1;
        while (index < total2 && getItemFromCache(props2, index, listCache).offset < offset) {
          index += exponent;
          exponent *= 2;
        }
        return bs(props2, listCache, Math.floor(index / 2), Math.min(index, total2 - 1), offset);
      };
      const getEstimatedTotalSize = ({ total: total2 }, { items, estimatedItemSize: estimatedItemSize2, lastVisitedIndex }) => {
        let totalSizeOfMeasuredItems = 0;
        if (lastVisitedIndex >= total2) {
          lastVisitedIndex = total2 - 1;
        }
        if (lastVisitedIndex >= 0) {
          const item = items[lastVisitedIndex];
          totalSizeOfMeasuredItems = item.offset + item.size;
        }
        const numUnmeasuredItems = total2 - lastVisitedIndex - 1;
        const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize2;
        return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
      };
      const DynamicSizeList = createList({
        name: "ElDynamicSizeList",
        getItemOffset: (props2, index, listCache) => getItemFromCache(props2, index, listCache).offset,
        getItemSize: (_2, index, { items }) => items[index].size,
        getEstimatedTotalSize,
        getOffset: (props2, index, alignment, scrollOffset, listCache) => {
          const { height, layout: layout2, width } = props2;
          const size2 = isHorizontal(layout2) ? width : height;
          const item = getItemFromCache(props2, index, listCache);
          const estimatedTotalSize = getEstimatedTotalSize(props2, listCache);
          const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size2, item.offset));
          const minOffset = Math.max(0, item.offset - size2 + item.size);
          if (alignment === SMART_ALIGNMENT) {
            if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
              alignment = AUTO_ALIGNMENT;
            } else {
              alignment = CENTERED_ALIGNMENT;
            }
          }
          switch (alignment) {
            case START_ALIGNMENT: {
              return maxOffset;
            }
            case END_ALIGNMENT: {
              return minOffset;
            }
            case CENTERED_ALIGNMENT: {
              return Math.round(minOffset + (maxOffset - minOffset) / 2);
            }
            case AUTO_ALIGNMENT:
            default: {
              if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
                return scrollOffset;
              } else if (scrollOffset < minOffset) {
                return minOffset;
              } else {
                return maxOffset;
              }
            }
          }
        },
        getStartIndexForOffset: (props2, offset, listCache) => findItem(props2, listCache, offset),
        getStopIndexForStartIndex: (props2, startIndex, scrollOffset, listCache) => {
          const { height, total: total2, layout: layout2, width } = props2;
          const size2 = isHorizontal(layout2) ? width : height;
          const item = getItemFromCache(props2, startIndex, listCache);
          const maxOffset = scrollOffset + size2;
          let offset = item.offset + item.size;
          let stopIndex = startIndex;
          while (stopIndex < total2 - 1 && offset < maxOffset) {
            stopIndex++;
            offset += getItemFromCache(props2, stopIndex, listCache).size;
          }
          return stopIndex;
        },
        initCache({ estimatedItemSize: estimatedItemSize2 = DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {
          const cache2 = {
            items: {},
            estimatedItemSize: estimatedItemSize2,
            lastVisitedIndex: -1
          };
          cache2.clearCacheAfterIndex = (index, forceUpdate = true) => {
            var _a2, _b;
            cache2.lastVisitedIndex = Math.min(cache2.lastVisitedIndex, index - 1);
            (_a2 = instance.exposed) == null ? void 0 : _a2.getItemStyleCache(-1);
            if (forceUpdate) {
              (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();
            }
          };
          return cache2;
        },
        clearCache: false,
        validateProps: ({ itemSize: itemSize2 }) => {
        }
      });
      const _sfc_main$l = defineComponent({
        props: {
          item: {
            type: Object,
            required: true
          },
          style: Object,
          height: Number
        },
        setup() {
          const ns = useNamespace("select");
          return {
            ns
          };
        }
      });
      function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
        return _ctx.item.isTitle ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.ns.be("group", "title")),
          style: normalizeStyle([_ctx.style, { lineHeight: `${_ctx.height}px` }])
        }, toDisplayString(_ctx.item.label), 7)) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.ns.be("group", "split")),
          style: normalizeStyle(_ctx.style)
        }, [
          createBaseVNode("span", {
            class: normalizeClass(_ctx.ns.be("group", "split-dash")),
            style: normalizeStyle({ top: `${_ctx.height / 2}px` })
          }, null, 6)
        ], 6));
      }
      var GroupItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["render", _sfc_render$3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/group-item.vue"]]);
      function useOption(props2, { emit: emit2 }) {
        return {
          hoverItem: () => {
            if (!props2.disabled) {
              emit2("hover", props2.index);
            }
          },
          selectOptionClick: () => {
            if (!props2.disabled) {
              emit2("select", props2.item, props2.index);
            }
          }
        };
      }
      const SelectProps = {
        allowCreate: Boolean,
        autocomplete: {
          type: String,
          default: "none"
        },
        automaticDropdown: Boolean,
        clearable: Boolean,
        clearIcon: {
          type: [String, Object],
          default: circle_close_default
        },
        effect: {
          type: String,
          default: "light"
        },
        collapseTags: Boolean,
        collapseTagsTooltip: {
          type: Boolean,
          default: false
        },
        maxCollapseTags: {
          type: Number,
          default: 1
        },
        defaultFirstOption: Boolean,
        disabled: Boolean,
        estimatedOptionHeight: {
          type: Number,
          default: void 0
        },
        filterable: Boolean,
        filterMethod: Function,
        height: {
          type: Number,
          default: 170
        },
        itemHeight: {
          type: Number,
          default: 34
        },
        id: String,
        loading: Boolean,
        loadingText: String,
        label: String,
        modelValue: [Array, String, Number, Boolean, Object],
        multiple: Boolean,
        multipleLimit: {
          type: Number,
          default: 0
        },
        name: String,
        noDataText: String,
        noMatchText: String,
        remoteMethod: Function,
        reserveKeyword: {
          type: Boolean,
          default: true
        },
        options: {
          type: Array,
          required: true
        },
        placeholder: {
          type: String
        },
        teleported: useTooltipContentProps.teleported,
        persistent: {
          type: Boolean,
          default: true
        },
        popperClass: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: Object,
          default: () => ({})
        },
        remote: Boolean,
        size: {
          type: String,
          validator: isValidComponentSize
        },
        valueKey: {
          type: String,
          default: "value"
        },
        scrollbarAlwaysOn: {
          type: Boolean,
          default: false
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        placement: {
          type: definePropType(String),
          values: Ee,
          default: "bottom-start"
        }
      };
      const OptionProps = {
        data: Array,
        disabled: Boolean,
        hovering: Boolean,
        item: Object,
        index: Number,
        style: Object,
        selected: Boolean,
        created: Boolean
      };
      const _sfc_main$k = defineComponent({
        props: OptionProps,
        emits: ["select", "hover"],
        setup(props2, { emit: emit2 }) {
          const ns = useNamespace("select");
          const { hoverItem, selectOptionClick } = useOption(props2, { emit: emit2 });
          return {
            ns,
            hoverItem,
            selectOptionClick
          };
        }
      });
      const _hoisted_1$A = ["aria-selected"];
      function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("li", {
          "aria-selected": _ctx.selected,
          style: normalizeStyle(_ctx.style),
          class: normalizeClass([
            _ctx.ns.be("dropdown", "option-item"),
            _ctx.ns.is("selected", _ctx.selected),
            _ctx.ns.is("disabled", _ctx.disabled),
            _ctx.ns.is("created", _ctx.created),
            { hover: _ctx.hovering }
          ]),
          onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "default", {
            item: _ctx.item,
            index: _ctx.index,
            disabled: _ctx.disabled
          }, () => [
            createBaseVNode("span", null, toDisplayString(_ctx.item.label), 1)
          ])
        ], 46, _hoisted_1$A);
      }
      var OptionItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["render", _sfc_render$2], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/option-item.vue"]]);
      const selectV2InjectionKey = Symbol("ElSelectV2Injection");
      var ElSelectMenu = defineComponent({
        name: "ElSelectDropdown",
        props: {
          data: {
            type: Array,
            required: true
          },
          hoveringIndex: Number,
          width: Number
        },
        setup(props2, {
          slots,
          expose
        }) {
          const select = inject(selectV2InjectionKey);
          const ns = useNamespace("select");
          const cachedHeights = ref([]);
          const listRef = ref();
          const size2 = computed(() => props2.data.length);
          watch(() => size2.value, () => {
            var _a2, _b;
            (_b = (_a2 = select.popper.value).updatePopper) == null ? void 0 : _b.call(_a2);
          });
          const isSized = computed(() => isUndefined(select.props.estimatedOptionHeight));
          const listProps = computed(() => {
            if (isSized.value) {
              return {
                itemSize: select.props.itemHeight
              };
            }
            return {
              estimatedSize: select.props.estimatedOptionHeight,
              itemSize: (idx) => cachedHeights.value[idx]
            };
          });
          const contains = (arr = [], target) => {
            const {
              props: {
                valueKey
              }
            } = select;
            if (!isObject$1(target)) {
              return arr.includes(target);
            }
            return arr && arr.some((item) => {
              return get(item, valueKey) === get(target, valueKey);
            });
          };
          const isEqual2 = (selected, target) => {
            if (!isObject$1(target)) {
              return selected === target;
            } else {
              const {
                valueKey
              } = select.props;
              return get(selected, valueKey) === get(target, valueKey);
            }
          };
          const isItemSelected = (modelValue, target) => {
            const {
              valueKey
            } = select.props;
            if (select.props.multiple) {
              return contains(modelValue, get(target, valueKey));
            }
            return isEqual2(modelValue, get(target, valueKey));
          };
          const isItemDisabled = (modelValue, selected) => {
            const {
              disabled,
              multiple,
              multipleLimit
            } = select.props;
            return disabled || !selected && (multiple ? multipleLimit > 0 && modelValue.length >= multipleLimit : false);
          };
          const isItemHovering = (target) => props2.hoveringIndex === target;
          const scrollToItem = (index) => {
            const list = listRef.value;
            if (list) {
              list.scrollToItem(index);
            }
          };
          const resetScrollTop = () => {
            const list = listRef.value;
            if (list) {
              list.resetScrollTop();
            }
          };
          expose({
            listRef,
            isSized,
            isItemDisabled,
            isItemHovering,
            isItemSelected,
            scrollToItem,
            resetScrollTop
          });
          const Item = (itemProps) => {
            const {
              index,
              data,
              style
            } = itemProps;
            const sized = unref(isSized);
            const {
              itemSize: itemSize2,
              estimatedSize
            } = unref(listProps);
            const {
              modelValue
            } = select.props;
            const {
              onSelect,
              onHover
            } = select;
            const item = data[index];
            if (item.type === "Group") {
              return createVNode(GroupItem, {
                "item": item,
                "style": style,
                "height": sized ? itemSize2 : estimatedSize
              }, null);
            }
            const isSelected = isItemSelected(modelValue, item);
            const isDisabled = isItemDisabled(modelValue, isSelected);
            const isHovering = isItemHovering(index);
            return createVNode(OptionItem, mergeProps(itemProps, {
              "selected": isSelected,
              "disabled": item.disabled || isDisabled,
              "created": !!item.created,
              "hovering": isHovering,
              "item": item,
              "onSelect": onSelect,
              "onHover": onHover
            }), {
              default: (props22) => {
                var _a2;
                return ((_a2 = slots.default) == null ? void 0 : _a2.call(slots, props22)) || createVNode("span", null, [item.label]);
              }
            });
          };
          const {
            onKeyboardNavigate,
            onKeyboardSelect
          } = select;
          const onForward = () => {
            onKeyboardNavigate("forward");
          };
          const onBackward = () => {
            onKeyboardNavigate("backward");
          };
          const onEscOrTab = () => {
            select.expanded = false;
          };
          const onKeydown = (e2) => {
            const {
              code
            } = e2;
            const {
              tab,
              esc,
              down: down2,
              up: up2,
              enter
            } = EVENT_CODE;
            if (code !== tab) {
              e2.preventDefault();
              e2.stopPropagation();
            }
            switch (code) {
              case tab:
              case esc: {
                onEscOrTab();
                break;
              }
              case down2: {
                onForward();
                break;
              }
              case up2: {
                onBackward();
                break;
              }
              case enter: {
                onKeyboardSelect();
                break;
              }
            }
          };
          return () => {
            var _a2;
            const {
              data,
              width
            } = props2;
            const {
              height,
              multiple,
              scrollbarAlwaysOn
            } = select.props;
            if (data.length === 0) {
              return createVNode("div", {
                "class": ns.b("dropdown"),
                "style": {
                  width: `${width}px`
                }
              }, [(_a2 = slots.empty) == null ? void 0 : _a2.call(slots)]);
            }
            const List = unref(isSized) ? FixedSizeList : DynamicSizeList;
            return createVNode("div", {
              "class": [ns.b("dropdown"), ns.is("multiple", multiple)]
            }, [createVNode(List, mergeProps({
              "ref": listRef
            }, unref(listProps), {
              "className": ns.be("dropdown", "list"),
              "scrollbarAlwaysOn": scrollbarAlwaysOn,
              "data": data,
              "height": height,
              "width": width,
              "total": data.length,
              "onKeydown": onKeydown
            }), {
              default: (props22) => createVNode(Item, props22, null)
            })]);
          };
        }
      });
      function useAllowCreate(props2, states) {
        const createOptionCount = ref(0);
        const cachedSelectedOption = ref(null);
        const enableAllowCreateMode = computed(() => {
          return props2.allowCreate && props2.filterable;
        });
        function hasExistingOption(query) {
          const hasValue = (option) => option.value === query;
          return props2.options && props2.options.some(hasValue) || states.createdOptions.some(hasValue);
        }
        function selectNewOption(option) {
          if (!enableAllowCreateMode.value) {
            return;
          }
          if (props2.multiple && option.created) {
            createOptionCount.value++;
          } else {
            cachedSelectedOption.value = option;
          }
        }
        function createNewOption(query) {
          if (enableAllowCreateMode.value) {
            if (query && query.length > 0 && !hasExistingOption(query)) {
              const newOption = {
                value: query,
                label: query,
                created: true,
                disabled: false
              };
              if (states.createdOptions.length >= createOptionCount.value) {
                states.createdOptions[createOptionCount.value] = newOption;
              } else {
                states.createdOptions.push(newOption);
              }
            } else {
              if (props2.multiple) {
                states.createdOptions.length = createOptionCount.value;
              } else {
                const selectedOption = cachedSelectedOption.value;
                states.createdOptions.length = 0;
                if (selectedOption && selectedOption.created) {
                  states.createdOptions.push(selectedOption);
                }
              }
            }
          }
        }
        function removeNewOption(option) {
          if (!enableAllowCreateMode.value || !option || !option.created || option.created && props2.reserveKeyword && states.inputValue === option.label) {
            return;
          }
          const idx = states.createdOptions.findIndex((it2) => it2.value === option.value);
          if (~idx) {
            states.createdOptions.splice(idx, 1);
            createOptionCount.value--;
          }
        }
        function clearAllNewOption() {
          if (enableAllowCreateMode.value) {
            states.createdOptions.length = 0;
            createOptionCount.value = 0;
          }
        }
        return {
          createNewOption,
          removeNewOption,
          selectNewOption,
          clearAllNewOption
        };
      }
      const flattenOptions = (options) => {
        const flattened = [];
        options.forEach((option) => {
          if (isArray$3(option.options)) {
            flattened.push({
              label: option.label,
              isTitle: true,
              type: "Group"
            });
            option.options.forEach((o2) => {
              flattened.push(o2);
            });
            flattened.push({
              type: "Group"
            });
          } else {
            flattened.push(option);
          }
        });
        return flattened;
      };
      function useInput(handleInput) {
        const isComposing = ref(false);
        const handleCompositionStart = () => {
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          const text = event.target.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          if (isComposing.value) {
            isComposing.value = false;
            if (isFunction$2(handleInput)) {
              handleInput(event);
            }
          }
        };
        return {
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        };
      }
      const DEFAULT_INPUT_PLACEHOLDER = "";
      const MINIMUM_INPUT_WIDTH = 11;
      const TAG_BASE_WIDTH = {
        larget: 51,
        default: 42,
        small: 33
      };
      const useSelect = (props2, emit2) => {
        const { t: t2 } = useLocale();
        const nsSelectV2 = useNamespace("select-v2");
        const nsInput = useNamespace("input");
        const { form: elForm2, formItem: elFormItem2 } = useFormItem();
        const states = reactive({
          inputValue: DEFAULT_INPUT_PLACEHOLDER,
          displayInputValue: DEFAULT_INPUT_PLACEHOLDER,
          calculatedWidth: 0,
          cachedPlaceholder: "",
          cachedOptions: [],
          createdOptions: [],
          createdLabel: "",
          createdSelected: false,
          currentPlaceholder: "",
          hoveringIndex: -1,
          comboBoxHovering: false,
          isOnComposition: false,
          isSilentBlur: false,
          isComposing: false,
          inputLength: 20,
          selectWidth: 200,
          initialInputHeight: 0,
          previousQuery: null,
          previousValue: void 0,
          query: "",
          selectedLabel: "",
          softFocus: false,
          tagInMultiLine: false
        });
        const selectedIndex = ref(-1);
        const popperSize = ref(-1);
        const controlRef = ref(null);
        const inputRef = ref(null);
        const menuRef = ref(null);
        const popper = ref(null);
        const selectRef = ref(null);
        const selectionRef = ref(null);
        const calculatorRef = ref(null);
        const expanded = ref(false);
        const selectDisabled = computed(() => props2.disabled || (elForm2 == null ? void 0 : elForm2.disabled));
        const popupHeight = computed(() => {
          const totalHeight = filteredOptions.value.length * 34;
          return totalHeight > props2.height ? props2.height : totalHeight;
        });
        const hasModelValue = computed(() => {
          return !isNil(props2.modelValue);
        });
        const showClearBtn = computed(() => {
          const hasValue = props2.multiple ? Array.isArray(props2.modelValue) && props2.modelValue.length > 0 : hasModelValue.value;
          const criteria = props2.clearable && !selectDisabled.value && states.comboBoxHovering && hasValue;
          return criteria;
        });
        const iconComponent = computed(() => props2.remote && props2.filterable ? "" : arrow_up_default);
        const iconReverse = computed(() => iconComponent.value && nsSelectV2.is("reverse", expanded.value));
        const validateState = computed(() => (elFormItem2 == null ? void 0 : elFormItem2.validateState) || "");
        const validateIcon = computed(() => ValidateComponentsMap[validateState.value]);
        const debounce$1 = computed(() => props2.remote ? 300 : 0);
        const emptyText = computed(() => {
          const options = filteredOptions.value;
          if (props2.loading) {
            return props2.loadingText || t2("el.select.loading");
          } else {
            if (props2.remote && states.inputValue === "" && options.length === 0)
              return false;
            if (props2.filterable && states.inputValue && options.length > 0) {
              return props2.noMatchText || t2("el.select.noMatch");
            }
            if (options.length === 0) {
              return props2.noDataText || t2("el.select.noData");
            }
          }
          return null;
        });
        const filteredOptions = computed(() => {
          const isValidOption = (o2) => {
            const query = states.inputValue;
            const regexp2 = new RegExp(escapeStringRegexp(query), "i");
            const containsQueryString = query ? regexp2.test(o2.label || "") : true;
            return containsQueryString;
          };
          if (props2.loading) {
            return [];
          }
          return flattenOptions(props2.options.concat(states.createdOptions).map((v2) => {
            if (isArray$3(v2.options)) {
              const filtered = v2.options.filter(isValidOption);
              if (filtered.length > 0) {
                return {
                  ...v2,
                  options: filtered
                };
              }
            } else {
              if (props2.remote || isValidOption(v2)) {
                return v2;
              }
            }
            return null;
          }).filter((v2) => v2 !== null));
        });
        const filteredOptionsValueMap = computed(() => {
          const valueMap = /* @__PURE__ */ new Map();
          filteredOptions.value.forEach((option, index) => {
            valueMap.set(getValueKey(option), { option, index });
          });
          return valueMap;
        });
        const optionsAllDisabled = computed(() => filteredOptions.value.every((option) => option.disabled));
        const selectSize = useFormSize();
        const collapseTagSize = computed(() => selectSize.value === "small" ? "small" : "default");
        const tagMaxWidth = computed(() => {
          const select = selectionRef.value;
          const size2 = collapseTagSize.value || "default";
          const paddingLeft = select ? Number.parseInt(getComputedStyle(select).paddingLeft) : 0;
          const paddingRight = select ? Number.parseInt(getComputedStyle(select).paddingRight) : 0;
          return states.selectWidth - paddingRight - paddingLeft - TAG_BASE_WIDTH[size2];
        });
        const calculatePopperSize = () => {
          var _a2;
          popperSize.value = ((_a2 = selectRef.value) == null ? void 0 : _a2.offsetWidth) || 200;
        };
        const inputWrapperStyle = computed(() => {
          return {
            width: `${states.calculatedWidth === 0 ? MINIMUM_INPUT_WIDTH : Math.ceil(states.calculatedWidth) + MINIMUM_INPUT_WIDTH}px`
          };
        });
        const shouldShowPlaceholder = computed(() => {
          if (isArray$3(props2.modelValue)) {
            return props2.modelValue.length === 0 && !states.displayInputValue;
          }
          return props2.filterable ? states.displayInputValue.length === 0 : true;
        });
        const currentPlaceholder = computed(() => {
          const _placeholder = props2.placeholder || t2("el.select.placeholder");
          return props2.multiple || isNil(props2.modelValue) ? _placeholder : states.selectedLabel;
        });
        const popperRef = computed(() => {
          var _a2, _b;
          return (_b = (_a2 = popper.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
        });
        const indexRef = computed(() => {
          if (props2.multiple) {
            const len = props2.modelValue.length;
            if (props2.modelValue.length > 0 && filteredOptionsValueMap.value.has(props2.modelValue[len - 1])) {
              const { index } = filteredOptionsValueMap.value.get(props2.modelValue[len - 1]);
              return index;
            }
          } else {
            if (props2.modelValue && filteredOptionsValueMap.value.has(props2.modelValue)) {
              const { index } = filteredOptionsValueMap.value.get(props2.modelValue);
              return index;
            }
          }
          return -1;
        });
        const dropdownMenuVisible = computed({
          get() {
            return expanded.value && emptyText.value !== false;
          },
          set(val) {
            expanded.value = val;
          }
        });
        const showTagList = computed(() => states.cachedOptions.slice(0, props2.maxCollapseTags));
        const collapseTagList = computed(() => states.cachedOptions.slice(props2.maxCollapseTags));
        const {
          createNewOption,
          removeNewOption,
          selectNewOption,
          clearAllNewOption
        } = useAllowCreate(props2, states);
        const {
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        } = useInput((e2) => onInput(e2));
        const focusAndUpdatePopup = () => {
          var _a2, _b, _c;
          (_b = (_a2 = inputRef.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          (_c = popper.value) == null ? void 0 : _c.updatePopper();
        };
        const toggleMenu = () => {
          if (props2.automaticDropdown)
            return;
          if (!selectDisabled.value) {
            if (states.isComposing)
              states.softFocus = true;
            return nextTick(() => {
              var _a2, _b;
              expanded.value = !expanded.value;
              (_b = (_a2 = inputRef.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
            });
          }
        };
        const onInputChange = () => {
          if (props2.filterable && states.inputValue !== states.selectedLabel) {
            states.query = states.selectedLabel;
          }
          handleQueryChange(states.inputValue);
          return nextTick(() => {
            createNewOption(states.inputValue);
          });
        };
        const debouncedOnInputChange = debounce(onInputChange, debounce$1.value);
        const handleQueryChange = (val) => {
          if (states.previousQuery === val) {
            return;
          }
          states.previousQuery = val;
          if (props2.filterable && isFunction$2(props2.filterMethod)) {
            props2.filterMethod(val);
          } else if (props2.filterable && props2.remote && isFunction$2(props2.remoteMethod)) {
            props2.remoteMethod(val);
          }
        };
        const emitChange = (val) => {
          if (!isEqual$1(props2.modelValue, val)) {
            emit2(CHANGE_EVENT, val);
          }
        };
        const update = (val) => {
          emit2(UPDATE_MODEL_EVENT, val);
          emitChange(val);
          states.previousValue = val == null ? void 0 : val.toString();
        };
        const getValueIndex = (arr = [], value) => {
          if (!isObject$1(value)) {
            return arr.indexOf(value);
          }
          const valueKey = props2.valueKey;
          let index = -1;
          arr.some((item, i2) => {
            if (get(item, valueKey) === get(value, valueKey)) {
              index = i2;
              return true;
            }
            return false;
          });
          return index;
        };
        const getValueKey = (item) => {
          return isObject$1(item) ? get(item, props2.valueKey) : item;
        };
        const getLabel = (item) => {
          return isObject$1(item) ? item.label : item;
        };
        const resetInputHeight = () => {
          return nextTick(() => {
            var _a2, _b;
            if (!inputRef.value)
              return;
            const selection = selectionRef.value;
            selectRef.value.height = selection.offsetHeight;
            if (expanded.value && emptyText.value !== false) {
              (_b = (_a2 = popper.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            }
          });
        };
        const handleResize = () => {
          var _a2, _b;
          resetInputWidth();
          calculatePopperSize();
          (_b = (_a2 = popper.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          if (props2.multiple) {
            return resetInputHeight();
          }
        };
        const resetInputWidth = () => {
          const select = selectionRef.value;
          if (select) {
            states.selectWidth = select.getBoundingClientRect().width;
          }
        };
        const onSelect = (option, idx, byClick = true) => {
          var _a2, _b;
          if (props2.multiple) {
            let selectedOptions = props2.modelValue.slice();
            const index = getValueIndex(selectedOptions, getValueKey(option));
            if (index > -1) {
              selectedOptions = [
                ...selectedOptions.slice(0, index),
                ...selectedOptions.slice(index + 1)
              ];
              states.cachedOptions.splice(index, 1);
              removeNewOption(option);
            } else if (props2.multipleLimit <= 0 || selectedOptions.length < props2.multipleLimit) {
              selectedOptions = [...selectedOptions, getValueKey(option)];
              states.cachedOptions.push(option);
              selectNewOption(option);
              updateHoveringIndex(idx);
            }
            update(selectedOptions);
            if (option.created) {
              states.query = "";
              handleQueryChange("");
              states.inputLength = 20;
            }
            if (props2.filterable && !props2.reserveKeyword) {
              (_b = (_a2 = inputRef.value).focus) == null ? void 0 : _b.call(_a2);
              onUpdateInputValue("");
            }
            if (props2.filterable) {
              states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
            }
            resetInputHeight();
            setSoftFocus();
          } else {
            selectedIndex.value = idx;
            states.selectedLabel = option.label;
            update(getValueKey(option));
            expanded.value = false;
            states.isComposing = false;
            states.isSilentBlur = byClick;
            selectNewOption(option);
            if (!option.created) {
              clearAllNewOption();
            }
            updateHoveringIndex(idx);
          }
        };
        const deleteTag = (event, tag) => {
          const { valueKey } = props2;
          const index = props2.modelValue.indexOf(get(tag, valueKey));
          if (index > -1 && !selectDisabled.value) {
            const value = [
              ...props2.modelValue.slice(0, index),
              ...props2.modelValue.slice(index + 1)
            ];
            states.cachedOptions.splice(index, 1);
            update(value);
            emit2("remove-tag", get(tag, valueKey));
            states.softFocus = true;
            removeNewOption(tag);
            return nextTick(focusAndUpdatePopup);
          }
          event.stopPropagation();
        };
        const handleFocus = (event) => {
          const focused = states.isComposing;
          states.isComposing = true;
          if (!states.softFocus) {
            if (!focused)
              emit2("focus", event);
          } else {
            states.softFocus = false;
          }
        };
        const handleBlur = (event) => {
          states.softFocus = false;
          return nextTick(() => {
            var _a2, _b;
            (_b = (_a2 = inputRef.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
            if (calculatorRef.value) {
              states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
            }
            if (states.isSilentBlur) {
              states.isSilentBlur = false;
            } else {
              if (states.isComposing) {
                emit2("blur", event);
              }
            }
            states.isComposing = false;
          });
        };
        const handleEsc = () => {
          if (states.displayInputValue.length > 0) {
            onUpdateInputValue("");
          } else {
            expanded.value = false;
          }
        };
        const handleDel = (e2) => {
          if (states.displayInputValue.length === 0) {
            e2.preventDefault();
            const selected = props2.modelValue.slice();
            selected.pop();
            removeNewOption(states.cachedOptions.pop());
            update(selected);
          }
        };
        const handleClear = () => {
          let emptyValue;
          if (isArray$3(props2.modelValue)) {
            emptyValue = [];
          } else {
            emptyValue = void 0;
          }
          states.softFocus = true;
          if (props2.multiple) {
            states.cachedOptions = [];
          } else {
            states.selectedLabel = "";
          }
          expanded.value = false;
          update(emptyValue);
          emit2("clear");
          clearAllNewOption();
          return nextTick(focusAndUpdatePopup);
        };
        const onUpdateInputValue = (val) => {
          states.displayInputValue = val;
          states.inputValue = val;
        };
        const onKeyboardNavigate = (direction2, hoveringIndex = void 0) => {
          const options = filteredOptions.value;
          if (!["forward", "backward"].includes(direction2) || selectDisabled.value || options.length <= 0 || optionsAllDisabled.value) {
            return;
          }
          if (!expanded.value) {
            return toggleMenu();
          }
          if (hoveringIndex === void 0) {
            hoveringIndex = states.hoveringIndex;
          }
          let newIndex = -1;
          if (direction2 === "forward") {
            newIndex = hoveringIndex + 1;
            if (newIndex >= options.length) {
              newIndex = 0;
            }
          } else if (direction2 === "backward") {
            newIndex = hoveringIndex - 1;
            if (newIndex < 0 || newIndex >= options.length) {
              newIndex = options.length - 1;
            }
          }
          const option = options[newIndex];
          if (option.disabled || option.type === "Group") {
            return onKeyboardNavigate(direction2, newIndex);
          } else {
            updateHoveringIndex(newIndex);
            scrollToItem(newIndex);
          }
        };
        const onKeyboardSelect = () => {
          if (!expanded.value) {
            return toggleMenu();
          } else if (~states.hoveringIndex && filteredOptions.value[states.hoveringIndex]) {
            onSelect(filteredOptions.value[states.hoveringIndex], states.hoveringIndex, false);
          }
        };
        const updateHoveringIndex = (idx) => {
          states.hoveringIndex = idx;
        };
        const resetHoveringIndex = () => {
          states.hoveringIndex = -1;
        };
        const setSoftFocus = () => {
          var _a2;
          const _input = inputRef.value;
          if (_input) {
            (_a2 = _input.focus) == null ? void 0 : _a2.call(_input);
          }
        };
        const onInput = (event) => {
          const value = event.target.value;
          onUpdateInputValue(value);
          if (states.displayInputValue.length > 0 && !expanded.value) {
            expanded.value = true;
          }
          states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
          if (props2.multiple) {
            resetInputHeight();
          }
          if (props2.remote) {
            debouncedOnInputChange();
          } else {
            return onInputChange();
          }
        };
        const handleClickOutside = () => {
          expanded.value = false;
          return handleBlur();
        };
        const handleMenuEnter = () => {
          states.inputValue = states.displayInputValue;
          return nextTick(() => {
            if (~indexRef.value) {
              updateHoveringIndex(indexRef.value);
              scrollToItem(states.hoveringIndex);
            }
          });
        };
        const scrollToItem = (index) => {
          menuRef.value.scrollToItem(index);
        };
        const initStates = () => {
          resetHoveringIndex();
          if (props2.multiple) {
            if (props2.modelValue.length > 0) {
              let initHovering = false;
              states.cachedOptions.length = 0;
              states.previousValue = props2.modelValue.toString();
              for (const value of props2.modelValue) {
                if (filteredOptionsValueMap.value.has(value)) {
                  const { index, option } = filteredOptionsValueMap.value.get(value);
                  states.cachedOptions.push(option);
                  if (!initHovering) {
                    updateHoveringIndex(index);
                  }
                  initHovering = true;
                }
              }
            } else {
              states.cachedOptions = [];
              states.previousValue = void 0;
            }
          } else {
            if (hasModelValue.value) {
              states.previousValue = props2.modelValue;
              const options = filteredOptions.value;
              const selectedItemIndex = options.findIndex((option) => getValueKey(option) === getValueKey(props2.modelValue));
              if (~selectedItemIndex) {
                states.selectedLabel = options[selectedItemIndex].label;
                updateHoveringIndex(selectedItemIndex);
              } else {
                states.selectedLabel = `${props2.modelValue}`;
              }
            } else {
              states.selectedLabel = "";
              states.previousValue = void 0;
            }
          }
          clearAllNewOption();
          calculatePopperSize();
        };
        watch(expanded, (val) => {
          var _a2, _b;
          emit2("visible-change", val);
          if (val) {
            (_b = (_a2 = popper.value).update) == null ? void 0 : _b.call(_a2);
          } else {
            states.displayInputValue = "";
            states.previousQuery = null;
            createNewOption("");
          }
        });
        watch(() => props2.modelValue, (val, oldVal) => {
          var _a2;
          if (!val || val.toString() !== states.previousValue) {
            initStates();
          }
          if (!isEqual$1(val, oldVal) && props2.validateEvent) {
            (_a2 = elFormItem2 == null ? void 0 : elFormItem2.validate) == null ? void 0 : _a2.call(elFormItem2, "change").catch((err) => debugWarn());
          }
        }, {
          deep: true
        });
        watch(() => props2.options, () => {
          const input = inputRef.value;
          if (!input || input && document.activeElement !== input) {
            initStates();
          }
        }, {
          deep: true
        });
        watch(filteredOptions, () => {
          return nextTick(menuRef.value.resetScrollTop);
        });
        watch(() => dropdownMenuVisible.value, (val) => {
          if (!val) {
            resetHoveringIndex();
          }
        });
        onMounted(() => {
          initStates();
        });
        useResizeObserver(selectRef, handleResize);
        return {
          collapseTagSize,
          currentPlaceholder,
          expanded,
          emptyText,
          popupHeight,
          debounce: debounce$1,
          filteredOptions,
          iconComponent,
          iconReverse,
          inputWrapperStyle,
          popperSize,
          dropdownMenuVisible,
          hasModelValue,
          shouldShowPlaceholder,
          selectDisabled,
          selectSize,
          showClearBtn,
          states,
          tagMaxWidth,
          nsSelectV2,
          nsInput,
          calculatorRef,
          controlRef,
          inputRef,
          menuRef,
          popper,
          selectRef,
          selectionRef,
          popperRef,
          validateState,
          validateIcon,
          showTagList,
          collapseTagList,
          debouncedOnInputChange,
          deleteTag,
          getLabel,
          getValueKey,
          handleBlur,
          handleClear,
          handleClickOutside,
          handleDel,
          handleEsc,
          handleFocus,
          handleMenuEnter,
          handleResize,
          toggleMenu,
          scrollTo: scrollToItem,
          onInput,
          onKeyboardNavigate,
          onKeyboardSelect,
          onSelect,
          onHover: updateHoveringIndex,
          onUpdateInputValue,
          handleCompositionStart,
          handleCompositionEnd,
          handleCompositionUpdate
        };
      };
      const _sfc_main$j = defineComponent({
        name: "ElSelectV2",
        components: {
          ElSelectMenu,
          ElTag,
          ElTooltip,
          ElIcon
        },
        directives: { ClickOutside, ModelText: vModelText },
        props: SelectProps,
        emits: [
          UPDATE_MODEL_EVENT,
          CHANGE_EVENT,
          "remove-tag",
          "clear",
          "visible-change",
          "focus",
          "blur"
        ],
        setup(props2, { emit: emit2 }) {
          const modelValue = computed(() => {
            const { modelValue: rawModelValue, multiple } = props2;
            const fallback = multiple ? [] : void 0;
            if (isArray$3(rawModelValue)) {
              return multiple ? rawModelValue : fallback;
            }
            return multiple ? fallback : rawModelValue;
          });
          const API = useSelect(reactive({
            ...toRefs$1(props2),
            modelValue
          }), emit2);
          provide(selectV2InjectionKey, {
            props: reactive({
              ...toRefs$1(props2),
              height: API.popupHeight,
              modelValue
            }),
            popper: API.popper,
            onSelect: API.onSelect,
            onHover: API.onHover,
            onKeyboardNavigate: API.onKeyboardNavigate,
            onKeyboardSelect: API.onKeyboardSelect
          });
          return {
            ...API,
            modelValue
          };
        }
      });
      const _hoisted_1$z = { key: 0 };
      const _hoisted_2$u = ["id", "autocomplete", "aria-expanded", "aria-labelledby", "disabled", "readonly", "name", "unselectable"];
      const _hoisted_3$q = ["textContent"];
      const _hoisted_4$9 = ["id", "aria-labelledby", "aria-expanded", "autocomplete", "disabled", "name", "readonly", "unselectable"];
      const _hoisted_5$4 = ["textContent"];
      function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_tag = resolveComponent("el-tag");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_select_menu = resolveComponent("el-select-menu");
        const _directive_model_text = resolveDirective("model-text");
        const _directive_click_outside = resolveDirective("click-outside");
        return withDirectives((openBlock(), createElementBlock("div", {
          ref: "selectRef",
          class: normalizeClass([_ctx.nsSelectV2.b(), _ctx.nsSelectV2.m(_ctx.selectSize)]),
          onClick: _cache[24] || (_cache[24] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"])),
          onMouseenter: _cache[25] || (_cache[25] = ($event) => _ctx.states.comboBoxHovering = true),
          onMouseleave: _cache[26] || (_cache[26] = ($event) => _ctx.states.comboBoxHovering = false)
        }, [
          createVNode(_component_el_tooltip, {
            ref: "popper",
            visible: _ctx.dropdownMenuVisible,
            teleported: _ctx.teleported,
            "popper-class": [_ctx.nsSelectV2.e("popper"), _ctx.popperClass],
            "gpu-acceleration": false,
            "stop-popper-mouse-event": false,
            "popper-options": _ctx.popperOptions,
            "fallback-placements": ["bottom-start", "top-start", "right", "left"],
            effect: _ctx.effect,
            placement: _ctx.placement,
            pure: "",
            transition: `${_ctx.nsSelectV2.namespace.value}-zoom-in-top`,
            trigger: "click",
            persistent: _ctx.persistent,
            onBeforeShow: _ctx.handleMenuEnter,
            onHide: _cache[23] || (_cache[23] = ($event) => _ctx.states.inputValue = _ctx.states.displayInputValue)
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                ref: "selectionRef",
                class: normalizeClass([
                  _ctx.nsSelectV2.e("wrapper"),
                  _ctx.nsSelectV2.is("focused", _ctx.states.isComposing || _ctx.expanded),
                  _ctx.nsSelectV2.is("hovering", _ctx.states.comboBoxHovering),
                  _ctx.nsSelectV2.is("filterable", _ctx.filterable),
                  _ctx.nsSelectV2.is("disabled", _ctx.selectDisabled)
                ])
              }, [
                _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", _hoisted_1$z, [
                  renderSlot(_ctx.$slots, "prefix")
                ])) : createCommentVNode("v-if", true),
                _ctx.multiple ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(_ctx.nsSelectV2.e("selection"))
                }, [
                  _ctx.collapseTags && _ctx.modelValue.length > 0 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showTagList, (item) => {
                      return openBlock(), createElementBlock("div", {
                        key: _ctx.getValueKey(item),
                        class: normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                      }, [
                        createVNode(_component_el_tag, {
                          closable: !_ctx.selectDisabled && !(item == null ? void 0 : item.disable),
                          size: _ctx.collapseTagSize,
                          type: "info",
                          "disable-transitions": "",
                          onClose: ($event) => _ctx.deleteTag($event, item)
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("span", {
                              class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                              style: normalizeStyle({
                                maxWidth: `${_ctx.tagMaxWidth}px`
                              })
                            }, toDisplayString(item == null ? void 0 : item.label), 7)
                          ]),
                          _: 2
                        }, 1032, ["closable", "size", "onClose"])
                      ], 2);
                    }), 128)),
                    createBaseVNode("div", {
                      class: normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                    }, [
                      _ctx.modelValue.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tag, {
                        key: 0,
                        closable: false,
                        size: _ctx.collapseTagSize,
                        type: "info",
                        "disable-transitions": ""
                      }, {
                        default: withCtx(() => [
                          _ctx.collapseTagsTooltip ? (openBlock(), createBlock(_component_el_tooltip, {
                            key: 0,
                            disabled: _ctx.dropdownMenuVisible,
                            "fallback-placements": ["bottom", "top", "right", "left"],
                            effect: _ctx.effect,
                            placement: "bottom",
                            teleported: false
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", {
                                class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                                style: normalizeStyle({
                                  maxWidth: `${_ctx.tagMaxWidth}px`
                                })
                              }, "+ " + toDisplayString(_ctx.modelValue.length - _ctx.maxCollapseTags), 7)
                            ]),
                            content: withCtx(() => [
                              createBaseVNode("div", {
                                class: normalizeClass(_ctx.nsSelectV2.e("selection"))
                              }, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapseTagList, (selected) => {
                                  return openBlock(), createElementBlock("div", {
                                    key: _ctx.getValueKey(selected),
                                    class: normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                                  }, [
                                    createVNode(_component_el_tag, {
                                      closable: !_ctx.selectDisabled && !selected.disabled,
                                      size: _ctx.collapseTagSize,
                                      class: "in-tooltip",
                                      type: "info",
                                      "disable-transitions": "",
                                      onClose: ($event) => _ctx.deleteTag($event, selected)
                                    }, {
                                      default: withCtx(() => [
                                        createBaseVNode("span", {
                                          class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                                          style: normalizeStyle({
                                            maxWidth: `${_ctx.tagMaxWidth}px`
                                          })
                                        }, toDisplayString(_ctx.getLabel(selected)), 7)
                                      ]),
                                      _: 2
                                    }, 1032, ["closable", "size", "onClose"])
                                  ], 2);
                                }), 128))
                              ], 2)
                            ]),
                            _: 1
                          }, 8, ["disabled", "effect"])) : (openBlock(), createElementBlock("span", {
                            key: 1,
                            class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                            style: normalizeStyle({
                              maxWidth: `${_ctx.tagMaxWidth}px`
                            })
                          }, "+ " + toDisplayString(_ctx.modelValue.length - _ctx.maxCollapseTags), 7))
                        ]),
                        _: 1
                      }, 8, ["size"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 64)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.states.cachedOptions, (selected) => {
                    return openBlock(), createElementBlock("div", {
                      key: _ctx.getValueKey(selected),
                      class: normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                    }, [
                      createVNode(_component_el_tag, {
                        closable: !_ctx.selectDisabled && !selected.disabled,
                        size: _ctx.collapseTagSize,
                        type: "info",
                        "disable-transitions": "",
                        onClose: ($event) => _ctx.deleteTag($event, selected)
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("span", {
                            class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                            style: normalizeStyle({
                              maxWidth: `${_ctx.tagMaxWidth}px`
                            })
                          }, toDisplayString(_ctx.getLabel(selected)), 7)
                        ]),
                        _: 2
                      }, 1032, ["closable", "size", "onClose"])
                    ], 2);
                  }), 128)),
                  createBaseVNode("div", {
                    class: normalizeClass([
                      _ctx.nsSelectV2.e("selected-item"),
                      _ctx.nsSelectV2.e("input-wrapper")
                    ]),
                    style: normalizeStyle(_ctx.inputWrapperStyle)
                  }, [
                    withDirectives(createBaseVNode("input", {
                      id: _ctx.id,
                      ref: "inputRef",
                      autocomplete: _ctx.autocomplete,
                      "aria-autocomplete": "list",
                      "aria-haspopup": "listbox",
                      autocapitalize: "off",
                      "aria-expanded": _ctx.expanded,
                      "aria-labelledby": _ctx.label,
                      class: normalizeClass([
                        _ctx.nsSelectV2.is(_ctx.selectSize),
                        _ctx.nsSelectV2.e("combobox-input")
                      ]),
                      disabled: _ctx.disabled,
                      role: "combobox",
                      readonly: !_ctx.filterable,
                      spellcheck: "false",
                      type: "text",
                      name: _ctx.name,
                      unselectable: _ctx.expanded ? "on" : void 0,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = (...args) => _ctx.onUpdateInputValue && _ctx.onUpdateInputValue(...args)),
                      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                      onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                      onInput: _cache[3] || (_cache[3] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                      onCompositionstart: _cache[4] || (_cache[4] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                      onCompositionupdate: _cache[5] || (_cache[5] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                      onCompositionend: _cache[6] || (_cache[6] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                      onKeydown: [
                        _cache[7] || (_cache[7] = withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                        _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                        _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => _ctx.onKeyboardSelect && _ctx.onKeyboardSelect(...args), ["stop", "prevent"]), ["enter"])),
                        _cache[10] || (_cache[10] = withKeys(withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"])),
                        _cache[11] || (_cache[11] = withKeys(withModifiers((...args) => _ctx.handleDel && _ctx.handleDel(...args), ["stop"]), ["delete"]))
                      ]
                    }, null, 42, _hoisted_2$u), [
                      [_directive_model_text, _ctx.states.displayInputValue]
                    ]),
                    _ctx.filterable ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      ref: "calculatorRef",
                      "aria-hidden": "true",
                      class: normalizeClass(_ctx.nsSelectV2.e("input-calculator")),
                      textContent: toDisplayString(_ctx.states.displayInputValue)
                    }, null, 10, _hoisted_3$q)) : createCommentVNode("v-if", true)
                  ], 6)
                ], 2)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                  createBaseVNode("div", {
                    class: normalizeClass([
                      _ctx.nsSelectV2.e("selected-item"),
                      _ctx.nsSelectV2.e("input-wrapper")
                    ])
                  }, [
                    withDirectives(createBaseVNode("input", {
                      id: _ctx.id,
                      ref: "inputRef",
                      "aria-autocomplete": "list",
                      "aria-haspopup": "listbox",
                      "aria-labelledby": _ctx.label,
                      "aria-expanded": _ctx.expanded,
                      autocapitalize: "off",
                      autocomplete: _ctx.autocomplete,
                      class: normalizeClass(_ctx.nsSelectV2.e("combobox-input")),
                      disabled: _ctx.disabled,
                      name: _ctx.name,
                      role: "combobox",
                      readonly: !_ctx.filterable,
                      spellcheck: "false",
                      type: "text",
                      unselectable: _ctx.expanded ? "on" : void 0,
                      onCompositionstart: _cache[12] || (_cache[12] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                      onCompositionupdate: _cache[13] || (_cache[13] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                      onCompositionend: _cache[14] || (_cache[14] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                      onFocus: _cache[15] || (_cache[15] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                      onBlur: _cache[16] || (_cache[16] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                      onInput: _cache[17] || (_cache[17] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                      onKeydown: [
                        _cache[18] || (_cache[18] = withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                        _cache[19] || (_cache[19] = withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                        _cache[20] || (_cache[20] = withKeys(withModifiers((...args) => _ctx.onKeyboardSelect && _ctx.onKeyboardSelect(...args), ["stop", "prevent"]), ["enter"])),
                        _cache[21] || (_cache[21] = withKeys(withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"]))
                      ],
                      "onUpdate:modelValue": _cache[22] || (_cache[22] = (...args) => _ctx.onUpdateInputValue && _ctx.onUpdateInputValue(...args))
                    }, null, 42, _hoisted_4$9), [
                      [_directive_model_text, _ctx.states.displayInputValue]
                    ])
                  ], 2),
                  _ctx.filterable ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    ref: "calculatorRef",
                    "aria-hidden": "true",
                    class: normalizeClass([
                      _ctx.nsSelectV2.e("selected-item"),
                      _ctx.nsSelectV2.e("input-calculator")
                    ]),
                    textContent: toDisplayString(_ctx.states.displayInputValue)
                  }, null, 10, _hoisted_5$4)) : createCommentVNode("v-if", true)
                ], 64)),
                _ctx.shouldShowPlaceholder ? (openBlock(), createElementBlock("span", {
                  key: 3,
                  class: normalizeClass([
                    _ctx.nsSelectV2.e("placeholder"),
                    _ctx.nsSelectV2.is("transparent", _ctx.multiple ? _ctx.modelValue.length === 0 : !_ctx.hasModelValue)
                  ])
                }, toDisplayString(_ctx.currentPlaceholder), 3)) : createCommentVNode("v-if", true),
                createBaseVNode("span", {
                  class: normalizeClass(_ctx.nsSelectV2.e("suffix"))
                }, [
                  _ctx.iconComponent ? withDirectives((openBlock(), createBlock(_component_el_icon, {
                    key: 0,
                    class: normalizeClass([_ctx.nsSelectV2.e("caret"), _ctx.nsInput.e("icon"), _ctx.iconReverse])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                    ]),
                    _: 1
                  }, 8, ["class"])), [
                    [vShow, !_ctx.showClearBtn]
                  ]) : createCommentVNode("v-if", true),
                  _ctx.showClearBtn && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 1,
                    class: normalizeClass([_ctx.nsSelectV2.e("caret"), _ctx.nsInput.e("icon")]),
                    onClick: withModifiers(_ctx.handleClear, ["prevent", "stop"])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                  _ctx.validateState && _ctx.validateIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 2,
                    class: normalizeClass([_ctx.nsInput.e("icon"), _ctx.nsInput.e("validateIcon")])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.validateIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 2)
              ], 2)
            ]),
            content: withCtx(() => [
              createVNode(_component_el_select_menu, {
                ref: "menuRef",
                data: _ctx.filteredOptions,
                width: _ctx.popperSize,
                "hovering-index": _ctx.states.hoveringIndex,
                "scrollbar-always-on": _ctx.scrollbarAlwaysOn
              }, {
                default: withCtx((scope) => [
                  renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(scope)))
                ]),
                empty: withCtx(() => [
                  renderSlot(_ctx.$slots, "empty", {}, () => [
                    createBaseVNode("p", {
                      class: normalizeClass(_ctx.nsSelectV2.e("empty"))
                    }, toDisplayString(_ctx.emptyText ? _ctx.emptyText : ""), 3)
                  ])
                ]),
                _: 3
              }, 8, ["data", "width", "hovering-index", "scrollbar-always-on"])
            ]),
            _: 3
          }, 8, ["visible", "teleported", "popper-class", "popper-options", "effect", "placement", "transition", "persistent", "onBeforeShow"])
        ], 34)), [
          [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
        ]);
      }
      var Select = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["render", _sfc_render$1], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/select.vue"]]);
      Select.install = (app2) => {
        app2.component(Select.name, Select);
      };
      const _Select = Select;
      const ElSelectV2 = _Select;
      const sliderContextKey = Symbol("sliderContextKey");
      const sliderProps = buildProps({
        modelValue: {
          type: definePropType([Number, Array]),
          default: 0
        },
        id: {
          type: String,
          default: void 0
        },
        min: {
          type: Number,
          default: 0
        },
        max: {
          type: Number,
          default: 100
        },
        step: {
          type: Number,
          default: 1
        },
        showInput: Boolean,
        showInputControls: {
          type: Boolean,
          default: true
        },
        size: useSizeProp,
        inputSize: useSizeProp,
        showStops: Boolean,
        showTooltip: {
          type: Boolean,
          default: true
        },
        formatTooltip: {
          type: definePropType(Function),
          default: void 0
        },
        disabled: Boolean,
        range: Boolean,
        vertical: Boolean,
        height: String,
        debounce: {
          type: Number,
          default: 300
        },
        label: {
          type: String,
          default: void 0
        },
        rangeStartLabel: {
          type: String,
          default: void 0
        },
        rangeEndLabel: {
          type: String,
          default: void 0
        },
        formatValueText: {
          type: definePropType(Function),
          default: void 0
        },
        tooltipClass: {
          type: String,
          default: void 0
        },
        placement: {
          type: String,
          values: Ee,
          default: "top"
        },
        marks: {
          type: definePropType(Object)
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const isValidValue = (value) => isNumber(value) || isArray$3(value) && value.every(isNumber);
      const sliderEmits = {
        [UPDATE_MODEL_EVENT]: isValidValue,
        [INPUT_EVENT]: isValidValue,
        [CHANGE_EVENT]: isValidValue
      };
      const useLifecycle = (props2, initData, resetSize) => {
        const sliderWrapper = ref();
        onMounted(async () => {
          if (props2.range) {
            if (Array.isArray(props2.modelValue)) {
              initData.firstValue = Math.max(props2.min, props2.modelValue[0]);
              initData.secondValue = Math.min(props2.max, props2.modelValue[1]);
            } else {
              initData.firstValue = props2.min;
              initData.secondValue = props2.max;
            }
            initData.oldValue = [initData.firstValue, initData.secondValue];
          } else {
            if (typeof props2.modelValue !== "number" || Number.isNaN(props2.modelValue)) {
              initData.firstValue = props2.min;
            } else {
              initData.firstValue = Math.min(props2.max, Math.max(props2.min, props2.modelValue));
            }
            initData.oldValue = initData.firstValue;
          }
          useEventListener$1(window, "resize", resetSize);
          await nextTick();
          resetSize();
        });
        return {
          sliderWrapper
        };
      };
      const useMarks = (props2) => {
        return computed(() => {
          if (!props2.marks) {
            return [];
          }
          const marksKeys = Object.keys(props2.marks);
          return marksKeys.map(Number.parseFloat).sort((a2, b2) => a2 - b2).filter((point) => point <= props2.max && point >= props2.min).map((point) => ({
            point,
            position: (point - props2.min) * 100 / (props2.max - props2.min),
            mark: props2.marks[point]
          }));
        });
      };
      const useSlide = (props2, initData, emit2) => {
        const { form: elForm2, formItem: elFormItem2 } = useFormItem();
        const slider = shallowRef();
        const firstButton = ref();
        const secondButton = ref();
        const buttonRefs = {
          firstButton,
          secondButton
        };
        const sliderDisabled = computed(() => {
          return props2.disabled || (elForm2 == null ? void 0 : elForm2.disabled) || false;
        });
        const minValue = computed(() => {
          return Math.min(initData.firstValue, initData.secondValue);
        });
        const maxValue = computed(() => {
          return Math.max(initData.firstValue, initData.secondValue);
        });
        const barSize = computed(() => {
          return props2.range ? `${100 * (maxValue.value - minValue.value) / (props2.max - props2.min)}%` : `${100 * (initData.firstValue - props2.min) / (props2.max - props2.min)}%`;
        });
        const barStart = computed(() => {
          return props2.range ? `${100 * (minValue.value - props2.min) / (props2.max - props2.min)}%` : "0%";
        });
        const runwayStyle = computed(() => {
          return props2.vertical ? { height: props2.height } : {};
        });
        const barStyle = computed(() => {
          return props2.vertical ? {
            height: barSize.value,
            bottom: barStart.value
          } : {
            width: barSize.value,
            left: barStart.value
          };
        });
        const resetSize = () => {
          if (slider.value) {
            initData.sliderSize = slider.value[`client${props2.vertical ? "Height" : "Width"}`];
          }
        };
        const getButtonRefByPercent = (percent) => {
          const targetValue = props2.min + percent * (props2.max - props2.min) / 100;
          if (!props2.range) {
            return firstButton;
          }
          let buttonRefName;
          if (Math.abs(minValue.value - targetValue) < Math.abs(maxValue.value - targetValue)) {
            buttonRefName = initData.firstValue < initData.secondValue ? "firstButton" : "secondButton";
          } else {
            buttonRefName = initData.firstValue > initData.secondValue ? "firstButton" : "secondButton";
          }
          return buttonRefs[buttonRefName];
        };
        const setPosition = (percent) => {
          const buttonRef = getButtonRefByPercent(percent);
          buttonRef.value.setPosition(percent);
          return buttonRef;
        };
        const setFirstValue = (firstValue) => {
          initData.firstValue = firstValue;
          _emit(props2.range ? [minValue.value, maxValue.value] : firstValue);
        };
        const setSecondValue = (secondValue) => {
          initData.secondValue = secondValue;
          if (props2.range) {
            _emit([minValue.value, maxValue.value]);
          }
        };
        const _emit = (val) => {
          emit2(UPDATE_MODEL_EVENT, val);
          emit2(INPUT_EVENT, val);
        };
        const emitChange = async () => {
          await nextTick();
          emit2(CHANGE_EVENT, props2.range ? [minValue.value, maxValue.value] : props2.modelValue);
        };
        const handleSliderPointerEvent = (event) => {
          var _a2, _b, _c, _d, _e, _f;
          if (sliderDisabled.value || initData.dragging)
            return;
          resetSize();
          let newPercent = 0;
          if (props2.vertical) {
            const clientY = (_c = (_b = (_a2 = event.touches) == null ? void 0 : _a2.item(0)) == null ? void 0 : _b.clientY) != null ? _c : event.clientY;
            const sliderOffsetBottom = slider.value.getBoundingClientRect().bottom;
            newPercent = (sliderOffsetBottom - clientY) / initData.sliderSize * 100;
          } else {
            const clientX = (_f = (_e = (_d = event.touches) == null ? void 0 : _d.item(0)) == null ? void 0 : _e.clientX) != null ? _f : event.clientX;
            const sliderOffsetLeft = slider.value.getBoundingClientRect().left;
            newPercent = (clientX - sliderOffsetLeft) / initData.sliderSize * 100;
          }
          if (newPercent < 0 || newPercent > 100)
            return;
          return setPosition(newPercent);
        };
        const onSliderWrapperPrevent = (event) => {
          var _a2, _b;
          if (((_a2 = buttonRefs["firstButton"].value) == null ? void 0 : _a2.dragging) || ((_b = buttonRefs["secondButton"].value) == null ? void 0 : _b.dragging)) {
            event.preventDefault();
          }
        };
        const onSliderDown = async (event) => {
          const buttonRef = handleSliderPointerEvent(event);
          if (buttonRef) {
            await nextTick();
            buttonRef.value.onButtonDown(event);
          }
        };
        const onSliderClick = (event) => {
          const buttonRef = handleSliderPointerEvent(event);
          if (buttonRef) {
            emitChange();
          }
        };
        return {
          elFormItem: elFormItem2,
          slider,
          firstButton,
          secondButton,
          sliderDisabled,
          minValue,
          maxValue,
          runwayStyle,
          barStyle,
          resetSize,
          setPosition,
          emitChange,
          onSliderWrapperPrevent,
          onSliderClick,
          onSliderDown,
          setFirstValue,
          setSecondValue
        };
      };
      const { left, down, right, up, home, end, pageUp, pageDown } = EVENT_CODE;
      const useTooltip = (props2, formatTooltip, showTooltip) => {
        const tooltip = ref();
        const tooltipVisible = ref(false);
        const enableFormat = computed(() => {
          return formatTooltip.value instanceof Function;
        });
        const formatValue = computed(() => {
          return enableFormat.value && formatTooltip.value(props2.modelValue) || props2.modelValue;
        });
        const displayTooltip = debounce(() => {
          showTooltip.value && (tooltipVisible.value = true);
        }, 50);
        const hideTooltip = debounce(() => {
          showTooltip.value && (tooltipVisible.value = false);
        }, 50);
        return {
          tooltip,
          tooltipVisible,
          formatValue,
          displayTooltip,
          hideTooltip
        };
      };
      const useSliderButton = (props2, initData, emit2) => {
        const {
          disabled,
          min,
          max,
          step,
          showTooltip,
          precision,
          sliderSize,
          formatTooltip,
          emitChange,
          resetSize,
          updateDragging
        } = inject(sliderContextKey);
        const { tooltip, tooltipVisible, formatValue, displayTooltip, hideTooltip } = useTooltip(props2, formatTooltip, showTooltip);
        const button2 = ref();
        const currentPosition = computed(() => {
          return `${(props2.modelValue - min.value) / (max.value - min.value) * 100}%`;
        });
        const wrapperStyle = computed(() => {
          return props2.vertical ? { bottom: currentPosition.value } : { left: currentPosition.value };
        });
        const handleMouseEnter = () => {
          initData.hovering = true;
          displayTooltip();
        };
        const handleMouseLeave = () => {
          initData.hovering = false;
          if (!initData.dragging) {
            hideTooltip();
          }
        };
        const onButtonDown = (event) => {
          if (disabled.value)
            return;
          event.preventDefault();
          onDragStart(event);
          window.addEventListener("mousemove", onDragging);
          window.addEventListener("touchmove", onDragging);
          window.addEventListener("mouseup", onDragEnd);
          window.addEventListener("touchend", onDragEnd);
          window.addEventListener("contextmenu", onDragEnd);
          button2.value.focus();
        };
        const incrementPosition = (amount) => {
          if (disabled.value)
            return;
          initData.newPosition = Number.parseFloat(currentPosition.value) + amount / (max.value - min.value) * 100;
          setPosition(initData.newPosition);
          emitChange();
        };
        const onLeftKeyDown = () => {
          incrementPosition(-step.value);
        };
        const onRightKeyDown = () => {
          incrementPosition(step.value);
        };
        const onPageDownKeyDown = () => {
          incrementPosition(-step.value * 4);
        };
        const onPageUpKeyDown = () => {
          incrementPosition(step.value * 4);
        };
        const onHomeKeyDown = () => {
          if (disabled.value)
            return;
          setPosition(0);
          emitChange();
        };
        const onEndKeyDown = () => {
          if (disabled.value)
            return;
          setPosition(100);
          emitChange();
        };
        const onKeyDown = (event) => {
          let isPreventDefault = true;
          if ([left, down].includes(event.key)) {
            onLeftKeyDown();
          } else if ([right, up].includes(event.key)) {
            onRightKeyDown();
          } else if (event.key === home) {
            onHomeKeyDown();
          } else if (event.key === end) {
            onEndKeyDown();
          } else if (event.key === pageDown) {
            onPageDownKeyDown();
          } else if (event.key === pageUp) {
            onPageUpKeyDown();
          } else {
            isPreventDefault = false;
          }
          isPreventDefault && event.preventDefault();
        };
        const getClientXY = (event) => {
          let clientX;
          let clientY;
          if (event.type.startsWith("touch")) {
            clientY = event.touches[0].clientY;
            clientX = event.touches[0].clientX;
          } else {
            clientY = event.clientY;
            clientX = event.clientX;
          }
          return {
            clientX,
            clientY
          };
        };
        const onDragStart = (event) => {
          initData.dragging = true;
          initData.isClick = true;
          const { clientX, clientY } = getClientXY(event);
          if (props2.vertical) {
            initData.startY = clientY;
          } else {
            initData.startX = clientX;
          }
          initData.startPosition = Number.parseFloat(currentPosition.value);
          initData.newPosition = initData.startPosition;
        };
        const onDragging = (event) => {
          if (initData.dragging) {
            initData.isClick = false;
            displayTooltip();
            resetSize();
            let diff;
            const { clientX, clientY } = getClientXY(event);
            if (props2.vertical) {
              initData.currentY = clientY;
              diff = (initData.startY - initData.currentY) / sliderSize.value * 100;
            } else {
              initData.currentX = clientX;
              diff = (initData.currentX - initData.startX) / sliderSize.value * 100;
            }
            initData.newPosition = initData.startPosition + diff;
            setPosition(initData.newPosition);
          }
        };
        const onDragEnd = () => {
          if (initData.dragging) {
            setTimeout(() => {
              initData.dragging = false;
              if (!initData.hovering) {
                hideTooltip();
              }
              if (!initData.isClick) {
                setPosition(initData.newPosition);
              }
              emitChange();
            }, 0);
            window.removeEventListener("mousemove", onDragging);
            window.removeEventListener("touchmove", onDragging);
            window.removeEventListener("mouseup", onDragEnd);
            window.removeEventListener("touchend", onDragEnd);
            window.removeEventListener("contextmenu", onDragEnd);
          }
        };
        const setPosition = async (newPosition) => {
          if (newPosition === null || Number.isNaN(+newPosition))
            return;
          if (newPosition < 0) {
            newPosition = 0;
          } else if (newPosition > 100) {
            newPosition = 100;
          }
          const lengthPerStep = 100 / ((max.value - min.value) / step.value);
          const steps = Math.round(newPosition / lengthPerStep);
          let value = steps * lengthPerStep * (max.value - min.value) * 0.01 + min.value;
          value = Number.parseFloat(value.toFixed(precision.value));
          if (value !== props2.modelValue) {
            emit2(UPDATE_MODEL_EVENT, value);
          }
          if (!initData.dragging && props2.modelValue !== initData.oldValue) {
            initData.oldValue = props2.modelValue;
          }
          await nextTick();
          initData.dragging && displayTooltip();
          tooltip.value.updatePopper();
        };
        watch(() => initData.dragging, (val) => {
          updateDragging(val);
        });
        return {
          disabled,
          button: button2,
          tooltip,
          tooltipVisible,
          showTooltip,
          wrapperStyle,
          formatValue,
          handleMouseEnter,
          handleMouseLeave,
          onButtonDown,
          onKeyDown,
          setPosition
        };
      };
      const useStops = (props2, initData, minValue, maxValue) => {
        const stops = computed(() => {
          if (!props2.showStops || props2.min > props2.max)
            return [];
          if (props2.step === 0) {
            return [];
          }
          const stopCount = (props2.max - props2.min) / props2.step;
          const stepWidth = 100 * props2.step / (props2.max - props2.min);
          const result = Array.from({ length: stopCount - 1 }).map((_2, index) => (index + 1) * stepWidth);
          if (props2.range) {
            return result.filter((step) => {
              return step < 100 * (minValue.value - props2.min) / (props2.max - props2.min) || step > 100 * (maxValue.value - props2.min) / (props2.max - props2.min);
            });
          } else {
            return result.filter((step) => step > 100 * (initData.firstValue - props2.min) / (props2.max - props2.min));
          }
        });
        const getStopStyle = (position) => {
          return props2.vertical ? { bottom: `${position}%` } : { left: `${position}%` };
        };
        return {
          stops,
          getStopStyle
        };
      };
      const useWatch = (props2, initData, minValue, maxValue, emit2, elFormItem2) => {
        const _emit = (val) => {
          emit2(UPDATE_MODEL_EVENT, val);
          emit2(INPUT_EVENT, val);
        };
        const valueChanged = () => {
          if (props2.range) {
            return ![minValue.value, maxValue.value].every((item, index) => item === initData.oldValue[index]);
          } else {
            return props2.modelValue !== initData.oldValue;
          }
        };
        const setValues = () => {
          var _a2, _b;
          if (props2.min > props2.max) {
            throwError("Slider", "min should not be greater than max.");
          }
          const val = props2.modelValue;
          if (props2.range && Array.isArray(val)) {
            if (val[1] < props2.min) {
              _emit([props2.min, props2.min]);
            } else if (val[0] > props2.max) {
              _emit([props2.max, props2.max]);
            } else if (val[0] < props2.min) {
              _emit([props2.min, val[1]]);
            } else if (val[1] > props2.max) {
              _emit([val[0], props2.max]);
            } else {
              initData.firstValue = val[0];
              initData.secondValue = val[1];
              if (valueChanged()) {
                if (props2.validateEvent) {
                  (_a2 = elFormItem2 == null ? void 0 : elFormItem2.validate) == null ? void 0 : _a2.call(elFormItem2, "change").catch((err) => debugWarn());
                }
                initData.oldValue = val.slice();
              }
            }
          } else if (!props2.range && typeof val === "number" && !Number.isNaN(val)) {
            if (val < props2.min) {
              _emit(props2.min);
            } else if (val > props2.max) {
              _emit(props2.max);
            } else {
              initData.firstValue = val;
              if (valueChanged()) {
                if (props2.validateEvent) {
                  (_b = elFormItem2 == null ? void 0 : elFormItem2.validate) == null ? void 0 : _b.call(elFormItem2, "change").catch((err) => debugWarn());
                }
                initData.oldValue = val;
              }
            }
          }
        };
        setValues();
        watch(() => initData.dragging, (val) => {
          if (!val) {
            setValues();
          }
        });
        watch(() => props2.modelValue, (val, oldVal) => {
          if (initData.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every((item, index) => item === oldVal[index]) && initData.firstValue === val[0] && initData.secondValue === val[1]) {
            return;
          }
          setValues();
        }, {
          deep: true
        });
        watch(() => [props2.min, props2.max], () => {
          setValues();
        });
      };
      const sliderButtonProps = buildProps({
        modelValue: {
          type: Number,
          default: 0
        },
        vertical: Boolean,
        tooltipClass: String,
        placement: {
          type: String,
          values: Ee,
          default: "top"
        }
      });
      const sliderButtonEmits = {
        [UPDATE_MODEL_EVENT]: (value) => isNumber(value)
      };
      const _hoisted_1$y = ["tabindex"];
      const __default__$8 = defineComponent({
        name: "ElSliderButton"
      });
      const _sfc_main$i = /* @__PURE__ */ defineComponent({
        ...__default__$8,
        props: sliderButtonProps,
        emits: sliderButtonEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props2 = __props;
          const ns = useNamespace("slider");
          const initData = reactive({
            hovering: false,
            dragging: false,
            isClick: false,
            startX: 0,
            currentX: 0,
            startY: 0,
            currentY: 0,
            startPosition: 0,
            newPosition: 0,
            oldValue: props2.modelValue
          });
          const {
            disabled,
            button: button2,
            tooltip,
            showTooltip,
            tooltipVisible,
            wrapperStyle,
            formatValue,
            handleMouseEnter,
            handleMouseLeave,
            onButtonDown,
            onKeyDown,
            setPosition
          } = useSliderButton(props2, initData, emit2);
          const { hovering, dragging } = toRefs$1(initData);
          expose({
            onButtonDown,
            onKeyDown,
            setPosition,
            hovering,
            dragging
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "button",
              ref: button2,
              class: normalizeClass([unref(ns).e("button-wrapper"), { hover: unref(hovering), dragging: unref(dragging) }]),
              style: normalizeStyle(unref(wrapperStyle)),
              tabindex: unref(disabled) ? -1 : 0,
              onMouseenter: _cache[0] || (_cache[0] = (...args) => unref(handleMouseEnter) && unref(handleMouseEnter)(...args)),
              onMouseleave: _cache[1] || (_cache[1] = (...args) => unref(handleMouseLeave) && unref(handleMouseLeave)(...args)),
              onMousedown: _cache[2] || (_cache[2] = (...args) => unref(onButtonDown) && unref(onButtonDown)(...args)),
              onTouchstart: _cache[3] || (_cache[3] = (...args) => unref(onButtonDown) && unref(onButtonDown)(...args)),
              onFocus: _cache[4] || (_cache[4] = (...args) => unref(handleMouseEnter) && unref(handleMouseEnter)(...args)),
              onBlur: _cache[5] || (_cache[5] = (...args) => unref(handleMouseLeave) && unref(handleMouseLeave)(...args)),
              onKeydown: _cache[6] || (_cache[6] = (...args) => unref(onKeyDown) && unref(onKeyDown)(...args))
            }, [
              createVNode(unref(ElTooltip), {
                ref_key: "tooltip",
                ref: tooltip,
                visible: unref(tooltipVisible),
                placement: _ctx.placement,
                "fallback-placements": ["top", "bottom", "right", "left"],
                "stop-popper-mouse-event": false,
                "popper-class": _ctx.tooltipClass,
                disabled: !unref(showTooltip),
                persistent: ""
              }, {
                content: withCtx(() => [
                  createBaseVNode("span", null, toDisplayString(unref(formatValue)), 1)
                ]),
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: normalizeClass([unref(ns).e("button"), { hover: unref(hovering), dragging: unref(dragging) }])
                  }, null, 2)
                ]),
                _: 1
              }, 8, ["visible", "placement", "popper-class", "disabled"])
            ], 46, _hoisted_1$y);
          };
        }
      });
      var SliderButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/button.vue"]]);
      const sliderMarkerProps = buildProps({
        mark: {
          type: definePropType([String, Object]),
          default: void 0
        }
      });
      var SliderMarker = defineComponent({
        name: "ElSliderMarker",
        props: sliderMarkerProps,
        setup(props2) {
          const ns = useNamespace("slider");
          const label = computed(() => {
            return isString$2(props2.mark) ? props2.mark : props2.mark.label;
          });
          const style = computed(() => isString$2(props2.mark) ? void 0 : props2.mark.style);
          return () => h$1("div", {
            class: ns.e("marks-text"),
            style: style.value
          }, label.value);
        }
      });
      const _hoisted_1$x = ["id", "role", "aria-label", "aria-labelledby"];
      const _hoisted_2$t = { key: 1 };
      const __default__$7 = defineComponent({
        name: "ElSlider"
      });
      const _sfc_main$h = /* @__PURE__ */ defineComponent({
        ...__default__$7,
        props: sliderProps,
        emits: sliderEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props2 = __props;
          const ns = useNamespace("slider");
          const { t: t2 } = useLocale();
          const initData = reactive({
            firstValue: 0,
            secondValue: 0,
            oldValue: 0,
            dragging: false,
            sliderSize: 1
          });
          const {
            elFormItem: elFormItem2,
            slider,
            firstButton,
            secondButton,
            sliderDisabled,
            minValue,
            maxValue,
            runwayStyle,
            barStyle,
            resetSize,
            emitChange,
            onSliderWrapperPrevent,
            onSliderClick,
            onSliderDown,
            setFirstValue,
            setSecondValue
          } = useSlide(props2, initData, emit2);
          const { stops, getStopStyle } = useStops(props2, initData, minValue, maxValue);
          const { inputId, isLabeledByFormItem } = useFormItemInputId(props2, {
            formItemContext: elFormItem2
          });
          const sliderWrapperSize = useFormSize();
          const sliderInputSize = computed(() => props2.inputSize || sliderWrapperSize.value);
          const groupLabel = computed(() => {
            return props2.label || t2("el.slider.defaultLabel", {
              min: props2.min,
              max: props2.max
            });
          });
          const firstButtonLabel = computed(() => {
            if (props2.range) {
              return props2.rangeStartLabel || t2("el.slider.defaultRangeStartLabel");
            } else {
              return groupLabel.value;
            }
          });
          const firstValueText = computed(() => {
            return props2.formatValueText ? props2.formatValueText(firstValue.value) : `${firstValue.value}`;
          });
          const secondButtonLabel = computed(() => {
            return props2.rangeEndLabel || t2("el.slider.defaultRangeEndLabel");
          });
          const secondValueText = computed(() => {
            return props2.formatValueText ? props2.formatValueText(secondValue.value) : `${secondValue.value}`;
          });
          const sliderKls = computed(() => [
            ns.b(),
            ns.m(sliderWrapperSize.value),
            ns.is("vertical", props2.vertical),
            { [ns.m("with-input")]: props2.showInput }
          ]);
          const markList = useMarks(props2);
          useWatch(props2, initData, minValue, maxValue, emit2, elFormItem2);
          const precision = computed(() => {
            const precisions = [props2.min, props2.max, props2.step].map((item) => {
              const decimal = `${item}`.split(".")[1];
              return decimal ? decimal.length : 0;
            });
            return Math.max.apply(null, precisions);
          });
          const { sliderWrapper } = useLifecycle(props2, initData, resetSize);
          const { firstValue, secondValue, sliderSize } = toRefs$1(initData);
          const updateDragging = (val) => {
            initData.dragging = val;
          };
          provide(sliderContextKey, {
            ...toRefs$1(props2),
            sliderSize,
            disabled: sliderDisabled,
            precision,
            emitChange,
            resetSize,
            updateDragging
          });
          expose({
            onSliderClick
          });
          return (_ctx, _cache) => {
            var _a2, _b;
            return openBlock(), createElementBlock("div", {
              id: _ctx.range ? unref(inputId) : void 0,
              ref_key: "sliderWrapper",
              ref: sliderWrapper,
              class: normalizeClass(unref(sliderKls)),
              role: _ctx.range ? "group" : void 0,
              "aria-label": _ctx.range && !unref(isLabeledByFormItem) ? unref(groupLabel) : void 0,
              "aria-labelledby": _ctx.range && unref(isLabeledByFormItem) ? (_a2 = unref(elFormItem2)) == null ? void 0 : _a2.labelId : void 0,
              onTouchstart: _cache[2] || (_cache[2] = (...args) => unref(onSliderWrapperPrevent) && unref(onSliderWrapperPrevent)(...args)),
              onTouchmove: _cache[3] || (_cache[3] = (...args) => unref(onSliderWrapperPrevent) && unref(onSliderWrapperPrevent)(...args))
            }, [
              createBaseVNode("div", {
                ref_key: "slider",
                ref: slider,
                class: normalizeClass([
                  unref(ns).e("runway"),
                  { "show-input": _ctx.showInput && !_ctx.range },
                  unref(ns).is("disabled", unref(sliderDisabled))
                ]),
                style: normalizeStyle(unref(runwayStyle)),
                onMousedown: _cache[0] || (_cache[0] = (...args) => unref(onSliderDown) && unref(onSliderDown)(...args)),
                onTouchstart: _cache[1] || (_cache[1] = (...args) => unref(onSliderDown) && unref(onSliderDown)(...args))
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).e("bar")),
                  style: normalizeStyle(unref(barStyle))
                }, null, 6),
                createVNode(SliderButton, {
                  id: !_ctx.range ? unref(inputId) : void 0,
                  ref_key: "firstButton",
                  ref: firstButton,
                  "model-value": unref(firstValue),
                  vertical: _ctx.vertical,
                  "tooltip-class": _ctx.tooltipClass,
                  placement: _ctx.placement,
                  role: "slider",
                  "aria-label": _ctx.range || !unref(isLabeledByFormItem) ? unref(firstButtonLabel) : void 0,
                  "aria-labelledby": !_ctx.range && unref(isLabeledByFormItem) ? (_b = unref(elFormItem2)) == null ? void 0 : _b.labelId : void 0,
                  "aria-valuemin": _ctx.min,
                  "aria-valuemax": _ctx.range ? unref(secondValue) : _ctx.max,
                  "aria-valuenow": unref(firstValue),
                  "aria-valuetext": unref(firstValueText),
                  "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                  "aria-disabled": unref(sliderDisabled),
                  "onUpdate:modelValue": unref(setFirstValue)
                }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
                _ctx.range ? (openBlock(), createBlock(SliderButton, {
                  key: 0,
                  ref_key: "secondButton",
                  ref: secondButton,
                  "model-value": unref(secondValue),
                  vertical: _ctx.vertical,
                  "tooltip-class": _ctx.tooltipClass,
                  placement: _ctx.placement,
                  role: "slider",
                  "aria-label": unref(secondButtonLabel),
                  "aria-valuemin": unref(firstValue),
                  "aria-valuemax": _ctx.max,
                  "aria-valuenow": unref(secondValue),
                  "aria-valuetext": unref(secondValueText),
                  "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                  "aria-disabled": unref(sliderDisabled),
                  "onUpdate:modelValue": unref(setSecondValue)
                }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : createCommentVNode("v-if", true),
                _ctx.showStops ? (openBlock(), createElementBlock("div", _hoisted_2$t, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(stops), (item, key) => {
                    return openBlock(), createElementBlock("div", {
                      key,
                      class: normalizeClass(unref(ns).e("stop")),
                      style: normalizeStyle(unref(getStopStyle)(item))
                    }, null, 6);
                  }), 128))
                ])) : createCommentVNode("v-if", true),
                unref(markList).length > 0 ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                  createBaseVNode("div", null, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(markList), (item, key) => {
                      return openBlock(), createElementBlock("div", {
                        key,
                        style: normalizeStyle(unref(getStopStyle)(item.position)),
                        class: normalizeClass([unref(ns).e("stop"), unref(ns).e("marks-stop")])
                      }, null, 6);
                    }), 128))
                  ]),
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ns).e("marks"))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(markList), (item, key) => {
                      return openBlock(), createBlock(unref(SliderMarker), {
                        key,
                        mark: item.mark,
                        style: normalizeStyle(unref(getStopStyle)(item.position))
                      }, null, 8, ["mark", "style"]);
                    }), 128))
                  ], 2)
                ], 64)) : createCommentVNode("v-if", true)
              ], 38),
              _ctx.showInput && !_ctx.range ? (openBlock(), createBlock(unref(ElInputNumber), {
                key: 0,
                ref: "input",
                "model-value": unref(firstValue),
                class: normalizeClass(unref(ns).e("input")),
                step: _ctx.step,
                disabled: unref(sliderDisabled),
                controls: _ctx.showInputControls,
                min: _ctx.min,
                max: _ctx.max,
                debounce: _ctx.debounce,
                size: unref(sliderInputSize),
                "onUpdate:modelValue": unref(setFirstValue),
                onChange: unref(emitChange)
              }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : createCommentVNode("v-if", true)
            ], 42, _hoisted_1$x);
          };
        }
      });
      var Slider = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/slider.vue"]]);
      const ElSlider = withInstall(Slider);
      const statisticProps = buildProps({
        decimalSeparator: {
          type: String,
          default: "."
        },
        groupSeparator: {
          type: String,
          default: ","
        },
        precision: {
          type: Number,
          default: 0
        },
        formatter: Function,
        value: {
          type: definePropType([Number, Object]),
          default: 0
        },
        prefix: String,
        suffix: String,
        title: String,
        valueStyle: {
          type: definePropType([String, Object, Array])
        }
      });
      const __default__$6 = defineComponent({
        name: "ElStatistic"
      });
      const _sfc_main$g = /* @__PURE__ */ defineComponent({
        ...__default__$6,
        props: statisticProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const ns = useNamespace("statistic");
          const displayValue = computed(() => {
            const { value, formatter, precision, decimalSeparator, groupSeparator } = props2;
            if (isFunction$2(formatter))
              return formatter(value);
            if (!isNumber(value))
              return value;
            let [integer2, decimal = ""] = String(value).split(".");
            decimal = decimal.padEnd(precision, "0").slice(0, precision > 0 ? precision : 0);
            integer2 = integer2.replace(/\B(?=(\d{3})+(?!\d))/g, groupSeparator);
            return [integer2, decimal].join(decimal ? decimalSeparator : "");
          });
          expose({
            displayValue
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b())
            }, [
              _ctx.$slots.title || _ctx.title ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("head"))
              }, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString(_ctx.title), 1)
                ])
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).e("content"))
              }, [
                _ctx.$slots.prefix || _ctx.prefix ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("prefix"))
                }, [
                  renderSlot(_ctx.$slots, "prefix", {}, () => [
                    createBaseVNode("span", null, toDisplayString(_ctx.prefix), 1)
                  ])
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("span", {
                  class: normalizeClass(unref(ns).e("number")),
                  style: normalizeStyle(_ctx.valueStyle)
                }, toDisplayString(unref(displayValue)), 7),
                _ctx.$slots.suffix || _ctx.suffix ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(ns).e("suffix"))
                }, [
                  renderSlot(_ctx.$slots, "suffix", {}, () => [
                    createBaseVNode("span", null, toDisplayString(_ctx.suffix), 1)
                  ])
                ], 2)) : createCommentVNode("v-if", true)
              ], 2)
            ], 2);
          };
        }
      });
      var Statistic = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/statistic/src/statistic.vue"]]);
      const ElStatistic = withInstall(Statistic);
      const tabsRootContextKey = Symbol("tabsRootContextKey");
      const tabBarProps = buildProps({
        tabs: {
          type: definePropType(Array),
          default: () => mutable([])
        }
      });
      const COMPONENT_NAME$2 = "ElTabBar";
      const __default__$5 = defineComponent({
        name: COMPONENT_NAME$2
      });
      const _sfc_main$f = /* @__PURE__ */ defineComponent({
        ...__default__$5,
        props: tabBarProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const instance = getCurrentInstance();
          const rootTabs = inject(tabsRootContextKey);
          if (!rootTabs)
            throwError(COMPONENT_NAME$2, "<el-tabs><el-tab-bar /></el-tabs>");
          const ns = useNamespace("tabs");
          const barRef = ref();
          const barStyle = ref();
          const getBarStyle = () => {
            let offset = 0;
            let tabSize = 0;
            const sizeName = ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height";
            const sizeDir = sizeName === "width" ? "x" : "y";
            const position = sizeDir === "x" ? "left" : "top";
            props2.tabs.every((tab) => {
              var _a2, _b;
              const $el = (_b = (_a2 = instance.parent) == null ? void 0 : _a2.refs) == null ? void 0 : _b[`tab-${tab.uid}`];
              if (!$el)
                return false;
              if (!tab.active) {
                return true;
              }
              offset = $el[`offset${capitalize(position)}`];
              tabSize = $el[`client${capitalize(sizeName)}`];
              const tabStyles = window.getComputedStyle($el);
              if (sizeName === "width") {
                if (props2.tabs.length > 1) {
                  tabSize -= Number.parseFloat(tabStyles.paddingLeft) + Number.parseFloat(tabStyles.paddingRight);
                }
                offset += Number.parseFloat(tabStyles.paddingLeft);
              }
              return false;
            });
            return {
              [sizeName]: `${tabSize}px`,
              transform: `translate${capitalize(sizeDir)}(${offset}px)`
            };
          };
          const update = () => barStyle.value = getBarStyle();
          watch(() => props2.tabs, async () => {
            await nextTick();
            update();
          }, { immediate: true });
          useResizeObserver(barRef, () => update());
          expose({
            ref: barRef,
            update
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "barRef",
              ref: barRef,
              class: normalizeClass([unref(ns).e("active-bar"), unref(ns).is(unref(rootTabs).props.tabPosition)]),
              style: normalizeStyle(barStyle.value)
            }, null, 6);
          };
        }
      });
      var TabBar = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-bar.vue"]]);
      const tabNavProps = buildProps({
        panes: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        currentName: {
          type: [String, Number],
          default: ""
        },
        editable: Boolean,
        type: {
          type: String,
          values: ["card", "border-card", ""],
          default: ""
        },
        stretch: Boolean
      });
      const tabNavEmits = {
        tabClick: (tab, tabName, ev) => ev instanceof Event,
        tabRemove: (tab, ev) => ev instanceof Event
      };
      const COMPONENT_NAME$1 = "ElTabNav";
      const TabNav = defineComponent({
        name: COMPONENT_NAME$1,
        props: tabNavProps,
        emits: tabNavEmits,
        setup(props2, {
          expose,
          emit: emit2
        }) {
          const vm = getCurrentInstance();
          const rootTabs = inject(tabsRootContextKey);
          if (!rootTabs)
            throwError(COMPONENT_NAME$1, `<el-tabs><tab-nav /></el-tabs>`);
          const ns = useNamespace("tabs");
          const visibility = useDocumentVisibility();
          const focused = useWindowFocus();
          const navScroll$ = ref();
          const nav$ = ref();
          const el$ = ref();
          const tabBarRef = ref();
          const scrollable = ref(false);
          const navOffset = ref(0);
          const isFocus = ref(false);
          const focusable = ref(true);
          const sizeName = computed(() => ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height");
          const navStyle = computed(() => {
            const dir = sizeName.value === "width" ? "X" : "Y";
            return {
              transform: `translate${dir}(-${navOffset.value}px)`
            };
          });
          const scrollPrev = () => {
            if (!navScroll$.value)
              return;
            const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (!currentOffset)
              return;
            const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;
            navOffset.value = newOffset;
          };
          const scrollNext = () => {
            if (!navScroll$.value || !nav$.value)
              return;
            const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
            const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (navSize - currentOffset <= containerSize)
              return;
            const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;
            navOffset.value = newOffset;
          };
          const scrollToActiveTab = async () => {
            const nav = nav$.value;
            if (!scrollable.value || !el$.value || !navScroll$.value || !nav)
              return;
            await nextTick();
            const activeTab = el$.value.querySelector(".is-active");
            if (!activeTab)
              return;
            const navScroll = navScroll$.value;
            const isHorizontal2 = ["top", "bottom"].includes(rootTabs.props.tabPosition);
            const activeTabBounding = activeTab.getBoundingClientRect();
            const navScrollBounding = navScroll.getBoundingClientRect();
            const maxOffset = isHorizontal2 ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;
            const currentOffset = navOffset.value;
            let newOffset = currentOffset;
            if (isHorizontal2) {
              if (activeTabBounding.left < navScrollBounding.left) {
                newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
              }
              if (activeTabBounding.right > navScrollBounding.right) {
                newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
              }
            } else {
              if (activeTabBounding.top < navScrollBounding.top) {
                newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);
              }
              if (activeTabBounding.bottom > navScrollBounding.bottom) {
                newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);
              }
            }
            newOffset = Math.max(newOffset, 0);
            navOffset.value = Math.min(newOffset, maxOffset);
          };
          const update = () => {
            var _a2;
            if (!nav$.value || !navScroll$.value)
              return;
            props2.stretch && ((_a2 = tabBarRef.value) == null ? void 0 : _a2.update());
            const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
            const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (containerSize < navSize) {
              scrollable.value = scrollable.value || {};
              scrollable.value.prev = currentOffset;
              scrollable.value.next = currentOffset + containerSize < navSize;
              if (navSize - currentOffset < containerSize) {
                navOffset.value = navSize - containerSize;
              }
            } else {
              scrollable.value = false;
              if (currentOffset > 0) {
                navOffset.value = 0;
              }
            }
          };
          const changeTab = (e2) => {
            const code = e2.code;
            const {
              up: up2,
              down: down2,
              left: left2,
              right: right2
            } = EVENT_CODE;
            if (![up2, down2, left2, right2].includes(code))
              return;
            const tabList = Array.from(e2.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)"));
            const currentIndex = tabList.indexOf(e2.target);
            let nextIndex;
            if (code === left2 || code === up2) {
              if (currentIndex === 0) {
                nextIndex = tabList.length - 1;
              } else {
                nextIndex = currentIndex - 1;
              }
            } else {
              if (currentIndex < tabList.length - 1) {
                nextIndex = currentIndex + 1;
              } else {
                nextIndex = 0;
              }
            }
            tabList[nextIndex].focus({
              preventScroll: true
            });
            tabList[nextIndex].click();
            setFocus();
          };
          const setFocus = () => {
            if (focusable.value)
              isFocus.value = true;
          };
          const removeFocus = () => isFocus.value = false;
          watch(visibility, (visibility2) => {
            if (visibility2 === "hidden") {
              focusable.value = false;
            } else if (visibility2 === "visible") {
              setTimeout(() => focusable.value = true, 50);
            }
          });
          watch(focused, (focused2) => {
            if (focused2) {
              setTimeout(() => focusable.value = true, 50);
            } else {
              focusable.value = false;
            }
          });
          useResizeObserver(el$, update);
          onMounted(() => setTimeout(() => scrollToActiveTab(), 0));
          onUpdated(() => update());
          expose({
            scrollToActiveTab,
            removeFocus
          });
          watch(() => props2.panes, () => vm.update(), {
            flush: "post",
            deep: true
          });
          return () => {
            const scrollBtn = scrollable.value ? [createVNode("span", {
              "class": [ns.e("nav-prev"), ns.is("disabled", !scrollable.value.prev)],
              "onClick": scrollPrev
            }, [createVNode(ElIcon, null, {
              default: () => [createVNode(arrow_left_default, null, null)]
            })]), createVNode("span", {
              "class": [ns.e("nav-next"), ns.is("disabled", !scrollable.value.next)],
              "onClick": scrollNext
            }, [createVNode(ElIcon, null, {
              default: () => [createVNode(arrow_right_default, null, null)]
            })])] : null;
            const tabs = props2.panes.map((pane, index) => {
              var _a2, _b, _c, _d;
              const uid2 = pane.uid;
              const disabled = pane.props.disabled;
              const tabName = (_b = (_a2 = pane.props.name) != null ? _a2 : pane.index) != null ? _b : `${index}`;
              const closable = !disabled && (pane.isClosable || props2.editable);
              pane.index = `${index}`;
              const btnClose = closable ? createVNode(ElIcon, {
                "class": "is-icon-close",
                "onClick": (ev) => emit2("tabRemove", pane, ev)
              }, {
                default: () => [createVNode(close_default, null, null)]
              }) : null;
              const tabLabelContent = ((_d = (_c = pane.slots).label) == null ? void 0 : _d.call(_c)) || pane.props.label;
              const tabindex = !disabled && pane.active ? 0 : -1;
              return createVNode("div", {
                "ref": `tab-${uid2}`,
                "class": [ns.e("item"), ns.is(rootTabs.props.tabPosition), ns.is("active", pane.active), ns.is("disabled", disabled), ns.is("closable", closable), ns.is("focus", isFocus.value)],
                "id": `tab-${tabName}`,
                "key": `tab-${uid2}`,
                "aria-controls": `pane-${tabName}`,
                "role": "tab",
                "aria-selected": pane.active,
                "tabindex": tabindex,
                "onFocus": () => setFocus(),
                "onBlur": () => removeFocus(),
                "onClick": (ev) => {
                  removeFocus();
                  emit2("tabClick", pane, tabName, ev);
                },
                "onKeydown": (ev) => {
                  if (closable && (ev.code === EVENT_CODE.delete || ev.code === EVENT_CODE.backspace)) {
                    emit2("tabRemove", pane, ev);
                  }
                }
              }, [...[tabLabelContent, btnClose]]);
            });
            return createVNode("div", {
              "ref": el$,
              "class": [ns.e("nav-wrap"), ns.is("scrollable", !!scrollable.value), ns.is(rootTabs.props.tabPosition)]
            }, [scrollBtn, createVNode("div", {
              "class": ns.e("nav-scroll"),
              "ref": navScroll$
            }, [createVNode("div", {
              "class": [ns.e("nav"), ns.is(rootTabs.props.tabPosition), ns.is("stretch", props2.stretch && ["top", "bottom"].includes(rootTabs.props.tabPosition))],
              "ref": nav$,
              "style": navStyle.value,
              "role": "tablist",
              "onKeydown": changeTab
            }, [...[!props2.type ? createVNode(TabBar, {
              "ref": tabBarRef,
              "tabs": [...props2.panes]
            }, null) : null, tabs]])])]);
          };
        }
      });
      const tabsProps = buildProps({
        type: {
          type: String,
          values: ["card", "border-card", ""],
          default: ""
        },
        activeName: {
          type: [String, Number]
        },
        closable: Boolean,
        addable: Boolean,
        modelValue: {
          type: [String, Number]
        },
        editable: Boolean,
        tabPosition: {
          type: String,
          values: ["top", "right", "bottom", "left"],
          default: "top"
        },
        beforeLeave: {
          type: definePropType(Function),
          default: () => true
        },
        stretch: Boolean
      });
      const isPaneName = (value) => isString$2(value) || isNumber(value);
      const tabsEmits = {
        [UPDATE_MODEL_EVENT]: (name) => isPaneName(name),
        tabClick: (pane, ev) => ev instanceof Event,
        tabChange: (name) => isPaneName(name),
        edit: (paneName, action) => ["remove", "add"].includes(action),
        tabRemove: (name) => isPaneName(name),
        tabAdd: () => true
      };
      var Tabs = defineComponent({
        name: "ElTabs",
        props: tabsProps,
        emits: tabsEmits,
        setup(props2, {
          emit: emit2,
          slots,
          expose
        }) {
          var _a2, _b;
          const ns = useNamespace("tabs");
          const {
            children: panes,
            addChild: registerPane,
            removeChild: unregisterPane
          } = useOrderedChildren(getCurrentInstance(), "ElTabPane");
          const nav$ = ref();
          const currentName = ref((_b = (_a2 = props2.modelValue) != null ? _a2 : props2.activeName) != null ? _b : "0");
          const changeCurrentName = (value) => {
            currentName.value = value;
            emit2(UPDATE_MODEL_EVENT, value);
            emit2("tabChange", value);
          };
          const setCurrentName = async (value) => {
            var _a22, _b2, _c;
            if (currentName.value === value || isUndefined(value))
              return;
            try {
              const canLeave = await ((_a22 = props2.beforeLeave) == null ? void 0 : _a22.call(props2, value, currentName.value));
              if (canLeave !== false) {
                changeCurrentName(value);
                (_c = (_b2 = nav$.value) == null ? void 0 : _b2.removeFocus) == null ? void 0 : _c.call(_b2);
              }
            } catch (e2) {
            }
          };
          const handleTabClick = (tab, tabName, event) => {
            if (tab.props.disabled)
              return;
            setCurrentName(tabName);
            emit2("tabClick", tab, event);
          };
          const handleTabRemove = (pane, ev) => {
            if (pane.props.disabled || isUndefined(pane.props.name))
              return;
            ev.stopPropagation();
            emit2("edit", pane.props.name, "remove");
            emit2("tabRemove", pane.props.name);
          };
          const handleTabAdd = () => {
            emit2("edit", void 0, "add");
            emit2("tabAdd");
          };
          useDeprecated({
            from: '"activeName"',
            replacement: '"model-value" or "v-model"',
            scope: "ElTabs",
            version: "2.3.0",
            ref: "https://element-plus.org/en-US/component/tabs.html#attributes",
            type: "Attribute"
          }, computed(() => !!props2.activeName));
          watch(() => props2.activeName, (modelValue) => setCurrentName(modelValue));
          watch(() => props2.modelValue, (modelValue) => setCurrentName(modelValue));
          watch(currentName, async () => {
            var _a22;
            await nextTick();
            (_a22 = nav$.value) == null ? void 0 : _a22.scrollToActiveTab();
          });
          provide(tabsRootContextKey, {
            props: props2,
            currentName,
            registerPane,
            unregisterPane
          });
          expose({
            currentName
          });
          return () => {
            const newButton = props2.editable || props2.addable ? createVNode("span", {
              "class": ns.e("new-tab"),
              "tabindex": "0",
              "onClick": handleTabAdd,
              "onKeydown": (ev) => {
                if (ev.code === EVENT_CODE.enter)
                  handleTabAdd();
              }
            }, [createVNode(ElIcon, {
              "class": ns.is("icon-plus")
            }, {
              default: () => [createVNode(plus_default, null, null)]
            })]) : null;
            const header = createVNode("div", {
              "class": [ns.e("header"), ns.is(props2.tabPosition)]
            }, [newButton, createVNode(TabNav, {
              "ref": nav$,
              "currentName": currentName.value,
              "editable": props2.editable,
              "type": props2.type,
              "panes": panes.value,
              "stretch": props2.stretch,
              "onTabClick": handleTabClick,
              "onTabRemove": handleTabRemove
            }, null)]);
            const panels = createVNode("div", {
              "class": ns.e("content")
            }, [renderSlot(slots, "default")]);
            return createVNode("div", {
              "class": [ns.b(), ns.m(props2.tabPosition), {
                [ns.m("card")]: props2.type === "card",
                [ns.m("border-card")]: props2.type === "border-card"
              }]
            }, [...props2.tabPosition !== "bottom" ? [header, panels] : [panels, header]]);
          };
        }
      });
      const tabPaneProps = buildProps({
        label: {
          type: String,
          default: ""
        },
        name: {
          type: [String, Number]
        },
        closable: Boolean,
        disabled: Boolean,
        lazy: Boolean
      });
      const _hoisted_1$w = ["id", "aria-hidden", "aria-labelledby"];
      const COMPONENT_NAME = "ElTabPane";
      const __default__$4 = defineComponent({
        name: COMPONENT_NAME
      });
      const _sfc_main$e = /* @__PURE__ */ defineComponent({
        ...__default__$4,
        props: tabPaneProps,
        setup(__props) {
          const props2 = __props;
          const instance = getCurrentInstance();
          const slots = useSlots();
          const tabsRoot = inject(tabsRootContextKey);
          if (!tabsRoot)
            throwError(COMPONENT_NAME, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
          const ns = useNamespace("tab-pane");
          const index = ref();
          const isClosable = computed(() => props2.closable || tabsRoot.props.closable);
          const active = computedEager(() => {
            var _a2;
            return tabsRoot.currentName.value === ((_a2 = props2.name) != null ? _a2 : index.value);
          });
          const loaded = ref(active.value);
          const paneName = computed(() => {
            var _a2;
            return (_a2 = props2.name) != null ? _a2 : index.value;
          });
          const shouldBeRender = computedEager(() => !props2.lazy || loaded.value || active.value);
          watch(active, (val) => {
            if (val)
              loaded.value = true;
          });
          const pane = reactive({
            uid: instance.uid,
            slots,
            props: props2,
            paneName,
            active,
            index,
            isClosable
          });
          onMounted(() => {
            tabsRoot.registerPane(pane);
          });
          onUnmounted(() => {
            tabsRoot.unregisterPane(pane.uid);
          });
          return (_ctx, _cache) => {
            return unref(shouldBeRender) ? withDirectives((openBlock(), createElementBlock("div", {
              key: 0,
              id: `pane-${unref(paneName)}`,
              class: normalizeClass(unref(ns).b()),
              role: "tabpanel",
              "aria-hidden": !unref(active),
              "aria-labelledby": `tab-${unref(paneName)}`
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 10, _hoisted_1$w)), [
              [vShow, unref(active)]
            ]) : createCommentVNode("v-if", true);
          };
        }
      });
      var TabPane = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-pane.vue"]]);
      const ElTabs = withInstall(Tabs, {
        TabPane
      });
      const ElTabPane = withNoopInstall(TabPane);
      const ROOT_TREE_INJECTION_KEY = Symbol();
      const EMPTY_NODE = {
        key: -1,
        level: -1,
        data: {}
      };
      var TreeOptionsEnum = /* @__PURE__ */ ((TreeOptionsEnum2) => {
        TreeOptionsEnum2["KEY"] = "id";
        TreeOptionsEnum2["LABEL"] = "label";
        TreeOptionsEnum2["CHILDREN"] = "children";
        TreeOptionsEnum2["DISABLED"] = "disabled";
        return TreeOptionsEnum2;
      })(TreeOptionsEnum || {});
      var SetOperationEnum = /* @__PURE__ */ ((SetOperationEnum2) => {
        SetOperationEnum2["ADD"] = "add";
        SetOperationEnum2["DELETE"] = "delete";
        return SetOperationEnum2;
      })(SetOperationEnum || {});
      const itemSize = {
        type: Number,
        default: 26
      };
      const treeProps = buildProps({
        data: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        emptyText: {
          type: String
        },
        height: {
          type: Number,
          default: 200
        },
        props: {
          type: definePropType(Object),
          default: () => mutable({
            children: "children",
            label: "label",
            disabled: "disabled",
            value: "id"
            /* KEY */
          })
        },
        highlightCurrent: {
          type: Boolean,
          default: false
        },
        showCheckbox: {
          type: Boolean,
          default: false
        },
        defaultCheckedKeys: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        checkStrictly: {
          type: Boolean,
          default: false
        },
        defaultExpandedKeys: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        indent: {
          type: Number,
          default: 16
        },
        itemSize,
        icon: {
          type: iconPropType
        },
        expandOnClickNode: {
          type: Boolean,
          default: true
        },
        checkOnClickNode: {
          type: Boolean,
          default: false
        },
        currentNodeKey: {
          type: definePropType([String, Number])
        },
        accordion: {
          type: Boolean,
          default: false
        },
        filterMethod: {
          type: definePropType(Function)
        },
        perfMode: {
          type: Boolean,
          default: true
        }
      });
      const treeNodeProps = buildProps({
        node: {
          type: definePropType(Object),
          default: () => mutable(EMPTY_NODE)
        },
        expanded: {
          type: Boolean,
          default: false
        },
        checked: {
          type: Boolean,
          default: false
        },
        indeterminate: {
          type: Boolean,
          default: false
        },
        showCheckbox: {
          type: Boolean,
          default: false
        },
        disabled: {
          type: Boolean,
          default: false
        },
        current: {
          type: Boolean,
          default: false
        },
        hiddenExpandIcon: {
          type: Boolean,
          default: false
        },
        itemSize
      });
      const treeNodeContentProps = buildProps({
        node: {
          type: definePropType(Object),
          required: true
        }
      });
      const NODE_CLICK = "node-click";
      const NODE_EXPAND = "node-expand";
      const NODE_COLLAPSE = "node-collapse";
      const CURRENT_CHANGE = "current-change";
      const NODE_CHECK = "check";
      const NODE_CHECK_CHANGE = "check-change";
      const NODE_CONTEXTMENU = "node-contextmenu";
      const treeEmits = {
        [NODE_CLICK]: (data, node, e2) => data && node && e2,
        [NODE_EXPAND]: (data, node) => data && node,
        [NODE_COLLAPSE]: (data, node) => data && node,
        [CURRENT_CHANGE]: (data, node) => data && node,
        [NODE_CHECK]: (data, checkedInfo) => data && checkedInfo,
        [NODE_CHECK_CHANGE]: (data, checked) => data && typeof checked === "boolean",
        [NODE_CONTEXTMENU]: (event, data, node) => event && data && node
      };
      const treeNodeEmits = {
        click: (node, e2) => !!(node && e2),
        toggle: (node) => !!node,
        check: (node, checked) => node && typeof checked === "boolean"
      };
      function useCheck(props2, tree) {
        const checkedKeys = ref(/* @__PURE__ */ new Set());
        const indeterminateKeys = ref(/* @__PURE__ */ new Set());
        const { emit: emit2 } = getCurrentInstance();
        watch([() => tree.value, () => props2.defaultCheckedKeys], () => {
          return nextTick(() => {
            _setCheckedKeys(props2.defaultCheckedKeys);
          });
        }, {
          immediate: true
        });
        const updateCheckedKeys = () => {
          if (!tree.value || !props2.showCheckbox || props2.checkStrictly) {
            return;
          }
          const { levelTreeNodeMap, maxLevel } = tree.value;
          const checkedKeySet = checkedKeys.value;
          const indeterminateKeySet = /* @__PURE__ */ new Set();
          for (let level = maxLevel - 1; level >= 1; --level) {
            const nodes = levelTreeNodeMap.get(level);
            if (!nodes)
              continue;
            nodes.forEach((node) => {
              const children = node.children;
              if (children) {
                let allChecked = true;
                let hasChecked = false;
                for (const childNode of children) {
                  const key = childNode.key;
                  if (checkedKeySet.has(key)) {
                    hasChecked = true;
                  } else if (indeterminateKeySet.has(key)) {
                    allChecked = false;
                    hasChecked = true;
                    break;
                  } else {
                    allChecked = false;
                  }
                }
                if (allChecked) {
                  checkedKeySet.add(node.key);
                } else if (hasChecked) {
                  indeterminateKeySet.add(node.key);
                  checkedKeySet.delete(node.key);
                } else {
                  checkedKeySet.delete(node.key);
                  indeterminateKeySet.delete(node.key);
                }
              }
            });
          }
          indeterminateKeys.value = indeterminateKeySet;
        };
        const isChecked = (node) => checkedKeys.value.has(node.key);
        const isIndeterminate = (node) => indeterminateKeys.value.has(node.key);
        const toggleCheckbox = (node, isChecked2, nodeClick = true) => {
          const checkedKeySet = checkedKeys.value;
          const toggle = (node2, checked) => {
            checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](node2.key);
            const children = node2.children;
            if (!props2.checkStrictly && children) {
              children.forEach((childNode) => {
                if (!childNode.disabled) {
                  toggle(childNode, checked);
                }
              });
            }
          };
          toggle(node, isChecked2);
          updateCheckedKeys();
          if (nodeClick) {
            afterNodeCheck(node, isChecked2);
          }
        };
        const afterNodeCheck = (node, checked) => {
          const { checkedNodes, checkedKeys: checkedKeys2 } = getChecked();
          const { halfCheckedNodes, halfCheckedKeys } = getHalfChecked();
          emit2(NODE_CHECK, node.data, {
            checkedKeys: checkedKeys2,
            checkedNodes,
            halfCheckedKeys,
            halfCheckedNodes
          });
          emit2(NODE_CHECK_CHANGE, node.data, checked);
        };
        function getCheckedKeys(leafOnly = false) {
          return getChecked(leafOnly).checkedKeys;
        }
        function getCheckedNodes(leafOnly = false) {
          return getChecked(leafOnly).checkedNodes;
        }
        function getHalfCheckedKeys() {
          return getHalfChecked().halfCheckedKeys;
        }
        function getHalfCheckedNodes() {
          return getHalfChecked().halfCheckedNodes;
        }
        function getChecked(leafOnly = false) {
          const checkedNodes = [];
          const keys2 = [];
          if ((tree == null ? void 0 : tree.value) && props2.showCheckbox) {
            const { treeNodeMap } = tree.value;
            checkedKeys.value.forEach((key) => {
              const node = treeNodeMap.get(key);
              if (node && (!leafOnly || leafOnly && node.isLeaf)) {
                keys2.push(key);
                checkedNodes.push(node.data);
              }
            });
          }
          return {
            checkedKeys: keys2,
            checkedNodes
          };
        }
        function getHalfChecked() {
          const halfCheckedNodes = [];
          const halfCheckedKeys = [];
          if ((tree == null ? void 0 : tree.value) && props2.showCheckbox) {
            const { treeNodeMap } = tree.value;
            indeterminateKeys.value.forEach((key) => {
              const node = treeNodeMap.get(key);
              if (node) {
                halfCheckedKeys.push(key);
                halfCheckedNodes.push(node.data);
              }
            });
          }
          return {
            halfCheckedNodes,
            halfCheckedKeys
          };
        }
        function setCheckedKeys(keys2) {
          checkedKeys.value.clear();
          indeterminateKeys.value.clear();
          _setCheckedKeys(keys2);
        }
        function setChecked2(key, isChecked2) {
          if ((tree == null ? void 0 : tree.value) && props2.showCheckbox) {
            const node = tree.value.treeNodeMap.get(key);
            if (node) {
              toggleCheckbox(node, isChecked2, false);
            }
          }
        }
        function _setCheckedKeys(keys2) {
          if (tree == null ? void 0 : tree.value) {
            const { treeNodeMap } = tree.value;
            if (props2.showCheckbox && treeNodeMap && keys2) {
              for (const key of keys2) {
                const node = treeNodeMap.get(key);
                if (node && !isChecked(node)) {
                  toggleCheckbox(node, true, false);
                }
              }
            }
          }
        }
        return {
          updateCheckedKeys,
          toggleCheckbox,
          isChecked,
          isIndeterminate,
          getCheckedKeys,
          getCheckedNodes,
          getHalfCheckedKeys,
          getHalfCheckedNodes,
          setChecked: setChecked2,
          setCheckedKeys
        };
      }
      function useFilter(props2, tree) {
        const hiddenNodeKeySet = ref(/* @__PURE__ */ new Set([]));
        const hiddenExpandIconKeySet = ref(/* @__PURE__ */ new Set([]));
        const filterable = computed(() => {
          return isFunction$2(props2.filterMethod);
        });
        function doFilter(query) {
          var _a2;
          if (!filterable.value) {
            return;
          }
          const expandKeySet = /* @__PURE__ */ new Set();
          const hiddenExpandIconKeys = hiddenExpandIconKeySet.value;
          const hiddenKeys = hiddenNodeKeySet.value;
          const family = [];
          const nodes = ((_a2 = tree.value) == null ? void 0 : _a2.treeNodes) || [];
          const filter = props2.filterMethod;
          hiddenKeys.clear();
          function traverse2(nodes2) {
            nodes2.forEach((node) => {
              family.push(node);
              if (filter == null ? void 0 : filter(query, node.data)) {
                family.forEach((member) => {
                  expandKeySet.add(member.key);
                });
              } else if (node.isLeaf) {
                hiddenKeys.add(node.key);
              }
              const children = node.children;
              if (children) {
                traverse2(children);
              }
              if (!node.isLeaf) {
                if (!expandKeySet.has(node.key)) {
                  hiddenKeys.add(node.key);
                } else if (children) {
                  let allHidden = true;
                  for (const childNode of children) {
                    if (!hiddenKeys.has(childNode.key)) {
                      allHidden = false;
                      break;
                    }
                  }
                  if (allHidden) {
                    hiddenExpandIconKeys.add(node.key);
                  } else {
                    hiddenExpandIconKeys.delete(node.key);
                  }
                }
              }
              family.pop();
            });
          }
          traverse2(nodes);
          return expandKeySet;
        }
        function isForceHiddenExpandIcon(node) {
          return hiddenExpandIconKeySet.value.has(node.key);
        }
        return {
          hiddenExpandIconKeySet,
          hiddenNodeKeySet,
          doFilter,
          isForceHiddenExpandIcon
        };
      }
      function useTree(props2, emit2) {
        const expandedKeySet = ref(new Set(props2.defaultExpandedKeys));
        const currentKey = ref();
        const tree = shallowRef();
        watch(() => props2.currentNodeKey, (key) => {
          currentKey.value = key;
        }, {
          immediate: true
        });
        watch(() => props2.data, (data) => {
          setData(data);
        }, {
          immediate: true
        });
        const {
          isIndeterminate,
          isChecked,
          toggleCheckbox,
          getCheckedKeys,
          getCheckedNodes,
          getHalfCheckedKeys,
          getHalfCheckedNodes,
          setChecked: setChecked2,
          setCheckedKeys
        } = useCheck(props2, tree);
        const { doFilter, hiddenNodeKeySet, isForceHiddenExpandIcon } = useFilter(props2, tree);
        const valueKey = computed(() => {
          var _a2;
          return ((_a2 = props2.props) == null ? void 0 : _a2.value) || TreeOptionsEnum.KEY;
        });
        const childrenKey = computed(() => {
          var _a2;
          return ((_a2 = props2.props) == null ? void 0 : _a2.children) || TreeOptionsEnum.CHILDREN;
        });
        const disabledKey = computed(() => {
          var _a2;
          return ((_a2 = props2.props) == null ? void 0 : _a2.disabled) || TreeOptionsEnum.DISABLED;
        });
        const labelKey = computed(() => {
          var _a2;
          return ((_a2 = props2.props) == null ? void 0 : _a2.label) || TreeOptionsEnum.LABEL;
        });
        const flattenTree = computed(() => {
          const expandedKeys = expandedKeySet.value;
          const hiddenKeys = hiddenNodeKeySet.value;
          const flattenNodes = [];
          const nodes = tree.value && tree.value.treeNodes || [];
          function traverse2() {
            const stack = [];
            for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
              stack.push(nodes[i2]);
            }
            while (stack.length) {
              const node = stack.pop();
              if (!node)
                continue;
              if (!hiddenKeys.has(node.key)) {
                flattenNodes.push(node);
              }
              if (expandedKeys.has(node.key)) {
                const children = node.children;
                if (children) {
                  const length = children.length;
                  for (let i2 = length - 1; i2 >= 0; --i2) {
                    stack.push(children[i2]);
                  }
                }
              }
            }
          }
          traverse2();
          return flattenNodes;
        });
        const isNotEmpty = computed(() => {
          return flattenTree.value.length > 0;
        });
        function createTree(data) {
          const treeNodeMap = /* @__PURE__ */ new Map();
          const levelTreeNodeMap = /* @__PURE__ */ new Map();
          let maxLevel = 1;
          function traverse2(nodes, level = 1, parent = void 0) {
            var _a2;
            const siblings = [];
            for (const rawNode of nodes) {
              const value = getKey(rawNode);
              const node = {
                level,
                key: value,
                data: rawNode
              };
              node.label = getLabel(rawNode);
              node.parent = parent;
              const children = getChildren(rawNode);
              node.disabled = getDisabled(rawNode);
              node.isLeaf = !children || children.length === 0;
              if (children && children.length) {
                node.children = traverse2(children, level + 1, node);
              }
              siblings.push(node);
              treeNodeMap.set(value, node);
              if (!levelTreeNodeMap.has(level)) {
                levelTreeNodeMap.set(level, []);
              }
              (_a2 = levelTreeNodeMap.get(level)) == null ? void 0 : _a2.push(node);
            }
            if (level > maxLevel) {
              maxLevel = level;
            }
            return siblings;
          }
          const treeNodes = traverse2(data);
          return {
            treeNodeMap,
            levelTreeNodeMap,
            maxLevel,
            treeNodes
          };
        }
        function filter(query) {
          const keys2 = doFilter(query);
          if (keys2) {
            expandedKeySet.value = keys2;
          }
        }
        function getChildren(node) {
          return node[childrenKey.value];
        }
        function getKey(node) {
          if (!node) {
            return "";
          }
          return node[valueKey.value];
        }
        function getDisabled(node) {
          return node[disabledKey.value];
        }
        function getLabel(node) {
          return node[labelKey.value];
        }
        function toggleExpand(node) {
          const expandedKeys = expandedKeySet.value;
          if (expandedKeys.has(node.key)) {
            collapseNode(node);
          } else {
            expandNode(node);
          }
        }
        function setExpandedKeys(keys2) {
          expandedKeySet.value = new Set(keys2);
        }
        function handleNodeClick(node, e2) {
          emit2(NODE_CLICK, node.data, node, e2);
          handleCurrentChange(node);
          if (props2.expandOnClickNode) {
            toggleExpand(node);
          }
          if (props2.showCheckbox && props2.checkOnClickNode && !node.disabled) {
            toggleCheckbox(node, !isChecked(node), true);
          }
        }
        function handleCurrentChange(node) {
          if (!isCurrent(node)) {
            currentKey.value = node.key;
            emit2(CURRENT_CHANGE, node.data, node);
          }
        }
        function handleNodeCheck(node, checked) {
          toggleCheckbox(node, checked);
        }
        function expandNode(node) {
          const keySet = expandedKeySet.value;
          if (tree.value && props2.accordion) {
            const { treeNodeMap } = tree.value;
            keySet.forEach((key) => {
              const treeNode = treeNodeMap.get(key);
              if (node && node.level === (treeNode == null ? void 0 : treeNode.level)) {
                keySet.delete(key);
              }
            });
          }
          keySet.add(node.key);
          emit2(NODE_EXPAND, node.data, node);
        }
        function collapseNode(node) {
          expandedKeySet.value.delete(node.key);
          emit2(NODE_COLLAPSE, node.data, node);
        }
        function isExpanded(node) {
          return expandedKeySet.value.has(node.key);
        }
        function isDisabled(node) {
          return !!node.disabled;
        }
        function isCurrent(node) {
          const current = currentKey.value;
          return !!current && current === node.key;
        }
        function getCurrentNode() {
          var _a2, _b;
          if (!currentKey.value)
            return void 0;
          return (_b = (_a2 = tree.value) == null ? void 0 : _a2.treeNodeMap.get(currentKey.value)) == null ? void 0 : _b.data;
        }
        function getCurrentKey() {
          return currentKey.value;
        }
        function setCurrentKey(key) {
          currentKey.value = key;
        }
        function setData(data) {
          nextTick(() => tree.value = createTree(data));
        }
        function getNode(data) {
          var _a2;
          const key = isObject$1(data) ? getKey(data) : data;
          return (_a2 = tree.value) == null ? void 0 : _a2.treeNodeMap.get(key);
        }
        return {
          tree,
          flattenTree,
          isNotEmpty,
          getKey,
          getChildren,
          toggleExpand,
          toggleCheckbox,
          isExpanded,
          isChecked,
          isIndeterminate,
          isDisabled,
          isCurrent,
          isForceHiddenExpandIcon,
          handleNodeClick,
          handleNodeCheck,
          getCurrentNode,
          getCurrentKey,
          setCurrentKey,
          getCheckedKeys,
          getCheckedNodes,
          getHalfCheckedKeys,
          getHalfCheckedNodes,
          setChecked: setChecked2,
          setCheckedKeys,
          filter,
          setData,
          getNode,
          expandNode,
          collapseNode,
          setExpandedKeys
        };
      }
      var ElNodeContent = defineComponent({
        name: "ElTreeNodeContent",
        props: treeNodeContentProps,
        setup(props2) {
          const tree = inject(ROOT_TREE_INJECTION_KEY);
          const ns = useNamespace("tree");
          return () => {
            const node = props2.node;
            const { data } = node;
            return (tree == null ? void 0 : tree.ctx.slots.default) ? tree.ctx.slots.default({ node, data }) : h$1("span", { class: ns.be("node", "label") }, [node == null ? void 0 : node.label]);
          };
        }
      });
      const _hoisted_1$v = ["aria-expanded", "aria-disabled", "aria-checked", "data-key", "onClick"];
      const __default__$3 = defineComponent({
        name: "ElTreeNode"
      });
      const _sfc_main$d = /* @__PURE__ */ defineComponent({
        ...__default__$3,
        props: treeNodeProps,
        emits: treeNodeEmits,
        setup(__props, { emit: emit2 }) {
          const props2 = __props;
          const tree = inject(ROOT_TREE_INJECTION_KEY);
          const ns = useNamespace("tree");
          const indent = computed(() => {
            var _a2;
            return (_a2 = tree == null ? void 0 : tree.props.indent) != null ? _a2 : 16;
          });
          const icon2 = computed(() => {
            var _a2;
            return (_a2 = tree == null ? void 0 : tree.props.icon) != null ? _a2 : caret_right_default;
          });
          const handleClick = (e2) => {
            emit2("click", props2.node, e2);
          };
          const handleExpandIconClick = () => {
            emit2("toggle", props2.node);
          };
          const handleCheckChange = (value) => {
            emit2("check", props2.node, value);
          };
          const handleContextMenu = (event) => {
            var _a2, _b, _c, _d;
            if ((_c = (_b = (_a2 = tree == null ? void 0 : tree.instance) == null ? void 0 : _a2.vnode) == null ? void 0 : _b.props) == null ? void 0 : _c["onNodeContextmenu"]) {
              event.stopPropagation();
              event.preventDefault();
            }
            tree == null ? void 0 : tree.ctx.emit(NODE_CONTEXTMENU, event, (_d = props2.node) == null ? void 0 : _d.data, props2.node);
          };
          return (_ctx, _cache) => {
            var _a2, _b, _c;
            return openBlock(), createElementBlock("div", {
              ref: "node$",
              class: normalizeClass([
                unref(ns).b("node"),
                unref(ns).is("expanded", _ctx.expanded),
                unref(ns).is("current", _ctx.current),
                unref(ns).is("focusable", !_ctx.disabled),
                unref(ns).is("checked", !_ctx.disabled && _ctx.checked)
              ]),
              role: "treeitem",
              tabindex: "-1",
              "aria-expanded": _ctx.expanded,
              "aria-disabled": _ctx.disabled,
              "aria-checked": _ctx.checked,
              "data-key": (_a2 = _ctx.node) == null ? void 0 : _a2.key,
              onClick: withModifiers(handleClick, ["stop"]),
              onContextmenu: handleContextMenu
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).be("node", "content")),
                style: normalizeStyle({
                  paddingLeft: `${(_ctx.node.level - 1) * unref(indent)}px`,
                  height: _ctx.itemSize + "px"
                })
              }, [
                unref(icon2) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass([
                    unref(ns).is("leaf", !!((_b = _ctx.node) == null ? void 0 : _b.isLeaf)),
                    unref(ns).is("hidden", _ctx.hiddenExpandIcon),
                    {
                      expanded: !((_c = _ctx.node) == null ? void 0 : _c.isLeaf) && _ctx.expanded
                    },
                    unref(ns).be("node", "expand-icon")
                  ]),
                  onClick: withModifiers(handleExpandIconClick, ["stop"])
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(icon2))))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                _ctx.showCheckbox ? (openBlock(), createBlock(unref(ElCheckbox), {
                  key: 1,
                  "model-value": _ctx.checked,
                  indeterminate: _ctx.indeterminate,
                  disabled: _ctx.disabled,
                  onChange: handleCheckChange,
                  onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                  }, ["stop"]))
                }, null, 8, ["model-value", "indeterminate", "disabled"])) : createCommentVNode("v-if", true),
                createVNode(unref(ElNodeContent), { node: _ctx.node }, null, 8, ["node"])
              ], 6)
            ], 42, _hoisted_1$v);
          };
        }
      });
      var ElTreeNode = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree-node.vue"]]);
      const __default__$2 = defineComponent({
        name: "ElTreeV2"
      });
      const _sfc_main$c = /* @__PURE__ */ defineComponent({
        ...__default__$2,
        props: treeProps,
        emits: treeEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props2 = __props;
          const slots = useSlots();
          const treeNodeSize = computed(() => props2.itemSize);
          provide(ROOT_TREE_INJECTION_KEY, {
            ctx: {
              emit: emit2,
              slots
            },
            props: props2,
            instance: getCurrentInstance()
          });
          provide(formItemContextKey, void 0);
          const { t: t2 } = useLocale();
          const ns = useNamespace("tree");
          const {
            flattenTree,
            isNotEmpty,
            toggleExpand,
            isExpanded,
            isIndeterminate,
            isChecked,
            isDisabled,
            isCurrent,
            isForceHiddenExpandIcon,
            handleNodeClick,
            handleNodeCheck,
            toggleCheckbox,
            getCurrentNode,
            getCurrentKey,
            setCurrentKey,
            getCheckedKeys,
            getCheckedNodes,
            getHalfCheckedKeys,
            getHalfCheckedNodes,
            setChecked: setChecked2,
            setCheckedKeys,
            filter,
            setData,
            getNode,
            expandNode,
            collapseNode,
            setExpandedKeys
          } = useTree(props2, emit2);
          expose({
            toggleCheckbox,
            getCurrentNode,
            getCurrentKey,
            setCurrentKey,
            getCheckedKeys,
            getCheckedNodes,
            getHalfCheckedKeys,
            getHalfCheckedNodes,
            setChecked: setChecked2,
            setCheckedKeys,
            filter,
            setData,
            getNode,
            expandNode,
            collapseNode,
            setExpandedKeys
          });
          return (_ctx, _cache) => {
            var _a2;
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b(), { [unref(ns).m("highlight-current")]: _ctx.highlightCurrent }]),
              role: "tree"
            }, [
              unref(isNotEmpty) ? (openBlock(), createBlock(unref(FixedSizeList), {
                key: 0,
                "class-name": unref(ns).b("virtual-list"),
                data: unref(flattenTree),
                total: unref(flattenTree).length,
                height: _ctx.height,
                "item-size": unref(treeNodeSize),
                "perf-mode": _ctx.perfMode
              }, {
                default: withCtx(({ data, index, style }) => [
                  (openBlock(), createBlock(ElTreeNode, {
                    key: data[index].key,
                    style: normalizeStyle(style),
                    node: data[index],
                    expanded: unref(isExpanded)(data[index]),
                    "show-checkbox": _ctx.showCheckbox,
                    checked: unref(isChecked)(data[index]),
                    indeterminate: unref(isIndeterminate)(data[index]),
                    "item-size": unref(treeNodeSize),
                    disabled: unref(isDisabled)(data[index]),
                    current: unref(isCurrent)(data[index]),
                    "hidden-expand-icon": unref(isForceHiddenExpandIcon)(data[index]),
                    onClick: unref(handleNodeClick),
                    onToggle: unref(toggleExpand),
                    onCheck: unref(handleNodeCheck)
                  }, null, 8, ["style", "node", "expanded", "show-checkbox", "checked", "indeterminate", "item-size", "disabled", "current", "hidden-expand-icon", "onClick", "onToggle", "onCheck"]))
                ]),
                _: 1
              }, 8, ["class-name", "data", "total", "height", "item-size", "perf-mode"])) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).e("empty-block"))
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(unref(ns).e("empty-text"))
                }, toDisplayString((_a2 = _ctx.emptyText) != null ? _a2 : unref(t2)("el.tree.emptyText")), 3)
              ], 2))
            ], 2);
          };
        }
      });
      var TreeV2 = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree.vue"]]);
      const ElTreeV2 = withInstall(TreeV2);
      const messageTypes = ["success", "info", "warning", "error"];
      const messageDefaults = mutable({
        customClass: "",
        center: false,
        dangerouslyUseHTMLString: false,
        duration: 3e3,
        icon: void 0,
        id: "",
        message: "",
        onClose: void 0,
        showClose: false,
        type: "info",
        offset: 16,
        zIndex: 0,
        grouping: false,
        repeatNum: 1,
        appendTo: isClient$1 ? document.body : void 0
      });
      const messageProps = buildProps({
        customClass: {
          type: String,
          default: messageDefaults.customClass
        },
        center: {
          type: Boolean,
          default: messageDefaults.center
        },
        dangerouslyUseHTMLString: {
          type: Boolean,
          default: messageDefaults.dangerouslyUseHTMLString
        },
        duration: {
          type: Number,
          default: messageDefaults.duration
        },
        icon: {
          type: iconPropType,
          default: messageDefaults.icon
        },
        id: {
          type: String,
          default: messageDefaults.id
        },
        message: {
          type: definePropType([
            String,
            Object,
            Function
          ]),
          default: messageDefaults.message
        },
        onClose: {
          type: definePropType(Function),
          required: false
        },
        showClose: {
          type: Boolean,
          default: messageDefaults.showClose
        },
        type: {
          type: String,
          values: messageTypes,
          default: messageDefaults.type
        },
        offset: {
          type: Number,
          default: messageDefaults.offset
        },
        zIndex: {
          type: Number,
          default: messageDefaults.zIndex
        },
        grouping: {
          type: Boolean,
          default: messageDefaults.grouping
        },
        repeatNum: {
          type: Number,
          default: messageDefaults.repeatNum
        }
      });
      const messageEmits = {
        destroy: () => true
      };
      const instances = shallowReactive([]);
      const getInstance = (id2) => {
        const idx = instances.findIndex((instance) => instance.id === id2);
        const current = instances[idx];
        let prev;
        if (idx > 0) {
          prev = instances[idx - 1];
        }
        return { current, prev };
      };
      const getLastOffset = (id2) => {
        const { prev } = getInstance(id2);
        if (!prev)
          return 0;
        return prev.vm.exposed.bottom.value;
      };
      const getOffsetOrSpace = (id2, offset) => {
        const idx = instances.findIndex((instance) => instance.id === id2);
        return idx > 0 ? 20 : offset;
      };
      const _hoisted_1$u = ["id"];
      const _hoisted_2$s = ["innerHTML"];
      const __default__$1 = defineComponent({
        name: "ElMessage"
      });
      const _sfc_main$b = /* @__PURE__ */ defineComponent({
        ...__default__$1,
        props: messageProps,
        emits: messageEmits,
        setup(__props, { expose }) {
          const props2 = __props;
          const { Close } = TypeComponents;
          const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("message");
          const { currentZIndex, nextZIndex } = zIndex2;
          const messageRef = ref();
          const visible = ref(false);
          const height = ref(0);
          let stopTimer = void 0;
          const badgeType = computed(() => props2.type ? props2.type === "error" ? "danger" : props2.type : "info");
          const typeClass = computed(() => {
            const type2 = props2.type;
            return { [ns.bm("icon", type2)]: type2 && TypeComponentsMap[type2] };
          });
          const iconComponent = computed(() => props2.icon || TypeComponentsMap[props2.type] || "");
          const lastOffset = computed(() => getLastOffset(props2.id));
          const offset = computed(() => getOffsetOrSpace(props2.id, props2.offset) + lastOffset.value);
          const bottom = computed(() => height.value + offset.value);
          const customStyle = computed(() => ({
            top: `${offset.value}px`,
            zIndex: currentZIndex.value
          }));
          function startTimer() {
            if (props2.duration === 0)
              return;
            ({ stop: stopTimer } = useTimeoutFn$1(() => {
              close2();
            }, props2.duration));
          }
          function clearTimer() {
            stopTimer == null ? void 0 : stopTimer();
          }
          function close2() {
            visible.value = false;
          }
          function keydown({ code }) {
            if (code === EVENT_CODE.esc) {
              close2();
            }
          }
          onMounted(() => {
            startTimer();
            nextZIndex();
            visible.value = true;
          });
          watch(() => props2.repeatNum, () => {
            clearTimer();
            startTimer();
          });
          useEventListener$1(document, "keydown", keydown);
          useResizeObserver(messageRef, () => {
            height.value = messageRef.value.getBoundingClientRect().height;
          });
          expose({
            visible,
            bottom,
            close: close2
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              onBeforeLeave: _ctx.onClose,
              onAfterLeave: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("destroy")),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  id: _ctx.id,
                  ref_key: "messageRef",
                  ref: messageRef,
                  class: normalizeClass([
                    unref(ns).b(),
                    { [unref(ns).m(_ctx.type)]: _ctx.type && !_ctx.icon },
                    unref(ns).is("center", _ctx.center),
                    unref(ns).is("closable", _ctx.showClose),
                    _ctx.customClass
                  ]),
                  style: normalizeStyle(unref(customStyle)),
                  role: "alert",
                  onMouseenter: clearTimer,
                  onMouseleave: startTimer
                }, [
                  _ctx.repeatNum > 1 ? (openBlock(), createBlock(unref(ElBadge), {
                    key: 0,
                    value: _ctx.repeatNum,
                    type: unref(badgeType),
                    class: normalizeClass(unref(ns).e("badge"))
                  }, null, 8, ["value", "type", "class"])) : createCommentVNode("v-if", true),
                  unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass([unref(ns).e("icon"), unref(typeClass)])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  renderSlot(_ctx.$slots, "default", {}, () => [
                    !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", {
                      key: 0,
                      class: normalizeClass(unref(ns).e("content"))
                    }, toDisplayString(_ctx.message), 3)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                      createBaseVNode("p", {
                        class: normalizeClass(unref(ns).e("content")),
                        innerHTML: _ctx.message
                      }, null, 10, _hoisted_2$s)
                    ], 2112))
                  ]),
                  _ctx.showClose ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 2,
                    class: normalizeClass(unref(ns).e("closeBtn")),
                    onClick: withModifiers(close2, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(Close))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ], 46, _hoisted_1$u), [
                  [vShow, visible.value]
                ])
              ]),
              _: 3
            }, 8, ["name", "onBeforeLeave"]);
          };
        }
      });
      var MessageConstructor = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]]);
      let seed$1 = 1;
      const normalizeOptions = (params) => {
        const options = !params || isString$2(params) || isVNode(params) || isFunction$2(params) ? { message: params } : params;
        const normalized = {
          ...messageDefaults,
          ...options
        };
        if (!normalized.appendTo) {
          normalized.appendTo = document.body;
        } else if (isString$2(normalized.appendTo)) {
          let appendTo = document.querySelector(normalized.appendTo);
          if (!isElement(appendTo)) {
            appendTo = document.body;
          }
          normalized.appendTo = appendTo;
        }
        return normalized;
      };
      const closeMessage = (instance) => {
        const idx = instances.indexOf(instance);
        if (idx === -1)
          return;
        instances.splice(idx, 1);
        const { handler } = instance;
        handler.close();
      };
      const createMessage = ({ appendTo, ...options }, context2) => {
        const id2 = `message_${seed$1++}`;
        const userOnClose = options.onClose;
        const container = document.createElement("div");
        const props2 = {
          ...options,
          id: id2,
          onClose: () => {
            userOnClose == null ? void 0 : userOnClose();
            closeMessage(instance);
          },
          onDestroy: () => {
            render$k(null, container);
          }
        };
        const vnode = createVNode(MessageConstructor, props2, isFunction$2(props2.message) || isVNode(props2.message) ? {
          default: isFunction$2(props2.message) ? props2.message : () => props2.message
        } : null);
        vnode.appContext = context2 || message._context;
        render$k(vnode, container);
        appendTo.appendChild(container.firstElementChild);
        const vm = vnode.component;
        const handler = {
          close: () => {
            vm.exposed.visible.value = false;
          }
        };
        const instance = {
          id: id2,
          vnode,
          vm,
          handler,
          props: vnode.component.props
        };
        return instance;
      };
      const message = (options = {}, context2) => {
        if (!isClient$1)
          return { close: () => void 0 };
        if (isNumber(messageConfig.max) && instances.length >= messageConfig.max) {
          return { close: () => void 0 };
        }
        const normalized = normalizeOptions(options);
        if (normalized.grouping && instances.length) {
          const instance2 = instances.find(({ vnode: vm }) => {
            var _a2;
            return ((_a2 = vm.props) == null ? void 0 : _a2.message) === normalized.message;
          });
          if (instance2) {
            instance2.props.repeatNum += 1;
            instance2.props.type = normalized.type;
            return instance2.handler;
          }
        }
        const instance = createMessage(normalized, context2);
        instances.push(instance);
        return instance.handler;
      };
      messageTypes.forEach((type2) => {
        message[type2] = (options = {}, appContext) => {
          const normalized = normalizeOptions(options);
          return message({ ...normalized, type: type2 }, appContext);
        };
      });
      function closeAll$1(type2) {
        for (const instance of instances) {
          if (!type2 || type2 === instance.props.type) {
            instance.handler.close();
          }
        }
      }
      message.closeAll = closeAll$1;
      message._context = null;
      const ElMessage = withInstallFunction(message, "$message");
      const _sfc_main$a = defineComponent({
        name: "ElMessageBox",
        directives: {
          TrapFocus
        },
        components: {
          ElButton,
          ElFocusTrap,
          ElInput,
          ElOverlay,
          ElIcon,
          ...TypeComponents
        },
        inheritAttrs: false,
        props: {
          buttonSize: {
            type: String,
            validator: isValidComponentSize
          },
          modal: {
            type: Boolean,
            default: true
          },
          lockScroll: {
            type: Boolean,
            default: true
          },
          showClose: {
            type: Boolean,
            default: true
          },
          closeOnClickModal: {
            type: Boolean,
            default: true
          },
          closeOnPressEscape: {
            type: Boolean,
            default: true
          },
          closeOnHashChange: {
            type: Boolean,
            default: true
          },
          center: Boolean,
          draggable: Boolean,
          roundButton: {
            default: false,
            type: Boolean
          },
          container: {
            type: String,
            default: "body"
          },
          boxType: {
            type: String,
            default: ""
          }
        },
        emits: ["vanish", "action"],
        setup(props2, { emit: emit2 }) {
          const {
            locale,
            zIndex: zIndex2,
            ns,
            size: btnSize
          } = useGlobalComponentSettings("message-box", computed(() => props2.buttonSize));
          const { t: t2 } = locale;
          const { nextZIndex } = zIndex2;
          const visible = ref(false);
          const state = reactive({
            autofocus: true,
            beforeClose: null,
            callback: null,
            cancelButtonText: "",
            cancelButtonClass: "",
            confirmButtonText: "",
            confirmButtonClass: "",
            customClass: "",
            customStyle: {},
            dangerouslyUseHTMLString: false,
            distinguishCancelAndClose: false,
            icon: "",
            inputPattern: null,
            inputPlaceholder: "",
            inputType: "text",
            inputValue: null,
            inputValidator: null,
            inputErrorMessage: "",
            message: null,
            modalFade: true,
            modalClass: "",
            showCancelButton: false,
            showConfirmButton: true,
            type: "",
            title: void 0,
            showInput: false,
            action: "",
            confirmButtonLoading: false,
            cancelButtonLoading: false,
            confirmButtonDisabled: false,
            editorErrorMessage: "",
            validateError: false,
            zIndex: nextZIndex()
          });
          const typeClass = computed(() => {
            const type2 = state.type;
            return { [ns.bm("icon", type2)]: type2 && TypeComponentsMap[type2] };
          });
          const contentId = useId();
          const inputId = useId();
          const iconComponent = computed(() => state.icon || TypeComponentsMap[state.type] || "");
          const hasMessage = computed(() => !!state.message);
          const rootRef = ref();
          const headerRef = ref();
          const focusStartRef = ref();
          const inputRef = ref();
          const confirmRef = ref();
          const confirmButtonClasses = computed(() => state.confirmButtonClass);
          watch(() => state.inputValue, async (val) => {
            await nextTick();
            if (props2.boxType === "prompt" && val !== null) {
              validate();
            }
          }, { immediate: true });
          watch(() => visible.value, (val) => {
            var _a2, _b;
            if (val) {
              if (props2.boxType !== "prompt") {
                if (state.autofocus) {
                  focusStartRef.value = (_b = (_a2 = confirmRef.value) == null ? void 0 : _a2.$el) != null ? _b : rootRef.value;
                } else {
                  focusStartRef.value = rootRef.value;
                }
              }
              state.zIndex = nextZIndex();
            }
            if (props2.boxType !== "prompt")
              return;
            if (val) {
              nextTick().then(() => {
                var _a22;
                if (inputRef.value && inputRef.value.$el) {
                  if (state.autofocus) {
                    focusStartRef.value = (_a22 = getInputElement()) != null ? _a22 : rootRef.value;
                  } else {
                    focusStartRef.value = rootRef.value;
                  }
                }
              });
            } else {
              state.editorErrorMessage = "";
              state.validateError = false;
            }
          });
          const draggable = computed(() => props2.draggable);
          useDraggable$1(rootRef, headerRef, draggable);
          onMounted(async () => {
            await nextTick();
            if (props2.closeOnHashChange) {
              window.addEventListener("hashchange", doClose);
            }
          });
          onBeforeUnmount(() => {
            if (props2.closeOnHashChange) {
              window.removeEventListener("hashchange", doClose);
            }
          });
          function doClose() {
            if (!visible.value)
              return;
            visible.value = false;
            nextTick(() => {
              if (state.action)
                emit2("action", state.action);
            });
          }
          const handleWrapperClick = () => {
            if (props2.closeOnClickModal) {
              handleAction(state.distinguishCancelAndClose ? "close" : "cancel");
            }
          };
          const overlayEvent = useSameTarget(handleWrapperClick);
          const handleInputEnter = (e2) => {
            if (state.inputType !== "textarea") {
              e2.preventDefault();
              return handleAction("confirm");
            }
          };
          const handleAction = (action) => {
            var _a2;
            if (props2.boxType === "prompt" && action === "confirm" && !validate()) {
              return;
            }
            state.action = action;
            if (state.beforeClose) {
              (_a2 = state.beforeClose) == null ? void 0 : _a2.call(state, action, state, doClose);
            } else {
              doClose();
            }
          };
          const validate = () => {
            if (props2.boxType === "prompt") {
              const inputPattern = state.inputPattern;
              if (inputPattern && !inputPattern.test(state.inputValue || "")) {
                state.editorErrorMessage = state.inputErrorMessage || t2("el.messagebox.error");
                state.validateError = true;
                return false;
              }
              const inputValidator = state.inputValidator;
              if (typeof inputValidator === "function") {
                const validateResult = inputValidator(state.inputValue);
                if (validateResult === false) {
                  state.editorErrorMessage = state.inputErrorMessage || t2("el.messagebox.error");
                  state.validateError = true;
                  return false;
                }
                if (typeof validateResult === "string") {
                  state.editorErrorMessage = validateResult;
                  state.validateError = true;
                  return false;
                }
              }
            }
            state.editorErrorMessage = "";
            state.validateError = false;
            return true;
          };
          const getInputElement = () => {
            const inputRefs = inputRef.value.$refs;
            return inputRefs.input || inputRefs.textarea;
          };
          const handleClose = () => {
            handleAction("close");
          };
          const onCloseRequested = () => {
            if (props2.closeOnPressEscape) {
              handleClose();
            }
          };
          if (props2.lockScroll) {
            useLockscreen(visible);
          }
          return {
            ...toRefs$1(state),
            ns,
            overlayEvent,
            visible,
            hasMessage,
            typeClass,
            contentId,
            inputId,
            btnSize,
            iconComponent,
            confirmButtonClasses,
            rootRef,
            focusStartRef,
            headerRef,
            inputRef,
            confirmRef,
            doClose,
            handleClose,
            onCloseRequested,
            handleWrapperClick,
            handleInputEnter,
            handleAction,
            t: t2
          };
        }
      });
      const _hoisted_1$t = ["aria-label", "aria-describedby"];
      const _hoisted_2$r = ["aria-label"];
      const _hoisted_3$p = ["id"];
      function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_icon = resolveComponent("el-icon");
        const _component_close = resolveComponent("close");
        const _component_el_input = resolveComponent("el-input");
        const _component_el_button = resolveComponent("el-button");
        const _component_el_focus_trap = resolveComponent("el-focus-trap");
        const _component_el_overlay = resolveComponent("el-overlay");
        return openBlock(), createBlock(Transition, {
          name: "fade-in-linear",
          onAfterLeave: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("vanish")),
          persisted: ""
        }, {
          default: withCtx(() => [
            withDirectives(createVNode(_component_el_overlay, {
              "z-index": _ctx.zIndex,
              "overlay-class": [_ctx.ns.is("message-box"), _ctx.modalClass],
              mask: _ctx.modal
            }, {
              default: withCtx(() => [
                createBaseVNode("div", {
                  role: "dialog",
                  "aria-label": _ctx.title,
                  "aria-modal": "true",
                  "aria-describedby": !_ctx.showInput ? _ctx.contentId : void 0,
                  class: normalizeClass(`${_ctx.ns.namespace.value}-overlay-message-box`),
                  onClick: _cache[8] || (_cache[8] = (...args) => _ctx.overlayEvent.onClick && _ctx.overlayEvent.onClick(...args)),
                  onMousedown: _cache[9] || (_cache[9] = (...args) => _ctx.overlayEvent.onMousedown && _ctx.overlayEvent.onMousedown(...args)),
                  onMouseup: _cache[10] || (_cache[10] = (...args) => _ctx.overlayEvent.onMouseup && _ctx.overlayEvent.onMouseup(...args))
                }, [
                  createVNode(_component_el_focus_trap, {
                    loop: "",
                    trapped: _ctx.visible,
                    "focus-trap-el": _ctx.rootRef,
                    "focus-start-el": _ctx.focusStartRef,
                    onReleaseRequested: _ctx.onCloseRequested
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        ref: "rootRef",
                        class: normalizeClass([
                          _ctx.ns.b(),
                          _ctx.customClass,
                          _ctx.ns.is("draggable", _ctx.draggable),
                          { [_ctx.ns.m("center")]: _ctx.center }
                        ]),
                        style: normalizeStyle(_ctx.customStyle),
                        tabindex: "-1",
                        onClick: _cache[7] || (_cache[7] = withModifiers(() => {
                        }, ["stop"]))
                      }, [
                        _ctx.title !== null && _ctx.title !== void 0 ? (openBlock(), createElementBlock("div", {
                          key: 0,
                          ref: "headerRef",
                          class: normalizeClass(_ctx.ns.e("header"))
                        }, [
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.ns.e("title"))
                          }, [
                            _ctx.iconComponent && _ctx.center ? (openBlock(), createBlock(_component_el_icon, {
                              key: 0,
                              class: normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                            }, {
                              default: withCtx(() => [
                                (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                              ]),
                              _: 1
                            }, 8, ["class"])) : createCommentVNode("v-if", true),
                            createBaseVNode("span", null, toDisplayString(_ctx.title), 1)
                          ], 2),
                          _ctx.showClose ? (openBlock(), createElementBlock("button", {
                            key: 0,
                            type: "button",
                            class: normalizeClass(_ctx.ns.e("headerbtn")),
                            "aria-label": _ctx.t("el.messagebox.close"),
                            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel")),
                            onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
                          }, [
                            createVNode(_component_el_icon, {
                              class: normalizeClass(_ctx.ns.e("close"))
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_close)
                              ]),
                              _: 1
                            }, 8, ["class"])
                          ], 42, _hoisted_2$r)) : createCommentVNode("v-if", true)
                        ], 2)) : createCommentVNode("v-if", true),
                        createBaseVNode("div", {
                          id: _ctx.contentId,
                          class: normalizeClass(_ctx.ns.e("content"))
                        }, [
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.ns.e("container"))
                          }, [
                            _ctx.iconComponent && !_ctx.center && _ctx.hasMessage ? (openBlock(), createBlock(_component_el_icon, {
                              key: 0,
                              class: normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                            }, {
                              default: withCtx(() => [
                                (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                              ]),
                              _: 1
                            }, 8, ["class"])) : createCommentVNode("v-if", true),
                            _ctx.hasMessage ? (openBlock(), createElementBlock("div", {
                              key: 1,
                              class: normalizeClass(_ctx.ns.e("message"))
                            }, [
                              renderSlot(_ctx.$slots, "default", {}, () => [
                                !_ctx.dangerouslyUseHTMLString ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                                  key: 0,
                                  for: _ctx.showInput ? _ctx.inputId : void 0
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString(!_ctx.dangerouslyUseHTMLString ? _ctx.message : ""), 1)
                                  ]),
                                  _: 1
                                }, 8, ["for"])) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                                  key: 1,
                                  for: _ctx.showInput ? _ctx.inputId : void 0,
                                  innerHTML: _ctx.message
                                }, null, 8, ["for", "innerHTML"]))
                              ])
                            ], 2)) : createCommentVNode("v-if", true)
                          ], 2),
                          withDirectives(createBaseVNode("div", {
                            class: normalizeClass(_ctx.ns.e("input"))
                          }, [
                            createVNode(_component_el_input, {
                              id: _ctx.inputId,
                              ref: "inputRef",
                              modelValue: _ctx.inputValue,
                              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.inputValue = $event),
                              type: _ctx.inputType,
                              placeholder: _ctx.inputPlaceholder,
                              "aria-invalid": _ctx.validateError,
                              class: normalizeClass({ invalid: _ctx.validateError }),
                              onKeydown: withKeys(_ctx.handleInputEnter, ["enter"])
                            }, null, 8, ["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                            createBaseVNode("div", {
                              class: normalizeClass(_ctx.ns.e("errormsg")),
                              style: normalizeStyle({
                                visibility: !!_ctx.editorErrorMessage ? "visible" : "hidden"
                              })
                            }, toDisplayString(_ctx.editorErrorMessage), 7)
                          ], 2), [
                            [vShow, _ctx.showInput]
                          ])
                        ], 10, _hoisted_3$p),
                        createBaseVNode("div", {
                          class: normalizeClass(_ctx.ns.e("btns"))
                        }, [
                          _ctx.showCancelButton ? (openBlock(), createBlock(_component_el_button, {
                            key: 0,
                            loading: _ctx.cancelButtonLoading,
                            class: normalizeClass([_ctx.cancelButtonClass]),
                            round: _ctx.roundButton,
                            size: _ctx.btnSize,
                            onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleAction("cancel")),
                            onKeydown: _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.handleAction("cancel"), ["prevent"]), ["enter"]))
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(_ctx.cancelButtonText || _ctx.t("el.messagebox.cancel")), 1)
                            ]),
                            _: 1
                          }, 8, ["loading", "class", "round", "size"])) : createCommentVNode("v-if", true),
                          withDirectives(createVNode(_component_el_button, {
                            ref: "confirmRef",
                            type: "primary",
                            loading: _ctx.confirmButtonLoading,
                            class: normalizeClass([_ctx.confirmButtonClasses]),
                            round: _ctx.roundButton,
                            disabled: _ctx.confirmButtonDisabled,
                            size: _ctx.btnSize,
                            onClick: _cache[5] || (_cache[5] = ($event) => _ctx.handleAction("confirm")),
                            onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.handleAction("confirm"), ["prevent"]), ["enter"]))
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(_ctx.confirmButtonText || _ctx.t("el.messagebox.confirm")), 1)
                            ]),
                            _: 1
                          }, 8, ["loading", "class", "round", "disabled", "size"]), [
                            [vShow, _ctx.showConfirmButton]
                          ])
                        ], 2)
                      ], 6)
                    ]),
                    _: 3
                  }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
                ], 42, _hoisted_1$t)
              ]),
              _: 3
            }, 8, ["z-index", "overlay-class", "mask"]), [
              [vShow, _ctx.visible]
            ])
          ]),
          _: 3
        });
      }
      var MessageBoxConstructor = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["render", _sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/message-box/src/index.vue"]]);
      const messageInstance = /* @__PURE__ */ new Map();
      const getAppendToElement = (props2) => {
        let appendTo = document.body;
        if (props2.appendTo) {
          if (isString$2(props2.appendTo)) {
            appendTo = document.querySelector(props2.appendTo);
          }
          if (isElement(props2.appendTo)) {
            appendTo = props2.appendTo;
          }
          if (!isElement(appendTo)) {
            appendTo = document.body;
          }
        }
        return appendTo;
      };
      const initInstance = (props2, container, appContext = null) => {
        const vnode = createVNode(MessageBoxConstructor, props2, isFunction$2(props2.message) || isVNode(props2.message) ? {
          default: isFunction$2(props2.message) ? props2.message : () => props2.message
        } : null);
        vnode.appContext = appContext;
        render$k(vnode, container);
        getAppendToElement(props2).appendChild(container.firstElementChild);
        return vnode.component;
      };
      const genContainer = () => {
        return document.createElement("div");
      };
      const showMessage = (options, appContext) => {
        const container = genContainer();
        options.onVanish = () => {
          render$k(null, container);
          messageInstance.delete(vm);
        };
        options.onAction = (action) => {
          const currentMsg = messageInstance.get(vm);
          let resolve2;
          if (options.showInput) {
            resolve2 = { value: vm.inputValue, action };
          } else {
            resolve2 = action;
          }
          if (options.callback) {
            options.callback(resolve2, instance.proxy);
          } else {
            if (action === "cancel" || action === "close") {
              if (options.distinguishCancelAndClose && action !== "cancel") {
                currentMsg.reject("close");
              } else {
                currentMsg.reject("cancel");
              }
            } else {
              currentMsg.resolve(resolve2);
            }
          }
        };
        const instance = initInstance(options, container, appContext);
        const vm = instance.proxy;
        for (const prop in options) {
          if (hasOwn(options, prop) && !hasOwn(vm.$props, prop)) {
            vm[prop] = options[prop];
          }
        }
        vm.visible = true;
        return vm;
      };
      function MessageBox(options, appContext = null) {
        if (!isClient$1)
          return Promise.reject();
        let callback;
        if (isString$2(options) || isVNode(options)) {
          options = {
            message: options
          };
        } else {
          callback = options.callback;
        }
        return new Promise((resolve2, reject) => {
          const vm = showMessage(options, appContext != null ? appContext : MessageBox._context);
          messageInstance.set(vm, {
            options,
            callback,
            resolve: resolve2,
            reject
          });
        });
      }
      const MESSAGE_BOX_VARIANTS = ["alert", "confirm", "prompt"];
      const MESSAGE_BOX_DEFAULT_OPTS = {
        alert: { closeOnPressEscape: false, closeOnClickModal: false },
        confirm: { showCancelButton: true },
        prompt: { showCancelButton: true, showInput: true }
      };
      MESSAGE_BOX_VARIANTS.forEach((boxType) => {
        MessageBox[boxType] = messageBoxFactory(boxType);
      });
      function messageBoxFactory(boxType) {
        return (message2, title, options, appContext) => {
          let titleOrOpts = "";
          if (isObject$1(title)) {
            options = title;
            titleOrOpts = "";
          } else if (isUndefined(title)) {
            titleOrOpts = "";
          } else {
            titleOrOpts = title;
          }
          return MessageBox(Object.assign({
            title: titleOrOpts,
            message: message2,
            type: "",
            ...MESSAGE_BOX_DEFAULT_OPTS[boxType]
          }, options, {
            boxType
          }), appContext);
        };
      }
      MessageBox.close = () => {
        messageInstance.forEach((_2, vm) => {
          vm.doClose();
        });
        messageInstance.clear();
      };
      MessageBox._context = null;
      const _MessageBox = MessageBox;
      _MessageBox.install = (app2) => {
        _MessageBox._context = app2._context;
        app2.config.globalProperties.$msgbox = _MessageBox;
        app2.config.globalProperties.$messageBox = _MessageBox;
        app2.config.globalProperties.$alert = _MessageBox.alert;
        app2.config.globalProperties.$confirm = _MessageBox.confirm;
        app2.config.globalProperties.$prompt = _MessageBox.prompt;
      };
      const ElMessageBox = _MessageBox;
      const notificationTypes = [
        "success",
        "info",
        "warning",
        "error"
      ];
      const notificationProps = buildProps({
        customClass: {
          type: String,
          default: ""
        },
        dangerouslyUseHTMLString: {
          type: Boolean,
          default: false
        },
        duration: {
          type: Number,
          default: 4500
        },
        icon: {
          type: iconPropType
        },
        id: {
          type: String,
          default: ""
        },
        message: {
          type: definePropType([String, Object]),
          default: ""
        },
        offset: {
          type: Number,
          default: 0
        },
        onClick: {
          type: definePropType(Function),
          default: () => void 0
        },
        onClose: {
          type: definePropType(Function),
          required: true
        },
        position: {
          type: String,
          values: ["top-right", "top-left", "bottom-right", "bottom-left"],
          default: "top-right"
        },
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        },
        type: {
          type: String,
          values: [...notificationTypes, ""],
          default: ""
        },
        zIndex: Number
      });
      const notificationEmits = {
        destroy: () => true
      };
      const _hoisted_1$s = ["id"];
      const _hoisted_2$q = ["textContent"];
      const _hoisted_3$o = { key: 0 };
      const _hoisted_4$8 = ["innerHTML"];
      const __default__ = defineComponent({
        name: "ElNotification"
      });
      const _sfc_main$9 = /* @__PURE__ */ defineComponent({
        ...__default__,
        props: notificationProps,
        emits: notificationEmits,
        setup(__props, { expose }) {
          const props2 = __props;
          const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("notification");
          const { nextZIndex, currentZIndex } = zIndex2;
          const { Close } = CloseComponents;
          const visible = ref(false);
          let timer = void 0;
          const typeClass = computed(() => {
            const type2 = props2.type;
            return type2 && TypeComponentsMap[props2.type] ? ns.m(type2) : "";
          });
          const iconComponent = computed(() => {
            if (!props2.type)
              return props2.icon;
            return TypeComponentsMap[props2.type] || props2.icon;
          });
          const horizontalClass = computed(() => props2.position.endsWith("right") ? "right" : "left");
          const verticalProperty = computed(() => props2.position.startsWith("top") ? "top" : "bottom");
          const positionStyle = computed(() => {
            var _a2;
            return {
              [verticalProperty.value]: `${props2.offset}px`,
              zIndex: (_a2 = props2.zIndex) != null ? _a2 : currentZIndex.value
            };
          });
          function startTimer() {
            if (props2.duration > 0) {
              ({ stop: timer } = useTimeoutFn$1(() => {
                if (visible.value)
                  close2();
              }, props2.duration));
            }
          }
          function clearTimer() {
            timer == null ? void 0 : timer();
          }
          function close2() {
            visible.value = false;
          }
          function onKeydown({ code }) {
            if (code === EVENT_CODE.delete || code === EVENT_CODE.backspace) {
              clearTimer();
            } else if (code === EVENT_CODE.esc) {
              if (visible.value) {
                close2();
              }
            } else {
              startTimer();
            }
          }
          onMounted(() => {
            startTimer();
            nextZIndex();
            visible.value = true;
          });
          useEventListener$1(document, "keydown", onKeydown);
          expose({
            visible,
            close: close2
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              onBeforeLeave: _ctx.onClose,
              onAfterLeave: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("destroy")),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  id: _ctx.id,
                  class: normalizeClass([unref(ns).b(), _ctx.customClass, unref(horizontalClass)]),
                  style: normalizeStyle(unref(positionStyle)),
                  role: "alert",
                  onMouseenter: clearTimer,
                  onMouseleave: startTimer,
                  onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
                }, [
                  unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass([unref(ns).e("icon"), unref(typeClass)])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ns).e("group"))
                  }, [
                    createBaseVNode("h2", {
                      class: normalizeClass(unref(ns).e("title")),
                      textContent: toDisplayString(_ctx.title)
                    }, null, 10, _hoisted_2$q),
                    withDirectives(createBaseVNode("div", {
                      class: normalizeClass(unref(ns).e("content")),
                      style: normalizeStyle(!!_ctx.title ? void 0 : { margin: 0 })
                    }, [
                      renderSlot(_ctx.$slots, "default", {}, () => [
                        !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", _hoisted_3$o, toDisplayString(_ctx.message), 1)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                          createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                          createBaseVNode("p", { innerHTML: _ctx.message }, null, 8, _hoisted_4$8)
                        ], 2112))
                      ])
                    ], 6), [
                      [vShow, _ctx.message]
                    ]),
                    _ctx.showClose ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(ns).e("closeBtn")),
                      onClick: withModifiers(close2, ["stop"])
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(Close))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 46, _hoisted_1$s), [
                  [vShow, visible.value]
                ])
              ]),
              _: 3
            }, 8, ["name", "onBeforeLeave"]);
          };
        }
      });
      var NotificationConstructor = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/notification/src/notification.vue"]]);
      const notifications = {
        "top-left": [],
        "top-right": [],
        "bottom-left": [],
        "bottom-right": []
      };
      const GAP_SIZE = 16;
      let seed = 1;
      const notify = function(options = {}, context2 = null) {
        if (!isClient$1)
          return { close: () => void 0 };
        if (typeof options === "string" || isVNode(options)) {
          options = { message: options };
        }
        const position = options.position || "top-right";
        let verticalOffset = options.offset || 0;
        notifications[position].forEach(({ vm: vm2 }) => {
          var _a2;
          verticalOffset += (((_a2 = vm2.el) == null ? void 0 : _a2.offsetHeight) || 0) + GAP_SIZE;
        });
        verticalOffset += GAP_SIZE;
        const id2 = `notification_${seed++}`;
        const userOnClose = options.onClose;
        const props2 = {
          ...options,
          offset: verticalOffset,
          id: id2,
          onClose: () => {
            close(id2, position, userOnClose);
          }
        };
        let appendTo = document.body;
        if (isElement(options.appendTo)) {
          appendTo = options.appendTo;
        } else if (isString$2(options.appendTo)) {
          appendTo = document.querySelector(options.appendTo);
        }
        if (!isElement(appendTo)) {
          appendTo = document.body;
        }
        const container = document.createElement("div");
        const vm = createVNode(NotificationConstructor, props2, isVNode(props2.message) ? {
          default: () => props2.message
        } : null);
        vm.appContext = context2 != null ? context2 : notify._context;
        vm.props.onDestroy = () => {
          render$k(null, container);
        };
        render$k(vm, container);
        notifications[position].push({ vm });
        appendTo.appendChild(container.firstElementChild);
        return {
          close: () => {
            vm.component.exposed.visible.value = false;
          }
        };
      };
      notificationTypes.forEach((type2) => {
        notify[type2] = (options = {}) => {
          if (typeof options === "string" || isVNode(options)) {
            options = {
              message: options
            };
          }
          return notify({
            ...options,
            type: type2
          });
        };
      });
      function close(id2, position, userOnClose) {
        const orientedNotifications = notifications[position];
        const idx = orientedNotifications.findIndex(({ vm: vm2 }) => {
          var _a2;
          return ((_a2 = vm2.component) == null ? void 0 : _a2.props.id) === id2;
        });
        if (idx === -1)
          return;
        const { vm } = orientedNotifications[idx];
        if (!vm)
          return;
        userOnClose == null ? void 0 : userOnClose(vm);
        const removedHeight = vm.el.offsetHeight;
        const verticalPos = position.split("-")[0];
        orientedNotifications.splice(idx, 1);
        const len = orientedNotifications.length;
        if (len < 1)
          return;
        for (let i2 = idx; i2 < len; i2++) {
          const { el, component } = orientedNotifications[i2].vm;
          const pos = Number.parseInt(el.style[verticalPos], 10) - removedHeight - GAP_SIZE;
          component.props.offset = pos;
        }
      }
      function closeAll() {
        for (const orientedNotifications of Object.values(notifications)) {
          orientedNotifications.forEach(({ vm }) => {
            vm.component.exposed.visible.value = false;
          });
        }
      }
      notify.closeAll = closeAll;
      notify._context = null;
      const ElNotification = withInstallFunction(notify, "$notify");
      const _hoisted_1$r = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$p = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896a448 448 0 0 1 0-896zM288 512a38.4 38.4 0 0 0 38.4 38.4h371.2a38.4 38.4 0 0 0 0-76.8H326.4A38.4 38.4 0 0 0 288 512z"
      }, null, -1);
      const _hoisted_3$n = [
        _hoisted_2$p
      ];
      function render$j(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$r, _hoisted_3$n);
      }
      const __unplugin_components_13$1 = { name: "ep-remove-filled", render: render$j };
      const _hoisted_1$q = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$o = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M352 480h320a32 32 0 1 1 0 64H352a32 32 0 0 1 0-64z"
      }, null, -1);
      const _hoisted_3$m = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768a384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896a448 448 0 0 1 0 896z"
      }, null, -1);
      const _hoisted_4$7 = [
        _hoisted_2$o,
        _hoisted_3$m
      ];
      function render$i(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$q, _hoisted_4$7);
      }
      const __unplugin_components_12 = { name: "ep-remove", render: render$i };
      const _hoisted_1$p = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$n = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M352 192V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64H96a32 32 0 0 1 0-64h256zm64 0h192v-64H416v64zM192 960a32 32 0 0 1-32-32V256h704v672a32 32 0 0 1-32 32H192zm224-192a32 32 0 0 0 32-32V416a32 32 0 0 0-64 0v320a32 32 0 0 0 32 32zm192 0a32 32 0 0 0 32-32V416a32 32 0 0 0-64 0v320a32 32 0 0 0 32 32z"
      }, null, -1);
      const _hoisted_3$l = [
        _hoisted_2$n
      ];
      function render$h(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$p, _hoisted_3$l);
      }
      const __unplugin_components_2$1 = { name: "ep-delete-filled", render: render$h };
      const _hoisted_1$o = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$m = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32zm192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32z"
      }, null, -1);
      const _hoisted_3$k = [
        _hoisted_2$m
      ];
      function render$g(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$o, _hoisted_3$k);
      }
      const __unplugin_components_0$3 = { name: "ep-delete", render: render$g };
      const _hoisted_1$n = {
        key: 0,
        class: "hover-button-default"
      };
      const _hoisted_2$l = {
        key: 0,
        class: "hover-button-hover"
      };
      const _sfc_main$8 = /* @__PURE__ */ defineComponent({
        __name: "HoverButton",
        setup(__props) {
          let isHover = ref(false);
          return (_ctx, _cache) => {
            const _component_i_ep_Delete = __unplugin_components_0$3;
            const _component_el_icon = ElIcon;
            const _component_i_ep_DeleteFilled = __unplugin_components_2$1;
            return openBlock(), createElementBlock("span", {
              class: "hover-button-container",
              onMouseenter: _cache[0] || (_cache[0] = ($event) => isRef(isHover) ? isHover.value = true : isHover = true),
              onMouseleave: _cache[1] || (_cache[1] = ($event) => isRef(isHover) ? isHover.value = false : isHover = false)
            }, [
              createVNode(Transition, { name: "hover-button-container" }, {
                default: withCtx(() => [
                  !unref(isHover) ? (openBlock(), createElementBlock("span", _hoisted_1$n, [
                    renderSlot(_ctx.$slots, "default", {}, () => [
                      createVNode(_component_el_icon, null, {
                        default: withCtx(() => [
                          createVNode(_component_i_ep_Delete)
                        ]),
                        _: 1
                      })
                    ], true)
                  ])) : createCommentVNode("", true)
                ]),
                _: 3
              }),
              createVNode(Transition, { name: "hover-button-container" }, {
                default: withCtx(() => [
                  unref(isHover) ? (openBlock(), createElementBlock("span", _hoisted_2$l, [
                    renderSlot(_ctx.$slots, "hover", {}, () => [
                      createVNode(_component_el_icon, null, {
                        default: withCtx(() => [
                          createVNode(_component_i_ep_DeleteFilled)
                        ]),
                        _: 1
                      })
                    ], true)
                  ])) : createCommentVNode("", true)
                ]),
                _: 3
              })
            ], 32);
          };
        }
      });
      const _export_sfc = (sfc, props2) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props2) {
          target[key] = val;
        }
        return target;
      };
      const __unplugin_components_3 = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-8b0631ff"]]);
      const _hoisted_1$m = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$k = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896a448 448 0 0 1 0-896zm-38.4 409.6H326.4a38.4 38.4 0 1 0 0 76.8h147.2v147.2a38.4 38.4 0 0 0 76.8 0V550.4h147.2a38.4 38.4 0 0 0 0-76.8H550.4V326.4a38.4 38.4 0 1 0-76.8 0v147.2z"
      }, null, -1);
      const _hoisted_3$j = [
        _hoisted_2$k
      ];
      function render$f(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$m, _hoisted_3$j);
      }
      const __unplugin_components_4 = { name: "ep-circle-plus-filled", render: render$f };
      const _hoisted_1$l = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$j = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M352 480h320a32 32 0 1 1 0 64H352a32 32 0 0 1 0-64z"
      }, null, -1);
      const _hoisted_3$i = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M480 672V352a32 32 0 1 1 64 0v320a32 32 0 0 1-64 0z"
      }, null, -1);
      const _hoisted_4$6 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768a384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896a448 448 0 0 1 0 896z"
      }, null, -1);
      const _hoisted_5$3 = [
        _hoisted_2$j,
        _hoisted_3$i,
        _hoisted_4$6
      ];
      function render$e(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$l, _hoisted_5$3);
      }
      const __unplugin_components_8$1 = { name: "ep-circle-plus", render: render$e };
      const _hoisted_1$k = { style: { "flex-grow": "1" } };
      const _hoisted_2$i = { style: { "flex-grow": "1" } };
      const _hoisted_3$h = { style: { "flex-grow": "1" } };
      const _hoisted_4$5 = { class: "side-button add-match-item" };
      const _hoisted_5$2 = { class: "side-button remove-match-item" };
      const _hoisted_6$2 = { style: { "flex-grow": "1" } };
      const _hoisted_7$2 = { class: "side-button add-match-item" };
      const _hoisted_8$1 = { class: "side-button remove-match-item" };
      const _hoisted_9$1 = { style: { "flex-grow": "1" } };
      const _hoisted_10$1 = { class: "side-button add-match-item" };
      const _hoisted_11$1 = { class: "side-button remove-match-item" };
      const _hoisted_12$1 = { style: { "flex-grow": "1" } };
      const _hoisted_13$1 = { class: "side-button add-match-item" };
      const _hoisted_14$1 = { class: "side-button remove-match-item" };
      const _hoisted_15$1 = { style: { "flex-grow": "1" } };
      const _hoisted_16$1 = { class: "side-button add-match-item" };
      const _hoisted_17$1 = { class: "side-button remove-match-item" };
      const _hoisted_18$1 = { style: { "flex-grow": "1" } };
      const _hoisted_19 = { class: "side-button add-match-item" };
      const _hoisted_20 = { class: "side-button remove-match-item" };
      const _hoisted_21 = { style: { "flex-grow": "1" } };
      const _hoisted_22 = { class: "side-button add-match-item" };
      const _hoisted_23 = { class: "side-button remove-match-item" };
      const _hoisted_24 = { style: { "flex-grow": "1" } };
      const _hoisted_25 = { class: "side-button add-match-item" };
      const _hoisted_26 = { class: "side-button remove-match-item" };
      const _hoisted_27 = { style: { "flex-grow": "1" } };
      const _hoisted_28 = { class: "side-button add-match-item" };
      const _hoisted_29 = { class: "side-button remove-match-item" };
      const _sfc_main$7 = /* @__PURE__ */ defineComponent({
        __name: "RuleForm",
        props: {
          formData: {}
        },
        setup(__props) {
          const props2 = __props;
          const info = reactive({
            activeName: "main"
          });
          const pushMatchItem = (index) => {
            const rule = props2.formData;
            for (const key of rule.enumMainKey) {
              for (const item of Object.keys(rule[key])) {
                if (rule.enumMatchItemKey.includes(item)) {
                  rule[key][item].splice(index + 1, 0, "");
                }
              }
            }
            rule.matchItemCount++;
          };
          const removeMatchItem = (index) => {
            const rule = props2.formData;
            if (rule.matchItemCount <= 1) {
              return;
            }
            for (const key of rule.enumMainKey) {
              for (const item of Object.keys(rule[key])) {
                if (rule.enumMatchItemKey.includes(item)) {
                  rule[key][item].splice(index, 1);
                }
              }
            }
            rule.matchItemCount--;
          };
          watch(
            () => props2.formData,
            (newVal, oldVal) => {
              info.activeName = "main";
            }
          );
          return (_ctx, _cache) => {
            const _component_el_input = ElInput;
            const _component_el_form_item = ElFormItem;
            const _component_el_option = ElOption;
            const _component_el_tooltip = ElTooltip;
            const _component_el_select = ElSelect;
            const _component_el_form = ElForm;
            const _component_el_tab_pane = ElTabPane;
            const _component_el_checkbox = ElCheckbox;
            const _component_i_ep_CirclePlus = __unplugin_components_8$1;
            const _component_el_icon = ElIcon;
            const _component_i_ep_CirclePlusFilled = __unplugin_components_4;
            const _component_HoverButton = __unplugin_components_3;
            const _component_i_ep_Remove = __unplugin_components_12;
            const _component_i_ep_RemoveFilled = __unplugin_components_13$1;
            const _component_el_tabs = ElTabs;
            return _ctx.formData != void 0 ? (openBlock(), createBlock(_component_el_tabs, {
              key: 0,
              modelValue: unref(info).activeName,
              "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => unref(info).activeName = $event),
              onTabClick: _cache[17] || (_cache[17] = () => {
              })
            }, {
              default: withCtx(() => [
                createVNode(_component_el_tab_pane, {
                  label: "首选项",
                  name: "main"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: _ctx.formData.main,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_form_item, { label: "规则名称" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_input, {
                              modelValue: _ctx.formData.main.name,
                              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.formData.main.name = $event)
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_form_item, { label: "根网址" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_input, {
                              modelValue: _ctx.formData.main.domainName,
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.formData.main.domainName = $event)
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_form_item, { label: "路径过滤器" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_input, {
                              modelValue: _ctx.formData.main.pathFilter.pattern,
                              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.formData.main.pathFilter.pattern = $event),
                              placeholder: "(正则表达式)"
                            }, {
                              prefix: withCtx(() => [
                                createTextVNode(" / ")
                              ]),
                              suffix: withCtx(() => [
                                createTextVNode(" / ")
                              ]),
                              append: withCtx(() => [
                                createVNode(_component_el_select, {
                                  style: { "width": "180px" },
                                  multiple: "",
                                  modelValue: _ctx.formData.main.pathFilter.flags,
                                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.formData.main.pathFilter.flags = $event),
                                  placeholder: "修饰符"
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_tooltip, {
                                      "show-after": 500,
                                      effect: "dark",
                                      content: "global - 全局匹配",
                                      placement: "top"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(_component_el_option, {
                                          value: "g",
                                          label: "g"
                                        })
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(_component_el_tooltip, {
                                      "show-after": 500,
                                      effect: "dark",
                                      content: "ignore - 不区分大小写",
                                      placement: "top"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(_component_el_option, {
                                          value: "i",
                                          label: "i"
                                        })
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(_component_el_tooltip, {
                                      "show-after": 500,
                                      effect: "dark",
                                      content: "特殊字符圆点 . 中包含换行符 \\n",
                                      placement: "top"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(_component_el_option, {
                                          value: "s",
                                          label: "s"
                                        })
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 1
                                }, 8, ["modelValue"])
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_form_item, { label: "标题选择器" }, {
                          default: withCtx(() => [
                            createBaseVNode("span", _hoisted_1$k, [
                              createVNode(_component_el_input, {
                                modelValue: _ctx.formData.main.titleSelector,
                                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.formData.main.titleSelector = $event),
                                type: "text"
                              }, null, 8, ["modelValue"])
                            ])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_form_item, { label: "站点图标Url" }, {
                          default: withCtx(() => [
                            createBaseVNode("span", _hoisted_2$i, [
                              createVNode(_component_el_input, {
                                modelValue: _ctx.formData.main.iconUrl,
                                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => _ctx.formData.main.iconUrl = $event),
                                type: "text"
                              }, null, 8, ["modelValue"])
                            ])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_tab_pane, {
                  label: "dom限定",
                  name: "domItem"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: _ctx.formData.domItem,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_form_item, { label: "启用" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_checkbox, {
                              modelValue: _ctx.formData.domItem.enable,
                              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.formData.domItem.enable = $event),
                              type: "checkbox"
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        _ctx.formData.domItem.enable ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.formData.domItem.selector, (selector, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `css选择器${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_3$h, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.domItem.selector[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.domItem.selector[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_4$5, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_5$2, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true)
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_tab_pane, {
                  label: "链接(必填)",
                  name: "linkUrl"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: _ctx.formData.linkUrl,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.formData.linkUrl.selector, (selector, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `css选择器${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_6$2, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.linkUrl.selector[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.linkUrl.selector[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_7$2, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_8$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)),
                        createVNode(_component_el_form_item, { label: "提取类型" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: _ctx.formData.linkUrl.infoType,
                              "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => _ctx.formData.linkUrl.infoType = $event),
                              placeholder: "选择要提取的类型"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "值"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "Attribute属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "Property属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 4,
                                  label: "innerText 内部文本"
                                }),
                                createVNode(_component_el_option, {
                                  value: 5,
                                  label: "innerHTML 内部HTML"
                                }),
                                createVNode(_component_el_option, {
                                  value: 6,
                                  label: "outerHTML 全部HTML"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.formData.linkUrl.attribute, (attribute, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `匹配属性${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_9$1, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.linkUrl.attribute[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.linkUrl.attribute[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_10$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_11$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_tab_pane, {
                  label: "图链",
                  name: "picUrl"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: _ctx.formData.picUrl,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_form_item, { label: "启用" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_checkbox, {
                              modelValue: _ctx.formData.picUrl.enable,
                              "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => _ctx.formData.picUrl.enable = $event),
                              type: "checkbox"
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        _ctx.formData.picUrl.enable ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.formData.picUrl.selector, (selector, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `css选择器${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_12$1, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.picUrl.selector[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.picUrl.selector[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_13$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_14$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true),
                        _ctx.formData.picUrl.enable ? (openBlock(), createBlock(_component_el_form_item, {
                          key: 1,
                          label: "提取类型"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: _ctx.formData.picUrl.infoType,
                              "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => _ctx.formData.picUrl.infoType = $event),
                              placeholder: "选择要提取的类型"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "值"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "Attribute属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "Property属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 4,
                                  label: "innerText 内部文本"
                                }),
                                createVNode(_component_el_option, {
                                  value: 5,
                                  label: "innerHTML 内部HTML"
                                }),
                                createVNode(_component_el_option, {
                                  value: 6,
                                  label: "outerHTML 全部HTML"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })) : createCommentVNode("", true),
                        _ctx.formData.picUrl.enable ? (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(_ctx.formData.picUrl.attribute, (attribute, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `匹配属性${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_15$1, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.picUrl.attribute[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.picUrl.attribute[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_16$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_17$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true)
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_tab_pane, {
                  label: "名称",
                  name: "name"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: _ctx.formData.name,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_form_item, { label: "启用" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_checkbox, {
                              modelValue: _ctx.formData.name.enable,
                              "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => _ctx.formData.name.enable = $event),
                              type: "checkbox"
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        _ctx.formData.name.enable ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.formData.name.selector, (selector, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `css选择器${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_18$1, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.name.selector[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.name.selector[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_19, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_20, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true),
                        _ctx.formData.name.enable ? (openBlock(), createBlock(_component_el_form_item, {
                          key: 1,
                          label: "提取类型"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: _ctx.formData.name.infoType,
                              "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => _ctx.formData.name.infoType = $event),
                              placeholder: "选择要提取的类型"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "值"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "Attribute属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "Property属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 4,
                                  label: "innerText 内部文本"
                                }),
                                createVNode(_component_el_option, {
                                  value: 5,
                                  label: "innerHTML 内部HTML"
                                }),
                                createVNode(_component_el_option, {
                                  value: 6,
                                  label: "outerHTML 全部HTML"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })) : createCommentVNode("", true),
                        _ctx.formData.name.enable ? (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(_ctx.formData.name.attribute, (attribute, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `匹配属性${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_21, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.name.attribute[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.name.attribute[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_22, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_23, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true)
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_tab_pane, {
                  label: "元信息",
                  name: "meta"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: _ctx.formData.meta,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_form_item, { label: "启用" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_checkbox, {
                              modelValue: _ctx.formData.meta.enable,
                              "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => _ctx.formData.meta.enable = $event),
                              type: "checkbox"
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        _ctx.formData.meta.enable ? (openBlock(), createBlock(_component_el_form_item, {
                          key: 0,
                          label: "来源"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: _ctx.formData.meta.origin,
                              "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => _ctx.formData.meta.origin = $event),
                              placeholder: "来源"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 0,
                                  label: "单独指定目标dom"
                                }),
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "从“链接”dom获取"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "从“图链”dom获取"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "从“名称”dom获取"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })) : createCommentVNode("", true),
                        _ctx.formData.meta.enable && _ctx.formData.meta.origin === 0 ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.formData.meta.selector, (selector, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `css选择器${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_24, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.meta.selector[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.meta.selector[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_25, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_26, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true),
                        _ctx.formData.meta.enable ? (openBlock(), createBlock(_component_el_form_item, {
                          key: 2,
                          label: "提取类型"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: _ctx.formData.meta.infoType,
                              "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => _ctx.formData.meta.infoType = $event),
                              placeholder: "选择要提取的类型"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 0,
                                  label: "来源对应的dom和链接"
                                }),
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "值"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "Attribute属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "Property属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 4,
                                  label: "innerText 内部文本"
                                }),
                                createVNode(_component_el_option, {
                                  value: 5,
                                  label: "innerHTML 内部HTML"
                                }),
                                createVNode(_component_el_option, {
                                  value: 6,
                                  label: "outerHTML 全部HTML"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })) : createCommentVNode("", true),
                        _ctx.formData.meta.enable && _ctx.formData.meta.infoType !== 0 ? (openBlock(true), createElementBlock(Fragment, { key: 3 }, renderList(_ctx.formData.meta.attribute, (attribute, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `匹配属性${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_27, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.meta.attribute[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.meta.attribute[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_28, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_29, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true),
                        _ctx.formData.meta.enable ? (openBlock(), createBlock(_component_el_form_item, {
                          key: 4,
                          label: "获取方式"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: _ctx.formData.meta.getMethod,
                              "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => _ctx.formData.meta.getMethod = $event),
                              placeholder: "选择要提取的类型"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 0,
                                  label: "自动"
                                }),
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "通过natural宽高(仅img标签有效)"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "通过Image对象(仅对图片链接有效)"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "通过Blob获取(获取实际可能较长)"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })) : createCommentVNode("", true)
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["modelValue"])) : createCommentVNode("", true);
          };
        }
      });
      const __unplugin_components_9 = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-d0fd7022"]]);
      function tryOnScopeDispose(fn2) {
        if (getCurrentScope()) {
          onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      function toValue(r2) {
        return typeof r2 === "function" ? r2() : unref(r2);
      }
      const isClient = typeof window !== "undefined";
      const noop = () => {
      };
      function toRef(...args) {
        if (args.length !== 1)
          return toRef$1(...args);
        const r2 = args[0];
        return typeof r2 === "function" ? readonly(customRef(() => ({ get: r2, set: noop }))) : ref(r2);
      }
      var __defProp$9 = Object.defineProperty;
      var __defProps$7 = Object.defineProperties;
      var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
      var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
      var __hasOwnProp$b = Object.prototype.hasOwnProperty;
      var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
      var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues$9 = (a2, b2) => {
        for (var prop in b2 || (b2 = {}))
          if (__hasOwnProp$b.call(b2, prop))
            __defNormalProp$9(a2, prop, b2[prop]);
        if (__getOwnPropSymbols$b)
          for (var prop of __getOwnPropSymbols$b(b2)) {
            if (__propIsEnum$b.call(b2, prop))
              __defNormalProp$9(a2, prop, b2[prop]);
          }
        return a2;
      };
      var __spreadProps$7 = (a2, b2) => __defProps$7(a2, __getOwnPropDescs$7(b2));
      function toRefs(objectRef) {
        if (!isRef(objectRef))
          return toRefs$1(objectRef);
        const result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};
        for (const key in objectRef.value) {
          result[key] = customRef(() => ({
            get() {
              return objectRef.value[key];
            },
            set(v2) {
              if (Array.isArray(objectRef.value)) {
                const copy = [...objectRef.value];
                copy[key] = v2;
                objectRef.value = copy;
              } else {
                const newObject = __spreadProps$7(__spreadValues$9({}, objectRef.value), { [key]: v2 });
                Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));
                objectRef.value = newObject;
              }
            }
          }));
        }
        return result;
      }
      function tryOnMounted(fn2, sync = true) {
        if (getCurrentInstance())
          onMounted(fn2);
        else if (sync)
          fn2();
        else
          nextTick(fn2);
      }
      function useTimeoutFn(cb, interval, options = {}) {
        const {
          immediate = true
        } = options;
        const isPending = ref(false);
        let timer = null;
        function clear2() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function stop() {
          isPending.value = false;
          clear2();
        }
        function start(...args) {
          clear2();
          isPending.value = true;
          timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            cb(...args);
          }, toValue(interval));
        }
        if (immediate) {
          isPending.value = true;
          if (isClient)
            start();
        }
        tryOnScopeDispose(stop);
        return {
          isPending: readonly(isPending),
          start,
          stop
        };
      }
      function unrefElement(elRef) {
        var _a2;
        const plain = toValue(elRef);
        return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
      }
      const defaultWindow = isClient ? window : void 0;
      const defaultNavigator = isClient ? window.navigator : void 0;
      function useEventListener(...args) {
        let target;
        let events;
        let listeners;
        let options;
        if (typeof args[0] === "string" || Array.isArray(args[0])) {
          [events, listeners, options] = args;
          target = defaultWindow;
        } else {
          [target, events, listeners, options] = args;
        }
        if (!target)
          return noop;
        if (!Array.isArray(events))
          events = [events];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = watch(
          () => [unrefElement(target), toValue(options)],
          ([el, options2]) => {
            cleanup();
            if (!el)
              return;
            cleanups.push(
              ...events.flatMap((event) => {
                return listeners.map((listener) => register(el, event, listener, options2));
              })
            );
          },
          { immediate: true, flush: "post" }
        );
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose(stop);
        return stop;
      }
      function useMounted() {
        const isMounted = ref(false);
        if (getCurrentInstance()) {
          onMounted(() => {
            isMounted.value = true;
          });
        }
        return isMounted;
      }
      function useSupported(callback) {
        const isMounted = useMounted();
        return computed(() => {
          isMounted.value;
          return Boolean(callback());
        });
      }
      function useMediaQuery(query, options = {}) {
        const { window: window2 = defaultWindow } = options;
        const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
        let mediaQuery;
        const matches = ref(false);
        const cleanup = () => {
          if (!mediaQuery)
            return;
          if ("removeEventListener" in mediaQuery)
            mediaQuery.removeEventListener("change", update);
          else
            mediaQuery.removeListener(update);
        };
        const update = () => {
          if (!isSupported.value)
            return;
          cleanup();
          mediaQuery = window2.matchMedia(toRef(query).value);
          matches.value = !!(mediaQuery == null ? void 0 : mediaQuery.matches);
          if (!mediaQuery)
            return;
          if ("addEventListener" in mediaQuery)
            mediaQuery.addEventListener("change", update);
          else
            mediaQuery.addListener(update);
        };
        watchEffect(update);
        tryOnScopeDispose(() => cleanup());
        return matches;
      }
      function useClipboard(options = {}) {
        const {
          navigator: navigator2 = defaultNavigator,
          read = false,
          source,
          copiedDuring = 1500,
          legacy = false
        } = options;
        const events = ["copy", "cut"];
        const isClipboardApiSupported = useSupported(() => navigator2 && "clipboard" in navigator2);
        const isSupported = computed(() => isClipboardApiSupported.value || legacy);
        const text = ref("");
        const copied = ref(false);
        const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);
        function updateText() {
          if (isClipboardApiSupported.value) {
            navigator2.clipboard.readText().then((value) => {
              text.value = value;
            });
          } else {
            text.value = legacyRead();
          }
        }
        if (isSupported.value && read) {
          for (const event of events)
            useEventListener(event, updateText);
        }
        async function copy(value = toValue(source)) {
          if (isSupported.value && value != null) {
            if (isClipboardApiSupported.value)
              await navigator2.clipboard.writeText(value);
            else
              legacyCopy(value);
            text.value = value;
            copied.value = true;
            timeout.start();
          }
        }
        function legacyCopy(value) {
          const ta = document.createElement("textarea");
          ta.value = value != null ? value : "";
          ta.style.position = "absolute";
          ta.style.opacity = "0";
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          ta.remove();
        }
        function legacyRead() {
          var _a2, _b, _c;
          return (_c = (_b = (_a2 = document == null ? void 0 : document.getSelection) == null ? void 0 : _a2.call(document)) == null ? void 0 : _b.toString()) != null ? _c : "";
        }
        return {
          isSupported,
          text,
          copied,
          copy
        };
      }
      var __defProp$g = Object.defineProperty;
      var __defProps$6 = Object.defineProperties;
      var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
      var __getOwnPropSymbols$i = Object.getOwnPropertySymbols;
      var __hasOwnProp$i = Object.prototype.hasOwnProperty;
      var __propIsEnum$i = Object.prototype.propertyIsEnumerable;
      var __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues$g = (a2, b2) => {
        for (var prop in b2 || (b2 = {}))
          if (__hasOwnProp$i.call(b2, prop))
            __defNormalProp$g(a2, prop, b2[prop]);
        if (__getOwnPropSymbols$i)
          for (var prop of __getOwnPropSymbols$i(b2)) {
            if (__propIsEnum$i.call(b2, prop))
              __defNormalProp$g(a2, prop, b2[prop]);
          }
        return a2;
      };
      var __spreadProps$6 = (a2, b2) => __defProps$6(a2, __getOwnPropDescs$6(b2));
      function useDraggable(target, options = {}) {
        var _a2, _b;
        const {
          pointerTypes,
          preventDefault,
          stopPropagation,
          exact,
          onMove,
          onEnd,
          onStart,
          initialValue,
          axis = "both",
          draggingElement = defaultWindow,
          handle: draggingHandle = target
        } = options;
        const position = ref(
          (_a2 = toValue(initialValue)) != null ? _a2 : { x: 0, y: 0 }
        );
        const pressedDelta = ref();
        const filterEvent = (e2) => {
          if (pointerTypes)
            return pointerTypes.includes(e2.pointerType);
          return true;
        };
        const handleEvent = (e2) => {
          if (toValue(preventDefault))
            e2.preventDefault();
          if (toValue(stopPropagation))
            e2.stopPropagation();
        };
        const start = (e2) => {
          if (!filterEvent(e2))
            return;
          if (toValue(exact) && e2.target !== toValue(target))
            return;
          const rect = toValue(target).getBoundingClientRect();
          const pos = {
            x: e2.clientX - rect.left,
            y: e2.clientY - rect.top
          };
          if ((onStart == null ? void 0 : onStart(pos, e2)) === false)
            return;
          pressedDelta.value = pos;
          handleEvent(e2);
        };
        const move = (e2) => {
          if (!filterEvent(e2))
            return;
          if (!pressedDelta.value)
            return;
          let { x: x2, y: y2 } = position.value;
          if (axis === "x" || axis === "both")
            x2 = e2.clientX - pressedDelta.value.x;
          if (axis === "y" || axis === "both")
            y2 = e2.clientY - pressedDelta.value.y;
          position.value = {
            x: x2,
            y: y2
          };
          onMove == null ? void 0 : onMove(position.value, e2);
          handleEvent(e2);
        };
        const end2 = (e2) => {
          if (!filterEvent(e2))
            return;
          if (!pressedDelta.value)
            return;
          pressedDelta.value = void 0;
          onEnd == null ? void 0 : onEnd(position.value, e2);
          handleEvent(e2);
        };
        if (isClient) {
          const config = { capture: (_b = options.capture) != null ? _b : true };
          useEventListener(draggingHandle, "pointerdown", start, config);
          useEventListener(draggingElement, "pointermove", move, config);
          useEventListener(draggingElement, "pointerup", end2, config);
        }
        return __spreadProps$6(__spreadValues$g({}, toRefs(position)), {
          position,
          isDragging: computed(() => !!pressedDelta.value),
          style: computed(
            () => `left:${position.value.x}px;top:${position.value.y}px;`
          )
        });
      }
      function useWindowSize(options = {}) {
        const {
          window: window2 = defaultWindow,
          initialWidth = Infinity,
          initialHeight = Infinity,
          listenOrientation = true,
          includeScrollbar = true
        } = options;
        const width = ref(initialWidth);
        const height = ref(initialHeight);
        const update = () => {
          if (window2) {
            if (includeScrollbar) {
              width.value = window2.innerWidth;
              height.value = window2.innerHeight;
            } else {
              width.value = window2.document.documentElement.clientWidth;
              height.value = window2.document.documentElement.clientHeight;
            }
          }
        };
        update();
        tryOnMounted(update);
        useEventListener("resize", update, { passive: true });
        if (listenOrientation) {
          const matches = useMediaQuery("(orientation: portrait)");
          watch(matches, () => update());
        }
        return { width, height };
      }
      const t = (t2, e2 = 1e4) => (t2 = parseFloat(t2 + "") || 0, Math.round((t2 + Number.EPSILON) * e2) / e2), e = function(t2) {
        if (!(t2 && t2 instanceof Element && t2.offsetParent))
          return false;
        const e2 = t2.scrollHeight > t2.clientHeight, i2 = window.getComputedStyle(t2).overflowY, n2 = -1 !== i2.indexOf("hidden"), s2 = -1 !== i2.indexOf("visible");
        return e2 && !n2 && !s2;
      }, i = function(t2, n2 = void 0) {
        return !(!t2 || t2 === document.body || n2 && t2 === n2) && (e(t2) ? t2 : i(t2.parentElement, n2));
      }, n = function(t2) {
        var e2 = new DOMParser().parseFromString(t2, "text/html").body;
        if (e2.childElementCount > 1) {
          for (var i2 = document.createElement("div"); e2.firstChild; )
            i2.appendChild(e2.firstChild);
          return i2;
        }
        return e2.firstChild;
      }, s = (t2) => `${t2 || ""}`.split(" ").filter((t3) => !!t3), o = (t2, e2, i2) => {
        s(e2).forEach((e3) => {
          t2 && t2.classList.toggle(e3, i2 || false);
        });
      };
      class a {
        constructor(t2) {
          Object.defineProperty(this, "pageX", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "pageY", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "clientX", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "clientY", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "id", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "time", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "nativePointer", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.nativePointer = t2, this.pageX = t2.pageX, this.pageY = t2.pageY, this.clientX = t2.clientX, this.clientY = t2.clientY, this.id = self.Touch && t2 instanceof Touch ? t2.identifier : -1, this.time = Date.now();
        }
      }
      const r = { passive: false };
      class l {
        constructor(t2, { start: e2 = () => true, move: i2 = () => {
        }, end: n2 = () => {
        } }) {
          Object.defineProperty(this, "element", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "startCallback", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "moveCallback", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "endCallback", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "currentPointers", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "startPointers", { enumerable: true, configurable: true, writable: true, value: [] }), this.element = t2, this.startCallback = e2, this.moveCallback = i2, this.endCallback = n2;
          for (const t3 of ["onPointerStart", "onTouchStart", "onMove", "onTouchEnd", "onPointerEnd", "onWindowBlur"])
            this[t3] = this[t3].bind(this);
          this.element.addEventListener("mousedown", this.onPointerStart, r), this.element.addEventListener("touchstart", this.onTouchStart, r), this.element.addEventListener("touchmove", this.onMove, r), this.element.addEventListener("touchend", this.onTouchEnd), this.element.addEventListener("touchcancel", this.onTouchEnd);
        }
        onPointerStart(t2) {
          if (!t2.buttons || 0 !== t2.button)
            return;
          const e2 = new a(t2);
          this.currentPointers.some((t3) => t3.id === e2.id) || this.triggerPointerStart(e2, t2) && (window.addEventListener("mousemove", this.onMove), window.addEventListener("mouseup", this.onPointerEnd), window.addEventListener("blur", this.onWindowBlur));
        }
        onTouchStart(t2) {
          for (const e2 of Array.from(t2.changedTouches || []))
            this.triggerPointerStart(new a(e2), t2);
          window.addEventListener("blur", this.onWindowBlur);
        }
        onMove(t2) {
          const e2 = this.currentPointers.slice(), i2 = "changedTouches" in t2 ? Array.from(t2.changedTouches || []).map((t3) => new a(t3)) : [new a(t2)], n2 = [];
          for (const t3 of i2) {
            const e3 = this.currentPointers.findIndex((e4) => e4.id === t3.id);
            e3 < 0 || (n2.push(t3), this.currentPointers[e3] = t3);
          }
          n2.length && this.moveCallback(t2, this.currentPointers.slice(), e2);
        }
        onPointerEnd(t2) {
          t2.buttons > 0 && 0 !== t2.button || (this.triggerPointerEnd(t2, new a(t2)), window.removeEventListener("mousemove", this.onMove), window.removeEventListener("mouseup", this.onPointerEnd), window.removeEventListener("blur", this.onWindowBlur));
        }
        onTouchEnd(t2) {
          for (const e2 of Array.from(t2.changedTouches || []))
            this.triggerPointerEnd(t2, new a(e2));
        }
        triggerPointerStart(t2, e2) {
          return !!this.startCallback(e2, t2, this.currentPointers.slice()) && (this.currentPointers.push(t2), this.startPointers.push(t2), true);
        }
        triggerPointerEnd(t2, e2) {
          const i2 = this.currentPointers.findIndex((t3) => t3.id === e2.id);
          i2 < 0 || (this.currentPointers.splice(i2, 1), this.startPointers.splice(i2, 1), this.endCallback(t2, e2, this.currentPointers.slice()));
        }
        onWindowBlur() {
          this.clear();
        }
        clear() {
          for (; this.currentPointers.length; ) {
            const t2 = this.currentPointers[this.currentPointers.length - 1];
            this.currentPointers.splice(this.currentPointers.length - 1, 1), this.startPointers.splice(this.currentPointers.length - 1, 1), this.endCallback(new Event("touchend", { bubbles: true, cancelable: true, clientX: t2.clientX, clientY: t2.clientY }), t2, this.currentPointers.slice());
          }
        }
        stop() {
          this.element.removeEventListener("mousedown", this.onPointerStart, r), this.element.removeEventListener("touchstart", this.onTouchStart, r), this.element.removeEventListener("touchmove", this.onMove, r), this.element.removeEventListener("touchend", this.onTouchEnd), this.element.removeEventListener("touchcancel", this.onTouchEnd), window.removeEventListener("mousemove", this.onMove), window.removeEventListener("mouseup", this.onPointerEnd), window.removeEventListener("blur", this.onWindowBlur);
        }
      }
      function c(t2, e2) {
        return e2 ? Math.sqrt(Math.pow(e2.clientX - t2.clientX, 2) + Math.pow(e2.clientY - t2.clientY, 2)) : 0;
      }
      function h(t2, e2) {
        return e2 ? { clientX: (t2.clientX + e2.clientX) / 2, clientY: (t2.clientY + e2.clientY) / 2 } : t2;
      }
      const d = (t2) => "object" == typeof t2 && null !== t2 && t2.constructor === Object && "[object Object]" === Object.prototype.toString.call(t2), u = (t2, ...e2) => {
        const i2 = e2.length;
        for (let n2 = 0; n2 < i2; n2++) {
          const i3 = e2[n2] || {};
          Object.entries(i3).forEach(([e3, i4]) => {
            const n3 = Array.isArray(i4) ? [] : {};
            t2[e3] || Object.assign(t2, { [e3]: n3 }), d(i4) ? Object.assign(t2[e3], u(n3, i4)) : Array.isArray(i4) ? Object.assign(t2, { [e3]: [...i4] }) : Object.assign(t2, { [e3]: i4 });
          });
        }
        return t2;
      }, p = function(t2, e2) {
        return t2.split(".").reduce((t3, e3) => "object" == typeof t3 ? t3[e3] : void 0, e2);
      };
      class f {
        constructor(t2 = {}) {
          Object.defineProperty(this, "options", { enumerable: true, configurable: true, writable: true, value: t2 }), Object.defineProperty(this, "events", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Map() }), this.setOptions(t2);
          for (const t3 of Object.getOwnPropertyNames(Object.getPrototypeOf(this)))
            t3.startsWith("on") && "function" == typeof this[t3] && (this[t3] = this[t3].bind(this));
        }
        setOptions(t2) {
          this.options = t2 ? u({}, this.constructor.defaults, t2) : {};
          for (const [t3, e2] of Object.entries(this.option("on") || {}))
            this.on(t3, e2);
        }
        option(t2, ...e2) {
          let i2 = p(t2, this.options);
          return i2 && "function" == typeof i2 && (i2 = i2.call(this, this, ...e2)), i2;
        }
        optionFor(t2, e2, i2, ...n2) {
          let s2 = p(e2, t2);
          var o2;
          "string" != typeof (o2 = s2) || isNaN(o2) || isNaN(parseFloat(o2)) || (s2 = parseFloat(s2)), "true" === s2 && (s2 = true), "false" === s2 && (s2 = false), s2 && "function" == typeof s2 && (s2 = s2.call(this, this, t2, ...n2));
          let a2 = p(e2, this.options);
          return a2 && "function" == typeof a2 ? s2 = a2.call(this, this, t2, ...n2, s2) : void 0 === s2 && (s2 = a2), void 0 === s2 ? i2 : s2;
        }
        cn(t2) {
          const e2 = this.options.classes;
          return e2 && e2[t2] || "";
        }
        localize(t2, e2 = []) {
          t2 = String(t2).replace(/\{\{(\w+).?(\w+)?\}\}/g, (t3, e3, i2) => {
            let n2 = "";
            return i2 ? n2 = this.option(`${e3[0] + e3.toLowerCase().substring(1)}.l10n.${i2}`) : e3 && (n2 = this.option(`l10n.${e3}`)), n2 || (n2 = t3), n2;
          });
          for (let i2 = 0; i2 < e2.length; i2++)
            t2 = t2.split(e2[i2][0]).join(e2[i2][1]);
          return t2 = t2.replace(/\{\{(.*?)\}\}/g, (t3, e3) => e3);
        }
        on(t2, e2) {
          let i2 = [];
          "string" == typeof t2 ? i2 = t2.split(" ") : Array.isArray(t2) && (i2 = t2), this.events || (this.events = /* @__PURE__ */ new Map()), i2.forEach((t3) => {
            let i3 = this.events.get(t3);
            i3 || (this.events.set(t3, []), i3 = []), i3.includes(e2) || i3.push(e2), this.events.set(t3, i3);
          });
        }
        off(t2, e2) {
          let i2 = [];
          "string" == typeof t2 ? i2 = t2.split(" ") : Array.isArray(t2) && (i2 = t2), i2.forEach((t3) => {
            const i3 = this.events.get(t3);
            if (Array.isArray(i3)) {
              const t4 = i3.indexOf(e2);
              t4 > -1 && i3.splice(t4, 1);
            }
          });
        }
        emit(t2, ...e2) {
          [...this.events.get(t2) || []].forEach((t3) => t3(this, ...e2)), "*" !== t2 && this.emit("*", t2, ...e2);
        }
      }
      Object.defineProperty(f, "version", { enumerable: true, configurable: true, writable: true, value: "5.0.20" }), Object.defineProperty(f, "defaults", { enumerable: true, configurable: true, writable: true, value: {} });
      class m extends f {
        constructor(t2 = {}) {
          super(t2), Object.defineProperty(this, "plugins", { enumerable: true, configurable: true, writable: true, value: {} });
        }
        attachPlugins(t2 = {}) {
          const e2 = /* @__PURE__ */ new Map();
          for (const [i2, n2] of Object.entries(t2)) {
            const t3 = this.option(i2), s2 = this.plugins[i2];
            s2 || false === t3 ? s2 && false === t3 && (s2.detach(), delete this.plugins[i2]) : e2.set(i2, new n2(this, t3 || {}));
          }
          for (const [t3, i2] of e2)
            this.plugins[t3] = i2, i2.attach();
          this.emit("attachPlugins");
        }
        detachPlugins(t2) {
          t2 = t2 || Object.keys(this.plugins);
          for (const e2 of t2) {
            const t3 = this.plugins[e2];
            t3 && t3.detach(), delete this.plugins[e2];
          }
          return this.emit("detachPlugins"), this;
        }
      }
      var g;
      !function(t2) {
        t2[t2.Init = 0] = "Init", t2[t2.Error = 1] = "Error", t2[t2.Ready = 2] = "Ready", t2[t2.Panning = 3] = "Panning", t2[t2.Mousemove = 4] = "Mousemove", t2[t2.Destroy = 5] = "Destroy";
      }(g || (g = {}));
      const b = ["a", "b", "c", "d", "e", "f"], v = { PANUP: "Move up", PANDOWN: "Move down", PANLEFT: "Move left", PANRIGHT: "Move right", ZOOMIN: "Zoom in", ZOOMOUT: "Zoom out", TOGGLEZOOM: "Toggle zoom level", TOGGLE1TO1: "Toggle zoom level", ITERATEZOOM: "Toggle zoom level", ROTATECCW: "Rotate counterclockwise", ROTATECW: "Rotate clockwise", FLIPX: "Flip horizontally", FLIPY: "Flip vertically", FITX: "Fit horizontally", FITY: "Fit vertically", RESET: "Reset", TOGGLEFS: "Toggle fullscreen" }, y = { content: null, width: "auto", height: "auto", panMode: "drag", touch: true, dragMinThreshold: 3, lockAxis: false, mouseMoveFactor: 1, mouseMoveFriction: 0.12, zoom: true, pinchToZoom: true, panOnlyZoomed: "auto", minScale: 1, maxScale: 2, friction: 0.25, dragFriction: 0.35, decelFriction: 0.05, click: "toggleZoom", dblClick: false, wheel: "zoom", wheelLimit: 7, spinner: true, bounds: "auto", infinite: false, rubberband: true, bounce: true, maxVelocity: 75, transformParent: false, classes: { content: "f-panzoom__content", isLoading: "is-loading", canZoomIn: "can-zoom_in", canZoomOut: "can-zoom_out", isDraggable: "is-draggable", isDragging: "is-dragging", inFullscreen: "in-fullscreen", htmlHasFullscreen: "with-panzoom-in-fullscreen" }, l10n: v }, w = '<div class="f-spinner"><svg viewBox="0 0 50 50"><circle cx="25" cy="25" r="20"></circle><circle cx="25" cy="25" r="20"></circle></svg></div>', x = (t2) => t2 && null !== t2 && t2 instanceof Element && "nodeType" in t2, E = (t2, e2) => {
        t2 && s(e2).forEach((e3) => {
          t2.classList.remove(e3);
        });
      }, S = (t2, e2) => {
        t2 && s(e2).forEach((e3) => {
          t2.classList.add(e3);
        });
      }, P = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 }, C = 1e5, M = 1e3, T = "mousemove", O = "drag", A = "content";
      let z = null, L = null;
      class R extends m {
        get isTouchDevice() {
          return null === L && (L = window.matchMedia("(hover: none)").matches), L;
        }
        get isMobile() {
          return null === z && (z = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)), z;
        }
        get panMode() {
          return this.options.panMode !== T || this.isTouchDevice ? O : T;
        }
        get panOnlyZoomed() {
          const t2 = this.options.panOnlyZoomed;
          return "auto" === t2 ? this.isTouchDevice : t2;
        }
        get isInfinite() {
          return this.option("infinite");
        }
        get angle() {
          return 180 * Math.atan2(this.current.b, this.current.a) / Math.PI || 0;
        }
        get targetAngle() {
          return 180 * Math.atan2(this.target.b, this.target.a) / Math.PI || 0;
        }
        get scale() {
          const { a: t2, b: e2 } = this.current;
          return Math.sqrt(t2 * t2 + e2 * e2) || 1;
        }
        get targetScale() {
          const { a: t2, b: e2 } = this.target;
          return Math.sqrt(t2 * t2 + e2 * e2) || 1;
        }
        get minScale() {
          return this.option("minScale") || 1;
        }
        get fullScale() {
          const { contentRect: t2 } = this;
          return t2.fullWidth / t2.fitWidth || 1;
        }
        get maxScale() {
          return this.fullScale * (this.option("maxScale") || 1) || 1;
        }
        get coverScale() {
          const { containerRect: t2, contentRect: e2 } = this, i2 = Math.max(t2.height / e2.fitHeight, t2.width / e2.fitWidth) || 1;
          return Math.min(this.fullScale, i2);
        }
        get isScaling() {
          return Math.abs(this.targetScale - this.scale) > 1e-5 && !this.isResting;
        }
        get isContentLoading() {
          const t2 = this.content;
          return !!(t2 && t2 instanceof HTMLImageElement) && !t2.complete;
        }
        get isResting() {
          if (this.isBouncingX || this.isBouncingY)
            return false;
          for (const t2 of b) {
            const e2 = "e" == t2 || "f" === t2 ? 1e-3 : 1e-5;
            if (Math.abs(this.target[t2] - this.current[t2]) > e2)
              return false;
          }
          return !(!this.ignoreBounds && !this.checkBounds().inBounds);
        }
        constructor(t2, e2 = {}, i2 = {}) {
          var s2;
          if (super(e2), Object.defineProperty(this, "pointerTracker", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "resizeObserver", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "updateTimer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "clickTimer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "rAF", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "isTicking", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "friction", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "ignoreBounds", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "isBouncingX", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "isBouncingY", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "clicks", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "trackingPoints", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "pwt", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "cwd", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "pmme", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: g.Init }), Object.defineProperty(this, "isDragging", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "content", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "spinner", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "containerRect", { enumerable: true, configurable: true, writable: true, value: { width: 0, height: 0, innerWidth: 0, innerHeight: 0 } }), Object.defineProperty(this, "contentRect", { enumerable: true, configurable: true, writable: true, value: { top: 0, right: 0, bottom: 0, left: 0, fullWidth: 0, fullHeight: 0, fitWidth: 0, fitHeight: 0, width: 0, height: 0 } }), Object.defineProperty(this, "dragStart", { enumerable: true, configurable: true, writable: true, value: { x: 0, y: 0, top: 0, left: 0, time: 0 } }), Object.defineProperty(this, "dragOffset", { enumerable: true, configurable: true, writable: true, value: { x: 0, y: 0, time: 0 } }), Object.defineProperty(this, "current", { enumerable: true, configurable: true, writable: true, value: Object.assign({}, P) }), Object.defineProperty(this, "target", { enumerable: true, configurable: true, writable: true, value: Object.assign({}, P) }), Object.defineProperty(this, "velocity", { enumerable: true, configurable: true, writable: true, value: { a: 0, b: 0, c: 0, d: 0, e: 0, f: 0 } }), Object.defineProperty(this, "lockedAxis", { enumerable: true, configurable: true, writable: true, value: false }), !t2)
            throw new Error("Container Element Not Found");
          this.container = t2, this.initContent(), this.attachPlugins(Object.assign(Object.assign({}, R.Plugins), i2)), this.emit("init");
          const o2 = this.content;
          if (o2.addEventListener("load", this.onLoad), o2.addEventListener("error", this.onError), this.isContentLoading) {
            if (this.option("spinner")) {
              t2.classList.add(this.cn("isLoading"));
              const e3 = n(w);
              !t2.contains(o2) || o2.parentElement instanceof HTMLPictureElement ? this.spinner = t2.appendChild(e3) : this.spinner = (null === (s2 = o2.parentElement) || void 0 === s2 ? void 0 : s2.insertBefore(e3, o2)) || null;
            }
            this.emit("beforeLoad");
          } else
            queueMicrotask(() => {
              this.enable();
            });
        }
        initContent() {
          const { container: t2 } = this, e2 = this.cn(A);
          let i2 = this.option(A) || t2.querySelector(`.${e2}`);
          if (i2 || (i2 = t2.querySelector("img,picture") || t2.firstElementChild, i2 && S(i2, e2)), i2 instanceof HTMLPictureElement && (i2 = i2.querySelector("img")), !i2)
            throw new Error("No content found");
          this.content = i2;
        }
        onLoad() {
          this.spinner && (this.spinner.remove(), this.spinner = null), this.option("spinner") && this.container.classList.remove(this.cn("isLoading")), this.emit("afterLoad"), this.state === g.Init ? this.enable() : this.updateMetrics();
        }
        onError() {
          this.state !== g.Destroy && (this.spinner && (this.spinner.remove(), this.spinner = null), this.stop(), this.detachEvents(), this.state = g.Error, this.emit("error"));
        }
        attachObserver() {
          var t2;
          const e2 = () => Math.abs(this.containerRect.width - this.container.getBoundingClientRect().width) > 0.1 || Math.abs(this.containerRect.height - this.container.getBoundingClientRect().height) > 0.1;
          this.resizeObserver || void 0 === window.ResizeObserver || (this.resizeObserver = new ResizeObserver(() => {
            this.updateTimer || (e2() ? (this.onResize(), this.isMobile && (this.updateTimer = setTimeout(() => {
              e2() && this.onResize(), this.updateTimer = null;
            }, 500))) : this.updateTimer && (clearTimeout(this.updateTimer), this.updateTimer = null));
          })), null === (t2 = this.resizeObserver) || void 0 === t2 || t2.observe(this.container);
        }
        detachObserver() {
          var t2;
          null === (t2 = this.resizeObserver) || void 0 === t2 || t2.disconnect();
        }
        attachEvents() {
          const { container: t2 } = this;
          t2.addEventListener("click", this.onClick, { passive: false, capture: false }), t2.addEventListener("wheel", this.onWheel, { passive: false }), this.pointerTracker = new l(t2, { start: this.onPointerDown, move: this.onPointerMove, end: this.onPointerUp }), document.addEventListener(T, this.onMouseMove);
        }
        detachEvents() {
          var t2;
          const { container: e2 } = this;
          e2.removeEventListener("click", this.onClick, { passive: false, capture: false }), e2.removeEventListener("wheel", this.onWheel, { passive: false }), null === (t2 = this.pointerTracker) || void 0 === t2 || t2.stop(), this.pointerTracker = null, document.removeEventListener(T, this.onMouseMove), document.removeEventListener("keydown", this.onKeydown, true), this.clickTimer && (clearTimeout(this.clickTimer), this.clickTimer = null), this.updateTimer && (clearTimeout(this.updateTimer), this.updateTimer = null);
        }
        animate() {
          const t2 = this.friction;
          this.setTargetForce();
          const e2 = this.option("maxVelocity");
          for (const i2 of b)
            t2 ? (this.velocity[i2] *= 1 - t2, e2 && !this.isScaling && (this.velocity[i2] = Math.max(Math.min(this.velocity[i2], e2), -1 * e2)), this.current[i2] += this.velocity[i2]) : this.current[i2] = this.target[i2];
          this.setTransform(), this.setEdgeForce(), !this.isResting || this.isDragging ? this.rAF = requestAnimationFrame(() => this.animate()) : this.stop("current");
        }
        setTargetForce() {
          for (const t2 of b)
            "e" === t2 && this.isBouncingX || "f" === t2 && this.isBouncingY || (this.velocity[t2] = (1 / (1 - this.friction) - 1) * (this.target[t2] - this.current[t2]));
        }
        checkBounds(t2 = 0, e2 = 0) {
          const { current: i2 } = this, n2 = i2.e + t2, s2 = i2.f + e2, o2 = this.getBounds(), { x: a2, y: r2 } = o2, l2 = a2.min, c2 = a2.max, h2 = r2.min, d2 = r2.max;
          let u2 = 0, p2 = 0;
          return l2 !== 1 / 0 && n2 < l2 ? u2 = l2 - n2 : c2 !== 1 / 0 && n2 > c2 && (u2 = c2 - n2), h2 !== 1 / 0 && s2 < h2 ? p2 = h2 - s2 : d2 !== 1 / 0 && s2 > d2 && (p2 = d2 - s2), Math.abs(u2) < 1e-3 && (u2 = 0), Math.abs(p2) < 1e-3 && (p2 = 0), Object.assign(Object.assign({}, o2), { xDiff: u2, yDiff: p2, inBounds: !u2 && !p2 });
        }
        clampTargetBounds() {
          const { target: t2 } = this, { x: e2, y: i2 } = this.getBounds();
          e2.min !== 1 / 0 && (t2.e = Math.max(t2.e, e2.min)), e2.max !== 1 / 0 && (t2.e = Math.min(t2.e, e2.max)), i2.min !== 1 / 0 && (t2.f = Math.max(t2.f, i2.min)), i2.max !== 1 / 0 && (t2.f = Math.min(t2.f, i2.max));
        }
        calculateContentDim(t2 = this.current) {
          const { content: e2, contentRect: i2 } = this, { fitWidth: n2, fitHeight: s2, fullWidth: o2, fullHeight: a2 } = i2;
          let r2 = o2, l2 = a2;
          if (this.option("zoom") || 0 !== this.angle) {
            const i3 = !(e2 instanceof HTMLImageElement) && ("none" === window.getComputedStyle(e2).maxWidth || "none" === window.getComputedStyle(e2).maxHeight), c2 = i3 ? o2 : n2, h2 = i3 ? a2 : s2, d2 = this.getMatrix(t2), u2 = new DOMPoint(0, 0).matrixTransform(d2), p2 = new DOMPoint(0 + c2, 0).matrixTransform(d2), f2 = new DOMPoint(0 + c2, 0 + h2).matrixTransform(d2), m2 = new DOMPoint(0, 0 + h2).matrixTransform(d2), g2 = Math.abs(f2.x - u2.x), b2 = Math.abs(f2.y - u2.y), v2 = Math.abs(m2.x - p2.x), y2 = Math.abs(m2.y - p2.y);
            r2 = Math.max(g2, v2), l2 = Math.max(b2, y2);
          }
          return { contentWidth: r2, contentHeight: l2 };
        }
        setEdgeForce() {
          if (this.ignoreBounds || this.isDragging || this.panMode === T || this.targetScale < this.scale)
            return this.isBouncingX = false, void (this.isBouncingY = false);
          const { target: t2 } = this, { x: e2, y: i2, xDiff: n2, yDiff: s2 } = this.checkBounds();
          const o2 = this.option("maxVelocity");
          let a2 = this.velocity.e, r2 = this.velocity.f;
          0 !== n2 ? (this.isBouncingX = true, n2 * a2 <= 0 ? a2 += 0.14 * n2 : (a2 = 0.14 * n2, e2.min !== 1 / 0 && (this.target.e = Math.max(t2.e, e2.min)), e2.max !== 1 / 0 && (this.target.e = Math.min(t2.e, e2.max))), o2 && (a2 = Math.max(Math.min(a2, o2), -1 * o2))) : this.isBouncingX = false, 0 !== s2 ? (this.isBouncingY = true, s2 * r2 <= 0 ? r2 += 0.14 * s2 : (r2 = 0.14 * s2, i2.min !== 1 / 0 && (this.target.f = Math.max(t2.f, i2.min)), i2.max !== 1 / 0 && (this.target.f = Math.min(t2.f, i2.max))), o2 && (r2 = Math.max(Math.min(r2, o2), -1 * o2))) : this.isBouncingY = false, this.isBouncingX && (this.velocity.e = a2), this.isBouncingY && (this.velocity.f = r2);
        }
        enable() {
          const { content: t2 } = this, e2 = new DOMMatrixReadOnly(window.getComputedStyle(t2).transform);
          for (const t3 of b)
            this.current[t3] = this.target[t3] = e2[t3];
          this.updateMetrics(), this.attachObserver(), this.attachEvents(), this.state = g.Ready, this.emit("ready");
        }
        onClick(t2) {
          var e2;
          this.isDragging && (null === (e2 = this.pointerTracker) || void 0 === e2 || e2.clear(), this.trackingPoints = [], this.startDecelAnim());
          const i2 = t2.target;
          if (!i2 || t2.defaultPrevented)
            return;
          if (i2 && i2.hasAttribute("disabled"))
            return t2.preventDefault(), void t2.stopPropagation();
          if ((() => {
            const t3 = window.getSelection();
            return t3 && "Range" === t3.type;
          })() && !i2.closest("button"))
            return;
          const n2 = i2.closest("[data-panzoom-action]"), s2 = i2.closest("[data-panzoom-change]"), o2 = n2 || s2, a2 = o2 && x(o2) ? o2.dataset : null;
          if (a2) {
            const e3 = a2.panzoomChange, i3 = a2.panzoomAction;
            if ((e3 || i3) && t2.preventDefault(), e3) {
              let t3 = {};
              try {
                t3 = JSON.parse(e3);
              } catch (t4) {
                console && console.warn("The given data was not valid JSON");
              }
              return void this.applyChange(t3);
            }
            if (i3)
              return void (this[i3] && this[i3]());
          }
          if (Math.abs(this.dragOffset.x) > 3 || Math.abs(this.dragOffset.y) > 3)
            return t2.preventDefault(), void t2.stopPropagation();
          const r2 = this.content.getBoundingClientRect();
          if (this.dragStart.time && !this.canZoomOut() && (Math.abs(r2.x - this.dragStart.x) > 2 || Math.abs(r2.y - this.dragStart.y) > 2))
            return;
          this.dragStart.time = 0;
          const l2 = (e3) => {
            this.option("zoom") && e3 && "string" == typeof e3 && /(iterateZoom)|(toggle(Zoom|Full|Cover|Max)|(zoomTo(Fit|Cover|Max)))/.test(e3) && "function" == typeof this[e3] && (t2.preventDefault(), this[e3]({ event: t2 }));
          }, c2 = this.option("click", t2), h2 = this.option("dblClick", t2);
          h2 ? (this.clicks++, 1 == this.clicks && (this.clickTimer = setTimeout(() => {
            1 === this.clicks ? (this.emit("click", t2), !t2.defaultPrevented && c2 && l2(c2)) : (this.emit("dblClick", t2), t2.defaultPrevented || l2(h2)), this.clicks = 0, this.clickTimer = null;
          }, 350))) : (this.emit("click", t2), !t2.defaultPrevented && c2 && l2(c2));
        }
        addTrackingPoint(t2) {
          const e2 = this.trackingPoints.filter((t3) => t3.time > Date.now() - 100);
          e2.push(t2), this.trackingPoints = e2;
        }
        onPointerDown(t2, e2, i2) {
          var n2;
          this.pwt = 0, this.dragOffset = { x: 0, y: 0, time: 0 }, this.trackingPoints = [];
          const s2 = this.content.getBoundingClientRect();
          if (this.dragStart = { x: s2.x, y: s2.y, top: s2.top, left: s2.left, time: Date.now() }, this.clickTimer)
            return false;
          if (this.panMode === T && this.targetScale > 1)
            return t2.preventDefault(), t2.stopPropagation(), false;
          if (!i2.length) {
            const e3 = t2.composedPath()[0];
            if (["A", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].includes(e3.nodeName) || e3.closest("[contenteditable]") || e3.closest("[data-selectable]") || e3.closest("[data-draggable]") || e3.closest("[data-clickable]") || e3.closest("[data-panzoom-change]") || e3.closest("[data-panzoom-action]"))
              return false;
            null === (n2 = window.getSelection()) || void 0 === n2 || n2.removeAllRanges();
          }
          if ("mousedown" === t2.type)
            t2.preventDefault();
          else if (Math.abs(this.velocity.a) > 0.3)
            return false;
          return this.target.e = this.current.e, this.target.f = this.current.f, this.stop(), this.isDragging || (this.isDragging = true, this.addTrackingPoint(e2), this.emit("touchStart", t2)), true;
        }
        onPointerMove(e2, n2, s2) {
          if (false === this.option("touch", e2))
            return;
          if (!this.isDragging)
            return;
          if (n2.length < 2 && this.panOnlyZoomed && t(this.targetScale) <= t(this.minScale))
            return;
          if (this.emit("touchMove", e2), e2.defaultPrevented)
            return;
          this.addTrackingPoint(n2[0]);
          const { content: o2 } = this, a2 = h(s2[0], s2[1]), r2 = h(n2[0], n2[1]);
          let l2 = 0, d2 = 0;
          if (n2.length > 1) {
            const t2 = o2.getBoundingClientRect();
            l2 = a2.clientX - t2.left - 0.5 * t2.width, d2 = a2.clientY - t2.top - 0.5 * t2.height;
          }
          const u2 = c(s2[0], s2[1]), p2 = c(n2[0], n2[1]);
          let f2 = u2 ? p2 / u2 : 1, m2 = r2.clientX - a2.clientX, g2 = r2.clientY - a2.clientY;
          this.dragOffset.x += m2, this.dragOffset.y += g2, this.dragOffset.time = Date.now() - this.dragStart.time;
          let b2 = t(this.targetScale) === t(this.minScale) && this.option("lockAxis");
          if (b2 && !this.lockedAxis)
            if ("xy" === b2 || "y" === b2 || "touchmove" === e2.type) {
              if (Math.abs(this.dragOffset.x) < 6 && Math.abs(this.dragOffset.y) < 6)
                return void e2.preventDefault();
              const t2 = Math.abs(180 * Math.atan2(this.dragOffset.y, this.dragOffset.x) / Math.PI);
              this.lockedAxis = t2 > 45 && t2 < 135 ? "y" : "x", this.dragOffset.x = 0, this.dragOffset.y = 0, m2 = 0, g2 = 0;
            } else
              this.lockedAxis = b2;
          if (i(e2.target, this.content) && (b2 = "x", this.dragOffset.y = 0), b2 && "xy" !== b2 && this.lockedAxis !== b2 && t(this.targetScale) === t(this.minScale))
            return;
          e2.cancelable && e2.preventDefault(), this.container.classList.add(this.cn("isDragging"));
          const v2 = this.checkBounds(m2, g2);
          this.option("rubberband") ? ("x" !== this.isInfinite && (v2.xDiff > 0 && m2 < 0 || v2.xDiff < 0 && m2 > 0) && (m2 *= Math.max(0, 0.5 - Math.abs(0.75 / this.contentRect.fitWidth * v2.xDiff))), "y" !== this.isInfinite && (v2.yDiff > 0 && g2 < 0 || v2.yDiff < 0 && g2 > 0) && (g2 *= Math.max(0, 0.5 - Math.abs(0.75 / this.contentRect.fitHeight * v2.yDiff)))) : (v2.xDiff && (m2 = 0), v2.yDiff && (g2 = 0));
          const y2 = this.targetScale, w2 = this.minScale, x2 = this.maxScale;
          y2 < 0.5 * w2 && (f2 = Math.max(f2, w2)), y2 > 1.5 * x2 && (f2 = Math.min(f2, x2)), "y" === this.lockedAxis && t(y2) === t(w2) && (m2 = 0), "x" === this.lockedAxis && t(y2) === t(w2) && (g2 = 0), this.applyChange({ originX: l2, originY: d2, panX: m2, panY: g2, scale: f2, friction: this.option("dragFriction"), ignoreBounds: true });
        }
        onPointerUp(t2, e2, n2) {
          if (n2.length)
            return this.dragOffset.x = 0, this.dragOffset.y = 0, void (this.trackingPoints = []);
          this.container.classList.remove(this.cn("isDragging")), this.isDragging && (this.addTrackingPoint(e2), this.panOnlyZoomed && this.contentRect.width - this.contentRect.fitWidth < 1 && this.contentRect.height - this.contentRect.fitHeight < 1 && (this.trackingPoints = []), i(t2.target, this.content) && "y" === this.lockedAxis && (this.trackingPoints = []), this.emit("touchEnd", t2), this.isDragging = false, this.lockedAxis = false, this.state !== g.Destroy && (t2.defaultPrevented || this.startDecelAnim()));
        }
        startDecelAnim() {
          var e2;
          const i2 = this.isScaling;
          this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.isBouncingX = false, this.isBouncingY = false;
          for (const t2 of b)
            this.velocity[t2] = 0;
          this.target.e = this.current.e, this.target.f = this.current.f, E(this.container, "is-scaling"), E(this.container, "is-animating"), this.isTicking = false;
          const { trackingPoints: n2 } = this, s2 = n2[0], o2 = n2[n2.length - 1];
          let a2 = 0, r2 = 0, l2 = 0;
          o2 && s2 && (a2 = o2.clientX - s2.clientX, r2 = o2.clientY - s2.clientY, l2 = o2.time - s2.time);
          const c2 = (null === (e2 = window.visualViewport) || void 0 === e2 ? void 0 : e2.scale) || 1;
          1 !== c2 && (a2 *= c2, r2 *= c2);
          let h2 = 0, d2 = 0, u2 = 0, p2 = 0, f2 = this.option("decelFriction");
          const m2 = this.targetScale;
          if (l2 > 0) {
            u2 = Math.abs(a2) > 3 ? a2 / (l2 / 30) : 0, p2 = Math.abs(r2) > 3 ? r2 / (l2 / 30) : 0;
            const t2 = this.option("maxVelocity");
            t2 && (u2 = Math.max(Math.min(u2, t2), -1 * t2), p2 = Math.max(Math.min(p2, t2), -1 * t2));
          }
          u2 && (h2 = u2 / (1 / (1 - f2) - 1)), p2 && (d2 = p2 / (1 / (1 - f2) - 1)), ("y" === this.option("lockAxis") || "xy" === this.option("lockAxis") && "y" === this.lockedAxis && t(m2) === this.minScale) && (h2 = u2 = 0), ("x" === this.option("lockAxis") || "xy" === this.option("lockAxis") && "x" === this.lockedAxis && t(m2) === this.minScale) && (d2 = p2 = 0);
          const g2 = this.dragOffset.x, v2 = this.dragOffset.y, y2 = this.option("dragMinThreshold") || 0;
          Math.abs(g2) < y2 && Math.abs(v2) < y2 && (h2 = d2 = 0, u2 = p2 = 0), (m2 < this.minScale - 1e-5 || m2 > this.maxScale + 1e-5 || i2 && !h2 && !d2) && (f2 = 0.35), this.applyChange({ panX: h2, panY: d2, friction: f2 }), this.emit("decel", u2, p2, g2, v2);
        }
        onWheel(t2) {
          var e2 = [-t2.deltaX || 0, -t2.deltaY || 0, -t2.detail || 0].reduce(function(t3, e3) {
            return Math.abs(e3) > Math.abs(t3) ? e3 : t3;
          });
          const i2 = Math.max(-1, Math.min(1, e2));
          if (this.emit("wheel", t2, i2), this.panMode === T)
            return;
          if (t2.defaultPrevented)
            return;
          const n2 = this.option("wheel");
          "pan" === n2 ? (t2.preventDefault(), this.panOnlyZoomed && !this.canZoomOut() || this.applyChange({ panX: 2 * -t2.deltaX, panY: 2 * -t2.deltaY, bounce: false })) : "zoom" === n2 && false !== this.option("zoom") && this.zoomWithWheel(t2);
        }
        onMouseMove(t2) {
          this.panWithMouse(t2);
        }
        onKeydown(t2) {
          "Escape" === t2.key && this.toggleFS();
        }
        onResize() {
          this.updateMetrics(), this.checkBounds().inBounds || this.requestTick();
        }
        setTransform() {
          this.emit("beforeTransform");
          const { current: e2, target: i2, content: n2, contentRect: s2 } = this, o2 = Object.assign({}, P);
          for (const n3 of b) {
            const s3 = "e" == n3 || "f" === n3 ? M : C;
            o2[n3] = t(e2[n3], s3), Math.abs(i2[n3] - e2[n3]) < ("e" == n3 || "f" === n3 ? 0.51 : 1e-3) && (e2[n3] = i2[n3]);
          }
          let { a: a2, b: r2, c: l2, d: c2, e: h2, f: d2 } = o2, u2 = `matrix(${a2}, ${r2}, ${l2}, ${c2}, ${h2}, ${d2})`, p2 = n2.parentElement instanceof HTMLPictureElement ? n2.parentElement : n2;
          if (this.option("transformParent") && (p2 = p2.parentElement || p2), p2.style.transform === u2)
            return;
          p2.style.transform = u2;
          const { contentWidth: f2, contentHeight: m2 } = this.calculateContentDim();
          s2.width = f2, s2.height = m2, this.emit("afterTransform");
        }
        updateMetrics(e2 = false) {
          var i2;
          if (!this || this.state === g.Destroy)
            return;
          if (this.isContentLoading)
            return;
          const n2 = Math.max(1, (null === (i2 = window.visualViewport) || void 0 === i2 ? void 0 : i2.scale) || 1), { container: s2, content: o2 } = this, a2 = o2 instanceof HTMLImageElement, r2 = s2.getBoundingClientRect(), l2 = getComputedStyle(this.container);
          let c2 = r2.width * n2, h2 = r2.height * n2;
          const d2 = parseFloat(l2.paddingTop) + parseFloat(l2.paddingBottom), u2 = c2 - (parseFloat(l2.paddingLeft) + parseFloat(l2.paddingRight)), p2 = h2 - d2;
          this.containerRect = { width: c2, height: h2, innerWidth: u2, innerHeight: p2 };
          let f2 = this.option("width") || "auto", m2 = this.option("height") || "auto";
          "auto" === f2 && (f2 = parseFloat(o2.dataset.width || "") || ((t2) => {
            let e3 = 0;
            return e3 = t2 instanceof HTMLImageElement ? t2.naturalWidth : t2 instanceof SVGElement ? t2.width.baseVal.value : Math.max(t2.offsetWidth, t2.scrollWidth), e3 || 0;
          })(o2)), "auto" === m2 && (m2 = parseFloat(o2.dataset.height || "") || ((t2) => {
            let e3 = 0;
            return e3 = t2 instanceof HTMLImageElement ? t2.naturalHeight : t2 instanceof SVGElement ? t2.height.baseVal.value : Math.max(t2.offsetHeight, t2.scrollHeight), e3 || 0;
          })(o2));
          let b2 = o2.parentElement instanceof HTMLPictureElement ? o2.parentElement : o2;
          this.option("transformParent") && (b2 = b2.parentElement || b2);
          const v2 = b2.getAttribute("style") || "";
          b2.style.setProperty("transform", "none", "important"), a2 && (b2.style.width = "", b2.style.height = ""), b2.offsetHeight;
          const y2 = o2.getBoundingClientRect();
          let w2 = y2.width * n2, x2 = y2.height * n2, E2 = 0, S2 = 0;
          a2 && (Math.abs(f2 - w2) > 1 || Math.abs(m2 - x2) > 1) && ({ width: w2, height: x2, top: E2, left: S2 } = ((t2, e3, i3, n3) => {
            const s3 = i3 / n3;
            return s3 > t2 / e3 ? (i3 = t2, n3 = t2 / s3) : (i3 = e3 * s3, n3 = e3), { width: i3, height: n3, top: 0.5 * (e3 - n3), left: 0.5 * (t2 - i3) };
          })(w2, x2, f2, m2)), this.contentRect = Object.assign(Object.assign({}, this.contentRect), { top: y2.top - r2.top + E2, bottom: r2.bottom - y2.bottom + E2, left: y2.left - r2.left + S2, right: r2.right - y2.right + S2, fitWidth: w2, fitHeight: x2, width: w2, height: x2, fullWidth: f2, fullHeight: m2 }), b2.style.cssText = v2, a2 && (b2.style.width = `${w2}px`, b2.style.height = `${x2}px`), this.setTransform(), true !== e2 && this.emit("refresh"), this.ignoreBounds || (t(this.targetScale) < t(this.minScale) ? this.zoomTo(this.minScale, { friction: 0 }) : this.targetScale > this.maxScale ? this.zoomTo(this.maxScale, { friction: 0 }) : this.state === g.Init || this.checkBounds().inBounds || this.requestTick()), this.updateControls();
        }
        getBounds() {
          const e2 = this.option("bounds");
          if ("auto" !== e2)
            return e2;
          const { contentWidth: i2, contentHeight: n2 } = this.calculateContentDim(this.target);
          let s2 = 0, o2 = 0, a2 = 0, r2 = 0;
          const l2 = this.option("infinite");
          if (true === l2 || this.lockedAxis && l2 === this.lockedAxis)
            s2 = -1 / 0, a2 = 1 / 0, o2 = -1 / 0, r2 = 1 / 0;
          else {
            let { containerRect: e3, contentRect: l3 } = this, c2 = t(this.contentRect.fitWidth * this.targetScale, M), h2 = t(this.contentRect.fitHeight * this.targetScale, M), { innerWidth: d2, innerHeight: u2 } = e3;
            if (this.containerRect.width === c2 && (d2 = e3.width), this.containerRect.width === h2 && (u2 = e3.height), i2 > d2) {
              a2 = 0.5 * (i2 - d2), s2 = -1 * a2;
              let t2 = 0.5 * (l3.right - l3.left);
              s2 += t2, a2 += t2;
            }
            if (this.contentRect.fitWidth > d2 && i2 < d2 && (s2 -= 0.5 * (this.contentRect.fitWidth - d2), a2 -= 0.5 * (this.contentRect.fitWidth - d2)), n2 > u2) {
              r2 = 0.5 * (n2 - u2), o2 = -1 * r2;
              let t2 = 0.5 * (l3.bottom - l3.top);
              o2 += t2, r2 += t2;
            }
            this.contentRect.fitHeight > u2 && n2 < u2 && (s2 -= 0.5 * (this.contentRect.fitHeight - u2), a2 -= 0.5 * (this.contentRect.fitHeight - u2));
          }
          return { x: { min: s2, max: a2 }, y: { min: o2, max: r2 } };
        }
        updateControls() {
          const e2 = this, i2 = e2.container, { panMode: n2, contentRect: s2, fullScale: a2, targetScale: r2, coverScale: l2, maxScale: c2, minScale: h2 } = e2;
          let d2 = { toggleMax: r2 - h2 < 0.5 * (c2 - h2) ? c2 : h2, toggleCover: r2 - h2 < 0.5 * (l2 - h2) ? l2 : h2, toggleZoom: r2 - h2 < 0.5 * (a2 - h2) ? a2 : h2 }[e2.option("click") || ""] || h2, u2 = e2.canZoomIn(), p2 = e2.canZoomOut(), f2 = p2 && n2 === O;
          t(r2) < t(h2) && !this.panOnlyZoomed && (f2 = true), (t(s2.width, 1) > t(s2.fitWidth, 1) || t(s2.height, 1) > t(s2.fitHeight, 1)) && (f2 = true), t(s2.width * r2, 1) < t(s2.fitWidth, 1) && (f2 = false), n2 === T && (f2 = false);
          let m2 = u2 && t(d2) > t(r2), g2 = !m2 && !f2 && p2 && t(d2) < t(r2);
          o(i2, this.cn("canZoomIn"), m2), o(i2, this.cn("canZoomOut"), g2), o(i2, this.cn("isDraggable"), f2);
          for (const t2 of i2.querySelectorAll('[data-panzoom-action="zoomIn"]'))
            u2 ? (t2.removeAttribute("disabled"), t2.removeAttribute("tabindex")) : (t2.setAttribute("disabled", ""), t2.setAttribute("tabindex", "-1"));
          for (const t2 of i2.querySelectorAll('[data-panzoom-action="zoomOut"]'))
            p2 ? (t2.removeAttribute("disabled"), t2.removeAttribute("tabindex")) : (t2.setAttribute("disabled", ""), t2.setAttribute("tabindex", "-1"));
          for (const t2 of i2.querySelectorAll('[data-panzoom-action="toggleZoom"],[data-panzoom-action="iterateZoom"]')) {
            u2 || p2 ? (t2.removeAttribute("disabled"), t2.removeAttribute("tabindex")) : (t2.setAttribute("disabled", ""), t2.setAttribute("tabindex", "-1"));
            const e3 = t2.querySelector("g");
            e3 && (e3.style.display = u2 ? "" : "none");
          }
        }
        panTo({ x: t2 = this.target.e, y: e2 = this.target.f, scale: i2 = this.targetScale, friction: n2 = this.option("friction"), angle: s2 = 0, originX: o2 = 0, originY: a2 = 0, flipX: r2 = false, flipY: l2 = false, ignoreBounds: c2 = false }) {
          this.state !== g.Destroy && this.applyChange({ panX: t2 - this.target.e, panY: e2 - this.target.f, scale: i2 / this.targetScale, angle: s2, originX: o2, originY: a2, friction: n2, flipX: r2, flipY: l2, ignoreBounds: c2 });
        }
        applyChange({ panX: e2 = 0, panY: i2 = 0, scale: n2 = 1, angle: s2 = 0, originX: o2 = -this.current.e, originY: a2 = -this.current.f, friction: r2 = this.option("friction"), flipX: l2 = false, flipY: c2 = false, ignoreBounds: h2 = false, bounce: d2 = this.option("bounce") }) {
          if (this.state === g.Destroy)
            return;
          this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.friction = r2 || 0, this.ignoreBounds = h2;
          const { current: u2 } = this, p2 = u2.e, f2 = u2.f, m2 = this.getMatrix(this.target);
          let v2 = new DOMMatrix().translate(p2, f2).translate(o2, a2).translate(e2, i2);
          if (this.option("zoom")) {
            if (!h2) {
              const t2 = this.targetScale, e3 = this.minScale, i3 = this.maxScale;
              t2 * n2 < e3 && (n2 = e3 / t2), t2 * n2 > i3 && (n2 = i3 / t2);
            }
            v2 = v2.scale(n2);
          }
          v2 = v2.translate(-o2, -a2).translate(-p2, -f2).multiply(m2), s2 && (v2 = v2.rotate(s2)), l2 && (v2 = v2.scale(-1, 1)), c2 && (v2 = v2.scale(1, -1));
          for (const e3 of b)
            "e" !== e3 && "f" !== e3 && (v2[e3] > this.minScale + 1e-5 || v2[e3] < this.minScale - 1e-5) ? this.target[e3] = v2[e3] : this.target[e3] = t(v2[e3], M);
          (this.targetScale < this.scale || Math.abs(n2 - 1) > 0.1 || this.panMode === T || false === d2) && !h2 && this.clampTargetBounds(), this.isResting || (this.state = g.Panning, this.requestTick());
        }
        stop(t2 = false) {
          if (this.state === g.Init || this.state === g.Destroy)
            return;
          const e2 = this.isTicking;
          this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.isBouncingX = false, this.isBouncingY = false;
          for (const e3 of b)
            this.velocity[e3] = 0, "current" === t2 ? this.current[e3] = this.target[e3] : "target" === t2 && (this.target[e3] = this.current[e3]);
          this.setTransform(), E(this.container, "is-scaling"), E(this.container, "is-animating"), this.isTicking = false, this.state = g.Ready, e2 && (this.emit("endAnimation"), this.updateControls());
        }
        requestTick() {
          this.isTicking || (this.emit("startAnimation"), this.updateControls(), S(this.container, "is-animating"), this.isScaling && S(this.container, "is-scaling")), this.isTicking = true, this.rAF || (this.rAF = requestAnimationFrame(() => this.animate()));
        }
        panWithMouse(e2, i2 = this.option("mouseMoveFriction")) {
          if (this.pmme = e2, this.panMode !== T || !e2)
            return;
          if (t(this.targetScale) <= t(this.minScale))
            return;
          this.emit("mouseMove", e2);
          const { container: n2, containerRect: s2, contentRect: o2 } = this, a2 = s2.width, r2 = s2.height, l2 = n2.getBoundingClientRect(), c2 = (e2.clientX || 0) - l2.left, h2 = (e2.clientY || 0) - l2.top;
          let { contentWidth: d2, contentHeight: u2 } = this.calculateContentDim(this.target);
          const p2 = this.option("mouseMoveFactor");
          p2 > 1 && (d2 !== a2 && (d2 *= p2), u2 !== r2 && (u2 *= p2));
          let f2 = 0.5 * (d2 - a2) - c2 / a2 * 100 / 100 * (d2 - a2);
          f2 += 0.5 * (o2.right - o2.left);
          let m2 = 0.5 * (u2 - r2) - h2 / r2 * 100 / 100 * (u2 - r2);
          m2 += 0.5 * (o2.bottom - o2.top), this.applyChange({ panX: f2 - this.target.e, panY: m2 - this.target.f, friction: i2 });
        }
        zoomWithWheel(e2) {
          if (this.state === g.Destroy || this.state === g.Init)
            return;
          const i2 = Date.now();
          if (i2 - this.pwt < 45)
            return void e2.preventDefault();
          this.pwt = i2;
          var n2 = [-e2.deltaX || 0, -e2.deltaY || 0, -e2.detail || 0].reduce(function(t2, e3) {
            return Math.abs(e3) > Math.abs(t2) ? e3 : t2;
          });
          const s2 = Math.max(-1, Math.min(1, n2)), { targetScale: o2, maxScale: a2, minScale: r2 } = this;
          let l2 = o2 * (100 + 45 * s2) / 100;
          t(l2) < t(r2) && t(o2) <= t(r2) ? (this.cwd += Math.abs(s2), l2 = r2) : t(l2) > t(a2) && t(o2) >= t(a2) ? (this.cwd += Math.abs(s2), l2 = a2) : (this.cwd = 0, l2 = Math.max(Math.min(l2, a2), r2)), this.cwd > this.option("wheelLimit") || (e2.preventDefault(), t(l2) !== t(o2) && this.zoomTo(l2, { event: e2 }));
        }
        canZoomIn() {
          return this.option("zoom") && (t(this.contentRect.width, 1) < t(this.contentRect.fitWidth, 1) || t(this.targetScale) < t(this.maxScale));
        }
        canZoomOut() {
          return this.option("zoom") && t(this.targetScale) > t(this.minScale);
        }
        zoomIn(t2 = 1.25, e2) {
          this.zoomTo(this.targetScale * t2, e2);
        }
        zoomOut(t2 = 0.8, e2) {
          this.zoomTo(this.targetScale * t2, e2);
        }
        zoomToFit(t2) {
          this.zoomTo("fit", t2);
        }
        zoomToCover(t2) {
          this.zoomTo("cover", t2);
        }
        zoomToFull(t2) {
          this.zoomTo("full", t2);
        }
        zoomToMax(t2) {
          this.zoomTo("max", t2);
        }
        toggleZoom(t2) {
          this.zoomTo(this.targetScale - this.minScale < 0.5 * (this.fullScale - this.minScale) ? "full" : "fit", t2);
        }
        toggleMax(t2) {
          this.zoomTo(this.targetScale - this.minScale < 0.5 * (this.maxScale - this.minScale) ? "max" : "fit", t2);
        }
        toggleCover(t2) {
          this.zoomTo(this.targetScale - this.minScale < 0.5 * (this.coverScale - this.minScale) ? "cover" : "fit", t2);
        }
        iterateZoom(t2) {
          this.zoomTo("next", t2);
        }
        zoomTo(t2 = 1, { friction: e2 = "auto", originX: i2 = 0, originY: n2 = 0, event: s2 } = {}) {
          if (this.isContentLoading || this.state === g.Destroy)
            return;
          const { targetScale: o2 } = this;
          this.stop();
          let a2 = 1;
          if (this.panMode === T && (s2 = this.pmme || s2), s2) {
            const t3 = this.content.getBoundingClientRect(), e3 = s2.clientX || 0, o3 = s2.clientY || 0;
            i2 = e3 - t3.left - 0.5 * t3.width, n2 = o3 - t3.top - 0.5 * t3.height;
          }
          const r2 = this.fullScale, l2 = this.maxScale;
          let c2 = this.coverScale;
          "number" == typeof t2 ? a2 = t2 / o2 : ("next" === t2 && (r2 - c2 < 0.2 && (c2 = r2), t2 = o2 < r2 - 1e-5 ? "full" : o2 < l2 - 1e-5 ? "max" : "fit"), a2 = "full" === t2 ? r2 / o2 || 1 : "cover" === t2 ? c2 / o2 || 1 : "max" === t2 ? l2 / o2 || 1 : 1 / o2 || 1), e2 = "auto" === e2 ? a2 > 1 ? 0.15 : 0.25 : e2, this.applyChange({ scale: a2, originX: i2, originY: n2, friction: e2 }), s2 && this.panMode === T && this.panWithMouse(s2, e2);
        }
        rotateCCW() {
          this.applyChange({ angle: -90 });
        }
        rotateCW() {
          this.applyChange({ angle: 90 });
        }
        flipX() {
          this.applyChange({ flipX: true });
        }
        flipY() {
          this.applyChange({ flipY: true });
        }
        fitX() {
          this.stop("target");
          const { containerRect: t2, contentRect: e2, target: i2 } = this;
          this.applyChange({ panX: 0.5 * t2.width - (e2.left + 0.5 * e2.fitWidth) - i2.e, panY: 0.5 * t2.height - (e2.top + 0.5 * e2.fitHeight) - i2.f, scale: t2.width / e2.fitWidth / this.targetScale, originX: 0, originY: 0, ignoreBounds: true });
        }
        fitY() {
          this.stop("target");
          const { containerRect: t2, contentRect: e2, target: i2 } = this;
          this.applyChange({ panX: 0.5 * t2.width - (e2.left + 0.5 * e2.fitWidth) - i2.e, panY: 0.5 * t2.innerHeight - (e2.top + 0.5 * e2.fitHeight) - i2.f, scale: t2.height / e2.fitHeight / this.targetScale, originX: 0, originY: 0, ignoreBounds: true });
        }
        toggleFS() {
          const { container: t2 } = this, e2 = this.cn("inFullscreen"), i2 = this.cn("htmlHasFullscreen");
          t2.classList.toggle(e2);
          const n2 = t2.classList.contains(e2);
          n2 ? (document.documentElement.classList.add(i2), document.addEventListener("keydown", this.onKeydown, true)) : (document.documentElement.classList.remove(i2), document.removeEventListener("keydown", this.onKeydown, true)), this.updateMetrics(), this.emit(n2 ? "enterFS" : "exitFS");
        }
        getMatrix(t2 = this.current) {
          const { a: e2, b: i2, c: n2, d: s2, e: o2, f: a2 } = t2;
          return new DOMMatrix([e2, i2, n2, s2, o2, a2]);
        }
        reset(t2) {
          if (this.state !== g.Init && this.state !== g.Destroy) {
            this.stop("current");
            for (const t3 of b)
              this.target[t3] = P[t3];
            this.target.a = this.minScale, this.target.d = this.minScale, this.clampTargetBounds(), this.isResting || (this.friction = void 0 === t2 ? this.option("friction") : t2, this.state = g.Panning, this.requestTick());
          }
        }
        destroy() {
          this.stop(), this.state = g.Destroy, this.detachEvents(), this.detachObserver();
          const { container: t2, content: e2 } = this, i2 = this.option("classes") || {};
          for (const e3 of Object.values(i2))
            t2.classList.remove(e3 + "");
          e2 && (e2.removeEventListener("load", this.onLoad), e2.removeEventListener("error", this.onError)), this.detachPlugins();
        }
      }
      Object.defineProperty(R, "defaults", { enumerable: true, configurable: true, writable: true, value: y }), Object.defineProperty(R, "Plugins", { enumerable: true, configurable: true, writable: true, value: {} });
      const k = function(t2, e2) {
        let i2 = true;
        return (...n2) => {
          i2 && (i2 = false, t2(...n2), setTimeout(() => {
            i2 = true;
          }, e2));
        };
      }, I = (t2, e2) => {
        let i2 = [];
        return t2.childNodes.forEach((t3) => {
          t3.nodeType !== Node.ELEMENT_NODE || e2 && !t3.matches(e2) || i2.push(t3);
        }), i2;
      }, D = { viewport: null, track: null, enabled: true, slides: [], axis: "x", transition: "fade", preload: 1, slidesPerPage: "auto", initialPage: 0, friction: 0.12, Panzoom: { decelFriction: 0.12 }, center: true, infinite: true, fill: true, dragFree: false, adaptiveHeight: false, direction: "ltr", classes: { container: "f-carousel", viewport: "f-carousel__viewport", track: "f-carousel__track", slide: "f-carousel__slide", isLTR: "is-ltr", isRTL: "is-rtl", isHorizontal: "is-horizontal", isVertical: "is-vertical", inTransition: "in-transition", isSelected: "is-selected" }, l10n: { NEXT: "Next slide", PREV: "Previous slide", GOTO: "Go to slide #%d" } };
      var F;
      !function(t2) {
        t2[t2.Init = 0] = "Init", t2[t2.Ready = 1] = "Ready", t2[t2.Destroy = 2] = "Destroy";
      }(F || (F = {}));
      const j = (t2) => {
        if ("string" == typeof t2 && (t2 = { html: t2 }), !(t2 instanceof String || t2 instanceof HTMLElement)) {
          const e2 = t2.thumb;
          void 0 !== e2 && ("string" == typeof e2 && (t2.thumbSrc = e2), e2 instanceof HTMLImageElement && (t2.thumbEl = e2, t2.thumbElSrc = e2.src, t2.thumbSrc = e2.src), delete t2.thumb);
        }
        return Object.assign({ html: "", el: null, isDom: false, class: "", index: -1, dim: 0, gap: 0, pos: 0, transition: false }, t2);
      }, H = (t2 = {}) => Object.assign({ index: -1, slides: [], dim: 0, pos: -1 }, t2);
      class B extends f {
        constructor(t2, e2) {
          super(e2), Object.defineProperty(this, "instance", { enumerable: true, configurable: true, writable: true, value: t2 });
        }
        attach() {
        }
        detach() {
        }
      }
      const N = { classes: { list: "f-carousel__dots", isDynamic: "is-dynamic", hasDots: "has-dots", dot: "f-carousel__dot", isBeforePrev: "is-before-prev", isPrev: "is-prev", isCurrent: "is-current", isNext: "is-next", isAfterNext: "is-after-next" }, dotTpl: '<button type="button" data-carousel-page="%i" aria-label="{{GOTO}}"><span class="f-carousel__dot" aria-hidden="true"></span></button>', dynamicFrom: 11, maxCount: 1 / 0, minCount: 2 };
      class _ extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "isDynamic", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "list", { enumerable: true, configurable: true, writable: true, value: null });
        }
        onRefresh() {
          this.refresh();
        }
        build() {
          let t2 = this.list;
          return t2 || (t2 = document.createElement("ul"), S(t2, this.cn("list")), t2.setAttribute("role", "tablist"), this.instance.container.appendChild(t2), S(this.instance.container, this.cn("hasDots")), this.list = t2), t2;
        }
        refresh() {
          var t2;
          const e2 = this.instance.pages.length, i2 = Math.min(2, this.option("minCount")), n2 = Math.max(2e3, this.option("maxCount")), s2 = this.option("dynamicFrom");
          if (e2 < i2 || e2 > n2)
            return void this.cleanup();
          const a2 = "number" == typeof s2 && e2 > 5 && e2 >= s2, r2 = !this.list || this.isDynamic !== a2 || this.list.children.length !== e2;
          r2 && this.cleanup();
          const l2 = this.build();
          if (o(l2, this.cn("isDynamic"), !!a2), r2)
            for (let t3 = 0; t3 < e2; t3++)
              l2.append(this.createItem(t3));
          let c2, h2 = 0;
          for (const e3 of [...l2.children]) {
            const i3 = h2 === this.instance.page;
            i3 && (c2 = e3), o(e3, this.cn("isCurrent"), i3), null === (t2 = e3.children[0]) || void 0 === t2 || t2.setAttribute("aria-selected", i3 ? "true" : "false");
            for (const t3 of ["isBeforePrev", "isPrev", "isNext", "isAfterNext"])
              E(e3, this.cn(t3));
            h2++;
          }
          if (c2 = c2 || l2.firstChild, a2 && c2) {
            const t3 = c2.previousElementSibling, e3 = t3 && t3.previousElementSibling;
            S(t3, this.cn("isPrev")), S(e3, this.cn("isBeforePrev"));
            const i3 = c2.nextElementSibling, n3 = i3 && i3.nextElementSibling;
            S(i3, this.cn("isNext")), S(n3, this.cn("isAfterNext"));
          }
          this.isDynamic = a2;
        }
        createItem(t2 = 0) {
          var e2;
          const i2 = document.createElement("li");
          i2.setAttribute("role", "presentation");
          const s2 = n(this.instance.localize(this.option("dotTpl"), [["%d", t2 + 1]]).replace(/\%i/g, t2 + ""));
          return i2.appendChild(s2), null === (e2 = i2.children[0]) || void 0 === e2 || e2.setAttribute("role", "tab"), i2;
        }
        cleanup() {
          this.list && (this.list.remove(), this.list = null), this.isDynamic = false, E(this.instance.container, this.cn("hasDots"));
        }
        attach() {
          this.instance.on(["refresh", "change"], this.onRefresh);
        }
        detach() {
          this.instance.off(["refresh", "change"], this.onRefresh), this.cleanup();
        }
      }
      Object.defineProperty(_, "defaults", { enumerable: true, configurable: true, writable: true, value: N });
      const W = "disabled", $ = "next", X = "prev";
      class Y extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "prev", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "next", { enumerable: true, configurable: true, writable: true, value: null });
        }
        onRefresh() {
          const t2 = this.instance, e2 = t2.pages.length, i2 = t2.page;
          if (e2 < 2)
            return void this.cleanup();
          this.build();
          let n2 = this.prev, s2 = this.next;
          n2 && s2 && (n2.removeAttribute(W), s2.removeAttribute(W), t2.isInfinite || (i2 <= 0 && n2.setAttribute(W, ""), i2 >= e2 - 1 && s2.setAttribute(W, "")));
        }
        createButton(t2) {
          const e2 = this.instance, i2 = document.createElement("button");
          i2.setAttribute("tabindex", "0"), i2.setAttribute("title", e2.localize(`{{${t2.toUpperCase()}}}`)), S(i2, this.cn("button") + " " + this.cn(t2 === $ ? "isNext" : "isPrev"));
          const n2 = e2.isRTL ? t2 === $ ? X : $ : t2;
          var s2;
          return i2.innerHTML = e2.localize(this.option(`${n2}Tpl`)), i2.dataset[`carousel${s2 = t2, s2 ? s2.match("^[a-z]") ? s2.charAt(0).toUpperCase() + s2.substring(1) : s2 : ""}`] = "true", i2;
        }
        build() {
          let t2 = this.container;
          t2 || (this.container = t2 = document.createElement("div"), S(t2, this.cn("container")), this.instance.container.appendChild(t2)), this.next || (this.next = t2.appendChild(this.createButton($))), this.prev || (this.prev = t2.appendChild(this.createButton(X)));
        }
        cleanup() {
          this.prev && this.prev.remove(), this.next && this.next.remove(), this.container && this.container.remove(), this.prev = null, this.next = null, this.container = null;
        }
        attach() {
          this.instance.on(["refresh", "change"], this.onRefresh);
        }
        detach() {
          this.instance.off(["refresh", "change"], this.onRefresh), this.cleanup();
        }
      }
      Object.defineProperty(Y, "defaults", { enumerable: true, configurable: true, writable: true, value: { classes: { container: "f-carousel__nav", button: "f-button", isNext: "is-next", isPrev: "is-prev" }, nextTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M9 3l9 9-9 9"/></svg>', prevTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M15 3l-9 9 9 9"/></svg>' } });
      class q extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "selectedIndex", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "target", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "nav", { enumerable: true, configurable: true, writable: true, value: null });
        }
        addAsTargetFor(t2) {
          this.target = this.instance, this.nav = t2, this.attachEvents();
        }
        addAsNavFor(t2) {
          this.nav = this.instance, this.target = t2, this.attachEvents();
        }
        attachEvents() {
          this.nav && this.target && (this.nav.options.initialSlide = this.target.options.initialPage, this.nav.on("ready", this.onNavReady), this.nav.state === F.Ready && this.onNavReady(this.nav), this.target.on("ready", this.onTargetReady), this.target.state === F.Ready && this.onTargetReady(this.target));
        }
        onNavReady(t2) {
          t2.on("createSlide", this.onNavCreateSlide), t2.on("Panzoom.click", this.onNavClick), t2.on("Panzoom.touchEnd", this.onNavTouch), this.onTargetChange();
        }
        onTargetReady(t2) {
          t2.on("change", this.onTargetChange), t2.on("Panzoom.refresh", this.onTargetChange), this.onTargetChange();
        }
        onNavClick(t2, e2, i2) {
          i2.pointerType || this.onNavTouch(t2, t2.panzoom, i2);
        }
        onNavTouch(t2, e2, i2) {
          var n2, s2;
          if (Math.abs(e2.dragOffset.x) > 3 || Math.abs(e2.dragOffset.y) > 3)
            return;
          const o2 = i2.target, { nav: a2, target: r2 } = this;
          if (!a2 || !r2 || !o2)
            return;
          const l2 = o2.closest("[data-index]");
          if (i2.stopPropagation(), i2.preventDefault(), !l2)
            return;
          const c2 = parseInt(l2.dataset.index || "", 10) || 0, h2 = r2.getPageForSlide(c2), d2 = a2.getPageForSlide(c2);
          a2.slideTo(d2), r2.slideTo(h2, { friction: (null === (s2 = null === (n2 = this.nav) || void 0 === n2 ? void 0 : n2.plugins) || void 0 === s2 ? void 0 : s2.Sync.option("friction")) || 0 }), this.markSelectedSlide(c2);
        }
        onNavCreateSlide(t2, e2) {
          e2.index === this.selectedIndex && this.markSelectedSlide(e2.index);
        }
        onTargetChange() {
          const { target: t2, nav: e2 } = this;
          if (!t2 || !e2)
            return;
          if (e2.state !== F.Ready || t2.state !== F.Ready)
            return;
          const i2 = t2.pages[t2.page].slides[0].index, n2 = e2.getPageForSlide(i2);
          this.markSelectedSlide(i2), e2.slideTo(n2);
        }
        markSelectedSlide(t2) {
          const e2 = this.nav;
          e2 && e2.state === F.Ready && (this.selectedIndex = t2, [...e2.slides].map((e3) => {
            e3.el && e3.el.classList[e3.index === t2 ? "add" : "remove"]("is-nav-selected");
          }));
        }
        attach() {
          const t2 = this;
          let e2 = t2.options.target, i2 = t2.options.nav;
          e2 ? t2.addAsNavFor(e2) : i2 && t2.addAsTargetFor(i2);
        }
        detach() {
          const t2 = this, e2 = t2.nav, i2 = t2.target;
          e2 && (e2.off("ready", t2.onNavReady), e2.off("createSlide", t2.onNavCreateSlide), e2.off("Panzoom.click", t2.onNavClick), e2.off("Panzoom.touchEnd", t2.onNavTouch)), t2.nav = null, i2 && (i2.off("ready", t2.onTargetReady), i2.off("refresh", t2.onTargetChange), i2.off("change", t2.onTargetChange)), t2.target = null;
        }
      }
      Object.defineProperty(q, "defaults", { enumerable: true, configurable: true, writable: true, value: { friction: 0.35 } });
      const V = { Navigation: Y, Dots: _, Sync: q };
      class Z extends m {
        get axis() {
          return this.isHorizontal ? "e" : "f";
        }
        get isEnabled() {
          return this.state === F.Ready;
        }
        get isInfinite() {
          let t2 = false;
          const { contentDim: e2, viewportDim: i2, pages: n2, slides: s2 } = this;
          return n2.length >= 2 && e2 + s2[0].dim >= i2 && (t2 = this.option("infinite")), t2;
        }
        get isRTL() {
          return "rtl" === this.option("direction");
        }
        get isHorizontal() {
          return "x" === this.option("axis");
        }
        constructor(t2, e2 = {}, i2 = {}) {
          if (super(), Object.defineProperty(this, "userOptions", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "userPlugins", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "bp", { enumerable: true, configurable: true, writable: true, value: "" }), Object.defineProperty(this, "lp", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: F.Init }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "prevPage", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "viewport", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "track", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "slides", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "pages", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "panzoom", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "inTransition", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Set() }), Object.defineProperty(this, "contentDim", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "viewportDim", { enumerable: true, configurable: true, writable: true, value: 0 }), "string" == typeof t2 && (t2 = document.querySelector(t2)), !t2 || !x(t2))
            throw new Error("No Element found");
          this.container = t2, this.slideNext = k(this.slideNext.bind(this), 150), this.slidePrev = k(this.slidePrev.bind(this), 150), this.userOptions = e2, this.userPlugins = i2, queueMicrotask(() => {
            this.processOptions();
          });
        }
        processOptions() {
          const t2 = u({}, Z.defaults, this.userOptions);
          let e2 = "";
          const i2 = t2.breakpoints;
          if (i2 && d(i2))
            for (const [n2, s2] of Object.entries(i2))
              window.matchMedia(n2).matches && d(s2) && (e2 += n2, u(t2, s2));
          e2 === this.bp && this.state !== F.Init || (this.bp = e2, this.state === F.Ready && (t2.initialSlide = this.pages[this.page].slides[0].index), this.state !== F.Init && this.destroy(), super.setOptions(t2), false === this.option("enabled") ? this.attachEvents() : setTimeout(() => {
            this.init();
          }, 0));
        }
        init() {
          this.state = F.Init, this.emit("init"), this.attachPlugins(Object.assign(Object.assign({}, Z.Plugins), this.userPlugins)), this.initLayout(), this.initSlides(), this.updateMetrics(), this.setInitialPosition(), this.initPanzoom(), this.attachEvents(), this.state = F.Ready, this.emit("ready");
        }
        initLayout() {
          const { container: t2 } = this, e2 = this.option("classes");
          S(t2, this.cn("container")), o(t2, e2.isLTR, !this.isRTL), o(t2, e2.isRTL, this.isRTL), o(t2, e2.isVertical, !this.isHorizontal), o(t2, e2.isHorizontal, this.isHorizontal);
          let i2 = this.option("viewport") || t2.querySelector(`.${e2.viewport}`);
          i2 || (i2 = document.createElement("div"), S(i2, e2.viewport), i2.append(...I(t2, `.${e2.slide}`)), t2.prepend(i2));
          let n2 = this.option("track") || t2.querySelector(`.${e2.track}`);
          n2 || (n2 = document.createElement("div"), S(n2, e2.track), n2.append(...Array.from(i2.childNodes))), n2.setAttribute("aria-live", "polite"), i2.contains(n2) || i2.prepend(n2), this.viewport = i2, this.track = n2, this.emit("initLayout");
        }
        initSlides() {
          const { track: t2 } = this;
          if (t2) {
            this.slides = [], [...I(t2, `.${this.cn("slide")}`)].forEach((t3) => {
              if (x(t3)) {
                const e2 = j({ el: t3, isDom: true, index: this.slides.length });
                this.slides.push(e2), this.emit("initSlide", e2, this.slides.length);
              }
            });
            for (let t3 of this.option("slides", [])) {
              const e2 = j(t3);
              e2.index = this.slides.length, this.slides.push(e2), this.emit("initSlide", e2, this.slides.length);
            }
            this.emit("initSlides");
          }
        }
        setInitialPage() {
          let t2 = 0;
          const e2 = this.option("initialSlide");
          t2 = "number" == typeof e2 ? this.getPageForSlide(e2) : parseInt(this.option("initialPage", 0) + "", 10) || 0, this.page = t2;
        }
        setInitialPosition() {
          if (!this.track || !this.pages.length)
            return;
          const t2 = this.isHorizontal;
          let e2 = this.page;
          this.pages[e2] || (this.page = e2 = 0);
          const i2 = this.pages[e2].pos * (this.isRTL && t2 ? 1 : -1), n2 = t2 ? `${i2}px` : "0", s2 = t2 ? "0" : `${i2}px`;
          this.track.style.transform = `translate3d(${n2}, ${s2}, 0) scale(1)`, this.option("adaptiveHeight") && this.setViewportHeight();
        }
        initPanzoom() {
          this.panzoom && (this.panzoom.destroy(), this.panzoom = null);
          const t2 = this.option("Panzoom") || {};
          this.panzoom = new R(this.viewport, u({}, { content: this.track, zoom: false, panOnlyZoomed: false, lockAxis: this.isHorizontal ? "x" : "y", infinite: this.isInfinite, click: false, dblClick: false, touch: (t3) => !(this.pages.length < 2 && !t3.options.infinite), bounds: () => this.getBounds(), maxVelocity: (t3) => Math.abs(t3.target[this.axis] - t3.current[this.axis]) < 2 * this.viewportDim ? 100 : 0 }, t2)), this.panzoom.on("*", (t3, e2, ...i2) => {
            this.emit(`Panzoom.${e2}`, t3, ...i2);
          }), this.panzoom.on("decel", this.onDecel), this.panzoom.on("refresh", this.onRefresh), this.panzoom.on("beforeTransform", this.onBeforeTransform), this.panzoom.on("endAnimation", this.onEndAnimation);
        }
        attachEvents() {
          const t2 = this.container;
          t2 && (t2.addEventListener("click", this.onClick, { passive: false, capture: false }), t2.addEventListener("slideTo", this.onSlideTo)), window.addEventListener("resize", this.onResize);
        }
        createPages() {
          let t2 = [];
          const { contentDim: e2, viewportDim: i2 } = this;
          let n2 = this.option("slidesPerPage");
          ("number" != typeof n2 || e2 <= i2) && (n2 = 1 / 0);
          let s2 = 0, o2 = 0, a2 = 0;
          for (const e3 of this.slides)
            (!t2.length || o2 + e3.dim > i2 || a2 === n2) && (t2.push(H()), s2 = t2.length - 1, o2 = 0, a2 = 0), t2[s2].slides.push(e3), o2 += e3.dim + e3.gap, a2++;
          return t2;
        }
        processPages() {
          const e2 = this.pages, { contentDim: i2, viewportDim: n2 } = this, s2 = this.option("center"), o2 = this.option("fill"), a2 = o2 && s2 && i2 > n2 && !this.isInfinite;
          if (e2.forEach((t2, e3) => {
            t2.index = e3, t2.pos = t2.slides[0].pos, t2.dim = 0;
            for (const [e4, i3] of t2.slides.entries())
              t2.dim += i3.dim, e4 < t2.slides.length - 1 && (t2.dim += i3.gap);
            a2 && t2.pos + 0.5 * t2.dim < 0.5 * n2 ? t2.pos = 0 : a2 && t2.pos + 0.5 * t2.dim >= i2 - 0.5 * n2 ? t2.pos = i2 - n2 : s2 && (t2.pos += -0.5 * (n2 - t2.dim));
          }), e2.forEach((e3, s3) => {
            o2 && !this.isInfinite && i2 > n2 && (e3.pos = Math.max(e3.pos, 0), e3.pos = Math.min(e3.pos, i2 - n2)), e3.pos = t(e3.pos, 1e3), e3.dim = t(e3.dim, 1e3), e3.pos < 0.1 && e3.pos > -0.1 && (e3.pos = 0);
          }), this.isInfinite)
            return e2;
          const r2 = [];
          let l2;
          return e2.forEach((t2) => {
            const e3 = Object.assign({}, t2);
            l2 && e3.pos === l2.pos ? (l2.dim += e3.dim, l2.slides = [...l2.slides, ...e3.slides]) : (e3.index = r2.length, l2 = e3, r2.push(e3));
          }), r2;
        }
        getPageFromIndex(t2 = 0) {
          const e2 = this.pages.length;
          let i2;
          return t2 = parseInt((t2 || 0).toString()) || 0, i2 = this.isInfinite ? (t2 % e2 + e2) % e2 : Math.max(Math.min(t2, e2 - 1), 0), i2;
        }
        getSlideMetrics(e2) {
          var i2;
          const n2 = this.isHorizontal ? "width" : "height";
          let s2 = 0, o2 = 0, a2 = e2.el;
          if (a2 ? s2 = parseFloat(a2.dataset[n2] || "") || 0 : (a2 = document.createElement("div"), a2.style.visibility = "hidden", S(a2, this.cn("slide") + " " + e2.class), (this.track || document.body).prepend(a2)), s2)
            a2.style[n2] = `${s2}px`, a2.style["width" === n2 ? "height" : "width"] = "";
          else {
            const t2 = Math.max(1, (null === (i2 = window.visualViewport) || void 0 === i2 ? void 0 : i2.scale) || 1);
            s2 = a2.getBoundingClientRect()[n2] * t2;
          }
          const r2 = getComputedStyle(a2);
          return "content-box" === r2.boxSizing && (this.isHorizontal ? (s2 += parseFloat(r2.paddingLeft) || 0, s2 += parseFloat(r2.paddingRight) || 0) : (s2 += parseFloat(r2.paddingTop) || 0, s2 += parseFloat(r2.paddingBottom) || 0)), o2 = parseFloat(r2[this.isHorizontal ? "marginRight" : "marginBottom"]) || 0, e2.el || a2.remove(), { dim: t(s2, 1e3), gap: t(o2, 1e3) };
        }
        getBounds() {
          const { isInfinite: t2, isRTL: e2, isHorizontal: i2, pages: n2 } = this;
          let s2 = { min: 0, max: 0 };
          if (t2)
            s2 = { min: -1 / 0, max: 1 / 0 };
          else if (n2.length) {
            const t3 = n2[0].pos, o2 = n2[n2.length - 1].pos;
            s2 = e2 && i2 ? { min: t3, max: o2 } : { min: -1 * o2, max: -1 * t3 };
          }
          return { x: i2 ? s2 : { min: 0, max: 0 }, y: i2 ? { min: 0, max: 0 } : s2 };
        }
        repositionSlides() {
          let e2, { isHorizontal: i2, isRTL: n2, isInfinite: s2, viewport: o2, viewportDim: a2, contentDim: r2, page: l2, pages: c2, slides: h2, panzoom: d2 } = this, u2 = 0, p2 = 0, f2 = 0, m2 = 0;
          d2 ? m2 = -1 * d2.current[this.axis] : c2[l2] && (m2 = c2[l2].pos || 0), e2 = i2 ? n2 ? "right" : "left" : "top", n2 && i2 && (m2 *= -1);
          for (const i3 of h2)
            i3.el ? ("top" === e2 ? (i3.el.style.right = "", i3.el.style.left = "") : i3.el.style.top = "", i3.index !== u2 ? i3.el.style[e2] = 0 === p2 ? "" : `${t(p2, 1e3)}px` : i3.el.style[e2] = "", f2 += i3.dim + i3.gap, u2++) : p2 += i3.dim + i3.gap;
          if (s2 && f2 && o2) {
            let n3 = getComputedStyle(o2), s3 = "padding", l3 = i2 ? "Right" : "Bottom", c3 = parseFloat(n3[s3 + (i2 ? "Left" : "Top")]);
            m2 -= c3, a2 += c3, a2 += parseFloat(n3[s3 + l3]);
            for (const i3 of h2)
              i3.el && (t(i3.pos) < t(a2) && t(i3.pos + i3.dim + i3.gap) < t(m2) && t(m2) > t(r2 - a2) && (i3.el.style[e2] = `${t(p2 + f2, 1e3)}px`), t(i3.pos + i3.gap) >= t(r2 - a2) && t(i3.pos) > t(m2 + a2) && t(m2) < t(a2) && (i3.el.style[e2] = `-${t(f2, 1e3)}px`));
          }
          let g2, b2, v2 = [...this.inTransition];
          if (v2.length > 1 && (g2 = c2[v2[0]], b2 = c2[v2[1]]), g2 && b2) {
            let i3 = 0;
            for (const n3 of h2)
              n3.el ? this.inTransition.has(n3.index) && g2.slides.indexOf(n3) < 0 && (n3.el.style[e2] = `${t(i3 + (g2.pos - b2.pos), 1e3)}px`) : i3 += n3.dim + n3.gap;
          }
        }
        createSlideEl(t2) {
          const { track: e2, slides: i2 } = this;
          if (!e2 || !t2)
            return;
          if (t2.el)
            return;
          const n2 = document.createElement("div");
          S(n2, this.cn("slide")), S(n2, t2.class), S(n2, t2.customClass), t2.html && (n2.innerHTML = t2.html);
          const s2 = [];
          i2.forEach((t3, e3) => {
            t3.el && s2.push(e3);
          });
          const o2 = t2.index;
          let a2 = null;
          if (s2.length) {
            a2 = i2[s2.reduce((t3, e3) => Math.abs(e3 - o2) < Math.abs(t3 - o2) ? e3 : t3)];
          }
          const r2 = a2 && a2.el ? a2.index < t2.index ? a2.el.nextSibling : a2.el : null;
          e2.insertBefore(n2, e2.contains(r2) ? r2 : null), t2.el = n2, this.emit("createSlide", t2);
        }
        removeSlideEl(t2, e2 = false) {
          const i2 = t2.el;
          if (!i2)
            return;
          if (E(i2, this.cn("isSelected")), t2.isDom && !e2)
            return i2.removeAttribute("aria-hidden"), i2.removeAttribute("data-index"), E(i2, this.cn("isSelected")), void (i2.style.left = "");
          this.emit("removeSlide", t2);
          const n2 = new CustomEvent("animationend");
          i2.dispatchEvent(n2), t2.el && t2.el.remove(), t2.el = null;
        }
        transitionTo(e2 = 0, i2 = this.option("transition")) {
          if (!i2)
            return false;
          const { pages: n2, panzoom: s2 } = this;
          e2 = parseInt((e2 || 0).toString()) || 0;
          const o2 = this.getPageFromIndex(e2);
          if (!s2 || !n2[o2] || n2.length < 2 || Math.abs(n2[this.page].slides[0].dim - this.viewportDim) > 1)
            return false;
          const a2 = e2 > this.page ? 1 : -1, r2 = this.pages[o2].pos * (this.isRTL ? 1 : -1);
          if (this.page === o2 && t(r2, 1e3) === t(s2.target[this.axis], 1e3))
            return false;
          this.clearTransitions();
          const l2 = s2.isResting;
          S(this.container, this.cn("inTransition"));
          const c2 = this.pages[this.page].slides[0], h2 = this.pages[o2].slides[0];
          this.inTransition.add(h2.index), this.createSlideEl(h2);
          let d2 = c2.el, u2 = h2.el;
          l2 || "slide" === i2 || (i2 = "fadeFast", d2 = null);
          const p2 = this.isRTL ? "next" : "prev", f2 = this.isRTL ? "prev" : "next";
          return d2 && (this.inTransition.add(c2.index), c2.transition = i2, d2.addEventListener("animationend", this.onAnimationEnd), d2.classList.add(`f-${i2}Out`, `to-${a2 > 0 ? f2 : p2}`)), u2 && (h2.transition = i2, u2.addEventListener("animationend", this.onAnimationEnd), u2.classList.add(`f-${i2}In`, `from-${a2 > 0 ? p2 : f2}`)), s2.panTo({ x: this.isHorizontal ? r2 : 0, y: this.isHorizontal ? 0 : r2, friction: 0 }), this.onChange(o2), true;
        }
        manageSlideVisiblity() {
          const t2 = /* @__PURE__ */ new Set(), e2 = /* @__PURE__ */ new Set(), i2 = this.getVisibleSlides(parseFloat(this.option("preload", 0) + "") || 0);
          for (const n2 of this.slides)
            i2.has(n2) ? t2.add(n2) : e2.add(n2);
          for (const e3 of this.inTransition)
            t2.add(this.slides[e3]);
          for (const e3 of t2)
            this.createSlideEl(e3), this.lazyLoadSlide(e3);
          for (const i3 of e2)
            t2.has(i3) || this.removeSlideEl(i3);
          this.markSelectedSlides(), this.repositionSlides();
        }
        markSelectedSlides() {
          if (!this.pages[this.page] || !this.pages[this.page].slides)
            return;
          const t2 = "aria-hidden";
          let e2 = this.cn("isSelected");
          if (e2)
            for (const i2 of this.slides)
              i2.el && (i2.el.dataset.index = `${i2.index}`, this.pages[this.page].slides.includes(i2) ? (i2.el.classList.contains(e2) || (S(i2.el, e2), this.emit("selectSlide", i2)), i2.el.removeAttribute(t2)) : (i2.el.classList.contains(e2) && (E(i2.el, e2), this.emit("unselectSlide", i2)), i2.el.setAttribute(t2, "true")));
        }
        flipInfiniteTrack() {
          const t2 = this.panzoom;
          if (!t2 || !this.isInfinite)
            return;
          const e2 = "x" === this.option("axis") ? "e" : "f", { viewportDim: i2, contentDim: n2 } = this;
          let s2 = t2.current[e2], o2 = t2.target[e2] - s2, a2 = 0, r2 = 0.5 * i2, l2 = n2;
          this.isRTL && this.isHorizontal ? (s2 < -r2 && (a2 = -1, s2 += l2), s2 > l2 - r2 && (a2 = 1, s2 -= l2)) : (s2 > r2 && (a2 = 1, s2 -= l2), s2 < -l2 + r2 && (a2 = -1, s2 += l2)), a2 && (t2.current[e2] = s2, t2.target[e2] = s2 + o2);
        }
        lazyLoadSlide(t2) {
          const e2 = this, i2 = t2 && t2.el;
          if (!i2)
            return;
          const s2 = /* @__PURE__ */ new Set(), o2 = "f-fadeIn";
          i2.querySelectorAll("[data-lazy-srcset]").forEach((t3) => {
            t3 instanceof HTMLImageElement && s2.add(t3);
          });
          let a2 = Array.from(i2.querySelectorAll("[data-lazy-src]"));
          i2.dataset.lazySrc && a2.push(i2), a2.map((t3) => {
            t3 instanceof HTMLImageElement ? s2.add(t3) : x(t3) && (t3.style.backgroundImage = `url('${t3.dataset.lazySrc || ""}')`, delete t3.dataset.lazySrc);
          });
          const r2 = (t3, i3, n2) => {
            n2 && (n2.remove(), n2 = null), i3.complete && (i3.classList.add(o2), setTimeout(() => {
              i3.classList.remove(o2);
            }, 350), i3.style.display = ""), this.option("adaptiveHeight") && t3.el && this.pages[this.page].slides.indexOf(t3) > -1 && (e2.updateMetrics(), e2.setViewportHeight()), this.emit("load", t3);
          };
          for (const e3 of s2) {
            let i3 = null;
            e3.src = e3.dataset.lazySrcset || e3.dataset.lazySrc || "", delete e3.dataset.lazySrc, delete e3.dataset.lazySrcset, e3.style.display = "none", e3.addEventListener("error", () => {
              r2(t2, e3, i3);
            }), e3.addEventListener("load", () => {
              r2(t2, e3, i3);
            }), setTimeout(() => {
              e3.parentNode && t2.el && (e3.complete ? r2(t2, e3, i3) : (i3 = n(w), e3.parentNode.insertBefore(i3, e3)));
            }, 300);
          }
        }
        onAnimationEnd(t2) {
          var e2;
          const i2 = t2.target, n2 = i2 ? parseInt(i2.dataset.index || "", 10) || 0 : -1, s2 = this.slides[n2], o2 = t2.animationName;
          if (!i2 || !s2 || !o2)
            return;
          const a2 = !!this.inTransition.has(n2) && s2.transition;
          a2 && o2.substring(0, a2.length + 2) === `f-${a2}` && this.inTransition.delete(n2), this.inTransition.size || this.clearTransitions(), n2 === this.page && (null === (e2 = this.panzoom) || void 0 === e2 ? void 0 : e2.isResting) && this.emit("settle");
        }
        onDecel(t2, e2 = 0, i2 = 0, n2 = 0, s2 = 0) {
          const { isRTL: o2, isHorizontal: a2, axis: r2, pages: l2 } = this, c2 = l2.length, h2 = Math.abs(Math.atan2(i2, e2) / (Math.PI / 180));
          let d2 = 0;
          if (d2 = h2 > 45 && h2 < 135 ? a2 ? 0 : i2 : a2 ? e2 : 0, !c2)
            return;
          const u2 = this.option("dragFree");
          let p2 = this.page, f2 = o2 && a2 ? 1 : -1;
          const m2 = t2.target[r2] * f2, g2 = t2.current[r2] * f2;
          let { pageIndex: b2 } = this.getPageFromPosition(m2), { pageIndex: v2 } = this.getPageFromPosition(g2);
          u2 ? this.onChange(b2) : (Math.abs(d2) > 5 ? (l2[p2].dim < document.documentElement["client" + (this.isHorizontal ? "Width" : "Height")] - 1 && (p2 = v2), p2 = o2 && a2 ? d2 < 0 ? p2 - 1 : p2 + 1 : d2 < 0 ? p2 + 1 : p2 - 1) : p2 = 0 === n2 && 0 === s2 ? p2 : v2, this.slideTo(p2, { transition: false, friction: t2.option("decelFriction") }));
        }
        onClick(t2) {
          const e2 = t2.target, i2 = e2 && x(e2) ? e2.dataset : null;
          let n2, s2;
          i2 && (void 0 !== i2.carouselPage ? (s2 = "slideTo", n2 = i2.carouselPage) : void 0 !== i2.carouselNext ? s2 = "slideNext" : void 0 !== i2.carouselPrev && (s2 = "slidePrev")), s2 ? (t2.preventDefault(), t2.stopPropagation(), e2 && !e2.hasAttribute("disabled") && this[s2](n2)) : this.emit("click", t2);
        }
        onSlideTo(t2) {
          const e2 = t2.detail || 0;
          this.slideTo(this.getPageForSlide(e2), { friction: 0 });
        }
        onChange(t2, e2 = 0) {
          const i2 = this.page;
          this.prevPage = i2, this.page = t2, this.option("adaptiveHeight") && this.setViewportHeight(), t2 !== i2 && (this.markSelectedSlides(), this.emit("change", t2, i2, e2));
        }
        onRefresh() {
          let t2 = this.contentDim, e2 = this.viewportDim;
          this.updateMetrics(), this.contentDim === t2 && this.viewportDim === e2 || this.slideTo(this.page, { friction: 0, transition: false });
        }
        onResize() {
          this.option("breakpoints") && this.processOptions();
        }
        onBeforeTransform(t2) {
          this.lp !== t2.current[this.axis] && (this.flipInfiniteTrack(), this.manageSlideVisiblity()), this.lp = t2.current.e;
        }
        onEndAnimation() {
          this.inTransition.size || this.emit("settle");
        }
        reInit(t2 = null, e2 = null) {
          this.destroy(), this.state = F.Init, this.userOptions = t2 || this.userOptions, this.userPlugins = e2 || this.userPlugins, this.processOptions();
        }
        slideTo(t2 = 0, { friction: e2 = this.option("friction"), transition: i2 = this.option("transition") } = {}) {
          if (this.state === F.Destroy)
            return;
          const { axis: n2, isHorizontal: s2, isRTL: o2, pages: a2, panzoom: r2 } = this, l2 = a2.length, c2 = o2 && s2 ? 1 : -1;
          if (!r2 || !l2)
            return;
          if (this.transitionTo(t2, i2))
            return;
          const h2 = this.getPageFromIndex(t2);
          let d2 = a2[h2].pos;
          if (this.isInfinite) {
            const e3 = this.contentDim, i3 = r2.target[n2] * c2;
            if (2 === l2)
              d2 += e3 * Math.floor(parseFloat(t2 + "") / 2);
            else {
              const t3 = i3;
              d2 = [d2, d2 - e3, d2 + e3].reduce(function(e4, i4) {
                return Math.abs(i4 - t3) < Math.abs(e4 - t3) ? i4 : e4;
              });
            }
          }
          d2 *= c2, Math.abs(r2.target[n2] - d2) < 0.1 || (r2.panTo({ x: s2 ? d2 : 0, y: s2 ? 0 : d2, friction: e2 }), this.onChange(h2));
        }
        slideToClosest(t2) {
          if (this.panzoom) {
            const { pageIndex: e2 } = this.getPageFromPosition(this.panzoom.current[this.isHorizontal ? "e" : "f"]);
            this.slideTo(e2, t2);
          }
        }
        slideNext() {
          this.slideTo(this.page + 1);
        }
        slidePrev() {
          this.slideTo(this.page - 1);
        }
        clearTransitions() {
          this.inTransition.clear(), E(this.container, this.cn("inTransition"));
          const t2 = ["to-prev", "to-next", "from-prev", "from-next"];
          for (const e2 of this.slides) {
            const i2 = e2.el;
            if (i2) {
              i2.removeEventListener("animationend", this.onAnimationEnd), i2.classList.remove(...t2);
              const n2 = e2.transition;
              n2 && i2.classList.remove(`f-${n2}Out`, `f-${n2}In`);
            }
          }
          this.manageSlideVisiblity();
        }
        prependSlide(t2) {
          var e2, i2;
          let n2 = Array.isArray(t2) ? t2 : [t2];
          for (const t3 of n2.reverse())
            this.slides.unshift(j(t3));
          for (let t3 = 0; t3 < this.slides.length; t3++)
            this.slides[t3].index = t3;
          const s2 = (null === (e2 = this.pages[this.page]) || void 0 === e2 ? void 0 : e2.pos) || 0;
          this.page += n2.length, this.updateMetrics();
          const o2 = (null === (i2 = this.pages[this.page]) || void 0 === i2 ? void 0 : i2.pos) || 0;
          if (this.panzoom) {
            const t3 = this.isRTL ? s2 - o2 : o2 - s2;
            this.panzoom.target.e -= t3, this.panzoom.current.e -= t3, this.panzoom.requestTick();
          }
        }
        appendSlide(t2) {
          let e2 = Array.isArray(t2) ? t2 : [t2];
          for (const t3 of e2) {
            const e3 = j(t3);
            e3.index = this.slides.length, this.slides.push(e3), this.emit("initSlide", e3, this.slides.length);
          }
          this.updateMetrics();
        }
        removeSlide(t2) {
          const e2 = this.slides.length;
          t2 = (t2 % e2 + e2) % e2, this.removeSlideEl(this.slides[t2], true), this.slides.splice(t2, 1);
          for (let t3 = 0; t3 < this.slides.length; t3++)
            this.slides[t3].index = t3;
          this.updateMetrics(), this.slideTo(this.page, { friction: 0, transition: false });
        }
        updateMetrics() {
          const { panzoom: e2, viewport: i2, track: n2, isHorizontal: s2 } = this;
          if (!n2)
            return;
          const o2 = s2 ? "width" : "height", a2 = s2 ? "offsetWidth" : "offsetHeight";
          if (i2) {
            let e3 = Math.max(i2[a2], t(i2.getBoundingClientRect()[o2], 1e3)), n3 = getComputedStyle(i2), r3 = "padding", l3 = s2 ? "Right" : "Bottom";
            e3 -= parseFloat(n3[r3 + (s2 ? "Left" : "Top")]) + parseFloat(n3[r3 + l3]), this.viewportDim = e3;
          }
          let r2, l2 = this.pages.length, c2 = 0;
          for (const [e3, i3] of this.slides.entries()) {
            let n3 = 0, s3 = 0;
            !i3.el && r2 ? (n3 = r2.dim, s3 = r2.gap) : ({ dim: n3, gap: s3 } = this.getSlideMetrics(i3), r2 = i3), n3 = t(n3, 1e3), s3 = t(s3, 1e3), i3.dim = n3, i3.gap = s3, i3.pos = c2, c2 += n3, (this.isInfinite || e3 < this.slides.length - 1) && (c2 += s3);
          }
          const h2 = this.contentDim;
          c2 = t(c2, 1e3), this.contentDim = c2, e2 && (e2.contentRect[o2] = c2, e2.contentRect["e" === this.axis ? "fullWidth" : "fullHeight"] = c2), this.pages = this.createPages(), this.pages = this.processPages(), this.state === F.Init && this.setInitialPage(), this.page = Math.max(0, Math.min(this.page, this.pages.length - 1)), e2 && l2 === this.pages.length && Math.abs(c2 - h2) > 0.5 && (e2.target[this.axis] = -1 * this.pages[this.page].pos, e2.current[this.axis] = -1 * this.pages[this.page].pos, e2.stop()), this.manageSlideVisiblity(), this.emit("refresh");
        }
        getProgress(e2, i2 = false) {
          void 0 === e2 && (e2 = this.page);
          const n2 = this, s2 = n2.panzoom, o2 = n2.pages[e2] || 0;
          if (!o2 || !s2)
            return 0;
          let a2 = -1 * s2.current.e, r2 = n2.contentDim;
          var l2 = [t((a2 - o2.pos) / (1 * o2.dim), 1e3), t((a2 + r2 - o2.pos) / (1 * o2.dim), 1e3), t((a2 - r2 - o2.pos) / (1 * o2.dim), 1e3)].reduce(function(t2, e3) {
            return Math.abs(e3) < Math.abs(t2) ? e3 : t2;
          });
          return i2 ? l2 : Math.max(-1, Math.min(1, l2));
        }
        setViewportHeight() {
          const { page: t2, pages: e2, viewport: i2, isHorizontal: n2 } = this;
          if (!i2 || !e2[t2])
            return;
          let s2 = 0;
          n2 && this.track && (this.track.style.height = "auto", e2[t2].slides.forEach((t3) => {
            t3.el && (s2 = Math.max(s2, t3.el.offsetHeight));
          })), i2.style.height = s2 ? `${s2}px` : "";
        }
        getPageForSlide(t2) {
          for (const e2 of this.pages)
            for (const i2 of e2.slides)
              if (i2.index === t2)
                return e2.index;
          return -1;
        }
        getVisibleSlides(t2 = 0) {
          var e2;
          const i2 = /* @__PURE__ */ new Set();
          let { contentDim: n2, viewportDim: s2, pages: o2, page: a2 } = this;
          n2 = n2 + (null === (e2 = this.slides[this.slides.length - 1]) || void 0 === e2 ? void 0 : e2.gap) || 0;
          let r2 = 0;
          r2 = this.panzoom ? -1 * this.panzoom.current[this.axis] : o2[a2] && o2[a2].pos || 0, this.isInfinite && (r2 -= Math.floor(r2 / n2) * n2), this.isRTL && this.isHorizontal && (r2 *= -1);
          const l2 = r2 - s2 * t2, c2 = r2 + s2 * (t2 + 1), h2 = this.isInfinite ? [-1, 0, 1] : [0];
          for (const t3 of this.slides)
            for (const e3 of h2) {
              const s3 = t3.pos + e3 * n2, o3 = t3.pos + t3.dim + t3.gap + e3 * n2;
              s3 < c2 && o3 > l2 && i2.add(t3);
            }
          return i2;
        }
        getPageFromPosition(t2) {
          const { viewportDim: e2, contentDim: i2 } = this, n2 = this.pages.length, s2 = this.slides.length, o2 = this.slides[s2 - 1];
          let a2 = 0, r2 = 0, l2 = 0;
          const c2 = this.option("center");
          c2 && (t2 += 0.5 * e2), this.isInfinite || (t2 = Math.max(this.slides[0].pos, Math.min(t2, o2.pos)));
          const h2 = i2 + o2.gap;
          l2 = Math.floor(t2 / h2) || 0, t2 -= l2 * h2;
          let d2 = o2, u2 = this.slides.find((e3) => {
            const i3 = t2 + (d2 && !c2 ? 0.5 * d2.dim : 0);
            return d2 = e3, e3.pos <= i3 && e3.pos + e3.dim + e3.gap > i3;
          });
          return u2 || (u2 = o2), r2 = this.getPageForSlide(u2.index), a2 = r2 + l2 * n2, { page: a2, pageIndex: r2 };
        }
        destroy() {
          if ([F.Destroy].includes(this.state))
            return;
          this.state = F.Destroy;
          const { container: t2, viewport: e2, track: i2, slides: n2, panzoom: s2 } = this, o2 = this.option("classes");
          t2.removeEventListener("click", this.onClick, { passive: false, capture: false }), t2.removeEventListener("slideTo", this.onSlideTo), window.removeEventListener("resize", this.onResize), s2 && (s2.destroy(), this.panzoom = null), n2 && n2.forEach((t3) => {
            this.removeSlideEl(t3);
          }), this.detachPlugins(), e2 && e2.offsetParent && i2 && i2.offsetParent && e2.replaceWith(...i2.childNodes);
          for (const [e3, i3] of Object.entries(o2))
            "container" !== e3 && i3 && t2.classList.remove(i3);
          this.track = null, this.viewport = null, this.page = 0, this.slides = [];
          const a2 = this.events.get("ready");
          this.events = /* @__PURE__ */ new Map(), a2 && this.events.set("ready", a2);
        }
      }
      Object.defineProperty(Z, "Panzoom", { enumerable: true, configurable: true, writable: true, value: R }), Object.defineProperty(Z, "defaults", { enumerable: true, configurable: true, writable: true, value: D }), Object.defineProperty(Z, "Plugins", { enumerable: true, configurable: true, writable: true, value: V });
      const U = function(t2) {
        const e2 = window.pageYOffset, i2 = window.pageYOffset + window.innerHeight;
        if (!x(t2))
          return 0;
        const n2 = t2.getBoundingClientRect(), s2 = n2.y + window.pageYOffset, o2 = n2.y + n2.height + window.pageYOffset;
        if (e2 > o2 || i2 < s2)
          return 0;
        if (e2 < s2 && i2 > o2)
          return 100;
        if (s2 < e2 && o2 > i2)
          return 100;
        let a2 = n2.height;
        s2 < e2 && (a2 -= window.pageYOffset - s2), o2 > i2 && (a2 -= o2 - i2);
        const r2 = a2 / window.innerHeight * 100;
        return Math.round(r2);
      }, G = !("undefined" == typeof window || !window.document || !window.document.createElement);
      let K;
      const J = ["a[href]", "area[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "button:not([disabled]):not([aria-hidden]):not(.fancybox-focus-guard)", "iframe", "object", "embed", "video", "audio", "[contenteditable]", '[tabindex]:not([tabindex^="-"]):not([disabled]):not([aria-hidden])'].join(","), Q = (t2) => {
        if (t2 && G) {
          void 0 === K && document.createElement("div").focus({ get preventScroll() {
            return K = true, false;
          } });
          try {
            if (K)
              t2.focus({ preventScroll: true });
            else {
              const e2 = window.pageXOffset || document.body.scrollTop, i2 = window.pageYOffset || document.body.scrollLeft;
              t2.focus(), document.body.scrollTo({ top: e2, left: i2, behavior: "auto" });
            }
          } catch (t3) {
          }
        }
      }, tt = { dragToClose: true, hideScrollbar: true, Carousel: { classes: { container: "fancybox__carousel", viewport: "fancybox__viewport", track: "fancybox__track", slide: "fancybox__slide" } }, contentClick: "toggleZoom", contentDblClick: false, backdropClick: "close", animated: true, idle: 3500, showClass: "f-zoomInUp", hideClass: "f-fadeOut", commonCaption: false, parentEl: null, startIndex: 0, l10n: Object.assign(Object.assign({}, v), { CLOSE: "Close", NEXT: "Next", PREV: "Previous", MODAL: "You can close this modal content with the ESC key", ERROR: "Something Went Wrong, Please Try Again Later", IMAGE_ERROR: "Image Not Found", ELEMENT_NOT_FOUND: "HTML Element Not Found", AJAX_NOT_FOUND: "Error Loading AJAX : Not Found", AJAX_FORBIDDEN: "Error Loading AJAX : Forbidden", IFRAME_ERROR: "Error Loading Page", TOGGLE_ZOOM: "Toggle zoom level", TOGGLE_THUMBS: "Toggle thumbnails", TOGGLE_SLIDESHOW: "Toggle slideshow", TOGGLE_FULLSCREEN: "Toggle full-screen mode", DOWNLOAD: "Download" }), tpl: { closeButton: '<button data-fancybox-close class="f-button is-close-btn" title="{{CLOSE}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M20 20L4 4m16 0L4 20"/></svg></button>', main: '<div class="fancybox__container" role="dialog" aria-modal="true" aria-label="{{MODAL}}" tabindex="-1">\n    <div class="fancybox__backdrop"></div>\n    <div class="fancybox__carousel"></div>\n    <div class="fancybox__footer"></div>\n  </div>' }, groupAll: false, groupAttr: "data-fancybox", defaultType: "image", defaultDisplay: "block", autoFocus: true, trapFocus: true, placeFocusBack: true, closeButton: "auto", keyboard: { Escape: "close", Delete: "close", Backspace: "close", PageUp: "next", PageDown: "prev", ArrowUp: "prev", ArrowDown: "next", ArrowRight: "next", ArrowLeft: "prev" }, Fullscreen: { autoStart: false }, compact: () => window.matchMedia("(max-width: 578px), (max-height: 578px)").matches, wheel: "zoom" };
      var et, it;
      !function(t2) {
        t2[t2.Init = 0] = "Init", t2[t2.Ready = 1] = "Ready", t2[t2.Closing = 2] = "Closing", t2[t2.CustomClosing = 3] = "CustomClosing", t2[t2.Destroy = 4] = "Destroy";
      }(et || (et = {})), function(t2) {
        t2[t2.Loading = 0] = "Loading", t2[t2.Opening = 1] = "Opening", t2[t2.Ready = 2] = "Ready", t2[t2.Closing = 3] = "Closing";
      }(it || (it = {}));
      const nt = () => {
        queueMicrotask(() => {
          (() => {
            const { slug: t2, index: e2 } = st.parseURL(), i2 = _t.getInstance();
            if (i2 && false !== i2.option("Hash")) {
              const n2 = i2.carousel;
              if (t2 && n2) {
                for (let e3 of n2.slides)
                  if (e3.slug && e3.slug === t2)
                    return n2.slideTo(e3.index);
                if (t2 === i2.option("slug"))
                  return n2.slideTo(e2 - 1);
                const s2 = i2.getSlide(), o2 = s2 && s2.triggerEl && s2.triggerEl.dataset;
                if (o2 && o2.fancybox === t2)
                  return n2.slideTo(e2 - 1);
              }
              st.hasSilentClose = true, i2.close();
            }
            st.startFromUrl();
          })();
        });
      };
      class st extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "origHash", { enumerable: true, configurable: true, writable: true, value: "" }), Object.defineProperty(this, "timer", { enumerable: true, configurable: true, writable: true, value: null });
        }
        onChange() {
          const t2 = this.instance, e2 = t2.carousel;
          this.timer && clearTimeout(this.timer);
          const i2 = t2.getSlide();
          if (!e2 || !i2)
            return;
          const n2 = t2.isOpeningSlide(i2), s2 = new URL(document.URL).hash;
          let o2, a2 = i2.slug || void 0, r2 = i2.triggerEl || void 0;
          o2 = a2 || this.instance.option("slug"), !o2 && r2 && r2.dataset && (o2 = r2.dataset.fancybox);
          let l2 = "";
          o2 && "true" !== o2 && (l2 = "#" + o2 + (!a2 && e2.slides.length > 1 ? "-" + (i2.index + 1) : "")), n2 && (this.origHash = s2 !== l2 ? s2 : ""), l2 && s2 !== l2 && (this.timer = setTimeout(() => {
            try {
              t2.state === et.Ready && window.history[n2 ? "pushState" : "replaceState"]({}, document.title, window.location.pathname + window.location.search + l2);
            } catch (t3) {
            }
          }, 300));
        }
        onClose() {
          if (this.timer && clearTimeout(this.timer), true !== st.hasSilentClose)
            try {
              window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (this.origHash || ""));
            } catch (t2) {
            }
        }
        attach() {
          const t2 = this.instance;
          t2.on("Carousel.ready", this.onChange), t2.on("Carousel.change", this.onChange), t2.on("close", this.onClose);
        }
        detach() {
          const t2 = this.instance;
          t2.off("Carousel.ready", this.onChange), t2.off("Carousel.change", this.onChange), t2.off("close", this.onClose);
        }
        static parseURL() {
          const t2 = window.location.hash.slice(1), e2 = t2.split("-"), i2 = e2[e2.length - 1], n2 = i2 && /^\+?\d+$/.test(i2) && parseInt(e2.pop() || "1", 10) || 1;
          return { hash: t2, slug: e2.join("-"), index: n2 };
        }
        static startFromUrl() {
          if (st.hasSilentClose = false, _t.getInstance() || false === _t.defaults.Hash)
            return;
          const { hash: t2, slug: e2, index: i2 } = st.parseURL();
          if (!e2)
            return;
          let n2 = document.querySelector(`[data-slug="${t2}"]`);
          if (n2 && n2.dispatchEvent(new CustomEvent("click", { bubbles: true, cancelable: true })), _t.getInstance())
            return;
          const s2 = document.querySelectorAll(`[data-fancybox="${e2}"]`);
          s2.length && (n2 = s2[i2 - 1], n2 && n2.dispatchEvent(new CustomEvent("click", { bubbles: true, cancelable: true })));
        }
        static destroy() {
          window.removeEventListener("hashchange", nt, false);
        }
      }
      function ot() {
        window.addEventListener("hashchange", nt, false), setTimeout(() => {
          st.startFromUrl();
        }, 500);
      }
      Object.defineProperty(st, "defaults", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(st, "hasSilentClose", { enumerable: true, configurable: true, writable: true, value: false }), G && (/complete|interactive|loaded/.test(document.readyState) ? ot() : document.addEventListener("DOMContentLoaded", ot));
      class at extends B {
        onCreateSlide(t2, e2, i2) {
          const n2 = this.instance.optionFor(i2, "src") || "";
          i2.el && "image" === i2.type && "string" == typeof n2 && this.setImage(i2, n2);
        }
        onRemoveSlide(t2, e2, i2) {
          i2.panzoom && i2.panzoom.destroy(), i2.panzoom = void 0, i2.imageEl = void 0;
        }
        onChange(t2, e2, i2, n2) {
          for (const t3 of e2.slides) {
            const e3 = t3.panzoom;
            e3 && t3.index !== i2 && e3.reset(0.35);
          }
        }
        onClose() {
          var t2;
          const e2 = this.instance, i2 = e2.container, n2 = e2.getSlide();
          if (!i2 || !i2.parentElement || !n2)
            return;
          const { el: s2, contentEl: o2, panzoom: a2 } = n2, r2 = n2.thumbElSrc;
          if (!s2 || !r2 || !o2 || !a2 || a2.isContentLoading || a2.state === g.Init || a2.state === g.Destroy)
            return;
          a2.updateMetrics();
          let l2 = this.getZoomInfo(n2);
          if (!l2)
            return;
          this.instance.state = et.CustomClosing, i2.classList.remove("is-zooming-in"), i2.classList.add("is-zooming-out"), o2.style.backgroundImage = `url('${r2}')`;
          const c2 = i2.getBoundingClientRect();
          1 === ((null === (t2 = window.visualViewport) || void 0 === t2 ? void 0 : t2.scale) || 1) && Object.assign(i2.style, { position: "absolute", top: `${window.pageYOffset}px`, left: `${window.pageXOffset}px`, bottom: "auto", right: "auto", width: `${c2.width}px`, height: `${c2.height}px`, overflow: "hidden" });
          const { x: h2, y: d2, scale: u2, opacity: p2 } = l2;
          if (p2) {
            const t3 = ((t4, e3, i3, n3) => {
              const s3 = e3 - t4, o3 = n3 - i3;
              return (e4) => i3 + ((e4 - t4) / s3 * o3 || 0);
            })(a2.scale, u2, 1, 0);
            a2.on("afterTransform", () => {
              o2.style.opacity = t3(a2.scale) + "";
            });
          }
          a2.on("endAnimation", () => {
            e2.destroy();
          }), a2.target.a = u2, a2.target.b = 0, a2.target.c = 0, a2.target.d = u2, a2.panTo({ x: h2, y: d2, scale: u2, friction: p2 ? 0.2 : 0.33, ignoreBounds: true }), a2.isResting && e2.destroy();
        }
        setImage(t2, e2) {
          const i2 = this.instance;
          t2.src = e2, this.process(t2, e2).then((e3) => {
            var n2;
            const s2 = t2.contentEl, o2 = t2.imageEl, a2 = t2.thumbElSrc;
            if (i2.isClosing() || !s2 || !o2)
              return;
            s2.offsetHeight;
            const r2 = !!i2.isOpeningSlide(t2) && this.getZoomInfo(t2);
            if (this.option("protected")) {
              null === (n2 = t2.el) || void 0 === n2 || n2.addEventListener("contextmenu", (t3) => {
                t3.preventDefault();
              });
              const e4 = document.createElement("div");
              S(e4, "fancybox-protected"), s2.appendChild(e4);
            }
            if (a2 && r2) {
              const n3 = e3.contentRect, o3 = Math.max(n3.fullWidth, n3.fullHeight);
              let c2 = null;
              !r2.opacity && o3 > 1200 && (c2 = document.createElement("img"), S(c2, "fancybox-ghost"), c2.src = a2, s2.appendChild(c2));
              const h2 = () => {
                c2 && (S(c2, "f-fadeFastOut"), setTimeout(() => {
                  c2 && (c2.remove(), c2 = null);
                }, 200));
              };
              (l2 = a2, new Promise((t3, e4) => {
                const i3 = new Image();
                i3.onload = t3, i3.onerror = e4, i3.src = l2;
              })).then(() => {
                t2.state = it.Opening, this.instance.emit("reveal", t2), this.zoomIn(t2).then(() => {
                  h2(), this.instance.done(t2);
                }, () => {
                  i2.hideLoading(t2);
                }), c2 && setTimeout(() => {
                  h2();
                }, o3 > 2500 ? 800 : 200);
              }, () => {
                i2.hideLoading(t2), i2.revealContent(t2);
              });
            } else {
              const n3 = this.optionFor(t2, "initialSize"), s3 = this.optionFor(t2, "zoom"), o3 = { event: i2.prevMouseMoveEvent || i2.options.event, friction: s3 ? 0.12 : 0 };
              let a3 = i2.optionFor(t2, "showClass") || void 0, r3 = true;
              i2.isOpeningSlide(t2) && ("full" === n3 ? e3.zoomToFull(o3) : "cover" === n3 ? e3.zoomToCover(o3) : "max" === n3 ? e3.zoomToMax(o3) : r3 = false, e3.stop("current")), r3 && a3 && (a3 = e3.isDragging ? "f-fadeIn" : ""), i2.revealContent(t2, a3);
            }
            var l2;
          }, () => {
            i2.setError(t2, "{{IMAGE_ERROR}}");
          });
        }
        process(t2, e2) {
          return new Promise((i2, s2) => {
            var o2, a2;
            const r2 = this.instance, l2 = t2.el;
            r2.clearContent(t2), r2.showLoading(t2);
            let c2 = this.optionFor(t2, "content");
            "string" == typeof c2 && (c2 = n(c2)), c2 && x(c2) || (c2 = document.createElement("img"), c2 instanceof HTMLImageElement && (c2.src = e2 || "", c2.alt = (null === (o2 = t2.caption) || void 0 === o2 ? void 0 : o2.replace(/<[^>]+>/gi, "").substring(0, 1e3)) || `Image ${t2.index + 1} of ${null === (a2 = r2.carousel) || void 0 === a2 ? void 0 : a2.pages.length}`, c2.draggable = false, t2.srcset && c2.setAttribute("srcset", t2.srcset)), t2.sizes && c2.setAttribute("sizes", t2.sizes)), c2.classList.add("fancybox-image"), t2.imageEl = c2, r2.setContent(t2, c2, false);
            t2.panzoom = new R(l2, u({ transformParent: true }, this.option("Panzoom") || {}, { content: c2, width: r2.optionFor(t2, "width", "auto"), height: r2.optionFor(t2, "height", "auto"), wheel: () => {
              const t3 = r2.option("wheel");
              return ("zoom" === t3 || "pan" == t3) && t3;
            }, click: (e3, i3) => {
              var n2, s3;
              if (r2.isCompact || r2.isClosing())
                return false;
              if (t2.index !== (null === (n2 = r2.getSlide()) || void 0 === n2 ? void 0 : n2.index))
                return false;
              if (i3) {
                const t3 = i3.composedPath()[0];
                if (["A", "BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].includes(t3.nodeName))
                  return false;
              }
              let o3 = !i3 || i3.target && (null === (s3 = t2.contentEl) || void 0 === s3 ? void 0 : s3.contains(i3.target));
              return r2.option(o3 ? "contentClick" : "backdropClick") || false;
            }, dblClick: () => r2.isCompact ? "toggleZoom" : r2.option("contentDblClick") || false, spinner: false, panOnlyZoomed: true, wheelLimit: 1 / 0, on: { ready: (t3) => {
              i2(t3);
            }, error: () => {
              s2();
            }, destroy: () => {
              s2();
            } } }));
          });
        }
        zoomIn(t2) {
          return new Promise((e2, i2) => {
            const n2 = this.instance, s2 = n2.container, { panzoom: o2, contentEl: a2, el: r2 } = t2;
            o2 && o2.updateMetrics();
            const l2 = this.getZoomInfo(t2);
            if (!(l2 && r2 && a2 && o2 && s2))
              return void i2();
            const { x: c2, y: h2, scale: d2, opacity: u2 } = l2, p2 = () => {
              t2.state !== it.Closing && (u2 && (a2.style.opacity = Math.max(Math.min(1, 1 - (1 - o2.scale) / (1 - d2)), 0) + ""), o2.scale >= 1 && o2.scale > o2.targetScale - 0.1 && e2(o2));
            }, f2 = (t3) => {
              E(s2, "is-zooming-in"), t3.scale < 0.99 || t3.scale > 1.01 || (a2.style.opacity = "", t3.off("endAnimation", f2), t3.off("touchStart", f2), t3.off("afterTransform", p2), e2(t3));
            };
            o2.on("endAnimation", f2), o2.on("touchStart", f2), o2.on("afterTransform", p2), o2.on(["error", "destroy"], () => {
              i2();
            }), o2.panTo({ x: c2, y: h2, scale: d2, friction: 0, ignoreBounds: true }), o2.stop("current");
            const m2 = { event: "mousemove" === o2.panMode ? n2.prevMouseMoveEvent || n2.options.event : void 0 }, g2 = this.optionFor(t2, "initialSize");
            S(s2, "is-zooming-in"), n2.hideLoading(t2), "full" === g2 ? o2.zoomToFull(m2) : "cover" === g2 ? o2.zoomToCover(m2) : "max" === g2 ? o2.zoomToMax(m2) : o2.reset(0.172);
          });
        }
        getZoomInfo(t2) {
          var e2;
          const { el: i2, imageEl: n2, thumbEl: s2, panzoom: o2 } = t2;
          if (!i2 || !n2 || !s2 || !o2 || U(s2) < 3 || !this.optionFor(t2, "zoom") || this.instance.state === et.Destroy)
            return false;
          if (1 !== ((null === (e2 = window.visualViewport) || void 0 === e2 ? void 0 : e2.scale) || 1))
            return false;
          let { top: a2, left: r2, width: l2, height: c2 } = s2.getBoundingClientRect(), { top: h2, left: d2, fitWidth: u2, fitHeight: p2 } = o2.contentRect;
          if (!(l2 && c2 && u2 && p2))
            return false;
          const f2 = o2.container.getBoundingClientRect();
          d2 += f2.left, h2 += f2.top;
          const m2 = -1 * (d2 + 0.5 * u2 - (r2 + 0.5 * l2)), g2 = -1 * (h2 + 0.5 * p2 - (a2 + 0.5 * c2)), b2 = l2 / u2;
          let v2 = this.option("zoomOpacity") || false;
          return "auto" === v2 && (v2 = Math.abs(l2 / c2 - u2 / p2) > 0.1), { x: m2, y: g2, scale: b2, opacity: v2 };
        }
        attach() {
          const t2 = this, e2 = t2.instance;
          e2.on("Carousel.change", t2.onChange), e2.on("Carousel.createSlide", t2.onCreateSlide), e2.on("Carousel.removeSlide", t2.onRemoveSlide), e2.on("close", t2.onClose);
        }
        detach() {
          const t2 = this, e2 = t2.instance;
          e2.off("Carousel.change", t2.onChange), e2.off("Carousel.createSlide", t2.onCreateSlide), e2.off("Carousel.removeSlide", t2.onRemoveSlide), e2.off("close", t2.onClose);
        }
      }
      Object.defineProperty(at, "defaults", { enumerable: true, configurable: true, writable: true, value: { initialSize: "fit", Panzoom: { maxScale: 1 }, protected: false, zoom: true, zoomOpacity: "auto" } }), "function" == typeof SuppressedError && SuppressedError;
      const rt = (t2, e2 = {}) => {
        const i2 = new URL(t2), n2 = new URLSearchParams(i2.search), s2 = new URLSearchParams();
        for (const [t3, i3] of [...n2, ...Object.entries(e2)]) {
          let e3 = i3.toString();
          "t" === t3 ? s2.set("start", parseInt(e3).toString()) : s2.set(t3, e3);
        }
        let o2 = s2.toString(), a2 = t2.match(/#t=((.*)?\d+s)/);
        return a2 && (o2 += `#t=${a2[1]}`), o2;
      }, lt = { ajax: null, autoSize: true, iframeAttr: { allow: "autoplay; fullscreen", scrolling: "auto" }, preload: true, videoAutoplay: true, videoRatio: 16 / 9, videoTpl: `<video class="fancybox__html5video" playsinline controls controlsList="nodownload" poster="{{poster}}">
  <source src="{{src}}" type="{{format}}" />Sorry, your browser doesn't support embedded videos.</video>`, videoFormat: "", vimeo: { byline: 1, color: "00adef", controls: 1, dnt: 1, muted: 0 }, youtube: { controls: 1, enablejsapi: 1, nocookie: 1, rel: 0, fs: 1 } }, ct = ["image", "html", "ajax", "inline", "clone", "iframe", "map", "pdf", "html5video", "youtube", "vimeo", "video"];
      class ht extends B {
        onInitSlide(t2, e2, i2) {
          this.processType(i2);
        }
        onCreateSlide(t2, e2, i2) {
          this.setContent(i2);
        }
        onRemoveSlide(t2, e2, i2) {
          i2.xhr && (i2.xhr.abort(), i2.xhr = null);
          const n2 = i2.iframeEl;
          n2 && (n2.onload = n2.onerror = null, n2.src = "//about:blank", i2.iframeEl = null);
          const s2 = i2.contentEl, o2 = i2.placeholderEl;
          if ("inline" === i2.type && s2 && o2)
            s2.classList.remove("fancybox__content"), "none" !== s2.style.display && (s2.style.display = "none"), o2.parentNode && o2.parentNode.insertBefore(s2, o2), o2.remove(), i2.contentEl = void 0, i2.placeholderEl = void 0;
          else
            for (; i2.el && i2.el.firstChild; )
              i2.el.removeChild(i2.el.firstChild);
        }
        onSelectSlide(t2, e2, i2) {
          i2.state === it.Ready && this.playVideo();
        }
        onUnselectSlide(t2, e2, i2) {
          var n2, s2;
          if ("html5video" === i2.type) {
            try {
              null === (s2 = null === (n2 = i2.el) || void 0 === n2 ? void 0 : n2.querySelector("video")) || void 0 === s2 || s2.pause();
            } catch (t3) {
            }
            return;
          }
          let o2;
          "vimeo" === i2.type ? o2 = { method: "pause", value: "true" } : "youtube" === i2.type && (o2 = { event: "command", func: "pauseVideo" }), o2 && i2.iframeEl && i2.iframeEl.contentWindow && i2.iframeEl.contentWindow.postMessage(JSON.stringify(o2), "*"), i2.poller && clearTimeout(i2.poller);
        }
        onDone(t2, e2) {
          t2.isCurrentSlide(e2) && !t2.isClosing() && this.playVideo();
        }
        onRefresh(t2, e2) {
          e2.slides.forEach((t3) => {
            t3.el && (this.setAspectRatio(t3), this.resizeIframe(t3));
          });
        }
        onMessage(t2) {
          try {
            let e2 = JSON.parse(t2.data);
            if ("https://player.vimeo.com" === t2.origin) {
              if ("ready" === e2.event)
                for (let e3 of Array.from(document.getElementsByClassName("fancybox__iframe")))
                  e3 instanceof HTMLIFrameElement && e3.contentWindow === t2.source && (e3.dataset.ready = "true");
            } else if (t2.origin.match(/^https:\/\/(www.)?youtube(-nocookie)?.com$/) && "onReady" === e2.event) {
              const t3 = document.getElementById(e2.id);
              t3 && (t3.dataset.ready = "true");
            }
          } catch (t3) {
          }
        }
        loadAjaxContent(t2) {
          const e2 = this.instance.optionFor(t2, "src") || "";
          this.instance.showLoading(t2);
          const i2 = this.instance, n2 = new XMLHttpRequest();
          i2.showLoading(t2), n2.onreadystatechange = function() {
            n2.readyState === XMLHttpRequest.DONE && i2.state === et.Ready && (i2.hideLoading(t2), 200 === n2.status ? i2.setContent(t2, n2.responseText) : i2.setError(t2, 404 === n2.status ? "{{AJAX_NOT_FOUND}}" : "{{AJAX_FORBIDDEN}}"));
          };
          const s2 = t2.ajax || null;
          n2.open(s2 ? "POST" : "GET", e2 + ""), n2.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), n2.setRequestHeader("X-Requested-With", "XMLHttpRequest"), n2.send(s2), t2.xhr = n2;
        }
        setInlineContent(t2) {
          let e2 = null;
          if (x(t2.src))
            e2 = t2.src;
          else if ("string" == typeof t2.src) {
            const i2 = t2.src.split("#", 2).pop();
            e2 = i2 ? document.getElementById(i2) : null;
          }
          if (e2) {
            if ("clone" === t2.type || e2.closest(".fancybox__slide")) {
              e2 = e2.cloneNode(true);
              const i2 = e2.dataset.animationName;
              i2 && (e2.classList.remove(i2), delete e2.dataset.animationName);
              let n2 = e2.getAttribute("id");
              n2 = n2 ? `${n2}--clone` : `clone-${this.instance.id}-${t2.index}`, e2.setAttribute("id", n2);
            } else if (e2.parentNode) {
              const i2 = document.createElement("div");
              i2.classList.add("fancybox-placeholder"), e2.parentNode.insertBefore(i2, e2), t2.placeholderEl = i2;
            }
            this.instance.setContent(t2, e2);
          } else
            this.instance.setError(t2, "{{ELEMENT_NOT_FOUND}}");
        }
        setIframeContent(t2) {
          const { src: e2, el: i2 } = t2;
          if (!e2 || "string" != typeof e2 || !i2)
            return;
          const n2 = this.instance, s2 = document.createElement("iframe");
          s2.className = "fancybox__iframe", s2.setAttribute("id", `fancybox__iframe_${n2.id}_${t2.index}`);
          for (const [e3, i3] of Object.entries(this.optionFor(t2, "iframeAttr") || {}))
            s2.setAttribute(e3, i3);
          s2.onerror = () => {
            n2.setError(t2, "{{IFRAME_ERROR}}");
          }, t2.iframeEl = s2;
          const o2 = this.optionFor(t2, "preload");
          if (i2.classList.add("is-loading"), "iframe" !== t2.type || false === o2)
            return s2.setAttribute("src", t2.src + ""), this.resizeIframe(t2), void n2.setContent(t2, s2);
          n2.showLoading(t2), s2.onload = () => {
            if (!s2.src.length)
              return;
            const e3 = "true" !== s2.dataset.ready;
            s2.dataset.ready = "true", this.resizeIframe(t2), e3 ? n2.revealContent(t2) : n2.hideLoading(t2);
          }, s2.setAttribute("src", e2), n2.setContent(t2, s2, false);
        }
        resizeIframe(t2) {
          const e2 = t2.iframeEl, i2 = null == e2 ? void 0 : e2.parentElement;
          if (!e2 || !i2)
            return;
          let n2 = t2.autoSize, s2 = t2.width || 0, o2 = t2.height || 0;
          s2 && o2 && (n2 = false);
          const a2 = i2 && i2.style;
          if (false !== t2.preload && false !== n2 && a2)
            try {
              const t3 = window.getComputedStyle(i2), n3 = parseFloat(t3.paddingLeft) + parseFloat(t3.paddingRight), r2 = parseFloat(t3.paddingTop) + parseFloat(t3.paddingBottom), l2 = e2.contentWindow;
              if (l2) {
                const t4 = l2.document, e3 = t4.getElementsByTagName("html")[0], i3 = t4.body;
                a2.width = "", i3.style.overflow = "hidden", s2 = s2 || e3.scrollWidth + n3, a2.width = `${s2}px`, i3.style.overflow = "", a2.flex = "0 0 auto", a2.height = `${i3.scrollHeight}px`, o2 = e3.scrollHeight + r2;
              }
            } catch (t3) {
            }
          if (s2 || o2) {
            const t3 = { flex: "0 1 auto", width: "", height: "" };
            s2 && (t3.width = `${s2}px`), o2 && (t3.height = `${o2}px`), Object.assign(a2, t3);
          }
        }
        playVideo() {
          const t2 = this.instance.getSlide();
          if (!t2)
            return;
          const { el: e2 } = t2;
          if (!e2 || !e2.offsetParent)
            return;
          if (!this.optionFor(t2, "videoAutoplay"))
            return;
          if ("html5video" === t2.type)
            try {
              const t3 = e2.querySelector("video");
              if (t3) {
                const e3 = t3.play();
                void 0 !== e3 && e3.then(() => {
                }).catch((e4) => {
                  t3.muted = true, t3.play();
                });
              }
            } catch (t3) {
            }
          if ("youtube" !== t2.type && "vimeo" !== t2.type)
            return;
          const i2 = () => {
            if (t2.iframeEl && t2.iframeEl.contentWindow) {
              let e3;
              if ("true" === t2.iframeEl.dataset.ready)
                return e3 = "youtube" === t2.type ? { event: "command", func: "playVideo" } : { method: "play", value: "true" }, e3 && t2.iframeEl.contentWindow.postMessage(JSON.stringify(e3), "*"), void (t2.poller = void 0);
              "youtube" === t2.type && (e3 = { event: "listening", id: t2.iframeEl.getAttribute("id") }, t2.iframeEl.contentWindow.postMessage(JSON.stringify(e3), "*"));
            }
            t2.poller = setTimeout(i2, 250);
          };
          i2();
        }
        processType(t2) {
          if (t2.html)
            return t2.type = "html", t2.src = t2.html, void (t2.html = "");
          const e2 = this.instance.optionFor(t2, "src", "");
          if (!e2 || "string" != typeof e2)
            return;
          let i2 = t2.type, n2 = null;
          if (n2 = e2.match(/(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(?:watch\?(?:.*&)?v=|v\/|u\/|shorts\/|embed\/?)?(videoseries\?list=(?:.*)|[\w-]{11}|\?listType=(?:.*)&list=(?:.*))(?:.*)/i)) {
            const s2 = this.optionFor(t2, "youtube"), { nocookie: o2 } = s2, a2 = function(t3, e3) {
              var i3 = {};
              for (var n3 in t3)
                Object.prototype.hasOwnProperty.call(t3, n3) && e3.indexOf(n3) < 0 && (i3[n3] = t3[n3]);
              if (null != t3 && "function" == typeof Object.getOwnPropertySymbols) {
                var s3 = 0;
                for (n3 = Object.getOwnPropertySymbols(t3); s3 < n3.length; s3++)
                  e3.indexOf(n3[s3]) < 0 && Object.prototype.propertyIsEnumerable.call(t3, n3[s3]) && (i3[n3[s3]] = t3[n3[s3]]);
              }
              return i3;
            }(s2, ["nocookie"]), r2 = `www.youtube${o2 ? "-nocookie" : ""}.com`, l2 = rt(e2, a2), c2 = encodeURIComponent(n2[2]);
            t2.videoId = c2, t2.src = `https://${r2}/embed/${c2}?${l2}`, t2.thumbSrc = t2.thumbSrc || `https://i.ytimg.com/vi/${c2}/mqdefault.jpg`, i2 = "youtube";
          } else if (n2 = e2.match(/^.+vimeo.com\/(?:\/)?([\d]+)((\/|\?h=)([a-z0-9]+))?(.*)?/)) {
            const s2 = rt(e2, this.optionFor(t2, "vimeo")), o2 = encodeURIComponent(n2[1]), a2 = n2[4] || "";
            t2.videoId = o2, t2.src = `https://player.vimeo.com/video/${o2}?${a2 ? `h=${a2}${s2 ? "&" : ""}` : ""}${s2}`, i2 = "vimeo";
          }
          if (!i2 && t2.triggerEl) {
            const e3 = t2.triggerEl.dataset.type;
            ct.includes(e3) && (i2 = e3);
          }
          i2 || "string" == typeof e2 && ("#" === e2.charAt(0) ? i2 = "inline" : (n2 = e2.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i)) ? (i2 = "html5video", t2.videoFormat = t2.videoFormat || "video/" + ("ogv" === n2[1] ? "ogg" : n2[1])) : e2.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i) ? i2 = "image" : e2.match(/\.(pdf)((\?|#).*)?$/i) ? i2 = "pdf" : (n2 = e2.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:(?:(?:maps\/(?:place\/(?:.*)\/)?\@(.*),(\d+.?\d+?)z))|(?:\?ll=))(.*)?/i)) ? (t2.src = `https://maps.google.${n2[1]}/?ll=${(n2[2] ? n2[2] + "&z=" + Math.floor(parseFloat(n2[3])) + (n2[4] ? n2[4].replace(/^\//, "&") : "") : n2[4] + "").replace(/\?/, "&")}&output=${n2[4] && n2[4].indexOf("layer=c") > 0 ? "svembed" : "embed"}`, i2 = "map") : (n2 = e2.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:maps\/search\/)(.*)/i)) && (t2.src = `https://maps.google.${n2[1]}/maps?q=${n2[2].replace("query=", "q=").replace("api=1", "")}&output=embed`, i2 = "map")), i2 = i2 || this.instance.option("defaultType"), t2.type = i2, "image" === i2 && (t2.thumbSrc = t2.thumbSrc || t2.src);
        }
        setContent(t2) {
          const e2 = this.instance.optionFor(t2, "src") || "";
          if (t2 && t2.type && e2) {
            switch (t2.type) {
              case "html":
                this.instance.setContent(t2, e2);
                break;
              case "html5video":
                const i2 = this.option("videoTpl");
                i2 && this.instance.setContent(t2, i2.replace(/\{\{src\}\}/gi, e2 + "").replace(/\{\{format\}\}/gi, this.optionFor(t2, "videoFormat") || "").replace(/\{\{poster\}\}/gi, t2.poster || t2.thumbSrc || ""));
                break;
              case "inline":
              case "clone":
                this.setInlineContent(t2);
                break;
              case "ajax":
                this.loadAjaxContent(t2);
                break;
              case "pdf":
              case "map":
              case "youtube":
              case "vimeo":
                t2.preload = false;
              case "iframe":
                this.setIframeContent(t2);
            }
            this.setAspectRatio(t2);
          }
        }
        setAspectRatio(t2) {
          var e2;
          const i2 = t2.contentEl, n2 = this.optionFor(t2, "videoRatio"), s2 = null === (e2 = t2.el) || void 0 === e2 ? void 0 : e2.getBoundingClientRect();
          if (!(i2 && s2 && n2 && 1 !== n2 && t2.type && ["video", "youtube", "vimeo", "html5video"].includes(t2.type)))
            return;
          const o2 = s2.width, a2 = s2.height;
          i2.style.aspectRatio = n2 + "", i2.style.width = o2 / a2 > n2 ? "auto" : "", i2.style.height = o2 / a2 > n2 ? "" : "auto";
        }
        attach() {
          const t2 = this, e2 = t2.instance;
          e2.on("Carousel.initSlide", t2.onInitSlide), e2.on("Carousel.createSlide", t2.onCreateSlide), e2.on("Carousel.removeSlide", t2.onRemoveSlide), e2.on("Carousel.selectSlide", t2.onSelectSlide), e2.on("Carousel.unselectSlide", t2.onUnselectSlide), e2.on("Carousel.Panzoom.refresh", t2.onRefresh), e2.on("done", t2.onDone), window.addEventListener("message", t2.onMessage);
        }
        detach() {
          const t2 = this, e2 = t2.instance;
          e2.off("Carousel.initSlide", t2.onInitSlide), e2.off("Carousel.createSlide", t2.onCreateSlide), e2.off("Carousel.removeSlide", t2.onRemoveSlide), e2.off("Carousel.selectSlide", t2.onSelectSlide), e2.off("Carousel.unselectSlide", t2.onUnselectSlide), e2.off("Carousel.Panzoom.refresh", t2.onRefresh), e2.off("done", t2.onDone), window.removeEventListener("message", t2.onMessage);
        }
      }
      Object.defineProperty(ht, "defaults", { enumerable: true, configurable: true, writable: true, value: lt });
      const dt = "play", ut = "pause", pt = "ready";
      class ft extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: pt }), Object.defineProperty(this, "inHover", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "timer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "progressBar", { enumerable: true, configurable: true, writable: true, value: null });
        }
        get isActive() {
          return this.state !== pt;
        }
        onReady(t2) {
          this.option("autoStart") && (t2.isInfinite || t2.page < t2.pages.length - 1) && this.start();
        }
        onChange() {
          var t2;
          (null === (t2 = this.instance.panzoom) || void 0 === t2 ? void 0 : t2.isResting) || (this.removeProgressBar(), this.pause());
        }
        onSettle() {
          this.resume();
        }
        onVisibilityChange() {
          "visible" === document.visibilityState ? this.resume() : this.pause();
        }
        onMouseEnter() {
          this.inHover = true, this.pause();
        }
        onMouseLeave() {
          var t2;
          this.inHover = false, (null === (t2 = this.instance.panzoom) || void 0 === t2 ? void 0 : t2.isResting) && this.resume();
        }
        onTimerEnd() {
          const t2 = this.instance;
          "play" === this.state && (t2.isInfinite || t2.page !== t2.pages.length - 1 ? t2.slideNext() : t2.slideTo(0));
        }
        removeProgressBar() {
          this.progressBar && (this.progressBar.remove(), this.progressBar = null);
        }
        createProgressBar() {
          var t2;
          if (!this.option("showProgress"))
            return null;
          this.removeProgressBar();
          const e2 = this.instance, i2 = (null === (t2 = e2.pages[e2.page]) || void 0 === t2 ? void 0 : t2.slides) || [];
          let n2 = this.option("progressParentEl");
          if (n2 || (n2 = (1 === i2.length ? i2[0].el : null) || e2.viewport), !n2)
            return null;
          const s2 = document.createElement("div");
          return S(s2, "f-progress"), n2.prepend(s2), this.progressBar = s2, s2.offsetHeight, s2;
        }
        set() {
          const t2 = this, e2 = t2.instance;
          if (e2.pages.length < 2)
            return;
          if (t2.timer)
            return;
          const i2 = t2.option("timeout");
          t2.state = dt, S(e2.container, "has-autoplay");
          let n2 = t2.createProgressBar();
          n2 && (n2.style.transitionDuration = `${i2}ms`, n2.style.transform = "scaleX(1)"), t2.timer = setTimeout(() => {
            t2.timer = null, t2.inHover || t2.onTimerEnd();
          }, i2), t2.emit("set");
        }
        clear() {
          const t2 = this;
          t2.timer && (clearTimeout(t2.timer), t2.timer = null), t2.removeProgressBar();
        }
        start() {
          const t2 = this;
          if (t2.set(), t2.state !== pt) {
            if (t2.option("pauseOnHover")) {
              const e2 = t2.instance.container;
              e2.addEventListener("mouseenter", t2.onMouseEnter, false), e2.addEventListener("mouseleave", t2.onMouseLeave, false);
            }
            document.addEventListener("visibilitychange", t2.onVisibilityChange, false), t2.emit("start");
          }
        }
        stop() {
          const t2 = this, e2 = t2.state, i2 = t2.instance.container;
          t2.clear(), t2.state = pt, i2.removeEventListener("mouseenter", t2.onMouseEnter, false), i2.removeEventListener("mouseleave", t2.onMouseLeave, false), document.removeEventListener("visibilitychange", t2.onVisibilityChange, false), E(i2, "has-autoplay"), e2 !== pt && t2.emit("stop");
        }
        pause() {
          const t2 = this;
          t2.state === dt && (t2.state = ut, t2.clear(), t2.emit(ut));
        }
        resume() {
          const t2 = this, e2 = t2.instance;
          if (e2.isInfinite || e2.page !== e2.pages.length - 1)
            if (t2.state !== dt) {
              if (t2.state === ut && !t2.inHover) {
                const e3 = new Event("resume", { bubbles: true, cancelable: true });
                t2.emit("resume", e3), e3.defaultPrevented || t2.set();
              }
            } else
              t2.set();
          else
            t2.stop();
        }
        toggle() {
          this.state === dt || this.state === ut ? this.stop() : this.start();
        }
        attach() {
          const t2 = this, e2 = t2.instance;
          e2.on("ready", t2.onReady), e2.on("Panzoom.startAnimation", t2.onChange), e2.on("Panzoom.endAnimation", t2.onSettle), e2.on("Panzoom.touchMove", t2.onChange);
        }
        detach() {
          const t2 = this, e2 = t2.instance;
          e2.off("ready", t2.onReady), e2.off("Panzoom.startAnimation", t2.onChange), e2.off("Panzoom.endAnimation", t2.onSettle), e2.off("Panzoom.touchMove", t2.onChange), t2.stop();
        }
      }
      Object.defineProperty(ft, "defaults", { enumerable: true, configurable: true, writable: true, value: { autoStart: true, pauseOnHover: true, progressParentEl: null, showProgress: true, timeout: 3e3 } });
      class mt extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "ref", { enumerable: true, configurable: true, writable: true, value: null });
        }
        onPrepare(t2) {
          const e2 = t2.carousel;
          if (!e2)
            return;
          const i2 = t2.container;
          i2 && (e2.options.Autoplay = u({ autoStart: false }, this.option("Autoplay") || {}, { pauseOnHover: false, timeout: this.option("timeout"), progressParentEl: () => this.option("progressParentEl") || null, on: { start: () => {
            t2.emit("startSlideshow");
          }, set: (e3) => {
            var n2;
            i2.classList.add("has-slideshow"), (null === (n2 = t2.getSlide()) || void 0 === n2 ? void 0 : n2.state) !== it.Ready && e3.pause();
          }, stop: () => {
            i2.classList.remove("has-slideshow"), t2.isCompact || t2.endIdle(), t2.emit("endSlideshow");
          }, resume: (e3, i3) => {
            var n2, s2, o2;
            !i3 || !i3.cancelable || (null === (n2 = t2.getSlide()) || void 0 === n2 ? void 0 : n2.state) === it.Ready && (null === (o2 = null === (s2 = t2.carousel) || void 0 === s2 ? void 0 : s2.panzoom) || void 0 === o2 ? void 0 : o2.isResting) || i3.preventDefault();
          } } }), e2.attachPlugins({ Autoplay: ft }), this.ref = e2.plugins.Autoplay);
        }
        onReady(t2) {
          const e2 = t2.carousel, i2 = this.ref;
          e2 && i2 && this.option("playOnStart") && (e2.isInfinite || e2.page < e2.pages.length - 1) && i2.start();
        }
        onDone(t2, e2) {
          const i2 = this.ref;
          if (!i2)
            return;
          const n2 = e2.panzoom;
          n2 && n2.on("startAnimation", () => {
            t2.isCurrentSlide(e2) && i2.stop();
          }), t2.isCurrentSlide(e2) && i2.resume();
        }
        onKeydown(t2, e2) {
          var i2;
          const n2 = this.ref;
          n2 && e2 === this.option("key") && "BUTTON" !== (null === (i2 = document.activeElement) || void 0 === i2 ? void 0 : i2.nodeName) && n2.toggle();
        }
        attach() {
          const t2 = this, e2 = t2.instance;
          e2.on("Carousel.init", t2.onPrepare), e2.on("Carousel.ready", t2.onReady), e2.on("done", t2.onDone), e2.on("keydown", t2.onKeydown);
        }
        detach() {
          const t2 = this, e2 = t2.instance;
          e2.off("Carousel.init", t2.onPrepare), e2.off("Carousel.ready", t2.onReady), e2.off("done", t2.onDone), e2.off("keydown", t2.onKeydown);
        }
      }
      Object.defineProperty(mt, "defaults", { enumerable: true, configurable: true, writable: true, value: { key: " ", playOnStart: false, progressParentEl: (t2) => {
        var e2;
        return (null === (e2 = t2.instance.container) || void 0 === e2 ? void 0 : e2.querySelector(".fancybox__toolbar [data-fancybox-toggle-slideshow]")) || t2.instance.container;
      }, timeout: 3e3 } });
      const gt = { classes: { container: "f-thumbs f-carousel__thumbs", viewport: "f-thumbs__viewport", track: "f-thumbs__track", slide: "f-thumbs__slide", isResting: "is-resting", isSelected: "is-selected", isLoading: "is-loading", hasThumbs: "has-thumbs" }, minCount: 2, parentEl: null, thumbTpl: '<button class="f-thumbs__slide__button" tabindex="0" type="button" aria-label="{{GOTO}}" data-carousel-index="%i"><img class="f-thumbs__slide__img" data-lazy-src="{{%s}}" alt="" /></button>', type: "modern" };
      var bt;
      !function(t2) {
        t2[t2.Init = 0] = "Init", t2[t2.Ready = 1] = "Ready", t2[t2.Hidden = 2] = "Hidden", t2[t2.Disabled = 3] = "Disabled";
      }(bt || (bt = {}));
      let vt = class extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "type", { enumerable: true, configurable: true, writable: true, value: "modern" }), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "track", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "carousel", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "panzoom", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "thumbWidth", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "thumbClipWidth", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "thumbHeight", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "thumbGap", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "thumbExtraGap", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "shouldCenter", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: bt.Init });
        }
        formatThumb(t2, e2) {
          return this.instance.localize(e2, [["%i", t2.index], ["%d", t2.index + 1], ["%s", t2.thumbSrc || "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"]]);
        }
        getSlides() {
          const t2 = [], e2 = this.option("thumbTpl") || "";
          if (e2)
            for (const i2 of this.instance.slides || []) {
              let n2 = "";
              i2.type && (n2 = `for-${i2.type}`, i2.type && ["video", "youtube", "vimeo", "html5video"].includes(i2.type) && (n2 += " for-video")), t2.push({ html: this.formatThumb(i2, e2), customClass: n2 });
            }
          return t2;
        }
        onInitSlide(t2, e2) {
          const i2 = e2.el;
          i2 && (e2.thumbSrc = i2.dataset.thumbSrc || e2.thumbSrc || "", e2.thumbClipWidth = parseFloat(i2.dataset.thumbClipWidth || "") || e2.thumbClipWidth || 0, e2.thumbHeight = parseFloat(i2.dataset.thumbHeight || "") || e2.thumbHeight || 0);
        }
        onInitSlides() {
          this.state === bt.Init && this.build();
        }
        onRefreshM() {
          this.refreshModern();
        }
        onChangeM() {
          "modern" === this.type && (this.shouldCenter = true, this.centerModern());
        }
        onClickModern(t2) {
          t2.preventDefault(), t2.stopPropagation();
          const e2 = this.instance, i2 = e2.page, n2 = (t3) => {
            if (t3) {
              const e3 = t3.closest("[data-carousel-index]");
              if (e3)
                return parseInt(e3.dataset.carouselIndex || "", 10) || 0;
            }
            return -1;
          }, s2 = (t3, e3) => {
            const i3 = document.elementFromPoint(t3, e3);
            return i3 ? n2(i3) : -1;
          };
          let o2 = n2(t2.target);
          o2 < 0 && (o2 = s2(t2.clientX + this.thumbGap, t2.clientY), o2 === i2 && (o2 = i2 - 1)), o2 < 0 && (o2 = s2(t2.clientX - this.thumbGap, t2.clientY), o2 === i2 && (o2 = i2 + 1)), o2 < 0 && (o2 = ((e3) => {
            let n3 = s2(t2.clientX - e3, t2.clientY), a2 = s2(t2.clientX + e3, t2.clientY);
            return o2 < 0 && n3 === i2 && (o2 = i2 + 1), o2 < 0 && a2 === i2 && (o2 = i2 - 1), o2;
          })(this.thumbExtraGap)), o2 === i2 ? this.centerModern() : o2 > -1 && o2 < e2.pages.length && e2.slideTo(o2);
        }
        onTransformM() {
          if ("modern" !== this.type)
            return;
          const { instance: t2, container: e2, track: i2 } = this, n2 = t2.panzoom;
          if (!(e2 && i2 && n2 && this.panzoom))
            return;
          o(e2, this.cn("isResting"), n2.state !== g.Init && n2.isResting);
          const s2 = this.thumbGap, a2 = this.thumbExtraGap, r2 = this.thumbClipWidth;
          let l2 = 0, c2 = 0, h2 = 0;
          for (const e3 of t2.slides) {
            let i3 = e3.index, n3 = e3.thumbSlideEl;
            if (!n3)
              continue;
            o(n3, this.cn("isSelected"), i3 === t2.page), c2 = 1 - Math.abs(t2.getProgress(i3)), n3.style.setProperty("--progress", c2 ? c2 + "" : "");
            const d2 = 0.5 * ((e3.thumbWidth || 0) - r2);
            l2 += s2, l2 += d2, c2 && (l2 -= c2 * (d2 + a2)), n3.style.setProperty("--shift", l2 - s2 + ""), l2 += d2, c2 && (l2 -= c2 * (d2 + a2)), l2 -= s2, 0 === i3 && (h2 = a2 * c2);
          }
          i2 && (i2.style.setProperty("--left", h2 + ""), i2.style.setProperty("--width", l2 + h2 + s2 + a2 * c2 + "")), this.shouldCenter && this.centerModern();
        }
        buildClassic() {
          const { container: t2, track: e2 } = this, i2 = this.getSlides();
          if (!t2 || !e2 || !i2)
            return;
          const n2 = new this.instance.constructor(t2, u({ track: e2, infinite: false, center: true, fill: true, dragFree: true, slidesPerPage: 1, transition: false, Dots: false, Navigation: false, classes: { container: "f-thumbs", viewport: "f-thumbs__viewport", track: "f-thumbs__track", slide: "f-thumbs__slide" } }, this.option("Carousel") || {}, { Sync: { target: this.instance }, slides: i2 }));
          this.carousel = n2, this.track = e2, n2.on("ready", () => {
            this.emit("ready");
          }), n2.on("createSlide", (t3, e3) => {
            this.emit("createSlide", e3, e3.el);
          });
        }
        buildModern() {
          if ("modern" !== this.type)
            return;
          const { container: t2, track: e2, instance: i2 } = this, s2 = this.option("thumbTpl") || "";
          if (!t2 || !e2 || !s2)
            return;
          S(t2, "is-horizontal"), this.updateModern();
          for (const t3 of i2.slides || []) {
            const i3 = document.createElement("div");
            if (S(i3, this.cn("slide")), t3.type) {
              let e3 = `for-${t3.type}`;
              ["video", "youtube", "vimeo", "html5video"].includes(t3.type) && (e3 += " for-video"), S(i3, e3);
            }
            i3.appendChild(n(this.formatThumb(t3, s2))), this.emit("createSlide", t3, i3), t3.thumbSlideEl = i3, e2.appendChild(i3), this.resizeModernSlide(t3);
          }
          const o2 = new i2.constructor.Panzoom(t2, { content: e2, lockAxis: "x", zoom: false, panOnlyZoomed: false, bounds: () => {
            let t3 = 0, e3 = 0, n2 = i2.slides[0], s3 = i2.slides[i2.slides.length - 1], o3 = i2.slides[i2.page];
            return n2 && s3 && o3 && (e3 = -1 * this.getModernThumbPos(0), 0 !== i2.page && (e3 += 0.5 * (n2.thumbWidth || 0)), t3 = -1 * this.getModernThumbPos(i2.slides.length - 1), i2.page !== i2.slides.length - 1 && (t3 += (s3.thumbWidth || 0) - (o3.thumbWidth || 0) - 0.5 * (s3.thumbWidth || 0))), { x: { min: t3, max: e3 }, y: { min: 0, max: 0 } };
          } });
          o2.on("touchStart", (t3, e3) => {
            this.shouldCenter = false;
          }), o2.on("click", (t3, e3) => this.onClickModern(e3)), o2.on("ready", () => {
            this.centerModern(), this.emit("ready");
          }), o2.on(["afterTransform", "refresh"], (t3) => {
            this.lazyLoadModern();
          }), this.panzoom = o2, this.refreshModern();
        }
        updateModern() {
          if ("modern" !== this.type)
            return;
          const { container: t2 } = this;
          t2 && (this.thumbGap = parseFloat(getComputedStyle(t2).getPropertyValue("--f-thumb-gap")) || 0, this.thumbExtraGap = parseFloat(getComputedStyle(t2).getPropertyValue("--f-thumb-extra-gap")) || 0, this.thumbWidth = parseFloat(getComputedStyle(t2).getPropertyValue("--f-thumb-width")) || 40, this.thumbClipWidth = parseFloat(getComputedStyle(t2).getPropertyValue("--f-thumb-clip-width")) || 40, this.thumbHeight = parseFloat(getComputedStyle(t2).getPropertyValue("--f-thumb-height")) || 40);
        }
        refreshModern() {
          var t2;
          if ("modern" === this.type) {
            this.updateModern();
            for (const t3 of this.instance.slides || [])
              this.resizeModernSlide(t3);
            this.onTransformM(), null === (t2 = this.panzoom) || void 0 === t2 || t2.updateMetrics(true), this.centerModern(0);
          }
        }
        centerModern(e2) {
          const i2 = this.instance, { container: n2, panzoom: s2 } = this;
          if (!n2 || !s2 || s2.state === g.Init)
            return;
          const o2 = i2.page;
          let a2 = this.getModernThumbPos(o2), r2 = a2;
          for (let t2 = i2.page - 3; t2 < i2.page + 3; t2++) {
            if (t2 < 0 || t2 > i2.pages.length - 1 || t2 === i2.page)
              continue;
            const e3 = 1 - Math.abs(i2.getProgress(t2));
            e3 > 0 && e3 < 1 && (r2 += e3 * (this.getModernThumbPos(t2) - a2));
          }
          let l2 = 100;
          void 0 === e2 && (e2 = 0.2, i2.inTransition.size > 0 && (e2 = 0.12), Math.abs(-1 * s2.current.e - r2) > s2.containerRect.width && (e2 = 0.5, l2 = 0)), s2.options.maxVelocity = l2, s2.applyChange({ panX: t(-1 * r2 - s2.target.e, 1e3), friction: null === i2.prevPage ? 0 : e2 });
        }
        lazyLoadModern() {
          const { instance: t2, panzoom: e2 } = this;
          if (!e2)
            return;
          const i2 = -1 * e2.current.e || 0;
          let s2 = this.getModernThumbPos(t2.page);
          if (e2.state !== g.Init || 0 === s2)
            for (const s3 of t2.slides || []) {
              const t3 = s3.thumbSlideEl;
              if (!t3)
                continue;
              const o2 = t3.querySelector("img[data-lazy-src]"), a2 = s3.index, r2 = this.getModernThumbPos(a2), l2 = i2 - 0.5 * e2.containerRect.innerWidth, c2 = l2 + e2.containerRect.innerWidth;
              if (!o2 || r2 < l2 || r2 > c2)
                continue;
              let h2 = o2.dataset.lazySrc;
              if (!h2 || !h2.length)
                continue;
              if (delete o2.dataset.lazySrc, o2.src = h2, o2.complete)
                continue;
              S(t3, this.cn("isLoading"));
              const d2 = n(w);
              t3.appendChild(d2), o2.addEventListener("load", () => {
                t3.offsetParent && (t3.classList.remove(this.cn("isLoading")), d2.remove());
              }, false);
            }
        }
        resizeModernSlide(t2) {
          if ("modern" !== this.type)
            return;
          if (!t2.thumbSlideEl)
            return;
          const e2 = t2.thumbClipWidth && t2.thumbHeight ? Math.round(this.thumbHeight * (t2.thumbClipWidth / t2.thumbHeight)) : this.thumbWidth;
          t2.thumbWidth = e2;
        }
        getModernThumbPos(e2) {
          const i2 = this.instance.slides[e2], n2 = this.panzoom;
          if (!n2 || !n2.contentRect.fitWidth)
            return 0;
          let s2 = n2.containerRect.innerWidth, o2 = n2.contentRect.width;
          2 === this.instance.slides.length && (e2 -= 1, o2 = 2 * this.thumbClipWidth);
          let a2 = e2 * (this.thumbClipWidth + this.thumbGap) + this.thumbExtraGap + 0.5 * (i2.thumbWidth || 0);
          return a2 -= o2 > s2 ? 0.5 * s2 : 0.5 * o2, t(a2 || 0, 1);
        }
        build() {
          const t2 = this.instance, e2 = t2.container, i2 = this.option("minCount") || 0;
          if (i2) {
            let e3 = 0;
            for (const i3 of t2.slides || [])
              i3.thumbSrc && e3++;
            if (e3 < i2)
              return this.cleanup(), void (this.state = bt.Disabled);
          }
          const n2 = this.option("type");
          if (["modern", "classic"].indexOf(n2) < 0)
            return void (this.state = bt.Disabled);
          this.type = n2;
          const s2 = document.createElement("div");
          S(s2, this.cn("container")), S(s2, `is-${n2}`);
          const o2 = this.option("parentEl");
          o2 ? o2.appendChild(s2) : e2.after(s2), this.container = s2, S(e2, this.cn("hasThumbs"));
          const a2 = document.createElement("div");
          S(a2, this.cn("track")), s2.appendChild(a2), this.track = a2, "classic" === n2 ? this.buildClassic() : this.buildModern(), this.state = bt.Ready, s2.addEventListener("click", (e3) => {
            setTimeout(() => {
              var e4;
              null === (e4 = null == s2 ? void 0 : s2.querySelector(`[data-carousel-index="${t2.page}"]`)) || void 0 === e4 || e4.focus();
            }, 100);
          });
        }
        cleanup() {
          this.carousel && this.carousel.destroy(), this.carousel = null, this.panzoom && this.panzoom.destroy(), this.panzoom = null, this.container && this.container.remove(), this.container = null, this.track = null, this.state = bt.Init, E(this.instance.container, this.cn("hasThumbs"));
        }
        attach() {
          const t2 = this, e2 = t2.instance;
          e2.on("initSlide", t2.onInitSlide), e2.state === F.Init ? e2.on("initSlides", t2.onInitSlides) : t2.onInitSlides(), e2.on("Panzoom.afterTransform", t2.onTransformM), e2.on("Panzoom.refresh", t2.onRefreshM), e2.on("change", t2.onChangeM);
        }
        detach() {
          const t2 = this, e2 = t2.instance;
          e2.off("initSlide", t2.onInitSlide), e2.off("initSlides", t2.onInitSlides), e2.off("Panzoom.afterTransform", t2.onTransformM), e2.off("Panzoom.refresh", t2.onRefreshM), e2.off("change", t2.onChangeM), t2.cleanup();
        }
      };
      Object.defineProperty(vt, "defaults", { enumerable: true, configurable: true, writable: true, value: gt });
      const yt = Object.assign(Object.assign({}, gt), { key: "t", showOnStart: true, parentEl: null }), wt = "is-masked", xt = "aria-hidden";
      class Et extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "ref", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "hidden", { enumerable: true, configurable: true, writable: true, value: false });
        }
        get isEnabled() {
          const t2 = this.ref;
          return t2 && t2.state !== bt.Disabled;
        }
        get isHidden() {
          return this.hidden;
        }
        onInit() {
          var t2;
          const e2 = this, i2 = e2.instance, n2 = i2.carousel;
          if (e2.ref || !n2)
            return;
          const s2 = e2.option("parentEl") || i2.footer || i2.container;
          if (!s2)
            return;
          const o2 = u({}, e2.options, { parentEl: s2, classes: { container: "f-thumbs fancybox__thumbs" }, Carousel: { Sync: { friction: i2.option("Carousel.friction") || 0 } }, on: { ready: (t3) => {
            const i3 = t3.container;
            i3 && this.hidden && (e2.refresh(), i3.style.transition = "none", e2.hide(), i3.offsetHeight, queueMicrotask(() => {
              i3.style.transition = "", e2.show();
            }));
          } } });
          o2.Carousel = o2.Carousel || {}, o2.Carousel.on = u((null === (t2 = e2.options.Carousel) || void 0 === t2 ? void 0 : t2.on) || {}, { click: (t3, e3) => {
            e3.stopPropagation();
          } }), n2.options.Thumbs = o2, n2.attachPlugins({ Thumbs: vt }), e2.ref = n2.plugins.Thumbs, e2.option("showOnStart") || (e2.ref.state = bt.Hidden, e2.hidden = true);
        }
        onResize() {
          var t2;
          const e2 = null === (t2 = this.ref) || void 0 === t2 ? void 0 : t2.container;
          e2 && (e2.style.maxHeight = "");
        }
        onKeydown(t2, e2) {
          const i2 = this.option("key");
          i2 && i2 === e2 && this.toggle();
        }
        toggle() {
          const t2 = this.ref;
          t2 && t2.state !== bt.Disabled && (t2.state !== bt.Hidden ? this.hidden ? this.show() : this.hide() : t2.build());
        }
        show() {
          const t2 = this.ref, e2 = t2 && t2.state !== bt.Disabled && t2.container;
          e2 && (this.refresh(), e2.offsetHeight, e2.removeAttribute(xt), e2.classList.remove(wt), this.hidden = false);
        }
        hide() {
          const t2 = this.ref, e2 = t2 && t2.container;
          e2 && (this.refresh(), e2.offsetHeight, e2.classList.add(wt), e2.setAttribute(xt, "true")), this.hidden = true;
        }
        refresh() {
          const t2 = this.ref;
          if (!t2 || t2.state === bt.Disabled)
            return;
          const e2 = t2.container, i2 = (null == e2 ? void 0 : e2.firstChild) || null;
          e2 && i2 && i2.childNodes.length && (e2.style.maxHeight = `${i2.getBoundingClientRect().height}px`);
        }
        attach() {
          const t2 = this, e2 = t2.instance;
          e2.state === et.Init ? e2.on("Carousel.init", t2.onInit) : t2.onInit(), e2.on("resize", t2.onResize), e2.on("keydown", t2.onKeydown);
        }
        detach() {
          var t2;
          const e2 = this, i2 = e2.instance;
          i2.off("Carousel.init", e2.onInit), i2.off("resize", e2.onResize), i2.off("keydown", e2.onKeydown), null === (t2 = i2.carousel) || void 0 === t2 || t2.detachPlugins(["Thumbs"]), e2.ref = null;
        }
      }
      Object.defineProperty(Et, "defaults", { enumerable: true, configurable: true, writable: true, value: yt });
      const St = { panLeft: { icon: '<svg><path d="M5 12h14M5 12l6 6M5 12l6-6"/></svg>', change: { panX: -100 } }, panRight: { icon: '<svg><path d="M5 12h14M13 18l6-6M13 6l6 6"/></svg>', change: { panX: 100 } }, panUp: { icon: '<svg><path d="M12 5v14M18 11l-6-6M6 11l6-6"/></svg>', change: { panY: -100 } }, panDown: { icon: '<svg><path d="M12 5v14M18 13l-6 6M6 13l6 6"/></svg>', change: { panY: 100 } }, zoomIn: { icon: '<svg><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M11 8v6M8 11h6"/></svg>', action: "zoomIn" }, zoomOut: { icon: '<svg><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>', action: "zoomOut" }, toggle1to1: { icon: '<svg><path d="M3.51 3.07c5.74.02 11.48-.02 17.22.02 1.37.1 2.34 1.64 2.18 3.13 0 4.08.02 8.16 0 12.23-.1 1.54-1.47 2.64-2.79 2.46-5.61-.01-11.24.02-16.86-.01-1.36-.12-2.33-1.65-2.17-3.14 0-4.07-.02-8.16 0-12.23.1-1.36 1.22-2.48 2.42-2.46Z"/><path d="M5.65 8.54h1.49v6.92m8.94-6.92h1.49v6.92M11.5 9.4v.02m0 5.18v0"/></svg>', action: "toggleZoom" }, toggleZoom: { icon: '<svg><g><line x1="11" y1="8" x2="11" y2="14"></line></g><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>', action: "toggleZoom" }, iterateZoom: { icon: '<svg><g><line x1="11" y1="8" x2="11" y2="14"></line></g><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>', action: "iterateZoom" }, rotateCCW: { icon: '<svg><path d="M15 4.55a8 8 0 0 0-6 14.9M9 15v5H4M18.37 7.16v.01M13 19.94v.01M16.84 18.37v.01M19.37 15.1v.01M19.94 11v.01"/></svg>', action: "rotateCCW" }, rotateCW: { icon: '<svg><path d="M9 4.55a8 8 0 0 1 6 14.9M15 15v5h5M5.63 7.16v.01M4.06 11v.01M4.63 15.1v.01M7.16 18.37v.01M11 19.94v.01"/></svg>', action: "rotateCW" }, flipX: { icon: '<svg style="stroke-width: 1.3"><path d="M12 3v18M16 7v10h5L16 7M8 7v10H3L8 7"/></svg>', action: "flipX" }, flipY: { icon: '<svg style="stroke-width: 1.3"><path d="M3 12h18M7 16h10L7 21v-5M7 8h10L7 3v5"/></svg>', action: "flipY" }, fitX: { icon: '<svg><path d="M4 12V6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v6M10 18H3M21 18h-7M6 15l-3 3 3 3M18 15l3 3-3 3"/></svg>', action: "fitX" }, fitY: { icon: '<svg><path d="M12 20H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h6M18 14v7M18 3v7M15 18l3 3 3-3M15 6l3-3 3 3"/></svg>', action: "fitY" }, reset: { icon: '<svg><path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"/></svg>', action: "reset" }, toggleFS: { icon: '<svg><g><path d="M14.5 9.5 21 3m0 0h-6m6 0v6M3 21l6.5-6.5M3 21v-6m0 6h6"/></g><g><path d="m14 10 7-7m-7 7h6m-6 0V4M3 21l7-7m0 0v6m0-6H4"/></g></svg>', action: "toggleFS" } };
      var Pt;
      !function(t2) {
        t2[t2.Init = 0] = "Init", t2[t2.Ready = 1] = "Ready", t2[t2.Disabled = 2] = "Disabled";
      }(Pt || (Pt = {}));
      const Ct = { absolute: "auto", display: { left: ["infobar"], middle: [], right: ["iterateZoom", "slideshow", "fullscreen", "thumbs", "close"] }, enabled: "auto", items: { infobar: { tpl: '<div class="fancybox__infobar" tabindex="-1"><span data-fancybox-current-index></span>/<span data-fancybox-count></span></div>' }, download: { tpl: '<a class="f-button" title="{{DOWNLOAD}}" data-fancybox-download href="javasript:;"><svg><path d="M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2M7 11l5 5 5-5M12 4v12"/></svg></a>' }, prev: { tpl: '<button class="f-button" title="{{PREV}}" data-fancybox-prev><svg><path d="m15 6-6 6 6 6"/></svg></button>' }, next: { tpl: '<button class="f-button" title="{{NEXT}}" data-fancybox-next><svg><path d="m9 6 6 6-6 6"/></svg></button>' }, slideshow: { tpl: '<button class="f-button" title="{{TOGGLE_SLIDESHOW}}" data-fancybox-toggle-slideshow><svg><g><path d="M8 4v16l13 -8z"></path></g><g><path d="M8 4v15M17 4v15"/></g></svg></button>' }, fullscreen: { tpl: '<button class="f-button" title="{{TOGGLE_FULLSCREEN}}" data-fancybox-toggle-fullscreen><svg><g><path d="M4 8V6a2 2 0 0 1 2-2h2M4 16v2a2 2 0 0 0 2 2h2M16 4h2a2 2 0 0 1 2 2v2M16 20h2a2 2 0 0 0 2-2v-2"/></g><g><path d="M15 19v-2a2 2 0 0 1 2-2h2M15 5v2a2 2 0 0 0 2 2h2M5 15h2a2 2 0 0 1 2 2v2M5 9h2a2 2 0 0 0 2-2V5"/></g></svg></button>' }, thumbs: { tpl: '<button class="f-button" title="{{TOGGLE_THUMBS}}" data-fancybox-toggle-thumbs><svg><circle cx="5.5" cy="5.5" r="1"/><circle cx="12" cy="5.5" r="1"/><circle cx="18.5" cy="5.5" r="1"/><circle cx="5.5" cy="12" r="1"/><circle cx="12" cy="12" r="1"/><circle cx="18.5" cy="12" r="1"/><circle cx="5.5" cy="18.5" r="1"/><circle cx="12" cy="18.5" r="1"/><circle cx="18.5" cy="18.5" r="1"/></svg></button>' }, close: { tpl: '<button class="f-button" title="{{CLOSE}}" data-fancybox-close><svg><path d="m19.5 4.5-15 15M4.5 4.5l15 15"/></svg></button>' } }, parentEl: null }, Mt = { tabindex: "-1", width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" };
      class Tt extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: Pt.Init }), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: null });
        }
        onReady(t2) {
          var e2;
          if (!t2.carousel)
            return;
          let i2 = this.option("display"), n2 = this.option("absolute"), s2 = this.option("enabled");
          if ("auto" === s2) {
            const t3 = this.instance.carousel;
            let e3 = 0;
            if (t3)
              for (const i3 of t3.slides)
                (i3.panzoom || "image" === i3.type) && e3++;
            e3 || (s2 = false);
          }
          s2 || (i2 = void 0);
          let o2 = 0;
          const a2 = { left: [], middle: [], right: [] };
          if (i2)
            for (const t3 of ["left", "middle", "right"])
              for (const n3 of i2[t3]) {
                const i3 = this.createEl(n3);
                i3 && (null === (e2 = a2[t3]) || void 0 === e2 || e2.push(i3), o2++);
              }
          let r2 = null;
          if (o2 && (r2 = this.createContainer()), r2) {
            for (const [t3, e3] of Object.entries(a2)) {
              const i3 = document.createElement("div");
              S(i3, "fancybox__toolbar__column is-" + t3);
              for (const t4 of e3)
                i3.appendChild(t4);
              "auto" !== n2 || "middle" !== t3 || e3.length || (n2 = true), r2.appendChild(i3);
            }
            true === n2 && S(r2, "is-absolute"), this.state = Pt.Ready, this.onRefresh();
          } else
            this.state = Pt.Disabled;
        }
        onClick(t2) {
          var e2, i2;
          const n2 = this.instance, s2 = n2.getSlide(), o2 = null == s2 ? void 0 : s2.panzoom, a2 = t2.target, r2 = a2 && x(a2) ? a2.dataset : null;
          if (!r2)
            return;
          if (void 0 !== r2.fancyboxToggleThumbs)
            return t2.preventDefault(), t2.stopPropagation(), void (null === (e2 = n2.plugins.Thumbs) || void 0 === e2 || e2.toggle());
          if (void 0 !== r2.fancyboxToggleFullscreen)
            return t2.preventDefault(), t2.stopPropagation(), void this.instance.toggleFullscreen();
          if (void 0 !== r2.fancyboxToggleSlideshow) {
            t2.preventDefault(), t2.stopPropagation();
            const e3 = null === (i2 = n2.carousel) || void 0 === i2 ? void 0 : i2.plugins.Autoplay;
            let s3 = e3.isActive;
            return o2 && "mousemove" === o2.panMode && !s3 && o2.reset(), void (s3 ? e3.stop() : e3.start());
          }
          const l2 = r2.panzoomAction, c2 = r2.panzoomChange;
          if ((c2 || l2) && (t2.preventDefault(), t2.stopPropagation()), c2) {
            let t3 = {};
            try {
              t3 = JSON.parse(c2);
            } catch (t4) {
            }
            o2 && o2.applyChange(t3);
          } else
            l2 && o2 && o2[l2] && o2[l2]();
        }
        onChange() {
          this.onRefresh();
        }
        onRefresh() {
          if (this.instance.isClosing())
            return;
          const t2 = this.container;
          if (!t2)
            return;
          const e2 = this.instance.getSlide();
          if (!e2 || e2.state !== it.Ready)
            return;
          const i2 = e2 && !e2.error && e2.panzoom;
          for (const e3 of t2.querySelectorAll("[data-panzoom-action]"))
            i2 ? (e3.removeAttribute("disabled"), e3.removeAttribute("tabindex")) : (e3.setAttribute("disabled", ""), e3.setAttribute("tabindex", "-1"));
          let n2 = i2 && i2.canZoomIn(), s2 = i2 && i2.canZoomOut();
          for (const e3 of t2.querySelectorAll('[data-panzoom-action="zoomIn"]'))
            n2 ? (e3.removeAttribute("disabled"), e3.removeAttribute("tabindex")) : (e3.setAttribute("disabled", ""), e3.setAttribute("tabindex", "-1"));
          for (const e3 of t2.querySelectorAll('[data-panzoom-action="zoomOut"]'))
            s2 ? (e3.removeAttribute("disabled"), e3.removeAttribute("tabindex")) : (e3.setAttribute("disabled", ""), e3.setAttribute("tabindex", "-1"));
          for (const e3 of t2.querySelectorAll('[data-panzoom-action="toggleZoom"],[data-panzoom-action="iterateZoom"]')) {
            s2 || n2 ? (e3.removeAttribute("disabled"), e3.removeAttribute("tabindex")) : (e3.setAttribute("disabled", ""), e3.setAttribute("tabindex", "-1"));
            const t3 = e3.querySelector("g");
            t3 && (t3.style.display = n2 ? "" : "none");
          }
        }
        onDone(t2, e2) {
          var i2;
          null === (i2 = e2.panzoom) || void 0 === i2 || i2.on("afterTransform", () => {
            this.instance.isCurrentSlide(e2) && this.onRefresh();
          }), this.instance.isCurrentSlide(e2) && this.onRefresh();
        }
        createContainer() {
          const t2 = this.instance.container;
          if (!t2)
            return null;
          const e2 = this.option("parentEl") || t2, i2 = document.createElement("div");
          return S(i2, "fancybox__toolbar"), e2.prepend(i2), i2.addEventListener("click", this.onClick, { passive: false, capture: true }), t2 && S(t2, "has-toolbar"), this.container = i2, i2;
        }
        createEl(t2) {
          const e2 = this.instance, i2 = e2.carousel;
          if (!i2)
            return null;
          if ("toggleFS" === t2)
            return null;
          if ("fullscreen" === t2 && !e2.fsAPI)
            return null;
          let s2 = null;
          const o2 = i2.slides.length || 0;
          let a2 = 0, r2 = 0;
          for (const t3 of i2.slides)
            (t3.panzoom || "image" === t3.type) && a2++, ("image" === t3.type || t3.downloadSrc) && r2++;
          if (o2 < 2 && ["infobar", "prev", "next"].includes(t2))
            return s2;
          if (void 0 !== St[t2] && !a2)
            return null;
          if ("download" === t2 && !r2)
            return null;
          if ("thumbs" === t2) {
            const t3 = e2.plugins.Thumbs;
            if (!t3 || !t3.isEnabled)
              return null;
          }
          if ("slideshow" === t2) {
            if (!i2.plugins.Autoplay || o2 < 2)
              return null;
          }
          if (void 0 !== St[t2]) {
            const e3 = St[t2];
            s2 = document.createElement("button"), s2.setAttribute("title", this.instance.localize(`{{${t2.toUpperCase()}}}`)), S(s2, "f-button"), e3.action && (s2.dataset.panzoomAction = e3.action), e3.change && (s2.dataset.panzoomChange = JSON.stringify(e3.change)), s2.appendChild(n(this.instance.localize(e3.icon)));
          } else {
            const e3 = (this.option("items") || [])[t2];
            e3 && (s2 = n(this.instance.localize(e3.tpl)), "function" == typeof e3.click && s2.addEventListener("click", (t3) => {
              t3.preventDefault(), t3.stopPropagation(), "function" == typeof e3.click && e3.click.call(this, this, t3);
            }));
          }
          const l2 = null == s2 ? void 0 : s2.querySelector("svg");
          if (l2)
            for (const [t3, e3] of Object.entries(Mt))
              l2.getAttribute(t3) || l2.setAttribute(t3, String(e3));
          return s2;
        }
        removeContainer() {
          const t2 = this.container;
          t2 && t2.remove(), this.container = null, this.state = Pt.Disabled;
          const e2 = this.instance.container;
          e2 && E(e2, "has-toolbar");
        }
        attach() {
          const t2 = this, e2 = t2.instance;
          e2.on("Carousel.initSlides", t2.onReady), e2.on("done", t2.onDone), e2.on("reveal", t2.onChange), e2.on("Carousel.change", t2.onChange), t2.onReady(t2.instance);
        }
        detach() {
          const t2 = this, e2 = t2.instance;
          e2.off("Carousel.initSlides", t2.onReady), e2.off("done", t2.onDone), e2.off("reveal", t2.onChange), e2.off("Carousel.change", t2.onChange), t2.removeContainer();
        }
      }
      Object.defineProperty(Tt, "defaults", { enumerable: true, configurable: true, writable: true, value: Ct });
      const Ot = { Hash: st, Html: ht, Images: at, Slideshow: mt, Thumbs: Et, Toolbar: Tt }, At = "with-fancybox", zt = "hide-scrollbar", Lt = "--fancybox-scrollbar-compensate", Rt = "--fancybox-body-margin", kt = "is-animated", It = "is-compact", Dt = "is-loading", Ft = function() {
        var t2 = window.getSelection();
        return t2 && "Range" === t2.type;
      };
      let jt = null, Ht = null;
      const Bt = /* @__PURE__ */ new Map();
      let Nt = 0;
      class _t extends m {
        get isIdle() {
          return this.idle;
        }
        get isCompact() {
          return this.option("compact");
        }
        constructor(t2 = [], e2 = {}, i2 = {}) {
          super(e2), Object.defineProperty(this, "userSlides", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "userPlugins", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "idle", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "idleTimer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "clickTimer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "pwt", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "ignoreFocusChange", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: et.Init }), Object.defineProperty(this, "id", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "footer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "carousel", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "lastFocus", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "prevMouseMoveEvent", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "fsAPI", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.fsAPI = (() => {
            let t3, e3 = "", i3 = "", n2 = "";
            return document.fullscreenEnabled ? (e3 = "requestFullscreen", i3 = "exitFullscreen", n2 = "fullscreenElement") : document.webkitFullscreenEnabled && (e3 = "webkitRequestFullscreen", i3 = "webkitExitFullscreen", n2 = "webkitFullscreenElement"), e3 && (t3 = { request: function(t4) {
              return "webkitRequestFullscreen" === e3 ? t4[e3](Element.ALLOW_KEYBOARD_INPUT) : t4[e3]();
            }, exit: function() {
              return document[n2] && document[i3]();
            }, isFullscreen: function() {
              return document[n2];
            } }), t3;
          })(), this.id = e2.id || ++Nt, Bt.set(this.id, this), this.userSlides = t2, this.userPlugins = i2, queueMicrotask(() => {
            this.init();
          });
        }
        init() {
          if (this.state === et.Destroy)
            return;
          this.state = et.Init, this.attachPlugins(Object.assign(Object.assign({}, _t.Plugins), this.userPlugins)), this.emit("init"), true === this.option("hideScrollbar") && (() => {
            if (!G)
              return;
            const t3 = document.body;
            if (t3.classList.contains(zt))
              return;
            let e3 = window.innerWidth - document.documentElement.getBoundingClientRect().width;
            e3 < 0 && (e3 = 0);
            const i2 = t3.currentStyle || window.getComputedStyle(t3), n2 = parseFloat(i2.marginRight);
            document.documentElement.style.setProperty(Lt, `${e3}px`), n2 && t3.style.setProperty(Rt, `${n2}px`), t3.classList.add(zt);
          })(), this.initLayout(), this.scale();
          const t2 = () => {
            this.initCarousel(this.userSlides), this.state = et.Ready, this.attachEvents(), this.emit("ready"), setTimeout(() => {
              this.container && this.container.setAttribute("aria-hidden", "false");
            }, 16);
          }, e2 = this.fsAPI;
          this.option("Fullscreen.autoStart") && e2 && !e2.isFullscreen() ? e2.request(this.container).then(() => t2()).catch(() => t2()) : t2();
        }
        initLayout() {
          var t2, e2;
          const i2 = this.option("parentEl") || document.body, s2 = n(this.localize(this.option("tpl.main") || ""));
          s2 && (s2.setAttribute("id", `fancybox-${this.id}`), s2.setAttribute("aria-label", this.localize("{{MODAL}}")), s2.classList.toggle(It, this.isCompact), S(s2, this.option("mainClass") || ""), this.container = s2, this.footer = s2.querySelector(".fancybox__footer"), i2.appendChild(s2), S(document.documentElement, At), jt && Ht || (jt = document.createElement("span"), S(jt, "fancybox-focus-guard"), jt.setAttribute("tabindex", "0"), jt.setAttribute("aria-hidden", "true"), jt.setAttribute("aria-label", "Focus guard"), Ht = jt.cloneNode(), null === (t2 = s2.parentElement) || void 0 === t2 || t2.insertBefore(jt, s2), null === (e2 = s2.parentElement) || void 0 === e2 || e2.append(Ht)), this.option("animated") && (S(s2, kt), setTimeout(() => {
            this.isClosing() || E(s2, kt);
          }, 350)), this.emit("initLayout"));
        }
        initCarousel(t2) {
          const i2 = this.container;
          if (!i2)
            return;
          const n2 = i2.querySelector(".fancybox__carousel");
          if (!n2)
            return;
          const s2 = this.carousel = new Z(n2, u({}, { slides: t2, transition: "fade", Panzoom: { lockAxis: this.option("dragToClose") ? "xy" : "x", infinite: !!this.option("dragToClose") && "y" }, Dots: false, Navigation: { classes: { container: "fancybox__nav", button: "f-button", isNext: "is-next", isPrev: "is-prev" } }, initialPage: this.option("startIndex"), l10n: this.option("l10n") }, this.option("Carousel") || {}));
          s2.on("*", (t3, e2, ...i3) => {
            this.emit(`Carousel.${e2}`, t3, ...i3);
          }), s2.on(["ready", "change"], () => {
            var t3;
            const e2 = this.getSlide();
            e2 && (null === (t3 = e2.panzoom) || void 0 === t3 || t3.updateControls()), this.manageCaption(e2);
          }), this.on("Carousel.removeSlide", (t3, e2, i3) => {
            i3.contentEl && (i3.contentEl.remove(), i3.contentEl = void 0);
            const n3 = i3.el;
            n3 && (E(n3, "has-error"), E(n3, "has-unknown"), E(n3, `has-${i3.type || "unknown"}`)), i3.closeBtnEl && i3.closeBtnEl.remove(), i3.closeBtnEl = void 0, i3.captionEl && i3.captionEl.remove(), i3.captionEl = void 0, i3.spinnerEl && i3.spinnerEl.remove(), i3.spinnerEl = void 0, i3.state = void 0;
          }), s2.on("Panzoom.touchStart", () => {
            this.isCompact || this.endIdle();
          }), s2.on("settle", () => {
            this.idleTimer || this.isCompact || !this.option("idle") || this.setIdle(), this.option("autoFocus") && this.checkFocus();
          }), this.option("dragToClose") && (s2.on("Panzoom.afterTransform", (t3, i3) => {
            const n3 = this.getSlide();
            if (n3 && e(n3.el))
              return;
            const s3 = this.container;
            if (s3) {
              const t4 = Math.abs(i3.current.f), e2 = t4 < 1 ? "" : Math.max(0.5, Math.min(1, 1 - t4 / i3.contentRect.fitHeight * 1.5));
              s3.style.setProperty("--fancybox-ts", e2 ? "0s" : ""), s3.style.setProperty("--fancybox-opacity", e2 + "");
            }
          }), s2.on("Panzoom.touchEnd", (t3, i3, n3) => {
            var s3;
            const o2 = this.getSlide();
            if (o2 && e(o2.el))
              return;
            if (i3.isMobile && document.activeElement && -1 !== ["TEXTAREA", "INPUT"].indexOf(null === (s3 = document.activeElement) || void 0 === s3 ? void 0 : s3.nodeName))
              return;
            const a2 = Math.abs(i3.dragOffset.y);
            "y" === i3.lockedAxis && (a2 >= 200 || a2 >= 50 && i3.dragOffset.time < 300) && (n3 && n3.cancelable && n3.preventDefault(), this.close(n3, "f-throwOut" + (i3.current.f < 0 ? "Up" : "Down")));
          })), s2.on("change", (t3) => {
            var e2;
            let i3 = null === (e2 = this.getSlide()) || void 0 === e2 ? void 0 : e2.triggerEl;
            if (i3) {
              const e3 = new CustomEvent("slideTo", { bubbles: true, cancelable: true, detail: t3.page });
              i3.dispatchEvent(e3);
            }
          }), s2.on(["refresh", "change"], (t3) => {
            const e2 = this.container;
            if (!e2)
              return;
            for (const i4 of e2.querySelectorAll("[data-fancybox-current-index]"))
              i4.innerHTML = t3.page + 1;
            for (const i4 of e2.querySelectorAll("[data-fancybox-count]"))
              i4.innerHTML = t3.pages.length;
            if (!t3.isInfinite) {
              for (const i4 of e2.querySelectorAll("[data-fancybox-next]"))
                t3.page < t3.pages.length - 1 ? (i4.removeAttribute("disabled"), i4.removeAttribute("tabindex")) : (i4.setAttribute("disabled", ""), i4.setAttribute("tabindex", "-1"));
              for (const i4 of e2.querySelectorAll("[data-fancybox-prev]"))
                t3.page > 0 ? (i4.removeAttribute("disabled"), i4.removeAttribute("tabindex")) : (i4.setAttribute("disabled", ""), i4.setAttribute("tabindex", "-1"));
            }
            const i3 = this.getSlide();
            if (!i3)
              return;
            let n3 = i3.downloadSrc || "";
            n3 || "image" !== i3.type || i3.error || "string" != typeof i3.src || (n3 = i3.src);
            const s3 = "disabled", o2 = "tabindex", a2 = "download", r2 = "href";
            for (const t4 of e2.querySelectorAll("[data-fancybox-download]")) {
              const e3 = i3.downloadFilename;
              n3 ? (t4.removeAttribute(s3), t4.removeAttribute(o2), t4.setAttribute(r2, n3), t4.setAttribute(a2, e3 || n3), t4.setAttribute("target", "_blank")) : (t4.setAttribute(s3, ""), t4.setAttribute(o2, "-1"), t4.removeAttribute(r2), t4.removeAttribute(a2));
            }
          }), this.emit("initCarousel");
        }
        attachEvents() {
          const t2 = this, e2 = t2.container;
          if (!e2)
            return;
          e2.addEventListener("click", t2.onClick, { passive: false, capture: false }), e2.addEventListener("wheel", t2.onWheel, { passive: false, capture: false }), document.addEventListener("keydown", t2.onKeydown, { passive: false, capture: true }), document.addEventListener("visibilitychange", t2.onVisibilityChange, false), document.addEventListener("mousemove", t2.onMousemove), t2.option("trapFocus") && document.addEventListener("focus", t2.onFocus, true), window.addEventListener("resize", t2.onResize);
          const i2 = window.visualViewport;
          i2 && (i2.addEventListener("scroll", t2.onResize), i2.addEventListener("resize", t2.onResize));
        }
        detachEvents() {
          const t2 = this, e2 = t2.container;
          if (!e2)
            return;
          document.removeEventListener("keydown", t2.onKeydown, { passive: false, capture: true }), e2.removeEventListener("wheel", t2.onWheel, { passive: false, capture: false }), e2.removeEventListener("click", t2.onClick, { passive: false, capture: false }), document.removeEventListener("mousemove", t2.onMousemove), window.removeEventListener("resize", t2.onResize);
          const i2 = window.visualViewport;
          i2 && (i2.removeEventListener("resize", t2.onResize), i2.removeEventListener("scroll", t2.onResize)), document.removeEventListener("visibilitychange", t2.onVisibilityChange, false), document.removeEventListener("focus", t2.onFocus, true);
        }
        scale() {
          const t2 = this.container;
          if (!t2)
            return;
          const e2 = window.visualViewport, i2 = Math.max(1, (null == e2 ? void 0 : e2.scale) || 1);
          let n2 = "", s2 = "", o2 = "";
          if (e2 && i2 > 1) {
            let t3 = `${e2.offsetLeft}px`, a2 = `${e2.offsetTop}px`;
            n2 = e2.width * i2 + "px", s2 = e2.height * i2 + "px", o2 = `translate3d(${t3}, ${a2}, 0) scale(${1 / i2})`;
          }
          t2.style.transform = o2, t2.style.width = n2, t2.style.height = s2;
        }
        onClick(t2) {
          var e2, i2;
          const { container: n2, isCompact: s2 } = this;
          if (!n2 || this.isClosing())
            return;
          !s2 && this.option("idle") && this.resetIdle();
          const o2 = document.activeElement;
          if (Ft() && o2 && n2.contains(o2))
            return;
          const a2 = t2.composedPath()[0];
          if (a2 === (null === (e2 = this.carousel) || void 0 === e2 ? void 0 : e2.container))
            return;
          if (a2.closest(".f-spinner") || a2.closest("[data-fancybox-close]"))
            return t2.preventDefault(), void this.close(t2);
          if (a2.closest("[data-fancybox-prev]"))
            return t2.preventDefault(), void this.prev();
          if (a2.closest("[data-fancybox-next]"))
            return t2.preventDefault(), void this.next();
          if (s2 && "image" === (null === (i2 = this.getSlide()) || void 0 === i2 ? void 0 : i2.type))
            return void (this.clickTimer ? (clearTimeout(this.clickTimer), this.clickTimer = null) : this.clickTimer = setTimeout(() => {
              this.toggleIdle(), this.clickTimer = null;
            }, 350));
          if (this.emit("click", t2), t2.defaultPrevented)
            return;
          let r2 = false;
          if (a2.closest(".fancybox__content")) {
            if (o2) {
              if (o2.closest("[contenteditable]"))
                return;
              a2.matches(J) || o2.blur();
            }
            if (Ft())
              return;
            r2 = this.option("contentClick");
          } else
            a2.closest(".fancybox__carousel") && !a2.matches(J) && (r2 = this.option("backdropClick"));
          "close" === r2 ? (t2.preventDefault(), this.close(t2)) : "next" === r2 ? (t2.preventDefault(), this.next()) : "prev" === r2 && (t2.preventDefault(), this.prev());
        }
        onWheel(t2) {
          var e2;
          let i2 = this.option("wheel", t2);
          (null === (e2 = t2.target) || void 0 === e2 ? void 0 : e2.closest(".fancybox__thumbs")) && (i2 = "slide");
          const n2 = "slide" === i2, s2 = [-t2.deltaX || 0, -t2.deltaY || 0, -t2.detail || 0].reduce(function(t3, e3) {
            return Math.abs(e3) > Math.abs(t3) ? e3 : t3;
          }), o2 = Math.max(-1, Math.min(1, s2)), a2 = Date.now();
          this.pwt && a2 - this.pwt < 300 ? n2 && t2.preventDefault() : (this.pwt = a2, this.emit("wheel", t2), t2.defaultPrevented || ("close" === i2 ? (t2.preventDefault(), this.close(t2)) : "slide" === i2 && (t2.preventDefault(), this[o2 > 0 ? "prev" : "next"]())));
        }
        onKeydown(t2) {
          if (!this.isTopmost())
            return;
          this.isCompact || !this.option("idle") || this.isClosing() || this.resetIdle();
          const e2 = t2.key, i2 = this.option("keyboard");
          if (!i2 || t2.ctrlKey || t2.altKey || t2.shiftKey)
            return;
          const n2 = t2.composedPath()[0], s2 = document.activeElement && document.activeElement.classList, o2 = s2 && s2.contains("f-button") || n2.dataset.carouselPage || n2.dataset.carouselIndex;
          if ("Escape" !== e2 && !o2 && x(n2)) {
            if (n2.isContentEditable || -1 !== ["TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(n2.nodeName))
              return;
          }
          this.emit("keydown", e2, t2);
          const a2 = i2[e2];
          "function" == typeof this[a2] && (t2.preventDefault(), this[a2]());
        }
        onResize() {
          const t2 = It, e2 = this.container;
          if (!e2)
            return;
          const i2 = this.isCompact;
          e2.classList.toggle(t2, i2), this.manageCaption(this.getSlide()), this.isCompact ? this.clearIdle() : this.endIdle(), this.scale(), this.emit("resize");
        }
        onFocus(t2) {
          this.isTopmost() && this.checkFocus(t2);
        }
        onMousemove(t2) {
          this.prevMouseMoveEvent = t2, !this.isCompact && this.option("idle") && this.resetIdle();
        }
        onVisibilityChange() {
          "visible" === document.visibilityState ? this.checkFocus() : this.endIdle();
        }
        manageCloseBtn(t2) {
          const e2 = this.optionFor(t2, "closeButton") || false;
          if ("auto" === e2) {
            const t3 = this.plugins.Toolbar;
            if (t3 && t3.state === Pt.Ready)
              return;
          }
          if (!e2)
            return;
          if (!t2.contentEl || t2.closeBtnEl)
            return;
          const i2 = this.option("tpl.closeButton");
          if (i2) {
            const e3 = n(this.localize(i2));
            t2.closeBtnEl = t2.contentEl.appendChild(e3), t2.el && S(t2.el, "has-close-btn");
          }
        }
        manageCaption(t2 = void 0) {
          var e2, i2;
          const n2 = "fancybox__caption", s2 = "has-caption", o2 = this.container;
          if (!o2)
            return;
          const a2 = this.isCompact || this.option("commonCaption"), r2 = !a2;
          if (this.caption && this.stop(this.caption), r2 && this.caption && (this.caption.remove(), this.caption = null), a2 && !this.caption)
            for (const t3 of (null === (e2 = this.carousel) || void 0 === e2 ? void 0 : e2.slides) || [])
              t3.captionEl && (t3.captionEl.remove(), t3.captionEl = void 0, E(t3.el, s2), null === (i2 = t3.el) || void 0 === i2 || i2.removeAttribute("aria-labelledby"));
          if (t2 || (t2 = this.getSlide()), !t2 || a2 && !this.isCurrentSlide(t2))
            return;
          const l2 = t2.el;
          let c2 = this.optionFor(t2, "caption", "");
          if ("string" != typeof c2 || !c2.length)
            return void (a2 && this.caption && this.animate(this.caption, "f-fadeOut", () => {
              this.caption && (this.caption.innerHTML = "");
            }));
          let h2 = null;
          if (r2) {
            if (h2 = t2.captionEl || null, l2 && !h2) {
              const e3 = n2 + `_${this.id}_${t2.index}`;
              h2 = document.createElement("div"), S(h2, n2), h2.setAttribute("id", e3), t2.captionEl = l2.appendChild(h2), S(l2, s2), l2.setAttribute("aria-labelledby", e3);
            }
          } else {
            if (h2 = this.caption, h2 || (h2 = o2.querySelector("." + n2)), !h2) {
              h2 = document.createElement("div"), h2.dataset.fancyboxCaption = "", S(h2, n2), h2.innerHTML = c2;
              (this.footer || o2).prepend(h2);
            }
            S(o2, s2), this.caption = h2;
          }
          h2 && (h2.innerHTML = c2);
        }
        checkFocus(t2) {
          var e2;
          const i2 = document.activeElement || null;
          i2 && (null === (e2 = this.container) || void 0 === e2 ? void 0 : e2.contains(i2)) || this.focus(t2);
        }
        focus(t2) {
          var e2;
          if (this.ignoreFocusChange)
            return;
          const i2 = document.activeElement || null, n2 = (null == t2 ? void 0 : t2.target) || null, s2 = this.container, o2 = this.getSlide();
          if (!s2 || !(null === (e2 = this.carousel) || void 0 === e2 ? void 0 : e2.viewport))
            return;
          if (!t2 && i2 && s2.contains(i2))
            return;
          const a2 = o2 && o2.state === it.Ready ? o2.el : null;
          if (!a2 || a2.contains(i2) || s2 === i2)
            return;
          t2 && t2.cancelable && t2.preventDefault(), this.ignoreFocusChange = true;
          const r2 = Array.from(s2.querySelectorAll(J));
          let l2 = [], c2 = null;
          for (let t3 of r2) {
            const e3 = !t3.offsetParent || t3.closest('[aria-hidden="true"]'), i3 = a2 && a2.contains(t3), n3 = !this.carousel.viewport.contains(t3);
            if (t3 === s2 || (i3 || n3) && !e3) {
              l2.push(t3);
              const e4 = t3.dataset.origTabindex;
              void 0 !== e4 && e4 && (t3.tabIndex = parseFloat(e4)), t3.removeAttribute("data-orig-tabindex"), !t3.hasAttribute("autoFocus") && c2 || (c2 = t3);
            } else {
              const e4 = void 0 === t3.dataset.origTabindex ? t3.getAttribute("tabindex") || "" : t3.dataset.origTabindex;
              e4 && (t3.dataset.origTabindex = e4), t3.tabIndex = -1;
            }
          }
          let h2 = null;
          t2 ? (!n2 || l2.indexOf(n2) < 0) && (h2 = c2 || s2, l2.length && (i2 === Ht ? h2 = l2[0] : this.lastFocus !== s2 && i2 !== jt || (h2 = l2[l2.length - 1]))) : h2 = o2 && "image" === o2.type ? s2 : c2 || s2, h2 && Q(h2), this.lastFocus = document.activeElement, this.ignoreFocusChange = false;
        }
        next() {
          const t2 = this.carousel;
          t2 && t2.pages.length > 1 && t2.slideNext();
        }
        prev() {
          const t2 = this.carousel;
          t2 && t2.pages.length > 1 && t2.slidePrev();
        }
        jumpTo(...t2) {
          this.carousel && this.carousel.slideTo(...t2);
        }
        isTopmost() {
          var t2;
          return (null === (t2 = _t.getInstance()) || void 0 === t2 ? void 0 : t2.id) == this.id;
        }
        animate(t2 = null, e2 = "", i2) {
          if (!t2 || !e2)
            return void (i2 && i2());
          this.stop(t2);
          const n2 = (s2) => {
            s2.target === t2 && t2.dataset.animationName && (t2.removeEventListener("animationend", n2), delete t2.dataset.animationName, i2 && i2(), E(t2, e2));
          };
          t2.dataset.animationName = e2, t2.addEventListener("animationend", n2), S(t2, e2);
        }
        stop(t2) {
          t2 && t2.dispatchEvent(new CustomEvent("animationend", { bubbles: false, cancelable: true, currentTarget: t2 }));
        }
        setContent(t2, e2 = "", i2 = true) {
          if (this.isClosing())
            return;
          const s2 = t2.el;
          if (!s2)
            return;
          let o2 = null;
          if (x(e2) ? o2 = e2 : (o2 = n(e2 + ""), x(o2) || (o2 = document.createElement("div"), o2.innerHTML = e2 + "")), ["img", "picture", "iframe", "video", "audio"].includes(o2.nodeName.toLowerCase())) {
            const t3 = document.createElement("div");
            t3.appendChild(o2), o2 = t3;
          }
          x(o2) && t2.filter && !t2.error && (o2 = o2.querySelector(t2.filter)), o2 && x(o2) ? (S(o2, "fancybox__content"), t2.id && o2.setAttribute("id", t2.id), "none" !== o2.style.display && "none" !== getComputedStyle(o2).getPropertyValue("display") || (o2.style.display = t2.display || this.option("defaultDisplay") || "flex"), s2.classList.add(`has-${t2.error ? "error" : t2.type || "unknown"}`), s2.prepend(o2), t2.contentEl = o2, i2 && this.revealContent(t2), this.manageCloseBtn(t2), this.manageCaption(t2)) : this.setError(t2, "{{ELEMENT_NOT_FOUND}}");
        }
        revealContent(t2, e2) {
          const i2 = t2.el, n2 = t2.contentEl;
          i2 && n2 && (this.emit("reveal", t2), this.hideLoading(t2), t2.state = it.Opening, (e2 = this.isOpeningSlide(t2) ? void 0 === e2 ? this.optionFor(t2, "showClass") : e2 : "f-fadeIn") ? this.animate(n2, e2, () => {
            this.done(t2);
          }) : this.done(t2));
        }
        done(t2) {
          this.isClosing() || (t2.state = it.Ready, this.emit("done", t2), S(t2.el, "is-done"), this.isCurrentSlide(t2) && this.option("autoFocus") && queueMicrotask(() => {
            this.option("autoFocus") && (this.option("autoFocus") ? this.focus() : this.checkFocus());
          }), this.isOpeningSlide(t2) && !this.isCompact && this.option("idle") && this.setIdle());
        }
        isCurrentSlide(t2) {
          const e2 = this.getSlide();
          return !(!t2 || !e2) && e2.index === t2.index;
        }
        isOpeningSlide(t2) {
          var e2, i2;
          return null === (null === (e2 = this.carousel) || void 0 === e2 ? void 0 : e2.prevPage) && t2.index === (null === (i2 = this.getSlide()) || void 0 === i2 ? void 0 : i2.index);
        }
        showLoading(t2) {
          t2.state = it.Loading;
          const e2 = t2.el;
          if (!e2)
            return;
          S(e2, Dt), this.emit("loading", t2), t2.spinnerEl || setTimeout(() => {
            if (!this.isClosing() && !t2.spinnerEl && t2.state === it.Loading) {
              let i2 = n(w);
              t2.spinnerEl = i2, e2.prepend(i2), this.animate(i2, "f-fadeIn");
            }
          }, 250);
        }
        hideLoading(t2) {
          const e2 = t2.el;
          if (!e2)
            return;
          const i2 = t2.spinnerEl;
          this.isClosing() ? null == i2 || i2.remove() : (E(e2, Dt), i2 && this.animate(i2, "f-fadeOut", () => {
            i2.remove();
          }), t2.state === it.Loading && (this.emit("loaded", t2), t2.state = it.Ready));
        }
        setError(t2, e2) {
          if (this.isClosing())
            return;
          const i2 = new Event("error", { bubbles: true, cancelable: true });
          if (this.emit("error", i2, t2), i2.defaultPrevented)
            return;
          t2.error = e2, this.hideLoading(t2), this.clearContent(t2);
          const n2 = document.createElement("div");
          n2.classList.add("fancybox-error"), n2.innerHTML = this.localize(e2 || "<p>{{ERROR}}</p>"), this.setContent(t2, n2);
        }
        clearContent(t2) {
          var e2;
          null === (e2 = this.carousel) || void 0 === e2 || e2.emit("removeSlide", t2);
        }
        getSlide() {
          var t2;
          const e2 = this.carousel;
          return (null === (t2 = null == e2 ? void 0 : e2.pages[null == e2 ? void 0 : e2.page]) || void 0 === t2 ? void 0 : t2.slides[0]) || void 0;
        }
        close(t2, e2) {
          if (this.isClosing())
            return;
          const i2 = new Event("shouldClose", { bubbles: true, cancelable: true });
          if (this.emit("shouldClose", i2, t2), i2.defaultPrevented)
            return;
          t2 && t2.cancelable && (t2.preventDefault(), t2.stopPropagation());
          const n2 = this.fsAPI, s2 = () => {
            this.proceedClose(t2, e2);
          };
          n2 && n2.isFullscreen() ? Promise.resolve(n2.exit()).then(() => s2()) : s2();
        }
        clearIdle() {
          this.idleTimer && clearTimeout(this.idleTimer), this.idleTimer = null;
        }
        setIdle(t2 = false) {
          const e2 = () => {
            this.clearIdle(), this.idle = true, S(this.container, "is-idle"), this.emit("setIdle");
          };
          if (this.clearIdle(), !this.isClosing())
            if (t2)
              e2();
            else {
              const t3 = this.option("idle");
              t3 && (this.idleTimer = setTimeout(e2, t3));
            }
        }
        endIdle() {
          this.clearIdle(), this.idle && !this.isClosing() && (this.idle = false, E(this.container, "is-idle"), this.emit("endIdle"));
        }
        resetIdle() {
          this.endIdle(), this.setIdle();
        }
        toggleIdle() {
          this.idle ? this.endIdle() : this.setIdle(true);
        }
        toggleFullscreen() {
          const t2 = this.fsAPI;
          t2 && (t2.isFullscreen() ? t2.exit() : this.container && t2.request(this.container));
        }
        isClosing() {
          return [et.Closing, et.CustomClosing, et.Destroy].includes(this.state);
        }
        proceedClose(t2, e2) {
          var i2, n2;
          this.state = et.Closing, this.clearIdle(), this.detachEvents();
          const s2 = this.container, o2 = this.carousel, a2 = this.getSlide(), r2 = a2 && this.option("placeFocusBack") ? a2.triggerEl || this.option("triggerEl") : null;
          if (r2 && (U(r2) ? Q(r2) : r2.focus()), s2 && (S(s2, "is-closing"), s2.setAttribute("aria-hidden", "true"), this.option("animated") && S(s2, kt), s2.style.pointerEvents = "none"), o2) {
            o2.clearTransitions(), null === (i2 = o2.panzoom) || void 0 === i2 || i2.destroy(), null === (n2 = o2.plugins.Navigation) || void 0 === n2 || n2.detach();
            for (const t3 of o2.slides) {
              t3.state = it.Closing, this.hideLoading(t3);
              const e3 = t3.contentEl;
              e3 && this.stop(e3);
              const i3 = null == t3 ? void 0 : t3.panzoom;
              i3 && (i3.stop(), i3.detachEvents(), i3.detachObserver()), this.isCurrentSlide(t3) || o2.emit("removeSlide", t3);
            }
          }
          this.emit("close", t2), this.state !== et.CustomClosing ? (void 0 === e2 && a2 && (e2 = this.optionFor(a2, "hideClass")), e2 && a2 ? (this.animate(a2.contentEl, e2, () => {
            o2 && o2.emit("removeSlide", a2);
          }), setTimeout(() => {
            this.destroy();
          }, 500)) : this.destroy()) : setTimeout(() => {
            this.destroy();
          }, 500);
        }
        destroy() {
          var t2;
          if (this.state === et.Destroy)
            return;
          this.state = et.Destroy, null === (t2 = this.carousel) || void 0 === t2 || t2.destroy();
          const e2 = this.container;
          e2 && e2.remove(), Bt.delete(this.id);
          const i2 = _t.getInstance();
          i2 ? i2.focus() : (jt && (jt.remove(), jt = null), Ht && (Ht.remove(), Ht = null), E(document.documentElement, At), (() => {
            if (!G)
              return;
            const t3 = document, e3 = t3.body;
            e3.classList.remove(zt), e3.style.setProperty(Rt, ""), t3.documentElement.style.setProperty(Lt, "");
          })(), this.emit("destroy"));
        }
        static bind(t2, e2, i2) {
          if (!G)
            return;
          let n2, s2 = "", o2 = {};
          if (void 0 === t2 ? n2 = document.body : "string" == typeof t2 ? (n2 = document.body, s2 = t2, "object" == typeof e2 && (o2 = e2 || {})) : (n2 = t2, "string" == typeof e2 && (s2 = e2), "object" == typeof i2 && (o2 = i2 || {})), !n2 || !x(n2))
            return;
          s2 = s2 || "[data-fancybox]";
          const a2 = _t.openers.get(n2) || /* @__PURE__ */ new Map();
          a2.set(s2, o2), _t.openers.set(n2, a2), 1 === a2.size && n2.addEventListener("click", _t.fromEvent);
        }
        static unbind(t2, e2) {
          let i2, n2 = "";
          if ("string" == typeof t2 ? (i2 = document.body, n2 = t2) : (i2 = t2, "string" == typeof e2 && (n2 = e2)), !i2)
            return;
          const s2 = _t.openers.get(i2);
          s2 && n2 && s2.delete(n2), n2 && s2 || (_t.openers.delete(i2), i2.removeEventListener("click", _t.fromEvent));
        }
        static destroy() {
          let t2;
          for (; t2 = _t.getInstance(); )
            t2.destroy();
          for (const t3 of _t.openers.keys())
            t3.removeEventListener("click", _t.fromEvent);
          _t.openers = /* @__PURE__ */ new Map();
        }
        static fromEvent(t2) {
          if (t2.defaultPrevented)
            return;
          if (t2.button && 0 !== t2.button)
            return;
          if (t2.ctrlKey || t2.metaKey || t2.shiftKey)
            return;
          let e2 = t2.composedPath()[0];
          const i2 = e2.closest("[data-fancybox-trigger]");
          if (i2) {
            const t3 = i2.dataset.fancyboxTrigger || "", n3 = document.querySelectorAll(`[data-fancybox="${t3}"]`), s3 = parseInt(i2.dataset.fancyboxIndex || "", 10) || 0;
            e2 = n3[s3] || e2;
          }
          if (!(e2 && e2 instanceof Element))
            return;
          let n2, s2, o2, a2;
          if ([..._t.openers].reverse().find(([t3, i3]) => !(!t3.contains(e2) || ![...i3].reverse().find(([i4, r3]) => {
            let l3 = e2.closest(i4);
            return !!l3 && (n2 = t3, s2 = i4, o2 = l3, a2 = r3, true);
          }))), !n2 || !s2 || !o2)
            return;
          a2 = a2 || {}, t2.preventDefault(), e2 = o2;
          let r2 = [], l2 = u({}, tt, a2);
          l2.event = t2, l2.triggerEl = e2, l2.delegate = i2;
          const c2 = l2.groupAll, h2 = l2.groupAttr, d2 = h2 && e2 ? e2.getAttribute(`${h2}`) : "";
          if ((!e2 || d2 || c2) && (r2 = [].slice.call(n2.querySelectorAll(s2))), e2 && !c2 && (r2 = d2 ? r2.filter((t3) => t3.getAttribute(`${h2}`) === d2) : [e2]), !r2.length)
            return;
          const p2 = _t.getInstance();
          return p2 && p2.options.triggerEl && r2.indexOf(p2.options.triggerEl) > -1 ? void 0 : (e2 && (l2.startIndex = r2.indexOf(e2)), _t.fromNodes(r2, l2));
        }
        static fromSelector(t2, e2) {
          let i2 = null, n2 = "";
          if ("string" == typeof t2 ? (i2 = document.body, n2 = t2) : t2 instanceof HTMLElement && "string" == typeof e2 && (i2 = t2, n2 = e2), !i2 || !n2)
            return false;
          const s2 = _t.openers.get(i2);
          if (!s2)
            return false;
          const o2 = s2.get(n2);
          return !!o2 && _t.fromNodes(Array.from(i2.querySelectorAll(n2)), o2);
        }
        static fromNodes(t2, e2) {
          e2 = u({}, tt, e2 || {});
          const i2 = [];
          for (const n2 of t2) {
            const t3 = n2.dataset || {}, s2 = t3.src || n2.getAttribute("href") || n2.getAttribute("currentSrc") || n2.getAttribute("src") || void 0;
            let o2;
            const a2 = e2.delegate;
            let r2;
            a2 && i2.length === e2.startIndex && (o2 = a2 instanceof HTMLImageElement ? a2 : a2.querySelector("img:not([aria-hidden])")), o2 || (o2 = n2 instanceof HTMLImageElement ? n2 : n2.querySelector("img:not([aria-hidden])")), o2 && (r2 = o2.currentSrc || o2.src || void 0, !r2 && o2.dataset && (r2 = o2.dataset.lazySrc || o2.dataset.src || void 0));
            const l2 = { src: s2, triggerEl: n2, thumbEl: o2, thumbElSrc: r2, thumbSrc: r2 };
            for (const e3 in t3)
              l2[e3] = t3[e3] + "";
            i2.push(l2);
          }
          return new _t(i2, e2);
        }
        static getInstance(t2) {
          if (t2)
            return Bt.get(t2);
          return Array.from(Bt.values()).reverse().find((t3) => !t3.isClosing() && t3) || null;
        }
        static getSlide() {
          var t2;
          return (null === (t2 = _t.getInstance()) || void 0 === t2 ? void 0 : t2.getSlide()) || null;
        }
        static show(t2 = [], e2 = {}) {
          return new _t(t2, e2);
        }
        static next() {
          const t2 = _t.getInstance();
          t2 && t2.next();
        }
        static prev() {
          const t2 = _t.getInstance();
          t2 && t2.prev();
        }
        static close(t2 = true, ...e2) {
          if (t2)
            for (const t3 of Bt.values())
              t3.close(...e2);
          else {
            const t3 = _t.getInstance();
            t3 && t3.close(...e2);
          }
        }
      }
      Object.defineProperty(_t, "version", { enumerable: true, configurable: true, writable: true, value: "5.0.20" }), Object.defineProperty(_t, "defaults", { enumerable: true, configurable: true, writable: true, value: tt }), Object.defineProperty(_t, "Plugins", { enumerable: true, configurable: true, writable: true, value: Ot }), Object.defineProperty(_t, "openers", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Map() });
      const _MatchRule = class _MatchRule {
        constructor(rule, status) {
          //* 计数器
          //* 主要数据枚举
          __publicField(this, "enumMainKey", ["main", "domItem", "linkUrl", "picUrl", "name", "meta"]);
          __publicField(this, "enumMatchItemKey", ["selector", "attribute"]);
          __publicField(this, "matchItemCount", 1);
          //* 当前匹配项条数
          __publicField(this, "id");
          __publicField(this, "main");
          __publicField(this, "domItem");
          __publicField(this, "linkUrl");
          __publicField(this, "picUrl");
          __publicField(this, "name");
          __publicField(this, "meta");
          __publicField(this, "status");
          __publicField(this, "backup");
          //f 获取当前匹配条目数量
          __publicField(this, "getMatchItemCount", () => {
            let max = 0;
            for (const key of this.enumMainKey) {
              Object.keys(this.linkUrl).forEach((item) => {
                if (this.enumMatchItemKey.includes(item)) {
                  if (max < this[key][item].length) {
                    max = this[key][item].length;
                  }
                }
              });
            }
            return max;
          });
          //f 创建备份
          __publicField(this, "createBackup", () => {
            this.backup = {};
            for (const key of this.enumMainKey) {
              this.backup[key] = JSON.parse(JSON.stringify(this[key]));
            }
          });
          //f 删除备份
          __publicField(this, "removeBackup", () => {
            this.backup = {};
          });
          //f 通过备份还原
          __publicField(this, "restoreByBackup", () => {
            if (this.backup != void 0) {
              for (const key of this.enumMainKey) {
                this[key] = JSON.parse(JSON.stringify(this.backup[key]));
              }
            }
          });
          //f 生成JSON数据(用于存储)
          __publicField(this, "getJsonData", () => {
            const jsonObj = {
              id: this.id,
              main: this.main,
              domItem: this.domItem,
              linkUrl: this.linkUrl,
              picUrl: this.picUrl,
              name: this.name,
              meta: this.meta
            };
            return JSON.stringify(jsonObj);
          });
          //f 生成uuid
          __publicField(this, "buildUUID", () => {
            const hexList = [];
            for (let i2 = 0; i2 <= 15; i2++) {
              hexList[i2] = i2.toString(16);
            }
            let uuid = "";
            for (let i2 = 1; i2 <= 36; i2++) {
              if (i2 === 9 || i2 === 14 || i2 === 19 || i2 === 24) {
                uuid += "-";
              } else if (i2 === 15) {
                uuid += 4;
              } else if (i2 === 20) {
                uuid += hexList[Math.random() * 4 | 8];
              } else {
                uuid += hexList[Math.random() * 16 | 0];
              }
            }
            return uuid.replace(/-/g, "");
          });
          var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t2, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J;
          _MatchRule.count++;
          this.id = (rule == null ? void 0 : rule.id) || (() => this.buildUUID())();
          this.main = {
            name: ((_a2 = rule == null ? void 0 : rule.main) == null ? void 0 : _a2.name) || "新规则",
            domainName: ((_b = rule == null ? void 0 : rule.main) == null ? void 0 : _b.domainName) || "",
            pathFilter: {
              pattern: ((_d = (_c = rule == null ? void 0 : rule.main) == null ? void 0 : _c.pathFilter) == null ? void 0 : _d.pattern) || "",
              flags: ((_f = (_e = rule == null ? void 0 : rule.main) == null ? void 0 : _e.pathFilter) == null ? void 0 : _f.flags) || []
            },
            titleSelector: ((_g = rule == null ? void 0 : rule.main) == null ? void 0 : _g.titleSelector) || "",
            iconUrl: ((_h = rule == null ? void 0 : rule.main) == null ? void 0 : _h.iconUrl) || ""
          };
          this.domItem = {
            enable: ((_i = rule == null ? void 0 : rule.domItem) == null ? void 0 : _i.enable) || false,
            method: ((_j = rule == null ? void 0 : rule.domItem) == null ? void 0 : _j.method) || 0,
            selector: ((_k = rule == null ? void 0 : rule.domItem) == null ? void 0 : _k.selector) || [""]
          };
          this.linkUrl = {
            method: ((_l = rule == null ? void 0 : rule.linkUrl) == null ? void 0 : _l.method) || 0,
            selector: ((_m = rule == null ? void 0 : rule.linkUrl) == null ? void 0 : _m.selector) || [""],
            infoType: ((_n = rule == null ? void 0 : rule.linkUrl) == null ? void 0 : _n.infoType) || 3,
            attribute: ((_o = rule == null ? void 0 : rule.linkUrl) == null ? void 0 : _o.attribute) || [""]
          };
          this.picUrl = {
            enable: ((_p = rule == null ? void 0 : rule.picUrl) == null ? void 0 : _p.enable) || false,
            origin: ((_q = rule == null ? void 0 : rule.picUrl) == null ? void 0 : _q.origin) || 0,
            method: ((_r = rule == null ? void 0 : rule.picUrl) == null ? void 0 : _r.method) || 0,
            selector: ((_s = rule == null ? void 0 : rule.picUrl) == null ? void 0 : _s.selector) || [""],
            infoType: ((_t2 = rule == null ? void 0 : rule.picUrl) == null ? void 0 : _t2.infoType) || 3,
            attribute: ((_u = rule == null ? void 0 : rule.picUrl) == null ? void 0 : _u.attribute) || [""]
          };
          this.name = {
            enable: ((_v = rule == null ? void 0 : rule.name) == null ? void 0 : _v.enable) || false,
            origin: ((_w = rule == null ? void 0 : rule.name) == null ? void 0 : _w.origin) || 0,
            method: ((_x = rule == null ? void 0 : rule.name) == null ? void 0 : _x.method) || 0,
            selector: ((_y = rule == null ? void 0 : rule.name) == null ? void 0 : _y.selector) || [""],
            infoType: ((_z = rule == null ? void 0 : rule.name) == null ? void 0 : _z.infoType) || 4,
            attribute: ((_A = rule == null ? void 0 : rule.name) == null ? void 0 : _A.attribute) || [""]
          };
          this.meta = {
            enable: ((_B = rule == null ? void 0 : rule.meta) == null ? void 0 : _B.enable) || true,
            origin: ((_C = rule == null ? void 0 : rule.meta) == null ? void 0 : _C.origin) || 2,
            method: ((_D = rule == null ? void 0 : rule.meta) == null ? void 0 : _D.method) || 0,
            selector: ((_E = rule == null ? void 0 : rule.meta) == null ? void 0 : _E.selector) || [""],
            infoType: ((_F = rule == null ? void 0 : rule.meta) == null ? void 0 : _F.infoType) !== void 0 ? (_G = rule == null ? void 0 : rule.meta) == null ? void 0 : _G.infoType : 0,
            attribute: ((_H = rule == null ? void 0 : rule.meta) == null ? void 0 : _H.attribute) || [""],
            getMethod: ((_I = rule == null ? void 0 : rule.meta) == null ? void 0 : _I.getMethod) !== void 0 ? (_J = rule == null ? void 0 : rule.meta) == null ? void 0 : _J.getMethod : 0
          };
          this.status = {
            editing: (status == null ? void 0 : status.editing) || false,
            //* 编辑状态标记
            isNewCreated: (status == null ? void 0 : status.isNewCreated) || false
            //* 标记是否为新创建的规则
          };
          this.backup = {};
        }
      };
      //? 静态成员
      __publicField(_MatchRule, "count", 0);
      let MatchRule = _MatchRule;
      //! Rule类的仅输入接口
      //! 输入输出接口
      var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
      var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();
      var _GM_xmlhttpRequest = /* @__PURE__ */ (() => typeof GM_xmlhttpRequest != "undefined" ? GM_xmlhttpRequest : void 0)();
      class TaskQueue {
        constructor(options) {
          __publicField(this, "max");
          __publicField(this, "initMax");
          __publicField(this, "taskList");
          __publicField(this, "showMessage");
          __publicField(this, "finallyCallback");
          this.max = (options == null ? void 0 : options.max) || 10;
          this.initMax = (options == null ? void 0 : options.max) || 10;
          this.taskList = [];
          this.showMessage = (options == null ? void 0 : options.showMessage) || false;
          this.finallyCallback = (options == null ? void 0 : options.finallyCallback) || Function();
        }
        /**
         * * 添加任务到队列
         * @param {ITask} task 任务项
         */
        addTask(task) {
          if (task) {
            this.taskList.push(task);
          }
        }
        /**
         * * push任务到队列
         * @param {ITask[]} taskList 任务项
         */
        pushTask(taskList) {
          if (taskList) {
            this.taskList.push(...taskList);
          }
        }
        //f 启动任务队列
        run() {
          const length = this.taskList.length;
          if (!length) {
            if (this.max === this.initMax) {
              this.finallyCallback();
            }
            return;
          }
          const min = Math.min(length, this.max);
          for (let i2 = 0; i2 < min; i2++) {
            const task = this.taskList.shift();
            this.max--;
            if (task && (task == null ? void 0 : task.main)) {
              task == null ? void 0 : task.main().then((res) => {
                if (this.showMessage)
                  console.log(res);
                if (task.callback) {
                  task.callback(res, task.index);
                }
              }).catch((err) => {
                if (this.showMessage)
                  console.log(err);
                if (task.callback) {
                  task.callback(err, task.index);
                }
              }).finally(() => {
                this.max++;
                this.run();
              });
            } else {
              this.max++;
              this.run();
            }
          }
        }
      }
      function getBlobByUrl(url, mode = "Fetch", referer = void 0) {
        if (isEmpty(url)) {
          return new Promise((resolve2, reject) => {
            resolve2(new Blob(void 0, { type: "none" }));
          });
        }
        if (mode === "Fetch") {
          return new Promise(async (resolve2, reject) => {
            let blob = await fetch(url).then((res) => res.blob()).catch((err) => null);
            if (blob != null) {
              console.log("Fetch成功", blob);
              resolve2(blob);
            } else {
              console.log("Fetch失败", blob);
              resolve2(new Blob(void 0, { type: "none" }));
            }
          });
        } else if (mode === "GM") {
          return new Promise(async (resolve2, reject) => {
            let headers;
            if (referer != null) {
              headers = {
                referer
              };
            }
            _GM_xmlhttpRequest({
              methods: "GET",
              url,
              responseType: "blob",
              headers,
              onload: (res) => {
                if (res.status == 200) {
                  console.log(`GM成功(referer:${referer})`, res.response, res.status);
                  resolve2(res.response);
                } else {
                  console.log(`GM失败(referer:${referer})`, res.response, res.status);
                  resolve2(new Blob(void 0, { type: "none" }));
                }
              },
              onerror: (err) => {
                resolve2(new Blob(void 0, { type: "none" }));
              },
              ontimeout: () => {
                resolve2(new Blob(void 0, { type: "none" }));
              },
              onabort: () => {
                resolve2(new Blob(void 0, { type: "none" }));
              }
            });
          });
        } else {
          return new Blob(void 0, { type: "none" });
        }
      }
      async function getBlobByUrlAuto(url) {
        if (isEmpty(url)) {
          return new Blob(void 0, { type: "none" });
        }
        let blob = new Blob(void 0, { type: "none" });
        blob = await getBlobByUrl(url, "Fetch");
        if (blob.type === "none") {
          blob = await getBlobByUrl(url, "GM");
        }
        if (blob.type === "none") {
          blob = await getBlobByUrl(url, "GM", location.origin);
        }
        return blob;
      }
      function buildUUID() {
        const hexList = [];
        for (let i2 = 0; i2 <= 15; i2++) {
          hexList[i2] = i2.toString(16);
        }
        let uuid = "";
        for (let i2 = 1; i2 <= 36; i2++) {
          if (i2 === 9 || i2 === 14 || i2 === 19 || i2 === 24) {
            uuid += "-";
          } else if (i2 === 15) {
            uuid += 4;
          } else if (i2 === 20) {
            uuid += hexList[Math.random() * 4 | 8];
          } else {
            uuid += hexList[Math.random() * 16 | 0];
          }
        }
        return uuid.replace(/-/g, "");
      }
      async function getFavicon() {
        let iconUrl;
        let urls = [...document.querySelectorAll("link[rel=icon]")].map((item) => item.href).filter((url) => /\.(png|svg|jpg|jpeg|webp|icon?)$/i.test(url));
        if (urls.length > 0) {
          iconUrl = urls[0];
        } else {
          iconUrl = `${location.origin}/favicon.ico`;
        }
        return iconUrl;
      }
      function getNameByUrl(url) {
        let list = url.match(new RegExp("(?<=\\/)([^\\/\\r\\n$]+)$", "g")) || [];
        if (list.length > 0) {
          return list[0] || url;
        } else {
          return url;
        }
      }
      function isEmpty(str = "", includeSpace = false) {
        return includeSpace ? str == null || str == void 0 || str == "" || /^ +?$/.test(str) : str == null || str == void 0 || str == "";
      }
      async function getImgMetaByBlob(blob) {
        const meta = await new Promise((resolve2, reject) => {
          let reader = new FileReader();
          reader.readAsDataURL(blob);
          reader.onload = (theFile) => {
            let image = new Image();
            image.src = theFile.target.result;
            image.onload = () => {
              resolve2({
                isOk: true,
                width: image.width,
                height: image.height,
                aspectRatio: image.width / image.height
              });
            };
            image.onerror = () => {
              reject({
                isOk: false,
                width: 0,
                height: 0
              });
            };
          };
        });
        return meta;
      }
      async function getImgMetaByImage(url) {
        if (isEmpty(url)) {
          const errMeta = {
            isOk: false,
            width: 0,
            height: 0,
            aspectRatio: 3 / 4
          };
          return errMeta;
        }
        return await new Promise((resolve2, reject) => {
          const img = new Image();
          img.src = url;
          if (img.complete) {
            resolve2({
              isOk: true,
              width: img.width,
              height: img.height,
              aspectRatio: img.width / img.height
            });
          } else {
            img.onload = () => {
              resolve2({
                isOk: true,
                width: img.width,
                height: img.height,
                aspectRatio: img.width / img.height
              });
            };
            img.onerror = () => {
              resolve2({
                isOk: false,
                width: 0,
                height: 0,
                aspectRatio: 3 / 4
              });
            };
          }
        });
      }
      async function getCardsByRule(rule, nowCount, singleCallback, finallyCallback, option) {
        var _a2, _b;
        let rowCardList = [];
        console.log("开始匹配", rule);
        if (rule.domItem.enable) {
          //! 启用了dom匹配
          for (let i2 = 0, len = rule.domItem.selector.length; i2 < len; i2++) {
            let domList = await getDom(
              document.body,
              rule.domItem.method,
              rule.domItem.selector[i2],
              0
            );
            //! 对每个dom进行结果匹配
            for (let index = 0; index < domList.length; index++) {
              let card = {
                id: buildUUID(),
                //* 生成uuid
                linkUrlType: "none",
                picUrlType: "none",
                metaOrigin: "",
                dom: domList[index]
              };
              rowCardList.push(card);
              let linkUrl_Selector = rule.linkUrl.selector[i2], picUrl_Selector = rule.picUrl.selector[i2], name_Selector = rule.name.selector[i2], meta_Selector = rule.meta.selector[i2];
              //! [匹配LinkUrl]
              card.linkUrlDom = card.dom;
              if (!isEmpty(linkUrl_Selector, true)) {
                card.linkUrlDom = await getDom(
                  card.dom,
                  rule.linkUrl.method,
                  linkUrl_Selector,
                  1
                );
              }
              //! 获取对应结果(链接)
              if (card.linkUrlDom) {
                card.linkUrl = await getTagInfo(
                  card.linkUrlDom,
                  rule.linkUrl.infoType,
                  rule.linkUrl.attribute[i2]
                );
              } else {
                card.linkUrl = "";
              }
              //! [匹配PicUrl]
              if (rule.picUrl.enable == true) {
                card.picUrlDom = card.dom;
                if (!isEmpty(picUrl_Selector, true)) {
                  if (picUrl_Selector == linkUrl_Selector) {
                    card.picUrlDom = card.linkUrlDom;
                  } else {
                    card.picUrlDom = await getDom(
                      card.dom,
                      rule.picUrl.method,
                      picUrl_Selector,
                      1
                    );
                  }
                }
                if (card.picUrlDom != null) {
                  card.picUrl = await getTagInfo(
                    card.picUrlDom,
                    rule.picUrl.infoType,
                    rule.picUrl.attribute[i2]
                  );
                  if (card.picUrl == null) {
                    card.picUrl = card.linkUrl;
                  }
                } else {
                  card.picUrl = card.linkUrl;
                }
              } else {
                card.picUrl = card.linkUrl;
                card.picUrlDom = card.linkUrlDom;
              }
              //! [匹配name]
              if (rule.name.enable == true) {
                card.nameDom = card.dom;
                if (!isEmpty(name_Selector, true)) {
                  if (name_Selector == linkUrl_Selector) {
                    card.nameDom = card.linkUrlDom;
                  } else if (name_Selector == picUrl_Selector) {
                    card.nameDom = card.picUrlDom;
                  } else {
                    card.nameDom = await getDom(
                      card.dom,
                      rule.name.method,
                      name_Selector,
                      1
                    );
                  }
                }
                if (card.nameDom) {
                  card.name = await getTagInfo(
                    card.nameDom,
                    rule.name.infoType,
                    rule.name.attribute[i2]
                  );
                  if (card.name == null) {
                    card.name = card.linkUrl;
                  }
                } else {
                  card.name = card.linkUrl;
                }
              } else {
                card.name = card.linkUrl;
                card.nameDom = card.linkUrlDom;
              }
              //! [匹配meta]
              if (rule.meta.enable == true && rule.meta.origin == 0) {
                card.metaDom = card.dom;
                if (!isEmpty(meta_Selector, true)) {
                  if (meta_Selector == linkUrl_Selector) {
                    card.metaDom = card.linkUrlDom;
                  } else if (meta_Selector == picUrl_Selector) {
                    card.metaDom = card.picUrlDom;
                  } else if (meta_Selector == name_Selector) {
                    card.metaDom = card.nameDom;
                  } else {
                    card.metaDom = await getDom(
                      card.dom,
                      rule.meta.method,
                      meta_Selector,
                      1
                    );
                  }
                }
                if (card.metaDom) {
                  card.metaOrigin = await getTagInfo(
                    card.metaDom,
                    rule.meta.infoType,
                    rule.meta.attribute[i2]
                  );
                  if (card.metaOrigin == void 0) {
                    card.metaOrigin = card.linkUrl;
                  }
                } else {
                  card.metaOrigin = card.linkUrl;
                }
              } else {
                if (rule.meta.origin == 1) {
                  card.metaDom = card.linkUrlDom;
                  card.metaOrigin = card.linkUrl;
                } else if (rule.meta.origin == 2) {
                  card.metaDom = card.picUrlDom;
                  card.metaOrigin = card.picUrl;
                } else if (rule.meta.origin == 3) {
                  card.metaDom = card.nameDom;
                  card.metaOrigin = card.name;
                }
              }
            }
          }
        } else {
          //! 未启用dom匹配
          for (let i2 = 0, len = rule.linkUrl.selector.length; i2 < len; i2++) {
            let linkUrlList_temp = [];
            let picUrlList_temp = [];
            let nameList_temp = [];
            let metaTextList_temp = [];
            //! 获取linkUrls
            let linkUrlDomList = [];
            linkUrlDomList.push(
              ...await getDom(
                document.body,
                rule.linkUrl.method,
                rule.linkUrl.selector[i2],
                0
              )
            );
            for (const linkUrlDom of linkUrlDomList) {
              if (linkUrlDom) {
                linkUrlList_temp.push(
                  await getTagInfo(
                    linkUrlDom,
                    rule.linkUrl.infoType,
                    rule.linkUrl.attribute[i2]
                  )
                );
              } else {
                linkUrlList_temp.push("");
              }
            }
            console.log(linkUrlList_temp);
            //! 获取picUrls
            let picUrlDomList = [];
            if (rule.picUrl.enable && !isEmpty(rule.picUrl.selector[i2], true)) {
              picUrlDomList.push(
                ...await getDom(
                  document.body,
                  rule.picUrl.method,
                  rule.picUrl.selector[i2],
                  0
                )
              );
              for (const picUrlDom of picUrlDomList) {
                if (picUrlDom) {
                  picUrlList_temp.push(
                    await getTagInfo(
                      picUrlDom,
                      rule.picUrl.infoType,
                      rule.picUrl.attribute[i2]
                    )
                  );
                } else {
                  picUrlList_temp.push("");
                }
              }
              picUrlList_temp = fillArrayToTargetLength(
                picUrlList_temp,
                linkUrlList_temp.length,
                ""
              );
            } else {
              picUrlList_temp = Array.from(linkUrlList_temp);
              picUrlDomList = linkUrlDomList;
            }
            //! 获取名称
            let nameDomList = [];
            if (rule.name.enable && !isEmpty(rule.name.selector[i2], true)) {
              nameDomList.push(
                ...await getDom(
                  document.body,
                  rule.name.method,
                  rule.name.selector[i2],
                  0
                )
              );
              for (const nameDom of nameDomList) {
                if (nameDom != null) {
                  nameList_temp.push(
                    await getTagInfo(
                      nameDom,
                      rule.name.infoType,
                      rule.name.attribute[i2]
                    )
                  );
                } else {
                  nameList_temp.push("");
                }
              }
              nameList_temp = fillArrayToTargetLength(
                nameList_temp,
                linkUrlList_temp.length,
                ""
              );
            } else {
              nameList_temp = Array.from(linkUrlList_temp);
              nameDomList = linkUrlDomList;
            }
            //! 获取meta
            let metaDomList = [];
            if (rule.meta.enable && rule.meta.origin == 0 && !isEmpty(rule.meta.selector[i2], true)) {
              metaDomList.push(
                ...await getDom(
                  document.body,
                  rule.meta.method,
                  rule.meta.selector[i2],
                  0
                )
              );
              for (const metaDom of metaDomList) {
                if (metaDom != null) {
                  metaTextList_temp.push(
                    await getTagInfo(
                      metaDom,
                      rule.meta.infoType,
                      rule.meta.attribute[i2]
                    )
                  );
                } else {
                  metaTextList_temp.push("");
                }
              }
              metaTextList_temp = fillArrayToTargetLength(
                metaTextList_temp,
                linkUrlList_temp.length,
                ""
              );
            } else {
              if (rule.meta.origin == 1) {
                metaTextList_temp = Array.from(linkUrlList_temp);
                metaDomList = linkUrlDomList;
              } else if (rule.meta.origin == 2) {
                metaTextList_temp = Array.from(picUrlList_temp);
                metaDomList = picUrlDomList;
              } else if (rule.meta.origin == 3) {
                metaTextList_temp = Array.from(nameList_temp);
                metaDomList = nameDomList;
              }
            }
            //! 合成一批cards
            for (let index = 0; index < linkUrlList_temp.length; index++) {
              const link = linkUrlList_temp[index];
              let card = {
                id: buildUUID(),
                //* 生成uuid
                linkUrlType: "none",
                picUrlType: "none",
                metaOrigin: ""
              };
              card.linkUrl = link;
              card.picUrl = picUrlList_temp[index];
              card.name = nameList_temp[index];
              card.metaOrigin = metaTextList_temp[index];
              card.dom = linkUrlDomList[index];
              card.linkUrlDom = linkUrlDomList[index];
              card.picUrlDom = picUrlDomList[index];
              card.nameDom = nameDomList[index];
              card.metaDom = metaDomList[index];
              rowCardList.push(card);
            }
          }
        }
        rowCardList = rowCardList.filter(
          (rowCard) => rowCard.dom && !isEmpty(rowCard.picUrl)
        );
        let processedCount = 0;
        const taskQueue = new TaskQueue({ showMessage: false, max: 10 });
        let cardList = [];
        for (let index = 0; index < rowCardList.length; index++) {
          const rowCard = rowCardList[index];
          if (!((_a2 = option == null ? void 0 : option.excludeDomSet) == null ? void 0 : _a2.has(rowCard.dom)) && !((_b = option == null ? void 0 : option.excludeUrlSet) == null ? void 0 : _b.has(rowCard.picUrl))) {
            const task = {
              index,
              main: async () => {
                const card = await singleCardProcessing(rowCard, rule);
                return card;
              },
              callback: (card, realIndex) => {
                processedCount++;
                if (singleCallback)
                  singleCallback(
                    card,
                    nowCount + realIndex,
                    processedCount,
                    rowCardList.length
                  );
                cardList.push(card);
              }
            };
            taskQueue.addTask(task);
          }
        }
        taskQueue.finallyCallback = () => {
          if (finallyCallback)
            finallyCallback(cardList, rowCardList);
        };
        taskQueue.run();
      }
      async function singleCardProcessing(rowCard, rule) {
        let card = {
          id: rowCard.id,
          name: rowCard.name || "",
          linkUrl: rowCard.linkUrl || "",
          picUrl: rowCard.picUrl || "",
          originUrls: rowCard.linkUrl ? [rowCard.linkUrl] : [],
          match: false,
          selected: false,
          metaOrigin: rowCard.metaOrigin,
          meta: {
            isOk: false,
            width: 0,
            height: 0,
            aspectRatio: 3 / 4
          },
          dom: rowCard.dom,
          linkUrlDom: rowCard.linkUrlDom,
          picUrlDom: rowCard.picUrlDom,
          nameDom: rowCard.nameDom,
          metaDom: rowCard.metaDom
        };
        //! 链接处理
        if (isUrl(card.linkUrl)) {
          card.linkUrl = urlCompletion(card.linkUrl);
        }
        if (!isEmpty(card.linkUrl))
          ;
        else {
          card.linkUrl = "";
        }
        //! 图链处理
        if (rule.picUrl.enable) {
          if (isUrl(card.picUrl)) {
            card.picUrl = urlCompletion(card.picUrl);
          }
          if (!isEmpty(card.picUrl))
            ;
          else {
            card.picUrl = card.linkUrl;
          }
        } else {
          card.picUrl = card.linkUrl;
        }
        //! 名称处理
        if (rule.name.enable) {
          if (!isEmpty(card.name))
            ;
          else {
            card.name = card.linkUrl;
          }
        } else {
          card.name = card.linkUrl;
        }
        if (isPath(card.name)) {
          card.name = getNameByUrl(card.name);
        }
        //! 元信息获取
        if (rule.meta.enable) {
          if (rule.meta.origin == 0) {
            if (card.metaDom)
              ;
          } else if (rule.meta.origin == 1) {
            if (card.linkUrlDom) {
              await getMeta(
                card.linkUrlDom,
                card.linkUrl,
                card,
                rule.meta.getMethod,
                "linkBlob"
              );
            }
          } else if (rule.meta.origin == 2) {
            if (card.picUrlDom) {
              await getMeta(
                card.picUrlDom,
                card.picUrl,
                card,
                rule.meta.getMethod,
                "picBlob"
              );
            }
          } else if (rule.meta.origin == 3) {
            if (card.nameDom) {
              await getMeta(
                card.nameDom,
                card.name,
                card,
                rule.meta.getMethod,
                "nameBlob"
              );
            }
          }
        }
        async function getMeta(dom, url, card2, getMetaMethod, blobType) {
          if (!dom)
            return;
          if (getMetaMethod === 0) {
            if (dom.tagName === "IMG") {
              const { naturalWidth, naturalHeight } = dom;
              if (naturalWidth > 0 && naturalHeight > 0) {
                card2.meta.width = naturalWidth;
                card2.meta.height = naturalHeight;
                card2.meta.isOk = true;
              } else {
                card2.meta = await getImgMetaByImage(url);
              }
            } else {
              card2[blobType] = await getBlobByUrlAuto(url);
              if (/^image/.test(card2[blobType].type)) {
                card2.meta = await getImgMetaByBlob(card2[blobType]);
              }
            }
          } else if (getMetaMethod === 1) {
            const { naturalWidth, naturalHeight } = dom;
            if (naturalWidth > 0 && naturalHeight > 0) {
              card2.meta.width = naturalWidth;
              card2.meta.height = naturalHeight;
              card2.meta.isOk = true;
            }
          } else if (getMetaMethod === 2) {
            card2.meta = await getImgMetaByImage(url);
          } else if (getMetaMethod === 3) {
            card2[blobType] = await getBlobByUrlAuto(url);
            if (/^image/.test(card2[blobType].type)) {
              card2.meta = await getImgMetaByBlob(card2[blobType]);
            }
          }
        }
        if (card.meta.isOk) {
          card.match = card.meta.isOk;
          card.meta.aspectRatio = card.meta.width / card.meta.height;
        }
        if (card.linkBlob) {
          if (!card.picBlob)
            card.picBlob = card.linkBlob;
          if (!card.nameBlob)
            card.nameBlob = card.linkBlob;
        } else if (card.picBlob) {
          if (!card.linkBlob)
            card.linkBlob = card.picBlob;
          if (!card.nameBlob)
            card.nameBlob = card.picBlob;
        } else if (card.nameBlob) {
          if (!card.linkBlob)
            card.linkBlob = card.nameBlob;
          if (!card.picBlob)
            card.picBlob = card.nameBlob;
        }
        if (card.linkBlob)
          card.linkUrlExt = getExtByBlob(card.linkBlob);
        if (card.picBlob)
          card.picUrlExt = getExtByBlob(card.picBlob);
        return card;
      }
      async function getDom(startDom, method2, selector, mode = 0) {
        let selectorList = [];
        if (/\|/.test(selector)) {
          selectorList = selector.split("|");
        } else {
          selectorList = [selector];
        }
        startDom = startDom || document.body;
        let resultDomList = [];
        if (method2 == 0) {
          for (const selectorItem of selectorList) {
            if (isEmpty(selectorItem)) {
              continue;
            }
            let tempDomList = [];
            try {
              tempDomList = [
                ...startDom.querySelectorAll(selectorItem)
              ];
            } catch (err) {
              console.log("方法getDom出错!(css选择器模式)");
            }
            resultDomList.push(...tempDomList);
          }
        } else if (method2 == 1) {
          for (const selectorItem of selectorList) {
            if (isEmpty(selectorItem)) {
              continue;
            }
            let tempDomList = [];
            try {
              tempDomList = getDomByXpath(startDom, selectorItem);
            } catch (err) {
              console.log("方法getDom出错!(xpath模式)");
            }
            resultDomList.push(...tempDomList);
          }
        }
        resultDomList = resultDomList.filter((dom) => dom);
        if (mode == 0) {
          return resultDomList;
        } else {
          if (resultDomList.length > 0) {
            return resultDomList[0];
          } else {
            return null;
          }
        }
      }
      function getDomByXpath(startDom, xpath) {
        const result = [];
        const xpathResult = document.evaluate(xpath, startDom, null, 5, null);
        let resultItem;
        while (resultItem = xpathResult.iterateNext()) {
          result.push(resultItem);
        }
        return result;
      }
      async function getTagInfo(dom, type2, attr) {
        if (type2 === 0) {
          return "";
        }
        let attrList = [];
        if (/\|/.test(attr)) {
          attrList = attr.split("|");
        } else {
          attrList = [attr];
        }
        let result = "";
        if (dom == null) {
          return result;
        }
        if (type2 == 1) {
          result = dom["value"] || "";
        } else if (type2 == 2) {
          for (let i2 = 0; i2 < attrList.length; i2++) {
            const attr2 = attrList[i2];
            let temp = dom.getAttribute(attr2);
            if (!isEmpty(temp)) {
              if (attr2 == "srcset") {
                temp = getSrcsetMaximumValue(temp);
              }
              result = temp || "";
              break;
            }
          }
        } else if (type2 == 3) {
          result = "";
          for (let i2 = 0; i2 < attrList.length; i2++) {
            const attr2 = attrList[i2];
            let temp = dom[attr2];
            if (!isEmpty(temp)) {
              if (attr2 == "srcset") {
                temp = getSrcsetMaximumValue(temp);
              }
              result = temp;
              break;
            }
          }
        } else if (type2 == 4) {
          document.createElement("div");
          result = dom.innerText;
        } else if (type2 == 5) {
          result = dom.innerHTML;
        } else if (type2 == 6) {
          result = dom.outerHTML;
        }
        if (isUrl(result)) {
          result = urlCompletion(result);
        }
        return result;
      }
      function isUrl(str) {
        var v2 = /^(\/|(.\/)).+?$/i;
        return v2.test(str);
      }
      function isPath(str) {
        return /\//i.test(str);
      }
      function getSrcsetMaximumValue(srcsetString) {
        let result = srcsetString;
        if (/\d+w/.test(srcsetString)) {
          let dataList = srcsetString.split(/\, */).filter((item) => !isEmpty(item, true)).map((item) => {
            const itemDataInfos = item.split(" ");
            if (itemDataInfos.length == 2) {
              return {
                url: itemDataInfos[0],
                resolution: Number(itemDataInfos[1].split(/w|W/)[0])
              };
            } else {
              return {
                url: itemDataInfos[0],
                resolution: 0
              };
            }
          });
          let maxItem = dataList[0];
          dataList.forEach((item) => {
            if (maxItem.resolution < item.resolution) {
              maxItem = item;
            }
          });
          result = maxItem.url;
        }
        return result;
      }
      function urlCompletion(url) {
        const v1 = /^\/[^\/].*$/i;
        const v2 = /^\/\/.*$/i;
        if (v1.test(url)) {
          return window.document.location.origin + url;
        }
        if (v2.test(url)) {
          return window.document.location.protocol + url;
        }
        return url;
      }
      function fillArrayToTargetLength(input_array = [], length, content) {
        const output_array = Array.from(input_array);
        for (let i2 = 0; i2 < length; i2++) {
          if (output_array[i2] == null) {
            output_array.push(content);
          }
        }
        return output_array;
      }
      function mixSort(_a2, _b) {
        const reg = /[a-zA-Z0-9]/;
        const a2 = _a2.toString();
        const b2 = _b.toString();
        if (reg.test(a2[0]) || reg.test(b2[0])) {
          if (a2 > b2) {
            return 1;
          } else if (a2 < b2) {
            return -1;
          } else {
            return 0;
          }
        } else {
          return a2.localeCompare(b2);
        }
      }
      function getExtByBlob(blob) {
        let match = new RegExp("(?<=\\/).+$").exec(blob.type);
        let ext = (match == null ? void 0 : match.at(0)) || "";
        if (!isEmpty(ext)) {
          ext = ext === "jpeg" ? "jpg" : ext;
        }
        return ext;
      }
      function strAutofill(str, fillContent, fill_length, direction2 = "prefix") {
        if (direction2 === "prefix") {
          return str.padStart(fill_length, fillContent.toString());
        } else {
          return str.padEnd(fill_length, fillContent.toString());
        }
      }
      function isMobile() {
        let sUserAgent = navigator.userAgent.toLowerCase();
        let regex = /ipad|iphone os|midp|rv:1.2.3.4|ucweb|android|windows ce|windows mobile/i;
        return regex.test(sUserAgent);
      }
      const useAppInfoStore = defineStore("appInfo", () => {
        const container = reactive({
          open: false,
          //* 开关标识符
          widthPercentage: 100
          //* 宽度百分比
        });
        const window2 = reactive({
          width: useWindowSize().width,
          height: useWindowSize().height
        });
        const loading2 = reactive({
          value: false,
          show: false,
          state: "",
          percentage: 0,
          //f 进度条初始化函数
          init: () => {
            loading2.value = true;
            loading2.show = true;
            loading2.percentage = 0;
            loading2.state = "";
          },
          //f 进度条重置函数
          reset: () => {
            setTimeout(() => {
              loading2.value = false;
              loading2.state = "success";
              setTimeout(() => {
                loading2.show = false;
                loading2.percentage = 0;
                loading2.state = "";
              }, 1500);
            }, 500);
          }
        });
        return { container, window: window2, loading: loading2 };
      });
      const useCardsStore = defineStore("Cards", () => {
        const appInfo = useAppInfoStore();
        const toolBar = useToolBarStore();
        useRuleEditorStore();
        const data = reactive({
          cardList: [],
          //* 卡片列表
          //f 所有匹配到的链接集合
          urlSet: /* @__PURE__ */ new Set(),
          //f 所有匹配到的dom集合
          domSet: /* @__PURE__ */ new Set()
        });
        const allValidCards = computed(() => {
          return data.cardList.filter((card) => card);
        });
        const filterCards = computed(() => {
          const filter = toolBar.filter;
          const listControl = toolBar.listControl;
          let regex = filter.formats.value.length ? new RegExp(`\\.(${filter.formats.value.join("|")})$`) : new RegExp("");
          let cardList = allValidCards.value.filter(
            (card) => card.meta.width >= filter.size.width.value[0] && card.meta.width <= filter.size.width.value[1] && card.meta.height >= filter.size.height.value[0] && card.meta.height <= filter.size.height.value[1] && regex.test(card.linkUrl)
          );
          if (listControl.sortMethod.value === "name-asc") {
            cardList = cardList.sort((a2, b2) => mixSort(a2.name, b2.name));
          } else if (listControl.sortMethod.value === "name-desc") {
            cardList = cardList.sort((a2, b2) => mixSort(b2.name, a2.name));
          } else if (listControl.sortMethod.value === "width-asc") {
            cardList = cardList.sort((a2, b2) => a2.meta.width - b2.meta.width);
          } else if (listControl.sortMethod.value === "width-desc") {
            cardList = cardList.sort((a2, b2) => b2.meta.width - a2.meta.width);
          } else if (listControl.sortMethod.value === "height-asc") {
            cardList = cardList.sort((a2, b2) => a2.meta.height - b2.meta.height);
          } else if (listControl.sortMethod.value === "height-desc") {
            cardList = cardList.sort((a2, b2) => b2.meta.height - a2.meta.height);
          }
          return cardList;
        });
        const selectedCards = computed(() => {
          return filterCards.value.filter((card) => card.selected);
        });
        const getCard = async (rule) => {
          const filter = toolBar.filter;
          appInfo.loading.init();
          const singleCallBack = (card, realIndex, processedCount, allCount) => {
            appInfo.loading.percentage = processedCount / allCount * 100;
            if (card.match && !data.urlSet.has(card.picUrl)) {
              console.log("匹配成功!", card, filter);
              data.cardList[realIndex] = card;
              data.urlSet.add(card.picUrl);
              data.domSet.add(card.dom);
              const max = filter.size.width.max = filter.size.height.max = Math.max(
                filter.size.width.max,
                filter.size.height.max,
                card.meta.width,
                card.meta.height
              );
              console.log(max);
              filter.size.width.value[1] = max;
              filter.size.height.value[1] = max;
            }
          };
          const finallyCallback = (cardList_output, rowCardList) => {
            appInfo.loading.percentage = 100;
            appInfo.loading.reset();
            if (!cardList_output.length) {
              ElMessage({
                message: "没有匹配到合适的项目(请切换/创建预设后重试)",
                type: "info",
                showClose: true,
                grouping: true,
                offset: 120
              });
            }
            data.cardList = data.cardList.filter((card) => card);
          };
          await getCardsByRule(
            rule,
            data.cardList.length,
            singleCallBack,
            finallyCallback,
            {
              excludeDomSet: data.domSet,
              excludeUrlSet: data.urlSet
            }
          );
        };
        const openFancyBox = async (startIndex = 0) => {
          const nodeList2 = filterCards.value.map((card) => card.linkUrlDom);
          _t.fromNodes(nodeList2, {
            hideScrollbar: true,
            startIndex,
            parentEl: document.querySelector(
              ".onlineGallery-child-window-container"
            ),
            groupAll: true,
            Thumbs: { type: "modern" },
            Images: {
              Panzoom: {
                maxScale: 5
              }
            },
            Toolbar: {
              display: {
                left: ["infobar"],
                middle: [
                  "zoomIn",
                  "zoomOut",
                  "toggle1to1",
                  "rotateCCW",
                  "rotateCW",
                  "flipX",
                  "flipY"
                ],
                right: ["slideshow", "download", "thumbs", "close"]
              }
            }
          });
        };
        return {
          data,
          allValidCards,
          filterCards,
          selectedCards,
          getCard,
          openFancyBox
        };
      });
      const useToolBarStore = defineStore("ToolBar", () => {
        useCardsStore();
        const ruleEditor = useRuleEditorStore();
        const filter = reactive({
          size: {
            width: {
              value: [350, 500],
              max: 500
            },
            height: {
              value: [350, 500],
              max: 500
            }
          },
          formats: {
            options: [
              { value: "png", label: "png" },
              { value: "jpg", label: "jpg" },
              { value: "jpeg", label: "jpeg" },
              { value: "gif", label: "gif" },
              { value: "bmp", label: "bmp" },
              { value: "webp", label: "webp" },
              { value: "svg", label: "svg" }
            ],
            value: ["png", "jpg", "jpeg", "gif", "webp", "bmp"]
          }
        });
        const ruleSelector = reactive({
          value: void 0,
          option: computed(() => {
            let options = [
              {
                value: "#",
                label: "(内置)默认规则",
                iconUrl: ""
              }
            ];
            options.push(
              ...ruleEditor.data.ruleList.map((rule) => {
                return {
                  value: rule.id,
                  label: rule.main.name,
                  iconUrl: rule.main.iconUrl
                };
              })
            );
            return options;
          })
        });
        const listControl = reactive({
          //* 排序方式
          sortMethod: {
            options: [
              { value: "#", label: "默认排序" },
              { value: "name-asc", label: "名称-升序" },
              { value: "name-desc", label: "名称-降序" },
              { value: "width-asc", label: "宽度-升序" },
              { value: "width-desc", label: "宽度-降序" },
              { value: "height-asc", label: "高度-升序" },
              { value: "height-desc", label: "高度-降序" }
            ],
            value: "#"
          },
          //* 显示行数
          showColumn: 3,
          allSelected: false
        });
        const selectingInitRule = () => {
          let matchedRule = ruleEditor.data.ruleList.filter((rule) => {
            return new RegExp(`${rule.main.domainName}`).test(location.origin);
          }).filter((rule) => {
            const pattern2 = rule.main.pathFilter.pattern;
            const flags = rule.main.pathFilter.flags.join("");
            return new RegExp(pattern2, flags).test(
              location.pathname + location.search
            );
          });
          if (matchedRule.length) {
            ruleSelector.value = matchedRule[0].id;
          } else {
            ruleSelector.value = "#";
          }
        };
        return { filter, listControl, ruleSelector, selectingInitRule };
      });
      const useRuleEditorStore = defineStore("ruleEditor", () => {
        const container = reactive({
          open: false
        });
        const info = reactive({
          showRuleId: "#",
          form: {
            activeName: "main",
            realTimeData: void 0
          },
          tree: {
            query: "",
            //* 查询(过滤)文本
            //* 树形列表配置信息对象
            treeProps: {
              value: "id",
              label: "label",
              children: "children",
              disabled: "disabled"
            },
            //* 树形列表数据
            treeData: computed(() => {
              let result = data.ruleList.map((rule) => {
                return {
                  id: rule.id,
                  label: rule.main.name || "未命名规则",
                  iconUrl: rule.main.iconUrl,
                  children: [],
                  disabled: false,
                  isNew: rule.status.isNewCreated
                };
              });
              result.push({
                id: "#",
                label: "创建规则",
                children: [],
                disabled: false
              });
              return result;
            })
          }
        });
        computed(() => {
          let result = data.ruleList.map((rule) => {
            return {
              id: rule.id,
              label: rule.main.name || "未命名规则",
              iconUrl: rule.main.iconUrl,
              children: [],
              disabled: false,
              isNew: rule.status.isNewCreated
            };
          });
          result.push({
            id: "#",
            label: "创建规则",
            children: [],
            disabled: false
          });
          return result;
        });
        const data = reactive({
          ruleList: []
          //* 规则列表
        });
        const getLocationRule = async () => {
          let localRuleList = _GM_getValue("ruleList");
          if (localRuleList != null) {
            data.ruleList = JSON.parse(localRuleList).map((rawRule) => {
              return new MatchRule(rawRule);
            });
            console.log("数据已导入", data);
          } else {
            data.ruleList = [];
            console.log("本地数据为空 -> 初始化数据", data);
          }
        };
        const saveRuleToLocation = async () => {
          const list = data.ruleList.map((rule) => rule.getJsonData());
          const jsonData = `[${list.join(",")}]`;
          console.log("保存数据", jsonData);
          _GM_setValue("ruleList", jsonData);
          ElMessage({
            type: "success",
            grouping: true,
            center: true,
            offset: 120,
            duration: 1e3,
            message: `保存成功!`
          });
        };
        const createRule = async () => {
          let rule = new MatchRule();
          data.ruleList.push(rule);
          rule.main.domainName = location.origin;
          rule.main.iconUrl = await getFavicon();
          console.log("规则创建", rule);
          return rule;
        };
        const deleteRule = async (id2) => {
          const index = data.ruleList.findIndex((item) => item.id === id2);
          const target = data.ruleList.splice(index, 1);
          console.log("移除规则", target);
          MatchRule.count--;
        };
        //! 默认规则
        const defaultRule = reactive({
          id: "#",
          main: {
            name: "(内置)默认规则",
            domainName: "",
            pathFilter: { pattern: "", flags: [] },
            titleSelector: "",
            iconUrl: ""
          },
          domItem: { enable: false, method: 0, selector: ["", "", "", ""] },
          linkUrl: {
            method: 0,
            selector: [
              'meta[property="og:image"]',
              "img[data-src]",
              "img[src]",
              "[srcset]"
            ],
            infoType: 2,
            attribute: [
              "content",
              "srcset|data-src|src",
              "srcset|data-src|src",
              "srcset|data-src|src"
            ]
          },
          picUrl: {
            enable: false,
            origin: 0,
            method: 0,
            selector: ["", "", "", ""],
            infoType: 3,
            attribute: ["", "", "", ""]
          },
          name: {
            enable: false,
            origin: 0,
            method: 0,
            selector: ["", "", "", ""],
            infoType: 4,
            attribute: ["", "", "", ""]
          },
          meta: {
            enable: true,
            origin: 2,
            method: 0,
            selector: ["", "", "", ""],
            infoType: 0,
            attribute: ["", "", "", ""],
            getMethod: 0
          }
        });
        return {
          container,
          info,
          data,
          defaultRule,
          getLocationRule,
          saveRuleToLocation,
          createRule,
          deleteRule
        };
      });
      defineStore("list", () => {
        const info = reactive({
          nowColumn: 3,
          allSelected: false
        });
        return { info };
      });
      const _hoisted_1$j = { class: "onlineGallery-RuleEditor-modal" };
      const _hoisted_2$h = /* @__PURE__ */ createBaseVNode("span", { style: { "color": "black", "font-size": "large" } }, "规则管理器", -1);
      const _hoisted_3$g = { style: { "color": "black", "font-size": "large" } };
      const _hoisted_4$4 = {
        key: 0,
        class: "tree-item tree-item-normal"
      };
      const _hoisted_5$1 = { class: "label-ruleName" };
      const _hoisted_6$1 = { class: "icon-button-deleteRule" };
      const _hoisted_7$1 = {
        key: 1,
        class: "tree-item tree-item-add-button"
      };
      const _sfc_main$6 = /* @__PURE__ */ defineComponent({
        __name: "RuleEditor",
        setup(__props) {
          const { text, isSupported, copy } = useClipboard();
          const appInfo = useAppInfoStore();
          const ruleEditor = useRuleEditorStore();
          const treeRef = ref();
          const info = ruleEditor.info;
          const form = ruleEditor.info.form;
          const tree = ruleEditor.info.tree;
          const data = ruleEditor.data;
          const inputFormData = async (ruleData) => {
            if (ruleData != void 0) {
              if (!ruleData.status.editing && !ruleData.status.isNewCreated) {
                ruleData.createBackup();
                ruleData.status.editing = true;
              }
              ruleData.status.isNewCreated = false;
              form.realTimeData = ruleData;
              info.showRuleId = ruleData.id;
              form.activeName = "main";
            } else {
              form.realTimeData = void 0;
              info.showRuleId = "-1";
            }
          };
          const onQueryChanged = (query) => {
            treeRef.value.filter(query);
          };
          const treeFilterMethod = (query, node) => {
            return node.label.includes(query);
          };
          const treeNodeClick = (nodeData, node, e2) => {
            const ruleIndex = data.ruleList.findIndex(
              (item) => item.id === nodeData.id
            );
            if (ruleIndex >= 0) {
              const rule = data.ruleList[ruleIndex];
              inputFormData(rule);
            }
          };
          const createRule = async () => {
            const rule = await ruleEditor.createRule();
            inputFormData(rule);
          };
          const deleteRule = async (id2, node) => {
            const ruleName = node.label;
            ElMessageBox.confirm(`确认删除规则 “${ruleName}” ？`, "提示", {
              confirmButtonText: "确认",
              cancelButtonText: "取消",
              lockScroll: false
            }).then(() => {
              ruleEditor.deleteRule(id2);
              inputFormData();
              ElMessage({
                type: "success",
                grouping: true,
                center: true,
                offset: 120,
                message: `规则 “${ruleName}” 删除成功!`
              });
            }).catch(() => {
            });
          };
          const copyNowRule = async () => {
            var _a2, _b;
            const content = (_a2 = form.realTimeData) == null ? void 0 : _a2.getJsonData();
            await copy(content);
            ElMessage({
              type: "success",
              // showClose: true,
              grouping: true,
              center: true,
              duration: 1e3,
              offset: 120,
              message: h$1("p", { style: "display:flex;gap:10px" }, [
                h$1("i", { style: "color: teal" }, "(规则)" + ((_b = form.realTimeData) == null ? void 0 : _b.main.name)),
                h$1("span", { style: "color: black" }, "复制成功！")
              ])
            });
          };
          const handleOpen = () => {
            initDialog();
            console.log("规则管理器 - Open");
          };
          const handleClose = async () => {
            ElMessageBox.confirm("确认关闭？", "提示", {
              confirmButtonText: "确认",
              cancelButtonText: "取消",
              lockScroll: false
            }).then(() => {
              ruleEditor.container.open = false;
              //! 关闭窗口
            }).catch(() => {
            });
          };
          const handleClosed = async () => {
            initDialog();
            console.log("规则管理器 - Close");
          };
          const initDialog = async () => {
            form.activeName = "main";
            inputFormData();
          };
          const allSave = async () => {
            await ruleEditor.saveRuleToLocation();
            ruleEditor.container.open = false;
            //! 关闭窗口
          };
          return (_ctx, _cache) => {
            const _component_el_input = ElInput;
            const _component_el_image = ElImage;
            const _component_el_tooltip = ElTooltip;
            const _component_HoverButton = __unplugin_components_3;
            const _component_i_ep_CirclePlusFilled = __unplugin_components_4;
            const _component_el_icon = ElIcon;
            const _component_el_button = ElButton;
            const _component_el_tree_v2 = ElTreeV2;
            const _component_el_aside = ElAside;
            const _component_RuleForm = __unplugin_components_9;
            const _component_el_main = ElMain;
            const _component_el_container = ElContainer;
            const _component_el_dialog = ElDialog;
            return openBlock(), createElementBlock("div", _hoisted_1$j, [
              createVNode(_component_el_dialog, {
                style: { "pointer-events": "auto !important", "padding": "0px" },
                modelValue: unref(ruleEditor).container.open,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(ruleEditor).container.open = $event),
                width: unref(appInfo).window.width > 800 ? "800px" : "100%",
                "before-close": handleClose,
                modal: false,
                "close-on-click-modal": false,
                "lock-scroll": false,
                "destroy-on-close": "",
                draggable: "",
                onOpen: handleOpen,
                onClosed: handleClosed
              }, {
                header: withCtx(() => [
                  _hoisted_2$h,
                  createBaseVNode("span", _hoisted_3$g, " (共" + toDisplayString(unref(ruleEditor).data.ruleList.length) + "条规则) ", 1)
                ]),
                default: withCtx(() => [
                  createVNode(_component_el_container, { style: { "user-select": "none" } }, {
                    default: withCtx(() => [
                      createVNode(_component_el_aside, {
                        width: "200px",
                        "show-checkbox": "",
                        "highlight-current": "",
                        style: { "padding": "5px" }
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_input, {
                            clearable: "",
                            modelValue: unref(tree).query,
                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(tree).query = $event),
                            placeholder: "输入关键词",
                            onInput: onQueryChanged
                          }, null, 8, ["modelValue"]),
                          createVNode(_component_el_tree_v2, {
                            ref_key: "treeRef",
                            ref: treeRef,
                            data: unref(tree).treeData,
                            props: unref(tree).treeProps,
                            height: 400,
                            "highlight-current": "",
                            "current-node-key": unref(info).showRuleId,
                            "filter-method": treeFilterMethod,
                            onNodeClick: treeNodeClick,
                            "item-size": 32
                          }, {
                            default: withCtx(({ node }) => [
                              node.key != "#" ? (openBlock(), createElementBlock("div", _hoisted_4$4, [
                                createVNode(_component_el_image, {
                                  style: { "width": "24px", "aspect-ratio": "1" },
                                  src: node.data.iconUrl
                                }, null, 8, ["src"]),
                                createVNode(_component_el_tooltip, {
                                  "show-after": 500,
                                  effect: "dark",
                                  content: node.label,
                                  placement: "top"
                                }, {
                                  default: withCtx(() => [
                                    createBaseVNode("span", _hoisted_5$1, toDisplayString(node.label), 1)
                                  ]),
                                  _: 2
                                }, 1032, ["content"]),
                                createBaseVNode("span", _hoisted_6$1, [
                                  createVNode(_component_HoverButton, {
                                    onClick: withModifiers(($event) => deleteRule(node.key, node), ["stop"])
                                  }, null, 8, ["onClick"])
                                ])
                              ])) : createCommentVNode("", true),
                              node.key == "#" ? (openBlock(), createElementBlock("div", _hoisted_7$1, [
                                createVNode(_component_el_button, {
                                  type: "primary",
                                  onClick: createRule
                                }, {
                                  icon: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  default: withCtx(() => [
                                    createBaseVNode("span", null, toDisplayString(node.label), 1)
                                  ]),
                                  _: 2
                                }, 1024)
                              ])) : createCommentVNode("", true)
                            ]),
                            _: 1
                          }, 8, ["data", "props", "current-node-key"])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_main, { style: { "padding": "5px" } }, {
                        default: withCtx(() => [
                          createVNode(_component_RuleForm, {
                            formData: unref(form).realTimeData
                          }, null, 8, ["formData"])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                footer: withCtx(() => [
                  createVNode(_component_el_button, {
                    type: "info",
                    onClick: copyNowRule
                  }, {
                    default: withCtx(() => [
                      createTextVNode("复制当前规则")
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: allSave
                  }, {
                    default: withCtx(() => [
                      createTextVNode("全部保存")
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_button, { onClick: handleClose }, {
                    default: withCtx(() => [
                      createTextVNode("取消")
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["modelValue", "width"])
            ]);
          };
        }
      });
      const _hoisted_1$i = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$g = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M764.288 214.592L512 466.88L259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512L214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
      }, null, -1);
      const _hoisted_3$f = [
        _hoisted_2$g
      ];
      function render$d(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$i, _hoisted_3$f);
      }
      const __unplugin_components_1$2 = { name: "ep-close", render: render$d };
      const _hoisted_1$h = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$f = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 320L192 704h639.936z"
      }, null, -1);
      const _hoisted_3$e = [
        _hoisted_2$f
      ];
      function render$c(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$h, _hoisted_3$e);
      }
      const __unplugin_components_1$1 = { name: "ep-caret-top", render: render$c };
      const _hoisted_1$g = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$e = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 928c23.936 0 117.504-68.352 192.064-153.152C803.456 661.888 864 535.808 864 416c0-189.632-155.84-320-352-320S160 226.368 160 416c0 120.32 60.544 246.4 159.936 359.232C394.432 859.84 488 928 512 928zm0-435.2a64 64 0 1 0 0-128a64 64 0 0 0 0 128zm0 140.8a204.8 204.8 0 1 1 0-409.6a204.8 204.8 0 0 1 0 409.6z"
      }, null, -1);
      const _hoisted_3$d = [
        _hoisted_2$e
      ];
      function render$b(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$g, _hoisted_3$d);
      }
      const __unplugin_components_7 = { name: "ep-location-filled", render: render$b };
      const _hoisted_1$f = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$d = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64zm384-253.696l236.288-236.352l45.248 45.248L508.8 704L192 387.2l45.248-45.248L480 584.704V128h64v450.304z"
      }, null, -1);
      const _hoisted_3$c = [
        _hoisted_2$d
      ];
      function render$a(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$f, _hoisted_3$c);
      }
      const __unplugin_components_8 = { name: "ep-download", render: render$a };
      const _hoisted_1$e = ["parentSelector"];
      const _sfc_main$5 = {
        __name: "Img",
        props: {
          src: String,
          parentSelector: {
            type: String,
            default: "null"
          },
          margin: {
            type: String,
            default: "0%"
          }
        },
        setup(__props) {
          onMounted(() => {
            _t.bind('[data-fancybox="onlineGallery"]', {
              Thumbs: { type: "modern" },
              Toolbar: {
                display: {
                  left: ["infobar"],
                  middle: [
                    "zoomIn",
                    "zoomOut",
                    "toggle1to1",
                    "rotateCCW",
                    "rotateCW",
                    "flipX",
                    "flipY"
                  ],
                  right: ["slideshow", "thumbs", "close"]
                }
              }
            });
          });
          const vLazy = {
            mounted(el, binding, vNode) {
              el.dataset.show = false;
              let url = binding.value;
              let observer = new IntersectionObserver(
                (entries, observer2) => {
                  entries.forEach((entire) => {
                    if (entire.isIntersecting) {
                      observer2.unobserve(el);
                      el.src = url;
                      if (el.tagName == "IMG") {
                        if (el.complete) {
                          el.dataset.show = true;
                        } else {
                          let fn2 = function() {
                            el.dataset.show = true;
                            el.removeEventListener("load", fn2);
                            el.removeEventListener("error", fn2);
                          };
                          el.addEventListener("load", fn2);
                          el.addEventListener("error", fn2);
                        }
                      } else {
                        el.dataset.show = true;
                      }
                    }
                  });
                },
                {
                  root: document.querySelector(vNode.props.parentSelector),
                  rootMargin: vNode.props.margin
                }
              );
              observer.observe(el);
            }
          };
          return (_ctx, _cache) => {
            return withDirectives((openBlock(), createElementBlock("img", {
              parentSelector: __props.parentSelector,
              "data-fancybox": "gallery"
            }, null, 8, _hoisted_1$e)), [
              [vLazy, __props.src]
            ]);
          };
        }
      };
      const __unplugin_components_0$2 = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-b78ae3cf"]]);
      const _hoisted_1$d = ["id", "data-fancybox-index"];
      const _hoisted_2$c = { class: "tag-group" };
      const _hoisted_3$b = { class: "button-group" };
      const _sfc_main$4 = /* @__PURE__ */ defineComponent({
        __name: "Card",
        props: {
          card: { default: () => {
            return {
              name: "",
              linkUrl: "",
              picUrl: "",
              originUrls: [],
              metaOrigin: "",
              meta: {
                width: 0,
                height: 0,
                aspectRatio: 3 / 4
              },
              picBlob: new Blob([], { type: "none" }),
              linkBlob: new Blob([], { type: "none" }),
              nameBlob: new Blob([], { type: "none" }),
              selected: false,
              //? 选中标识符
              dom: null
            };
          } },
          index: {}
        },
        setup(__props, { expose: __expose }) {
          const props2 = __props;
          const { text, isSupported, copy } = useClipboard();
          const cardsStore = useCardsStore();
          const cardDom = ref();
          const appInfo = useAppInfoStore();
          const downloading = ref(false);
          const copyTagContent = async (content) => {
            await copy(content);
            ElMessage({
              type: "success",
              // showClose: true,
              grouping: true,
              center: true,
              duration: 1e3,
              offset: 120,
              message: h$1("p", { style: "display:flex;gap:10px" }, [
                h$1("i", { style: "color: teal" }, content),
                h$1("span", { style: "color: black" }, "复制成功！")
              ])
            });
          };
          const previewByFancyBox = async (e2) => {
            cardsStore.openFancyBox(props2.index);
          };
          const download = async () => {
            const card = props2.card;
            downloading.value = true;
            if (card.linkBlob) {
              let ext = getExtByBlob(card.linkBlob);
              let reg = new RegExp(`(\\.${ext})+$`);
              await saveAs(card.linkBlob, `${card.name.replace(reg, "")}.${ext}`);
              downloading.value = false;
            } else {
              const url = card.linkUrl;
              let tempBlob = await getBlobByUrlAuto(url);
              console.log(tempBlob);
              if (tempBlob && tempBlob.type !== "none") {
                card.linkBlob = tempBlob;
                await saveAs(card.linkBlob, card.name);
                downloading.value = false;
              } else {
                downloading.value = false;
              }
            }
          };
          const toPosition = async () => {
            const dom = props2.card.dom;
            if (dom != null) {
              appInfo.container.open = !appInfo.container.open;
              dom.scrollIntoView({
                behavior: "smooth",
                block: "center",
                inline: "center"
              });
            }
          };
          __expose({
            cardDom
          });
          return (_ctx, _cache) => {
            const _component_Img = __unplugin_components_0$2;
            const _component_el_tag = ElTag;
            const _component_el_tooltip = ElTooltip;
            const _component_el_checkbox = ElCheckbox;
            const _component_i_ep_Download = __unplugin_components_8;
            const _component_el_icon = ElIcon;
            const _component_el_button = ElButton;
            const _component_i_ep_LocationFilled = __unplugin_components_7;
            return openBlock(), createElementBlock("div", {
              ref_key: "cardDom",
              ref: cardDom,
              class: "card",
              id: `id_${_ctx.card.id}`,
              "data-fancybox-trigger": "onlineGallery",
              "data-fancybox-index": _ctx.index,
              onContextmenu: _cache[4] || (_cache[4] = withModifiers(() => {
              }, ["prevent", "self"]))
            }, [
              createVNode(_component_Img, {
                class: "content",
                "data-fancybox": "onlineGallery",
                src: _ctx.card.picUrl,
                onDblclick: previewByFancyBox
              }, null, 8, ["src"]),
              createBaseVNode("div", _hoisted_2$c, [
                _ctx.card.linkBlob ? (openBlock(), createBlock(_component_el_tooltip, {
                  key: 0,
                  effect: "dark",
                  content: (_ctx.card.linkBlob.size / 1024 / 1024).toFixed(2) + "Mb",
                  placement: "top"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_tag, {
                      class: "el-tag",
                      round: "",
                      size: "small",
                      onContextmenu: _cache[0] || (_cache[0] = withModifiers(($event) => copyTagContent((_ctx.card.linkBlob.size / 1024 / 1024).toFixed(2) + "Mb"), ["right"]))
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString((_ctx.card.linkBlob.size / 1024 / 1024).toFixed(2) + "Mb"), 1)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["content"])) : createCommentVNode("", true),
                createVNode(_component_el_tooltip, {
                  effect: "dark",
                  content: `${_ctx.card.meta.width}x${_ctx.card.meta.height}`,
                  placement: "top"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_tag, {
                      class: "el-tag",
                      size: "small",
                      type: "info",
                      onContextmenu: _cache[1] || (_cache[1] = withModifiers(($event) => copyTagContent(_ctx.card.meta.width + "x" + _ctx.card.meta.height), ["right"])),
                      round: ""
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.card.meta.width) + "x" + toDisplayString(_ctx.card.meta.height), 1)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["content"]),
                createVNode(_component_el_tooltip, {
                  effect: "dark",
                  content: _ctx.card.name,
                  placement: "top"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_tag, {
                      class: "el-tag",
                      round: "",
                      size: "small",
                      onContextmenu: _cache[2] || (_cache[2] = withModifiers(($event) => copyTagContent(_ctx.card.name), ["right"]))
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.card.name), 1)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["content"])
              ]),
              createVNode(_component_el_checkbox, {
                modelValue: _ctx.card.selected,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.card.selected = $event),
                class: "checkbox"
              }, null, 8, ["modelValue"]),
              createBaseVNode("div", _hoisted_3$b, [
                createVNode(_component_el_button, {
                  class: "button download",
                  type: "primary",
                  circle: "",
                  onClick: withModifiers(download, ["stop"]),
                  loading: unref(downloading)
                }, {
                  icon: withCtx(() => [
                    createVNode(_component_el_icon, null, {
                      default: withCtx(() => [
                        createVNode(_component_i_ep_Download)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["onClick", "loading"]),
                createVNode(_component_el_button, {
                  class: "button toPosition",
                  type: "primary",
                  circle: "",
                  onClick: withModifiers(toPosition, ["stop"]),
                  loading: unref(downloading)
                }, {
                  icon: withCtx(() => [
                    createVNode(_component_el_icon, null, {
                      default: withCtx(() => [
                        createVNode(_component_i_ep_LocationFilled)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["onClick", "loading"])
              ])
            ], 40, _hoisted_1$d);
          };
        }
      });
      const __unplugin_components_0$1 = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-33e8a5f9"]]);
      const _sfc_main$3 = /* @__PURE__ */ defineComponent({
        __name: "List",
        setup(__props) {
          const listContainer = ref();
          const listBody = ref();
          const scrollbarRef = ref();
          ref();
          const cardsStore = useCardsStore();
          const toolBar = useToolBarStore();
          const listControl = toolBar.listControl;
          const getStyle2 = computed(() => {
            if (listContainer.value == null) {
              return;
            }
            const containerInfo = listContainer.value.getBoundingClientRect();
            let style = {
              "--nowColumn": listControl.showColumn,
              "--listHeight": containerInfo.height - 8 * listControl.showColumn - 10 + "px",
              "--cardMaxHeight": `calc(var(--listHeight) / var(--nowColumn))`
            };
            if (listControl.showColumn <= 0) {
              style["--cardMaxHeight"] = "1000%";
            }
            return style;
          });
          const backTop = ref();
          const backTopShow = ref(false);
          const handleScroll = (scrollEvent) => {
            if (scrollEvent.scrollTop > 150) {
              backTopShow.value = true;
            } else {
              backTopShow.value = false;
            }
          };
          const backToTop = () => {
            scrollbarRef.value.setScrollTop(0);
          };
          return (_ctx, _cache) => {
            const _component_Card = __unplugin_components_0$1;
            const _component_i_ep_CaretTop = __unplugin_components_1$1;
            const _component_el_icon = ElIcon;
            const _component_el_scrollbar = ElScrollbar;
            return openBlock(), createElementBlock("div", {
              ref_key: "listContainer",
              ref: listContainer
            }, [
              createVNode(_component_el_scrollbar, {
                ref_key: "scrollbarRef",
                ref: scrollbarRef,
                onScroll: handleScroll
              }, {
                default: withCtx(() => [
                  createVNode(TransitionGroup, {
                    id: "onlineGallery-listBody",
                    class: "onlineGallery-listBody",
                    ref_key: "listBody",
                    ref: listBody,
                    style: normalizeStyle(unref(getStyle2)),
                    name: "list",
                    tag: "div"
                  }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(cardsStore).filterCards, (card, index) => {
                        return openBlock(), createBlock(_component_Card, {
                          card,
                          key: card.id,
                          index,
                          "data-index": index,
                          style: normalizeStyle({
                            "--aspect-ratio": card.meta.aspectRatio
                          })
                        }, null, 8, ["card", "index", "data-index", "style"]);
                      }), 128))
                    ]),
                    _: 1
                  }, 8, ["style"]),
                  createVNode(Transition, { name: "backTop" }, {
                    default: withCtx(() => [
                      withDirectives(createBaseVNode("div", {
                        ref_key: "backTop",
                        ref: backTop,
                        class: "onlineGallery-backTop",
                        onClick: backToTop
                      }, [
                        createVNode(_component_el_icon, null, {
                          default: withCtx(() => [
                            createVNode(_component_i_ep_CaretTop)
                          ]),
                          _: 1
                        })
                      ], 512), [
                        [vShow, unref(backTopShow)]
                      ])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 512)
            ], 512);
          };
        }
      });
      const __unplugin_components_2 = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-f25bdb68"]]);
      const _hoisted_1$c = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$b = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M764.416 254.72a351.68 351.68 0 0 1 86.336 149.184H960v192.064H850.752a351.68 351.68 0 0 1-86.336 149.312l54.72 94.72l-166.272 96l-54.592-94.72a352.64 352.64 0 0 1-172.48 0L371.136 936l-166.272-96l54.72-94.72a351.68 351.68 0 0 1-86.336-149.312H64v-192h109.248a351.68 351.68 0 0 1 86.336-149.312L204.8 160l166.208-96h.192l54.656 94.592a352.64 352.64 0 0 1 172.48 0L652.8 64h.128L819.2 160l-54.72 94.72zM704 499.968a192 192 0 1 0-384 0a192 192 0 0 0 384 0z"
      }, null, -1);
      const _hoisted_3$a = [
        _hoisted_2$b
      ];
      function render$9(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$c, _hoisted_3$a);
      }
      const __unplugin_components_13 = { name: "ep-tools", render: render$9 };
      const _hoisted_1$b = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$a = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M576 128v288l96-96l96 96V128h128v768H320V128h256zm-448 0h128v768H128V128z"
      }, null, -1);
      const _hoisted_3$9 = [
        _hoisted_2$a
      ];
      function render$8(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$b, _hoisted_3$9);
      }
      const __unplugin_components_11 = { name: "ep-management", render: render$8 };
      const _hoisted_1$a = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$9 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M176 416a112 112 0 1 1 0 224a112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224a112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224a112 112 0 0 1 0-224z"
      }, null, -1);
      const _hoisted_3$8 = [
        _hoisted_2$9
      ];
      function render$7(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$a, _hoisted_3$8);
      }
      const __unplugin_components_10 = { name: "ep-more-filled", render: render$7 };
      const _hoisted_1$9 = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$8 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384a384 384 0 0 1-384-384a384 384 0 0 1 643.712-282.88z"
      }, null, -1);
      const _hoisted_3$7 = [
        _hoisted_2$8
      ];
      function render$6(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$9, _hoisted_3$7);
      }
      const __unplugin_components_5 = { name: "ep-refresh-right", render: render$6 };
      const _hoisted_1$8 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24"
      };
      const _hoisted_2$7 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "none",
        d: "M0 0h24v24H0z"
      }, null, -1);
      const _hoisted_3$6 = /* @__PURE__ */ createBaseVNode("path", { d: "M4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm1 2v14h14V5H5z" }, null, -1);
      const _hoisted_4$3 = [
        _hoisted_2$7,
        _hoisted_3$6
      ];
      function render$5(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$8, _hoisted_4$3);
      }
      const CheckboxNone = { render: render$5 };
      const _hoisted_1$7 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24"
      };
      const _hoisted_2$6 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "none",
        d: "M0 0h24v24H0z"
      }, null, -1);
      const _hoisted_3$5 = /* @__PURE__ */ createBaseVNode("path", { d: "M4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm7.003 13 7.07-7.071-1.414-1.414-5.656 5.657-2.829-2.829-1.414 1.414L11.003 16z" }, null, -1);
      const _hoisted_4$2 = [
        _hoisted_2$6,
        _hoisted_3$5
      ];
      function render$4(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$7, _hoisted_4$2);
      }
      const CheckboxAll = { render: render$4 };
      const _withScopeId = (n2) => (pushScopeId("data-v-0fb243fe"), n2 = n2(), popScopeId(), n2);
      const _hoisted_1$6 = { class: "onlineGallery-toolBar" };
      const _hoisted_2$5 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { style: { "display": "flex", "justify-content": "center" } }, " 选中 / 可见 / 总数 ", -1));
      const _hoisted_3$4 = { class: "filter-container" };
      const _hoisted_4$1 = { class: "filter-size" };
      const _hoisted_5 = { class: "width filter-size-row" };
      const _hoisted_6 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "filter-size-label" }, "宽度", -1));
      const _hoisted_7 = { class: "height filter-size-row" };
      const _hoisted_8 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "filter-size-label" }, "高度", -1));
      const _hoisted_9 = { class: "filter-format" };
      const _hoisted_10 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "format-label" }, "格式", -1));
      const _hoisted_11 = { class: "list-control-container" };
      const _hoisted_12 = { class: "list-control-column" };
      const _hoisted_13 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "list-control-column-label" }, "行数", -1));
      const _hoisted_14 = { class: "list-control-sort-method" };
      const _hoisted_15 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "list-control-sort-method-label" }, "排序", -1));
      const _hoisted_16 = { class: "rule-selector-container" };
      const _hoisted_17 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "rule-selector-label" }, "预设", -1));
      const _hoisted_18 = { class: "rule-item" };
      const _sfc_main$2 = /* @__PURE__ */ defineComponent({
        __name: "Toolbar",
        setup(__props) {
          const appInfo = useAppInfoStore();
          const cardsStore = useCardsStore();
          const toolbar = useToolBarStore();
          const ruleEditor = useRuleEditorStore();
          const loading2 = appInfo.loading;
          const filter = toolbar.filter;
          const listControl = toolbar.listControl;
          const ruleSelector = toolbar.ruleSelector;
          const refresh = async () => {
            if (ruleSelector.value === "#") {
              await cardsStore.getCard(ruleEditor.defaultRule);
            } else {
              const ruleIndex = ruleEditor.data.ruleList.findIndex(
                (rule2) => rule2.id === ruleSelector.value
              );
              const rule = ruleEditor.data.ruleList[ruleIndex];
              if (rule) {
                await cardsStore.getCard(rule);
              } else {
                ElMessage({
                  message: "请选择预设后再尝试此操作",
                  type: "info",
                  showClose: true,
                  grouping: true,
                  offset: 120
                });
              }
            }
          };
          const allSelectSwitch = async () => {
            toolbar.listControl.allSelected = !toolbar.listControl.allSelected;
            appInfo.loading.value = true;
            cardsStore.filterCards.forEach(
              (card) => card.selected = toolbar.listControl.allSelected
            );
            appInfo.loading.value = false;
          };
          const downloadSelected = async () => {
            const downloadCards = cardsStore.selectedCards;
            if (!downloadCards.length) {
              ElMessage({
                message: "请选择要下载的数据",
                type: "info",
                showClose: true,
                grouping: true,
                offset: 120
              });
              return;
            }
            const taskQueue = new TaskQueue({ showMessage: false, max: 5 });
            loading2.init();
            let finallyCount = 0;
            for (let index = 0; index < downloadCards.length; index++) {
            }
            const taskList = downloadCards.map((card, index) => {
              return {
                index,
                //* 主要执行函数
                main: async () => {
                  if (!card.linkBlob) {
                    const url = card.linkUrl;
                    card.linkBlob = await getBlobByUrlAuto(url);
                    if (card.linkBlob && card.linkBlob["type"] !== "none") {
                      return [card.name, "处理成功!"];
                    } else {
                      return [card.name, "处理失败"];
                    }
                  } else {
                    return [card.name, "处理成功!"];
                  }
                },
                //* 单次执行完成后的回调
                callback: (res, index2) => {
                  finallyCount++;
                  loading2.percentage = finallyCount / downloadCards.length * 100;
                }
              };
            });
            taskQueue.pushTask(taskList);
            taskQueue.finallyCallback = async () => {
              ElMessage({
                message: "下载成功! (正在生成压缩包)",
                type: "success",
                showClose: true,
                grouping: true,
                offset: 120
              });
              const zipContainer = new JSZip();
              for (let index = 0; index < downloadCards.length; index++) {
                const card = downloadCards[index];
                if (card.name && card.linkBlob) {
                  let ext = getExtByBlob(card.linkBlob);
                  let reg = new RegExp(`(\\.${ext})+$`);
                  let fix = strAutofill(index.toString(), 0, 4);
                  zipContainer.file(
                    `${fix} - ${card.name.replace(reg, "")}.${ext}`,
                    card.linkBlob
                  );
                }
              }
              const zip = await zipContainer.generateAsync({
                type: "blob",
                compression: "DEFLATE",
                level: 9
              });
              let zipName = document.querySelector("title").innerText;
              saveAs(zip, `${zipName}.zip`);
              loading2.percentage = 100;
              loading2.reset();
            };
            taskQueue.run();
          };
          return (_ctx, _cache) => {
            const _component_el_statistic = ElStatistic;
            const _component_el_slider = ElSlider;
            const _component_el_select_v2 = ElSelectV2;
            const _component_el_input_number = ElInputNumber;
            const _component_el_image = ElImage;
            const _component_i_ep_RefreshRight = __unplugin_components_5;
            const _component_el_icon = ElIcon;
            const _component_el_button = ElButton;
            const _component_i_ep_Download = __unplugin_components_8;
            const _component_el_button_group = ElButtonGroup$1;
            const _component_i_ep_MoreFilled = __unplugin_components_10;
            const _component_i_ep_Management = __unplugin_components_11;
            const _component_el_dropdown_item = ElDropdownItem;
            const _component_i_ep_Tools = __unplugin_components_13;
            const _component_el_dropdown_menu = ElDropdownMenu;
            const _component_el_dropdown = ElDropdown;
            return openBlock(), createElementBlock("div", _hoisted_1$6, [
              createVNode(_component_el_statistic, {
                class: "statistic-container",
                value: unref(cardsStore).filterCards.length,
                prefix: unref(cardsStore).selectedCards.length.toString() + " /",
                suffix: "/ " + unref(cardsStore).allValidCards.length.toString()
              }, {
                title: withCtx(() => [
                  _hoisted_2$5
                ]),
                _: 1
              }, 8, ["value", "prefix", "suffix"]),
              createBaseVNode("div", _hoisted_3$4, [
                createBaseVNode("div", _hoisted_4$1, [
                  createBaseVNode("div", _hoisted_5, [
                    _hoisted_6,
                    createVNode(_component_el_slider, {
                      debounce: 500,
                      class: "filter-size-slider",
                      label: "宽度",
                      modelValue: unref(filter).size.width.value,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(filter).size.width.value = $event),
                      range: "",
                      min: 0,
                      max: unref(filter).size.width.max,
                      placement: "right"
                    }, null, 8, ["modelValue", "max"])
                  ]),
                  createBaseVNode("div", _hoisted_7, [
                    _hoisted_8,
                    createVNode(_component_el_slider, {
                      debounce: 500,
                      class: "filter-size-slider",
                      label: "高度",
                      modelValue: unref(filter).size.height.value,
                      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(filter).size.height.value = $event),
                      range: "",
                      min: 0,
                      max: unref(filter).size.height.max,
                      placement: "right"
                    }, null, 8, ["modelValue", "max"])
                  ])
                ]),
                createBaseVNode("div", _hoisted_9, [
                  _hoisted_10,
                  createVNode(_component_el_select_v2, {
                    class: "format-select",
                    modelValue: unref(filter).formats.value,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(filter).formats.value = $event),
                    filterable: "",
                    clearable: "",
                    "allow-create": "",
                    "collapse-tags": "",
                    "collapse-tags-tooltip": "",
                    "max-collapse-tags": 1,
                    options: unref(filter).formats.options,
                    placeholder: "格式过滤",
                    multiple: ""
                  }, null, 8, ["modelValue", "options"])
                ])
              ]),
              createBaseVNode("div", _hoisted_11, [
                createBaseVNode("div", _hoisted_12, [
                  _hoisted_13,
                  createVNode(_component_el_input_number, {
                    class: "list-control-column-input-number",
                    min: 1,
                    max: 6,
                    step: 1,
                    "step-strictly": "",
                    "controls-position": "right",
                    onWheel: _cache[3] || (_cache[3] = (e2) => {
                      if (e2.deltaY < 0) {
                        if (unref(toolbar).listControl.showColumn < 6)
                          unref(toolbar).listControl.showColumn++;
                      } else {
                        if (unref(toolbar).listControl.showColumn > 1)
                          unref(toolbar).listControl.showColumn--;
                      }
                    }),
                    modelValue: unref(toolbar).listControl.showColumn,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(toolbar).listControl.showColumn = $event)
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_14, [
                  _hoisted_15,
                  createVNode(_component_el_select_v2, {
                    class: "list-control-sort-method-select",
                    modelValue: unref(listControl).sortMethod.value,
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => unref(listControl).sortMethod.value = $event),
                    options: unref(listControl).sortMethod.options,
                    placeholder: "排序方法"
                  }, null, 8, ["modelValue", "options"])
                ])
              ]),
              createBaseVNode("div", _hoisted_16, [
                _hoisted_17,
                createVNode(_component_el_select_v2, {
                  class: "rule-selector-select",
                  modelValue: unref(ruleSelector).value,
                  "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(ruleSelector).value = $event),
                  filterable: "",
                  options: unref(ruleSelector).option,
                  placeholder: "选择当前预设"
                }, {
                  empty: withCtx(() => [
                    createTextVNode(" 11 ")
                  ]),
                  default: withCtx((node) => [
                    createBaseVNode("div", _hoisted_18, [
                      createVNode(_component_el_image, {
                        class: "rule-icon",
                        src: node.item.iconUrl
                      }, null, 8, ["src"]),
                      createTextVNode(" " + toDisplayString(node.item.label), 1)
                    ])
                  ]),
                  _: 1
                }, 8, ["modelValue", "options"])
              ]),
              createVNode(_component_el_button_group, { class: "button-group-container" }, {
                default: withCtx(() => [
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: refresh,
                    loading: unref(loading2).value
                  }, {
                    icon: withCtx(() => [
                      createVNode(_component_el_icon, null, {
                        default: withCtx(() => [
                          createVNode(_component_i_ep_RefreshRight)
                        ]),
                        _: 1
                      })
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" 刷新 ")
                    ]),
                    _: 1
                  }, 8, ["loading"]),
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: allSelectSwitch,
                    loading: unref(loading2).value,
                    icon: unref(toolbar).listControl.allSelected ? unref(CheckboxAll) : unref(CheckboxNone)
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(unref(toolbar).listControl.allSelected ? "取消全选" : "全部选中"), 1)
                    ]),
                    _: 1
                  }, 8, ["loading", "icon"]),
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: downloadSelected,
                    loading: unref(loading2).value
                  }, {
                    icon: withCtx(() => [
                      createVNode(_component_el_icon, null, {
                        default: withCtx(() => [
                          createVNode(_component_i_ep_Download)
                        ]),
                        _: 1
                      })
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" 下载选中 ")
                    ]),
                    _: 1
                  }, 8, ["loading"])
                ]),
                _: 1
              }),
              createVNode(_component_el_dropdown, null, {
                dropdown: withCtx(() => [
                  createVNode(_component_el_dropdown_menu, null, {
                    default: withCtx(() => [
                      createVNode(_component_el_dropdown_item, {
                        onClick: _cache[7] || (_cache[7] = ($event) => unref(ruleEditor).container.open = true)
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_icon, null, {
                            default: withCtx(() => [
                              createVNode(_component_i_ep_Management)
                            ]),
                            _: 1
                          }),
                          createTextVNode(" 规则管理 ")
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_dropdown_item, {
                        onClick: _cache[8] || (_cache[8] = () => {
                        })
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_icon, null, {
                            default: withCtx(() => [
                              createVNode(_component_i_ep_Tools)
                            ]),
                            _: 1
                          }),
                          createTextVNode(" 设置 ")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                default: withCtx(() => [
                  createVNode(_component_el_button, { type: "primary" }, {
                    icon: withCtx(() => [
                      createVNode(_component_el_icon, null, {
                        default: withCtx(() => [
                          createVNode(_component_i_ep_MoreFilled)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]);
          };
        }
      });
      const __unplugin_components_1 = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-0fb243fe"]]);
      const _hoisted_1$5 = {
        class: "onlineGallery-body",
        ref: "body"
      };
      const _sfc_main$1 = /* @__PURE__ */ defineComponent({
        __name: "Body",
        setup(__props) {
          const appInfo = useAppInfoStore();
          const cardsStore = useCardsStore();
          let toolbar = ref();
          cardsStore.data;
          const loading2 = appInfo.loading;
          return (_ctx, _cache) => {
            const _component_el_progress = ElProgress;
            const _component_Toolbar = __unplugin_components_1;
            const _component_List = __unplugin_components_2;
            return openBlock(), createElementBlock("div", _hoisted_1$5, [
              withDirectives(createVNode(_component_el_progress, {
                class: "loadingBar",
                percentage: Math.round(unref(loading2).percentage),
                status: unref(loading2).state,
                striped: "",
                "striped-flow": ""
              }, null, 8, ["percentage", "status"]), [
                [vShow, unref(loading2).show]
              ]),
              createVNode(_component_Toolbar, {
                ref_key: "toolbar",
                ref: toolbar,
                class: "onlineGallery-toolBar"
              }, null, 512),
              createVNode(_component_List, {
                ref: "list",
                class: "listContainer"
              }, null, 512)
            ], 512);
          };
        }
      });
      const __unplugin_components_0 = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-889d9413"]]);
      const _hoisted_1$4 = {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        fill: "none"
      };
      const _hoisted_2$4 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "#000",
        d: "M18 20a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm-6 0a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm-6 0a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm12-6a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm-6 0a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm-6 0a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm12-6a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm-6 0a2 2 0 1 1 0-4 2 2 0 0 1 0 4ZM6 8a2 2 0 1 1 0-4 2 2 0 0 1 0 4Z"
      }, null, -1);
      const _hoisted_3$3 = [
        _hoisted_2$4
      ];
      function render$3(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$4, _hoisted_3$3);
      }
      const IconGirdRound = { render: render$3 };
      const _hoisted_1$3 = {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        fill: "none"
      };
      const _hoisted_2$3 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "#000",
        d: "M21 21h-8v-6h8v6Zm-10 0H3V11h8v10Zm10-8h-8V3h8v10ZM11 9H3V3h8v6Z"
      }, null, -1);
      const _hoisted_3$2 = [
        _hoisted_2$3
      ];
      function render$2(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$3, _hoisted_3$2);
      }
      const IconDashboard = { render: render$2 };
      const _hoisted_1$2 = {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24"
      };
      const _hoisted_2$2 = /* @__PURE__ */ createBaseVNode("path", { d: "M19 2H6c-1.206 0-3 .799-3 3v14c0 2.201 1.794 3 3 3h15v-2H6.012C5.55 19.988 5 19.806 5 19c0-.101.009-.191.024-.273.112-.576.584-.717.988-.727H21V4a2 2 0 0 0-2-2zm0 9-2-1-2 1V4h4v7z" }, null, -1);
      const _hoisted_3$1 = [
        _hoisted_2$2
      ];
      function render$1(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$2, _hoisted_3$1);
      }
      const IconBxsBookBookmark = { render: render$1 };
      const _hoisted_1$1 = {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24"
      };
      const _hoisted_2$1 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "none",
        d: "M0 0h24v24H0z"
      }, null, -1);
      const _hoisted_3 = /* @__PURE__ */ createBaseVNode("path", { d: "M5.33 3.271a3.5 3.5 0 0 1 4.472 4.474L20.647 18.59l-2.122 2.121L7.68 9.867a3.5 3.5 0 0 1-4.472-4.474L5.444 7.63a1.5 1.5 0 1 0 2.121-2.121L5.329 3.27zm10.367 1.884 3.182-1.768 1.414 1.414-1.768 3.182-1.768.354-2.12 2.121-1.415-1.414 2.121-2.121.354-1.768zm-7.071 7.778 2.121 2.122-4.95 4.95A1.5 1.5 0 0 1 3.58 17.99l.097-.107 4.95-4.95z" }, null, -1);
      const _hoisted_4 = [
        _hoisted_2$1,
        _hoisted_3
      ];
      function render(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$1, _hoisted_4);
      }
      const IconToolsFill = { render };
      const _hoisted_1 = ["data-open"];
      const _hoisted_2 = { class: "onlineGallery-child-window-container" };
      const _sfc_main = /* @__PURE__ */ defineComponent({
        __name: "App",
        setup(__props) {
          const appInfo = useAppInfoStore();
          const cardsStore = useCardsStore();
          const toolBar = useToolBarStore();
          const ruleEditor = useRuleEditorStore();
          const container = ref();
          const floatButtonRef = ref();
          useDraggable(floatButtonRef, {
            initialValue: { x: 0, y: appInfo.window.height / 2 },
            preventDefault: true,
            stopPropagation: true,
            pointerTypes: ["touch", "mouse", "pen"]
          });
          watch(
            //f 监听 - 主容器container.open变化
            () => appInfo.container.open,
            (newVal, oldVal) => {
              if (newVal) {
                console.log("onlineGallery - 打开");
                document.documentElement.dataset.showScrollbar = false.toString();
                container.value.focus();
              } else {
                console.log("onlineGallery - 收起");
                document.documentElement.dataset.showScrollbar = true.toString();
              }
            }
          );
          //! 挂载完成时执行
          onMounted(async () => {
            await ruleEditor.getLocationRule();
            toolBar.selectingInitRule();
            ElNotification({
              title: "提示",
              message: h$1("i", { style: "color: teal" }, "onlineGallery 已加载"),
              // type: "success",
              duration: 3e3
            });
            if (appInfo.container.open) {
              document.documentElement.dataset.showScrollbar = "false";
              container.value.focus();
            } else {
              document.documentElement.dataset.showScrollbar = "true";
            }
          });
          return (_ctx, _cache) => {
            const _component_Body = __unplugin_components_0;
            const _component_i_ep_Close = __unplugin_components_1$2;
            const _component_el_icon = ElIcon;
            const _component_el_button = ElButton;
            const _component_RuleEditor = _sfc_main$6;
            const _component_var_button = Button$1;
            const _component_var_badge = Badge$1;
            const _component_var_fab = Fab;
            return openBlock(), createElementBlock(Fragment, null, [
              createBaseVNode("div", {
                class: "onlineGallery-container",
                ref_key: "container",
                ref: container,
                "data-open": unref(appInfo).container.open,
                style: normalizeStyle({
                  "--width": unref(appInfo).window.width * unref(appInfo).container.widthPercentage * 0.01 + "px"
                })
              }, [
                createVNode(_component_Body),
                createVNode(_component_el_button, {
                  class: "onlineGallery-button-close",
                  type: "danger",
                  circle: "",
                  onClick: _cache[0] || (_cache[0] = ($event) => unref(appInfo).container.open = false)
                }, {
                  icon: withCtx(() => [
                    createVNode(_component_el_icon, null, {
                      default: withCtx(() => [
                        createVNode(_component_i_ep_Close)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ], 12, _hoisted_1),
              createBaseVNode("div", _hoisted_2, [
                createVNode(_component_RuleEditor)
              ]),
              createVNode(_component_var_fab, {
                type: "primary",
                bottom: "100px",
                right: "30px",
                drag: true,
                trigger: ("isMobile" in _ctx ? _ctx.isMobile : unref(isMobile))() ? "click" : "hover",
                elevation: 24,
                teleport: ".onlineGallery-child-window-container"
              }, {
                trigger: withCtx(() => [
                  createVNode(_component_var_button, {
                    color: "rgb(64,158,255,1)",
                    onDblclick: _cache[1] || (_cache[1] = ($event) => unref(appInfo).container.open = true),
                    class: "onlineGallery-float-button"
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(IconGirdRound))
                    ]),
                    _: 1
                  })
                ]),
                default: withCtx(() => [
                  createVNode(_component_var_badge, {
                    style: { "z-index": "1" },
                    type: "danger",
                    value: unref(cardsStore).data.cardList.length,
                    "max-value": 999
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_var_button, {
                        type: "success",
                        onClick: _cache[2] || (_cache[2] = ($event) => unref(appInfo).container.open = true),
                        round: ""
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(IconDashboard))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["value"]),
                  createVNode(_component_var_button, {
                    type: "info",
                    onClick: _cache[3] || (_cache[3] = ($event) => unref(ruleEditor).container.open = true),
                    round: ""
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(IconBxsBookBookmark))
                    ]),
                    _: 1
                  }),
                  createVNode(_component_var_button, {
                    color: "rgb(217, 121, 252)",
                    onClick: _cache[4] || (_cache[4] = () => {
                    }),
                    round: ""
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(IconToolsFill))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["trigger"])
            ], 64);
          };
        }
      });
      const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-1b52a8bb"]]);
      window["JSZip"] = JSZip$1;
      window["saveAs"] = FileSaver_minExports.saveAs;
      document.documentElement.dataset.showScrollbar = "true";
      const appDom = document.createElement("div");
      const id = `app_vue_${Date.now()}`;
      appDom.id = id;
      const pinia = createPinia();
      const app = createApp(App).use(pinia).use(vueTouchEvents);
      document.documentElement.append(appDom);
      app.mount(`#${id}`);
    }
  });
  require_main_001();

})(JSZip);
=======
// ==UserScript==
// @name       onlineGallery
// @namespace  npm/vite-plugin-monkey
// @version    1.0.0
// @author     Lxs
// @license    MIT
// @icon       https://vitejs.dev/logo.svg
// @match      http*://*
// @match      http*://*/*
// @exclude    *://element-plus.org/*
// @require    https://cdn.bootcdn.net/ajax/libs/jszip/3.7.1/jszip.min.js
// @connect    *
// @grant      GM_getValue
// @grant      GM_setValue
// @grant      GM_xmlhttpRequest
// @grant      unsafeWindow
// @run-at     document-start
// @noframes
// ==/UserScript==

(o=>{const e=document.createElement("style");e.dataset.source="vite-plugin-monkey",e.textContent=o,document.head.append(e)})(` @charset "UTF-8";.el-popper,.el-message,.el-notification,.is-message-box{z-index:9147483647!important}.el-checkbox__inner{z-index:0!important}.el-statistic__content{font-size:large!important}:root[data-show-scrollbar=false]>::-webkit-scrollbar{width:0px!important;height:0px!important;transition:all .5s}[class*=el-input]{border:0!important}:root{--f-spinner-width: 36px;--f-spinner-height: 36px;--f-spinner-color-1: rgba(0, 0, 0, .1);--f-spinner-color-2: rgba(17, 24, 28, .8);--f-spinner-stroke: 2.75}.f-spinner{margin:auto;padding:0;width:var(--f-spinner-width);height:var(--f-spinner-height)}.f-spinner svg{width:100%;height:100%;vertical-align:top;animation:f-spinner-rotate 2s linear infinite}.f-spinner svg *{stroke-width:var(--f-spinner-stroke);fill:none}.f-spinner svg *:first-child{stroke:var(--f-spinner-color-1)}.f-spinner svg *:last-child{stroke:var(--f-spinner-color-2);animation:f-spinner-dash 2s ease-in-out infinite}@keyframes f-spinner-rotate{to{transform:rotate(360deg)}}@keyframes f-spinner-dash{0%{stroke-dasharray:1,150;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-35}to{stroke-dasharray:90,150;stroke-dashoffset:-124}}.f-throwOutUp{animation:.175s ease-out both f-throwOutUp}.f-throwOutDown{animation:.175s ease-out both f-throwOutDown}@keyframes f-throwOutUp{to{transform:translate3d(0,-150px,0);opacity:0}}@keyframes f-throwOutDown{to{transform:translate3d(0,150px,0);opacity:0}}.f-zoomInUp{animation:var(--f-transition-duration, .2s) ease-out .1s both f-zoomInUp}.f-zoomOutDown{animation:var(--f-transition-duration, .2s) ease-out both f-zoomOutDown}@keyframes f-zoomInUp{0%{transform:scale(.975) translate3d(0,16px,0);opacity:0}to{transform:scale(1) translateZ(0);opacity:1}}@keyframes f-zoomOutDown{to{transform:scale(.975) translate3d(0,16px,0);opacity:0}}.f-fadeIn{animation:var(--f-transition-duration, .2s) ease both f-fadeIn;z-index:2}.f-fadeOut{animation:var(--f-transition-duration, .2s) ease both f-fadeOut;z-index:1}@keyframes f-fadeIn{0%{opacity:0}to{opacity:1}}@keyframes f-fadeOut{to{opacity:0}}.f-fadeSlowIn{animation:var(--f-transition-duration, .5s) ease both f-fadeSlowIn;z-index:2}.f-fadeSlowOut{animation:var(--f-transition-duration, .5s) ease both f-fadeSlowOut;z-index:1}@keyframes f-fadeSlowIn{0%{opacity:0}to{opacity:1}}@keyframes f-fadeSlowOut{to{opacity:0}}.f-fadeFastIn{animation:var(--f-transition-duration, .2s) ease-out both f-fadeFastIn;z-index:2}.f-fadeFastOut{animation:var(--f-transition-duration, .2s) ease-out both f-fadeFastOut;z-index:2}@keyframes f-fadeFastIn{0%{opacity:.75}to{opacity:1}}@keyframes f-fadeFastOut{to{opacity:0}}.f-crossfadeIn{animation:var(--f-transition-duration, .2s) ease-out both f-crossfadeIn;z-index:2}.f-crossfadeOut{animation:calc(var(--f-transition-duration, .2s)*.5) linear .1s both f-crossfadeOut;z-index:1}@keyframes f-crossfadeIn{0%{opacity:0}to{opacity:1}}@keyframes f-crossfadeOut{to{opacity:0}}.f-slideIn.from-next{animation:var(--f-transition-duration, .85s) cubic-bezier(.16,1,.3,1) f-slideInNext}.f-slideIn.from-prev{animation:var(--f-transition-duration, .85s) cubic-bezier(.16,1,.3,1) f-slideInPrev}.f-slideOut.to-next{animation:var(--f-transition-duration, .85s) cubic-bezier(.16,1,.3,1) f-slideOutNext}.f-slideOut.to-prev{animation:var(--f-transition-duration, .85s) cubic-bezier(.16,1,.3,1) f-slideOutPrev}@keyframes f-slideInPrev{0%{transform:translate(100%)}to{transform:translateZ(0)}}@keyframes f-slideInNext{0%{transform:translate(-100%)}to{transform:translateZ(0)}}@keyframes f-slideOutNext{to{transform:translate(-100%)}}@keyframes f-slideOutPrev{to{transform:translate(100%)}}.f-classicIn.from-next{animation:var(--f-transition-duration, .85s) cubic-bezier(.16,1,.3,1) f-classicInNext;z-index:2}.f-classicIn.from-prev{animation:var(--f-transition-duration, .85s) cubic-bezier(.16,1,.3,1) f-classicInPrev;z-index:2}.f-classicOut.to-next{animation:var(--f-transition-duration, .85s) cubic-bezier(.16,1,.3,1) f-classicOutNext;z-index:1}.f-classicOut.to-prev{animation:var(--f-transition-duration, .85s) cubic-bezier(.16,1,.3,1) f-classicOutPrev;z-index:1}@keyframes f-classicInNext{0%{transform:translate(-75px);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes f-classicInPrev{0%{transform:translate(75px);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes f-classicOutNext{to{transform:translate(-75px);opacity:0}}@keyframes f-classicOutPrev{to{transform:translate(75px);opacity:0}}:root{--f-button-width: 40px;--f-button-height: 40px;--f-button-border: 0;--f-button-border-radius: 0;--f-button-color: #374151;--f-button-bg: #f8f8f8;--f-button-hover-bg: #e0e0e0;--f-button-active-bg: #d0d0d0;--f-button-shadow: none;--f-button-transition: all .15s ease;--f-button-transform: none;--f-button-svg-width: 20px;--f-button-svg-height: 20px;--f-button-svg-stroke-width: 1.5;--f-button-svg-fill: none;--f-button-svg-filter: none;--f-button-svg-disabled-opacity: .65}.f-button{display:flex;justify-content:center;align-items:center;box-sizing:content-box;position:relative;margin:0;padding:0;width:var(--f-button-width);height:var(--f-button-height);border:var(--f-button-border);border-radius:var(--f-button-border-radius);color:var(--f-button-color);background:var(--f-button-bg);box-shadow:var(--f-button-shadow);pointer-events:all;cursor:pointer;transition:var(--f-button-transition)}@media (hover: hover){.f-button:hover:not([disabled]){color:var(--f-button-hover-color);background-color:var(--f-button-hover-bg)}}.f-button:active:not([disabled]){background-color:var(--f-button-active-bg)}.f-button:focus:not(:focus-visible){outline:none}.f-button:focus-visible{outline:none;box-shadow:inset 0 0 0 var(--f-button-outline, 2px) var(--f-button-outline-color, var(--f-button-color))}.f-button svg{width:var(--f-button-svg-width);height:var(--f-button-svg-height);fill:var(--f-button-svg-fill);stroke:currentColor;stroke-width:var(--f-button-svg-stroke-width);stroke-linecap:round;stroke-linejoin:round;transition:opacity .15s ease;transform:var(--f-button-transform);filter:var(--f-button-svg-filter);pointer-events:none}.f-button[disabled]{cursor:default}.f-button[disabled] svg{opacity:var(--f-button-svg-disabled-opacity)}.f-carousel__nav .f-button.is-prev,.f-carousel__nav .f-button.is-next,.fancybox__nav .f-button.is-prev,.fancybox__nav .f-button.is-next{position:absolute;z-index:1}.is-horizontal .f-carousel__nav .f-button.is-prev,.is-horizontal .f-carousel__nav .f-button.is-next,.is-horizontal .fancybox__nav .f-button.is-prev,.is-horizontal .fancybox__nav .f-button.is-next{top:50%;transform:translateY(-50%)}.is-horizontal .f-carousel__nav .f-button.is-prev,.is-horizontal .fancybox__nav .f-button.is-prev{left:var(--f-button-prev-pos)}.is-horizontal .f-carousel__nav .f-button.is-next,.is-horizontal .fancybox__nav .f-button.is-next{right:var(--f-button-next-pos)}.is-horizontal.is-rtl .f-carousel__nav .f-button.is-prev,.is-horizontal.is-rtl .fancybox__nav .f-button.is-prev{left:auto;right:var(--f-button-next-pos)}.is-horizontal.is-rtl .f-carousel__nav .f-button.is-next,.is-horizontal.is-rtl .fancybox__nav .f-button.is-next{right:auto;left:var(--f-button-prev-pos)}.is-vertical .f-carousel__nav .f-button.is-prev,.is-vertical .f-carousel__nav .f-button.is-next,.is-vertical .fancybox__nav .f-button.is-prev,.is-vertical .fancybox__nav .f-button.is-next{top:auto;left:50%;transform:translate(-50%)}.is-vertical .f-carousel__nav .f-button.is-prev,.is-vertical .fancybox__nav .f-button.is-prev{top:var(--f-button-next-pos)}.is-vertical .f-carousel__nav .f-button.is-next,.is-vertical .fancybox__nav .f-button.is-next{bottom:var(--f-button-next-pos)}.is-vertical .f-carousel__nav .f-button.is-prev svg,.is-vertical .f-carousel__nav .f-button.is-next svg,.is-vertical .fancybox__nav .f-button.is-prev svg,.is-vertical .fancybox__nav .f-button.is-next svg{transform:rotate(90deg)}html.with-fancybox{width:auto;overflow:visible;scroll-behavior:auto}html.with-fancybox body{touch-action:none}html.with-fancybox body.hide-scrollbar{width:auto;margin-right:calc(var(--fancybox-body-margin, 0px) + var(--fancybox-scrollbar-compensate, 0px));overflow:hidden!important;overscroll-behavior-y:none}.fancybox__container{--fancybox-color: #dbdbdb;--fancybox-hover-color: #fff;--fancybox-bg: rgba(24, 24, 27, .98);--fancybox-slide-gap: 10px;--f-spinner-width: 50px;--f-spinner-height: 50px;--f-spinner-color-1: rgba(255, 255, 255, .1);--f-spinner-color-2: #bbb;--f-spinner-stroke: 3.65;position:fixed;top:0;left:0;bottom:0;right:0;direction:ltr;display:flex;flex-direction:column;box-sizing:border-box;margin:0;padding:0;color:#f8f8f8;-webkit-tap-highlight-color:rgba(0,0,0,0);overflow:visible;z-index:1050;outline:none;transform-origin:top left;-webkit-text-size-adjust:100%;-moz-text-size-adjust:none;-ms-text-size-adjust:100%;text-size-adjust:100%;overscroll-behavior-y:contain}.fancybox__container *,.fancybox__container *:before,.fancybox__container *:after{box-sizing:inherit}.fancybox__backdrop{position:fixed;top:0;left:0;bottom:0;right:0;z-index:-1;background:var(--fancybox-bg);opacity:var(--fancybox-opacity, 1);will-change:opacity}.fancybox__carousel{position:relative;box-sizing:border-box;flex:1;min-height:0;z-index:10;overflow-y:visible;overflow-x:clip}.fancybox__viewport{width:100%;height:100%}.fancybox__track{display:flex;margin:0 auto;height:100%}.fancybox__slide{flex:0 0 auto;position:relative;display:flex;flex-direction:column;align-items:center;width:100%;height:100%;margin:0 var(--fancybox-slide-gap) 0 0;padding:4px;overflow:auto;transform:translateZ(0);backface-visibility:hidden}.fancybox__container:not(.is-compact) .fancybox__slide.has-close-btn{padding-top:40px}.fancybox__slide.has-iframe,.fancybox__slide.has-video,.fancybox__slide.has-html5video,.fancybox__slide.has-image{overflow:hidden}.fancybox__slide.has-image.is-animating,.fancybox__slide.has-image.is-selected{overflow:visible}.fancybox__slide:before,.fancybox__slide:after{content:"";flex:0 0 0;margin:auto}.fancybox__content{align-self:center;display:flex;flex-direction:column;position:relative;margin:0;padding:2rem;max-width:100%;color:var(--fancybox-content-color, #374151);background:var(--fancybox-content-bg, #fff);cursor:default;border-radius:0;z-index:20}.is-loading .fancybox__content{opacity:0}.is-draggable .fancybox__content{cursor:move;cursor:grab}.can-zoom_in .fancybox__content{cursor:zoom-in}.can-zoom_out .fancybox__content{cursor:zoom-out}.is-dragging .fancybox__content{cursor:move;cursor:grabbing}.fancybox__content [data-selectable],.fancybox__content [contenteditable]{cursor:auto}.fancybox__slide.has-image>.fancybox__content{padding:0;background:rgba(0,0,0,0);min-height:1px;background-repeat:no-repeat;background-size:contain;background-position:center center;transition:none;transform:translateZ(0);backface-visibility:hidden}.fancybox__slide.has-image>.fancybox__content>picture>img{width:100%;height:auto;max-height:100%}.is-zooming-in .fancybox__viewport:not(.is-dragging) .fancybox__slide:not(.is-selected) .fancybox__content,.is-zooming-out .fancybox__slide:not(.is-selected) .fancybox__content{visibility:hidden}.is-animating .fancybox__content,.is-dragging .fancybox__content{filter:blur(0px);will-change:transform,width,height}.fancybox-image{margin:auto;display:block;width:100%;height:100%;min-height:0;object-fit:contain;-webkit-user-select:none;user-select:none}.fancybox__caption{align-self:center;max-width:100%;flex-shrink:0;margin:0;padding:14px 0 4px;overflow-wrap:anywhere;line-height:1.375;color:var(--fancybox-color, currentColor);opacity:var(--fancybox-opacity, 1);cursor:auto;visibility:visible}.is-loading .fancybox__caption,.is-closing .fancybox__caption{opacity:0;visibility:hidden}.is-compact .fancybox__caption{padding-bottom:0}.f-button.is-close-btn{--f-button-svg-stroke-width: 2;position:absolute;top:0;right:8px;z-index:40}.fancybox__content>.f-button.is-close-btn{--f-button-width: 34px;--f-button-height: 34px;--f-button-border-radius: 4px;--f-button-color: var(--fancybox-color, #fff);--f-button-hover-color: var(--fancybox-color, #fff);--f-button-bg: transparent;--f-button-hover-bg: transparent;--f-button-active-bg: transparent;--f-button-svg-width: 22px;--f-button-svg-height: 22px;position:absolute;top:-38px;right:0;opacity:.75}.is-loading .fancybox__content>.f-button.is-close-btn{visibility:hidden}.is-zooming-out .fancybox__content>.f-button.is-close-btn{visibility:hidden}.fancybox__content>.f-button.is-close-btn:hover{opacity:1}.fancybox__footer{padding:0;margin:0;position:relative}.fancybox__footer .fancybox__caption{width:100%;padding:24px;opacity:var(--fancybox-opacity, 1);transition:all .25s ease}.is-compact .fancybox__footer{position:absolute;bottom:0;left:0;right:0;z-index:20;background:rgba(24,24,27,.5)}.is-compact .fancybox__footer .fancybox__caption{padding:12px}.is-compact .fancybox__content>.f-button.is-close-btn{--f-button-border-radius: 50%;--f-button-color: #fff;--f-button-hover-color: #fff;--f-button-outline-color: #000;--f-button-bg: rgba(0, 0, 0, .6);--f-button-active-bg: rgba(0, 0, 0, .6);--f-button-hover-bg: rgba(0, 0, 0, .6);--f-button-svg-width: 18px;--f-button-svg-height: 18px;--f-button-svg-filter: none;top:5px;right:5px}.fancybox__nav{--f-button-width: 50px;--f-button-height: 50px;--f-button-border: 0;--f-button-border-radius: 50%;--f-button-color: var(--fancybox-color);--f-button-hover-color: var(--fancybox-hover-color);--f-button-bg: transparent;--f-button-hover-bg: rgba(24, 24, 27, .3);--f-button-active-bg: rgba(24, 24, 27, .5);--f-button-shadow: none;--f-button-transition: all .15s ease;--f-button-transform: none;--f-button-svg-width: 26px;--f-button-svg-height: 26px;--f-button-svg-stroke-width: 2.5;--f-button-svg-fill: none;--f-button-svg-filter: drop-shadow(1px 1px 1px rgba(24, 24, 27, .5));--f-button-svg-disabled-opacity: .65;--f-button-next-pos: 1rem;--f-button-prev-pos: 1rem;opacity:var(--fancybox-opacity, 1)}.fancybox__nav .f-button:before{position:absolute;content:"";top:-30px;right:-20px;left:-20px;bottom:-30px;z-index:1}.is-idle .fancybox__nav{animation:.15s ease-out both f-fadeOut}.is-idle.is-compact .fancybox__footer{pointer-events:none;animation:.15s ease-out both f-fadeOut}.fancybox__slide>.f-spinner{position:absolute;top:50%;left:50%;margin:var(--f-spinner-top, calc(var(--f-spinner-width) * -.5)) 0 0 var(--f-spinner-left, calc(var(--f-spinner-height) * -.5));z-index:30;cursor:pointer}.fancybox-protected{position:absolute;top:0;left:0;right:0;bottom:0;z-index:40;-webkit-user-select:none;user-select:none}.fancybox-ghost{position:absolute;top:0;left:0;width:100%;height:100%;min-height:0;object-fit:contain;z-index:40;-webkit-user-select:none;user-select:none;pointer-events:none}.fancybox-focus-guard{outline:none;opacity:0;position:fixed;pointer-events:none}.fancybox__container:not([aria-hidden]){opacity:0}.fancybox__container.is-animated[aria-hidden=false]>*:not(.fancybox__backdrop,.fancybox__carousel),.fancybox__container.is-animated[aria-hidden=false] .fancybox__carousel>*:not(.fancybox__viewport),.fancybox__container.is-animated[aria-hidden=false] .fancybox__slide>*:not(.fancybox__content){animation:.25s ease .1s backwards f-fadeIn}.fancybox__container.is-animated[aria-hidden=false] .fancybox__backdrop{animation:.35s ease backwards f-fadeIn}.fancybox__container.is-animated[aria-hidden=true]>*:not(.fancybox__backdrop,.fancybox__carousel),.fancybox__container.is-animated[aria-hidden=true] .fancybox__carousel>*:not(.fancybox__viewport),.fancybox__container.is-animated[aria-hidden=true] .fancybox__slide>*:not(.fancybox__content){animation:.15s ease forwards f-fadeOut}.fancybox__container.is-animated[aria-hidden=true] .fancybox__backdrop{animation:.35s ease forwards f-fadeOut}.has-iframe .fancybox__content,.has-map .fancybox__content,.has-pdf .fancybox__content,.has-youtube .fancybox__content,.has-vimeo .fancybox__content,.has-html5video .fancybox__content{max-width:100%;flex-shrink:1;min-height:1px;overflow:visible}.has-iframe .fancybox__content,.has-map .fancybox__content,.has-pdf .fancybox__content{width:100%;height:100%}.fancybox__container:not(.is-compact) .has-iframe .fancybox__content,.fancybox__container:not(.is-compact) .has-map .fancybox__content,.fancybox__container:not(.is-compact) .has-pdf .fancybox__content{width:calc(100% - 120px);height:90%}.has-youtube .fancybox__content,.has-vimeo .fancybox__content,.has-html5video .fancybox__content{width:960px;height:540px;max-width:100%;max-height:100%}.has-map .fancybox__content,.has-pdf .fancybox__content,.has-youtube .fancybox__content,.has-vimeo .fancybox__content,.has-html5video .fancybox__content{padding:0;background:rgba(24,24,27,.9);color:#fff}.has-map .fancybox__content{background:#e5e3df}.fancybox__html5video,.fancybox__iframe{border:0;display:block;height:100%;width:100%;background:rgba(0,0,0,0)}.fancybox-placeholder{border:0!important;clip:rect(1px,1px,1px,1px)!important;-webkit-clip-path:inset(50%)!important;clip-path:inset(50%)!important;height:1px!important;margin:-1px!important;overflow:hidden!important;padding:0!important;position:absolute!important;width:1px!important;white-space:nowrap!important}.f-carousel__thumbs{--f-thumb-width: 96px;--f-thumb-height: 72px;--f-thumb-outline: 0;--f-thumb-outline-color: #5eb0ef;--f-thumb-opacity: 1;--f-thumb-hover-opacity: 1;--f-thumb-selected-opacity: 1;--f-thumb-border-radius: 2px;--f-thumb-offset: 0px;--f-button-next-pos: 0;--f-button-prev-pos: 0}.f-carousel__thumbs.is-classic{--f-thumb-gap: 8px;--f-thumb-opacity: .5;--f-thumb-hover-opacity: 1;--f-thumb-selected-opacity: 1}.f-carousel__thumbs.is-modern{--f-thumb-gap: 4px;--f-thumb-extra-gap: 20px;--f-thumb-clip-width: 46px}.f-thumbs{position:relative;flex:0 0 auto;margin:0;overflow:hidden;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;user-select:none;perspective:1000px;transform:translateZ(0)}.f-thumbs .f-spinner{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:2px;background-image:linear-gradient(#ebeff2,#e2e8f0);z-index:-1}.f-thumbs .f-spinner svg{display:none}.f-thumbs.is-vertical{height:100%}.f-thumbs__viewport{width:100%;height:auto;overflow:hidden}.f-thumbs__track{display:flex;will-change:transform}.f-thumbs__slide{position:relative;flex:0 0 auto;box-sizing:content-box;display:flex;align-items:center;justify-content:center;padding:0;margin:0;width:var(--f-thumb-width);min-width:var(--f-thumb-width);height:var(--f-thumb-height);overflow:visible;cursor:pointer}.f-thumbs__slide.is-loading img{opacity:0}.is-classic .f-thumbs__viewport{height:100%}.is-modern .f-thumbs__track{width:max-content}.is-modern .f-thumbs__track:before{content:"";position:absolute;top:0;bottom:0;left:calc(var(--left, 0)*1px);width:calc(100% - var(--width, 0)*1px);cursor:pointer}.is-modern .f-thumbs__slide{--clip-path: inset( 0 calc( (var(--f-thumb-width, 0) - var(--f-thumb-clip-width, 0)) * .5 * (1 - var(--progress, 0)) ) round var(--f-thumb-border-radius, 0) );transform:translate3d(calc(var(--shift, 0) * -1px),0,0);transition:none;pointer-events:none}.is-modern .f-thumbs__slide:focus-within:not(.is-selected){filter:drop-shadow(-1px 0px 0px var(--f-thumb-outline-color)) drop-shadow(2px 0px 0px var(--f-thumb-outline-color)) drop-shadow(0px -1px 0px var(--f-thumb-outline-color)) drop-shadow(0px 2px 0px var(--f-thumb-outline-color))}.is-modern .f-thumbs__slide>*{clip-path:var(--clip-path)}.is-modern.in-touch .f-thumbs__slide{filter:none}.is-modern.is-resting .f-thumbs__slide{transition:all .33s ease}.is-modern.is-resting .f-thumbs__slide>*{transition:all .33s ease}.f-thumbs__slide__button{-webkit-appearance:none;-moz-appearance:none;appearance:none;width:100%;height:100%;margin:0;padding:0;border:0;position:relative;border-radius:var(--f-thumb-border-radius);overflow:hidden;background:rgba(0,0,0,0);outline:none;cursor:pointer;pointer-events:auto;touch-action:manipulation;opacity:var(--f-thumb-opacity);transition:opacity .2s ease}.f-thumbs__slide__button:hover{opacity:var(--f-thumb-hover-opacity)}.f-thumbs__slide__button:focus:not(:focus-visible){outline:none}.f-thumbs__slide__button:focus-visible{outline:none;opacity:var(--f-thumb-selected-opacity)}.is-nav-selected .f-thumbs__slide__button{opacity:var(--f-thumb-selected-opacity)}.is-nav-selected .f-thumbs__slide__button:after{content:"";position:absolute;top:0;left:0;right:0;height:auto;bottom:0;border:var(--f-thumb-outline, 0) solid var(--f-thumb-outline-color, transparent);border-radius:var(--f-thumb-border-radius);animation:f-fadeIn .2s ease-out;z-index:10}.f-thumbs__slide__img{position:absolute;overflow:hidden;top:0;right:0;bottom:0;left:0;width:100%;height:100%;padding:var(--f-thumb-offset);box-sizing:border-box;pointer-events:none;object-fit:cover}.f-thumbs.is-horizontal .f-thumbs__track{margin:0 auto;padding:8px 0 12px}.f-thumbs.is-horizontal .f-thumbs__slide{margin:0 var(--f-thumb-gap) 0 0}.f-thumbs.is-vertical .f-thumbs__track{flex-wrap:wrap;margin:auto 0;padding:0 8px}.f-thumbs.is-vertical .f-thumbs__slide{margin:0 0 var(--f-thumb-gap) 0}.fancybox__thumbs{--f-thumb-width: 96px;--f-thumb-height: 72px;--f-thumb-border-radius: 2px;--f-thumb-outline: 2px;--f-thumb-outline-color: #ededed;position:relative;opacity:var(--fancybox-opacity, 1);transition:max-height .35s cubic-bezier(.23,1,.32,1)}.fancybox__thumbs.is-classic{--f-thumb-gap: 8px;--f-thumb-opacity: .5;--f-thumb-hover-opacity: 1}.fancybox__thumbs.is-classic .f-spinner{background-image:linear-gradient(rgba(255,255,255,.1),rgba(255,255,255,.05))}.fancybox__thumbs.is-modern{--f-thumb-gap: 4px;--f-thumb-extra-gap: 20px;--f-thumb-clip-width: 46px;--f-thumb-opacity: 1;--f-thumb-hover-opacity: 1}.fancybox__thumbs.is-modern .f-spinner{background-image:linear-gradient(rgba(255,255,255,.1),rgba(255,255,255,.05))}.fancybox__thumbs.is-horizontal{padding:0 var(--f-thumb-gap)}.fancybox__thumbs.is-vertical{padding:var(--f-thumb-gap) 0}.is-compact .fancybox__thumbs{--f-thumb-width: 64px;--f-thumb-clip-width: 32px;--f-thumb-height: 48px;--f-thumb-extra-gap: 10px}.fancybox__thumbs.is-masked{max-height:0px!important}.is-closing .fancybox__thumbs{transition:none!important}.fancybox__toolbar{--f-progress-color: var(--fancybox-color, rgba(255, 255, 255, .94));--f-button-width: 46px;--f-button-height: 46px;--f-button-color: var(--fancybox-color);--f-button-hover-color: var(--fancybox-hover-color);--f-button-bg: rgba(24, 24, 27, .65);--f-button-hover-bg: rgba(70, 70, 73, .65);--f-button-active-bg: rgba(90, 90, 93, .65);--f-button-border-radius: 0;--f-button-svg-width: 24px;--f-button-svg-height: 24px;--f-button-svg-stroke-width: 1.5;--f-button-svg-filter: drop-shadow(1px 1px 1px rgba(24, 24, 27, .15));--f-button-svg-fill: none;--f-button-svg-disabled-opacity: .65;display:flex;flex-direction:row;justify-content:space-between;margin:0;padding:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI Adjusted,Segoe UI,Liberation Sans,sans-serif;color:var(--fancybox-color, currentColor);opacity:var(--fancybox-opacity, 1);text-shadow:var(--fancybox-toolbar-text-shadow, 1px 1px 1px rgba(0, 0, 0, .5));pointer-events:none;z-index:20}.fancybox__toolbar :focus-visible{z-index:1}.fancybox__toolbar.is-absolute,.is-compact .fancybox__toolbar{position:absolute;top:0;left:0;right:0}.is-idle .fancybox__toolbar{pointer-events:none;animation:.15s ease-out both f-fadeOut}.fancybox__toolbar__column{display:flex;flex-direction:row;flex-wrap:wrap;align-content:flex-start}.fancybox__toolbar__column.is-left,.fancybox__toolbar__column.is-right{flex-grow:1;flex-basis:0}.fancybox__toolbar__column.is-right{display:flex;justify-content:flex-end;flex-wrap:nowrap}.fancybox__infobar{padding:0 5px;line-height:var(--f-button-height);text-align:center;font-size:17px;font-variant-numeric:tabular-nums;-webkit-font-smoothing:subpixel-antialiased;cursor:default;-webkit-user-select:none;user-select:none}.fancybox__infobar span{padding:0 5px}.fancybox__infobar:not(:first-child):not(:last-child){background:var(--f-button-bg)}[data-fancybox-toggle-slideshow]{position:relative}[data-fancybox-toggle-slideshow] .f-progress{height:100%;opacity:.3}[data-fancybox-toggle-slideshow] svg g:first-child{display:flex}[data-fancybox-toggle-slideshow] svg g:last-child{display:none}.has-slideshow [data-fancybox-toggle-slideshow] svg g:first-child{display:none}.has-slideshow [data-fancybox-toggle-slideshow] svg g:last-child{display:flex}[data-fancybox-toggle-fullscreen] svg g:first-child{display:flex}[data-fancybox-toggle-fullscreen] svg g:last-child{display:none}:fullscreen [data-fancybox-toggle-fullscreen] svg g:first-child{display:none}:fullscreen [data-fancybox-toggle-fullscreen] svg g:last-child{display:flex}.f-progress{position:absolute;top:0;left:0;right:0;height:3px;transform:scaleX(0);transform-origin:0;transition-property:transform;transition-timing-function:linear;background:var(--f-progress-color, var(--f-carousel-theme-color, #0091ff));z-index:30;-webkit-user-select:none;user-select:none;pointer-events:none}:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","\u5FAE\u8F6F\u96C5\u9ED1",Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:.3s;--el-transition-duration-fast:.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(.645, .045, .355, 1);--el-transition-function-fast-bezier:cubic-bezier(.23, 1, .32, 1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px}:root{color-scheme:light;--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary:#409eff;--el-color-primary-light-3:#79bbff;--el-color-primary-light-5:#a0cfff;--el-color-primary-light-7:#c6e2ff;--el-color-primary-light-8:#d9ecff;--el-color-primary-light-9:#ecf5ff;--el-color-primary-dark-2:#337ecc;--el-color-success:#67c23a;--el-color-success-light-3:#95d475;--el-color-success-light-5:#b3e19d;--el-color-success-light-7:#d1edc4;--el-color-success-light-8:#e1f3d8;--el-color-success-light-9:#f0f9eb;--el-color-success-dark-2:#529b2e;--el-color-warning:#e6a23c;--el-color-warning-light-3:#eebe77;--el-color-warning-light-5:#f3d19e;--el-color-warning-light-7:#f8e3c5;--el-color-warning-light-8:#faecd8;--el-color-warning-light-9:#fdf6ec;--el-color-warning-dark-2:#b88230;--el-color-danger:#f56c6c;--el-color-danger-light-3:#f89898;--el-color-danger-light-5:#fab6b6;--el-color-danger-light-7:#fcd3d3;--el-color-danger-light-8:#fde2e2;--el-color-danger-light-9:#fef0f0;--el-color-danger-dark-2:#c45656;--el-color-error:#f56c6c;--el-color-error-light-3:#f89898;--el-color-error-light-5:#fab6b6;--el-color-error-light-7:#fcd3d3;--el-color-error-light-8:#fde2e2;--el-color-error-light-9:#fef0f0;--el-color-error-dark-2:#c45656;--el-color-info:#909399;--el-color-info-light-3:#b1b3b8;--el-color-info-light-5:#c8c9cc;--el-color-info-light-7:#dedfe0;--el-color-info-light-8:#e9e9eb;--el-color-info-light-9:#f4f4f5;--el-color-info-dark-2:#73767a;--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0, 0, 0, .04),0px 8px 20px rgba(0, 0, 0, .08);--el-box-shadow-light:0px 0px 12px rgba(0, 0, 0, .12);--el-box-shadow-lighter:0px 0px 6px rgba(0, 0, 0, .12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0, 0, 0, .08),0px 12px 32px rgba(0, 0, 0, .12),0px 8px 16px -8px rgba(0, 0, 0, .16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0, 0, 0, .8);--el-overlay-color-light:rgba(0, 0, 0, .7);--el-overlay-color-lighter:rgba(0, 0, 0, .5);--el-mask-color:rgba(255, 255, 255, .9);--el-mask-color-extra-light:rgba(255, 255, 255, .3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:20px;--el-dialog-border-radius:var(--el-border-radius-small);position:relative;margin:var(--el-dialog-margin-top,15vh) auto 50px;background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:0!important}.el-dialog.is-align-center{margin:auto}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;margin-bottom:0;height:100%;overflow:auto}.el-dialog__wrapper{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto;margin:0}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-dialog__header{padding:var(--el-dialog-padding-primary);padding-bottom:10px;margin-right:16px}.el-dialog__headerbtn{position:absolute;top:6px;right:0;padding:0;width:54px;height:54px;background:0 0;border:none;outline:0;cursor:pointer;font-size:var(--el-message-close-size,16px)}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{line-height:var(--el-dialog-font-line-height);font-size:var(--el-dialog-title-font-size);color:var(--el-text-color-primary)}.el-dialog__body{padding:calc(var(--el-dialog-padding-primary) + 10px) var(--el-dialog-padding-primary);color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size)}.el-dialog__footer{padding:var(--el-dialog-padding-primary);padding-top:10px;text-align:right;box-sizing:border-box}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial;padding:25px calc(var(--el-dialog-padding-primary) + 5px) 30px}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-overlay-dialog{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto}.dialog-fade-enter-active{-webkit-animation:modal-fade-in var(--el-transition-duration);animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{-webkit-animation:dialog-fade-in var(--el-transition-duration);animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{-webkit-animation:modal-fade-out var(--el-transition-duration);animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{-webkit-animation:dialog-fade-out var(--el-transition-duration);animation:dialog-fade-out var(--el-transition-duration)}@-webkit-keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@-webkit-keyframes dialog-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}@keyframes dialog-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}@-webkit-keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@-webkit-keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}@keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}.el-overlay{position:fixed;top:0;right:0;bottom:0;left:0;z-index:2000;height:100%;background-color:var(--el-overlay-color-lighter);overflow:auto}.el-overlay .el-overlay-root{height:0}.el-container{display:flex;flex-direction:row;flex:1;flex-basis:auto;box-sizing:border-box;min-width:0}.el-container.is-vertical{flex-direction:column}.el-aside{overflow:auto;box-sizing:border-box;flex-shrink:0;width:var(--el-aside-width,300px)}.el-footer{--el-footer-padding:0 20px;--el-footer-height:60px;padding:var(--el-footer-padding);box-sizing:border-box;flex-shrink:0;height:var(--el-footer-height)}.el-header{--el-header-padding:0 20px;--el-header-height:60px;padding:var(--el-header-padding);box-sizing:border-box;flex-shrink:0;height:var(--el-header-height)}.el-main{--el-main-padding:20px;display:block;flex:1;flex-basis:auto;overflow:auto;box-sizing:border-box;padding:var(--el-main-padding)}.el-tabs{--el-tabs-header-height:40px}.el-tabs__header{padding:0;position:relative;margin:0 0 15px}.el-tabs__active-bar{position:absolute;bottom:0;left:0;height:2px;background-color:var(--el-color-primary);z-index:1;transition:width var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),transform var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);list-style:none}.el-tabs__new-tab{display:flex;align-items:center;justify-content:center;float:right;border:1px solid var(--el-border-color);height:20px;width:20px;line-height:20px;margin:10px 0 10px 10px;border-radius:3px;text-align:center;font-size:12px;color:var(--el-text-color-primary);cursor:pointer;transition:all .15s}.el-tabs__new-tab .is-icon-plus{height:inherit;width:inherit;transform:scale(.8)}.el-tabs__new-tab .is-icon-plus svg{vertical-align:middle}.el-tabs__new-tab:hover{color:var(--el-color-primary)}.el-tabs__nav-wrap{overflow:hidden;margin-bottom:-1px;position:relative}.el-tabs__nav-wrap:after{content:"";position:absolute;left:0;bottom:0;width:100%;height:2px;background-color:var(--el-border-color-light);z-index:var(--el-index-normal)}.el-tabs__nav-wrap.is-scrollable{padding:0 20px;box-sizing:border-box}.el-tabs__nav-scroll{overflow:hidden}.el-tabs__nav-next,.el-tabs__nav-prev{position:absolute;cursor:pointer;line-height:44px;font-size:12px;color:var(--el-text-color-secondary);width:20px;text-align:center}.el-tabs__nav-next{right:0}.el-tabs__nav-prev{left:0}.el-tabs__nav{display:flex;white-space:nowrap;position:relative;transition:transform var(--el-transition-duration);float:left;z-index:calc(var(--el-index-normal) + 1)}.el-tabs__nav.is-stretch{min-width:100%;display:flex}.el-tabs__nav.is-stretch>*{flex:1;text-align:center}.el-tabs__item{padding:0 20px;height:var(--el-tabs-header-height);box-sizing:border-box;display:flex;align-items:center;justify-content:center;list-style:none;font-size:var(--el-font-size-base);font-weight:500;color:var(--el-text-color-primary);position:relative}.el-tabs__item:focus,.el-tabs__item:focus:active{outline:0}.el-tabs__item:focus-visible{box-shadow:0 0 2px 2px var(--el-color-primary) inset;border-radius:3px}.el-tabs__item .is-icon-close{border-radius:50%;text-align:center;transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);margin-left:5px}.el-tabs__item .is-icon-close:before{transform:scale(.9);display:inline-block}.el-tabs__item .is-icon-close:hover{background-color:var(--el-text-color-placeholder);color:#fff}.el-tabs__item.is-active{color:var(--el-color-primary)}.el-tabs__item:hover{color:var(--el-color-primary);cursor:pointer}.el-tabs__item.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-tabs__content{overflow:hidden;position:relative}.el-tabs--card>.el-tabs__header{border-bottom:1px solid var(--el-border-color-light);height:var(--el-tabs-header-height)}.el-tabs--card>.el-tabs__header .el-tabs__nav-wrap:after{content:none}.el-tabs--card>.el-tabs__header .el-tabs__nav{border:1px solid var(--el-border-color-light);border-bottom:none;border-radius:4px 4px 0 0;box-sizing:border-box}.el-tabs--card>.el-tabs__header .el-tabs__active-bar{display:none}.el-tabs--card>.el-tabs__header .el-tabs__item .is-icon-close{position:relative;font-size:12px;width:0;height:14px;overflow:hidden;right:-2px;transform-origin:100% 50%}.el-tabs--card>.el-tabs__header .el-tabs__item{border-bottom:1px solid transparent;border-left:1px solid var(--el-border-color-light);transition:color var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),padding var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs--card>.el-tabs__header .el-tabs__item:first-child{border-left:none}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover{padding-left:13px;padding-right:13px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover .is-icon-close{width:14px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active{border-bottom-color:var(--el-bg-color)}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable{padding-left:20px;padding-right:20px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable .is-icon-close{width:14px}.el-tabs--border-card{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color)}.el-tabs--border-card>.el-tabs__content{padding:15px}.el-tabs--border-card>.el-tabs__header{background-color:var(--el-fill-color-light);border-bottom:1px solid var(--el-border-color-light);margin:0}.el-tabs--border-card>.el-tabs__header .el-tabs__nav-wrap:after{content:none}.el-tabs--border-card>.el-tabs__header .el-tabs__item{transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);border:1px solid transparent;margin-top:-1px;color:var(--el-text-color-secondary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item:first-child{margin-left:-1px}.el-tabs--border-card>.el-tabs__header .el-tabs__item+.el-tabs__item{margin-left:-1px}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-active{color:var(--el-color-primary);background-color:var(--el-bg-color-overlay);border-right-color:var(--el-border-color);border-left-color:var(--el-border-color)}.el-tabs--border-card>.el-tabs__header .el-tabs__item:not(.is-disabled):hover{color:var(--el-color-primary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-disabled{color:var(--el-disabled-text-color)}.el-tabs--border-card>.el-tabs__header .is-scrollable .el-tabs__item:first-child{margin-left:0}.el-tabs--bottom .el-tabs__item.is-bottom:nth-child(2),.el-tabs--bottom .el-tabs__item.is-top:nth-child(2),.el-tabs--top .el-tabs__item.is-bottom:nth-child(2),.el-tabs--top .el-tabs__item.is-top:nth-child(2){padding-left:0}.el-tabs--bottom .el-tabs__item.is-bottom:last-child,.el-tabs--bottom .el-tabs__item.is-top:last-child,.el-tabs--top .el-tabs__item.is-bottom:last-child,.el-tabs--top .el-tabs__item.is-top:last-child{padding-right:0}.el-tabs--bottom .el-tabs--left>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom .el-tabs--right>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top .el-tabs--left>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top .el-tabs--right>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2){padding-left:20px}.el-tabs--bottom .el-tabs--left>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--bottom .el-tabs--right>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--top .el-tabs--left>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--top .el-tabs--right>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover{padding-left:13px}.el-tabs--bottom .el-tabs--left>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom .el-tabs--right>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top .el-tabs--left>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top .el-tabs--right>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:last-child{padding-right:20px}.el-tabs--bottom .el-tabs--left>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--bottom .el-tabs--right>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--top .el-tabs--left>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--top .el-tabs--right>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover{padding-right:13px}.el-tabs--bottom .el-tabs__header.is-bottom{margin-bottom:0;margin-top:10px}.el-tabs--bottom.el-tabs--border-card .el-tabs__header.is-bottom{border-bottom:0;border-top:1px solid var(--el-border-color)}.el-tabs--bottom.el-tabs--border-card .el-tabs__nav-wrap.is-bottom{margin-top:-1px;margin-bottom:0}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom:not(.is-active){border:1px solid transparent}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom{margin:0 -1px -1px}.el-tabs--left,.el-tabs--right{overflow:hidden}.el-tabs--left .el-tabs__header.is-left,.el-tabs--left .el-tabs__header.is-right,.el-tabs--left .el-tabs__nav-scroll,.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__header.is-left,.el-tabs--right .el-tabs__header.is-right,.el-tabs--right .el-tabs__nav-scroll,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{height:100%}.el-tabs--left .el-tabs__active-bar.is-left,.el-tabs--left .el-tabs__active-bar.is-right,.el-tabs--right .el-tabs__active-bar.is-left,.el-tabs--right .el-tabs__active-bar.is-right{top:0;bottom:auto;width:2px;height:auto}.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{margin-bottom:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{height:30px;line-height:30px;width:100%;text-align:center;cursor:pointer}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i{transform:rotate(90deg)}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{left:auto;top:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next{right:auto;bottom:0}.el-tabs--left .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--left .el-tabs__nav-wrap.is-right.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-right.is-scrollable{padding:30px 0}.el-tabs--left .el-tabs__nav-wrap.is-left:after,.el-tabs--left .el-tabs__nav-wrap.is-right:after,.el-tabs--right .el-tabs__nav-wrap.is-left:after,.el-tabs--right .el-tabs__nav-wrap.is-right:after{height:100%;width:2px;bottom:auto;top:0}.el-tabs--left .el-tabs__nav.is-left,.el-tabs--left .el-tabs__nav.is-right,.el-tabs--right .el-tabs__nav.is-left,.el-tabs--right .el-tabs__nav.is-right{flex-direction:column}.el-tabs--left .el-tabs__item.is-left,.el-tabs--right .el-tabs__item.is-left{justify-content:flex-end}.el-tabs--left .el-tabs__item.is-right,.el-tabs--right .el-tabs__item.is-right{justify-content:flex-start}.el-tabs--left .el-tabs__header.is-left{float:left;margin-bottom:0;margin-right:10px}.el-tabs--left .el-tabs__nav-wrap.is-left{margin-right:-1px}.el-tabs--left .el-tabs__nav-wrap.is-left:after{left:auto;right:0}.el-tabs--left .el-tabs__active-bar.is-left{right:0;left:auto}.el-tabs--left .el-tabs__item.is-left{text-align:right}.el-tabs--left.el-tabs--card .el-tabs__active-bar.is-left{display:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left{border-left:none;border-right:1px solid var(--el-border-color-light);border-bottom:none;border-top:1px solid var(--el-border-color-light);text-align:left}.el-tabs--left.el-tabs--card .el-tabs__item.is-left:first-child{border-right:1px solid var(--el-border-color-light);border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active{border:1px solid var(--el-border-color-light);border-right-color:#fff;border-left:none;border-bottom:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:first-child{border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:last-child{border-bottom:none}.el-tabs--left.el-tabs--card .el-tabs__nav{border-radius:4px 0 0 4px;border-bottom:1px solid var(--el-border-color-light);border-right:none}.el-tabs--left.el-tabs--card .el-tabs__new-tab{float:none}.el-tabs--left.el-tabs--border-card .el-tabs__header.is-left{border-right:1px solid var(--el-border-color)}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left{border:1px solid transparent;margin:-1px 0 -1px -1px}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left.is-active{border-color:transparent;border-top-color:#d1dbe5;border-bottom-color:#d1dbe5}.el-tabs--right .el-tabs__header.is-right{float:right;margin-bottom:0;margin-left:10px}.el-tabs--right .el-tabs__nav-wrap.is-right{margin-left:-1px}.el-tabs--right .el-tabs__nav-wrap.is-right:after{left:0;right:auto}.el-tabs--right .el-tabs__active-bar.is-right{left:0}.el-tabs--right.el-tabs--card .el-tabs__active-bar.is-right{display:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right{border-bottom:none;border-top:1px solid var(--el-border-color-light)}.el-tabs--right.el-tabs--card .el-tabs__item.is-right:first-child{border-left:1px solid var(--el-border-color-light);border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active{border:1px solid var(--el-border-color-light);border-left-color:#fff;border-right:none;border-bottom:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:first-child{border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:last-child{border-bottom:none}.el-tabs--right.el-tabs--card .el-tabs__nav{border-radius:0 4px 4px 0;border-bottom:1px solid var(--el-border-color-light);border-left:none}.el-tabs--right.el-tabs--border-card .el-tabs__header.is-right{border-left:1px solid var(--el-border-color)}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right{border:1px solid transparent;margin:-1px -1px -1px 0}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right.is-active{border-color:transparent;border-top-color:#d1dbe5;border-bottom-color:#d1dbe5}.slideInLeft-transition,.slideInRight-transition{display:inline-block}.slideInRight-enter{-webkit-animation:slideInRight-enter var(--el-transition-duration);animation:slideInRight-enter var(--el-transition-duration)}.slideInRight-leave{position:absolute;left:0;right:0;-webkit-animation:slideInRight-leave var(--el-transition-duration);animation:slideInRight-leave var(--el-transition-duration)}.slideInLeft-enter{-webkit-animation:slideInLeft-enter var(--el-transition-duration);animation:slideInLeft-enter var(--el-transition-duration)}.slideInLeft-leave{position:absolute;left:0;right:0;-webkit-animation:slideInLeft-leave var(--el-transition-duration);animation:slideInLeft-leave var(--el-transition-duration)}@-webkit-keyframes slideInRight-enter{0%{opacity:0;transform-origin:0 0;transform:translate(100%)}to{opacity:1;transform-origin:0 0;transform:translate(0)}}@keyframes slideInRight-enter{0%{opacity:0;transform-origin:0 0;transform:translate(100%)}to{opacity:1;transform-origin:0 0;transform:translate(0)}}@-webkit-keyframes slideInRight-leave{0%{transform-origin:0 0;transform:translate(0);opacity:1}to{transform-origin:0 0;transform:translate(100%);opacity:0}}@keyframes slideInRight-leave{0%{transform-origin:0 0;transform:translate(0);opacity:1}to{transform-origin:0 0;transform:translate(100%);opacity:0}}@-webkit-keyframes slideInLeft-enter{0%{opacity:0;transform-origin:0 0;transform:translate(-100%)}to{opacity:1;transform-origin:0 0;transform:translate(0)}}@keyframes slideInLeft-enter{0%{opacity:0;transform-origin:0 0;transform:translate(-100%)}to{opacity:1;transform-origin:0 0;transform:translate(0)}}@-webkit-keyframes slideInLeft-leave{0%{transform-origin:0 0;transform:translate(0);opacity:1}to{transform-origin:0 0;transform:translate(-100%);opacity:0}}@keyframes slideInLeft-leave{0%{transform-origin:0 0;transform:translate(0);opacity:1}to{transform-origin:0 0;transform:translate(-100%);opacity:0}}.el-icon-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@-webkit-keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.el-icon{--color:inherit;height:1em;width:1em;line-height:1em;display:inline-flex;justify-content:center;align-items:center;position:relative;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}.container[data-v-c6eaee5b]{position:relative;width:24px;aspect-ratio:1;display:flex;justify-content:center;align-items:center;cursor:pointer}.container>*[data-v-c6eaee5b]{position:absolute;display:flex;justify-content:center;align-items:center}.v-enter-active[data-v-c6eaee5b],.v-leave-active[data-v-c6eaee5b]{transition:opacity .5s ease}.v-enter-from[data-v-c6eaee5b],.v-leave-to[data-v-c6eaee5b]{opacity:0}.el-checkbox{--el-checkbox-font-size:14px;--el-checkbox-font-weight:var(--el-font-weight-primary);--el-checkbox-text-color:var(--el-text-color-regular);--el-checkbox-input-height:14px;--el-checkbox-input-width:14px;--el-checkbox-border-radius:var(--el-border-radius-small);--el-checkbox-bg-color:var(--el-fill-color-blank);--el-checkbox-input-border:var(--el-border);--el-checkbox-disabled-border-color:var(--el-border-color);--el-checkbox-disabled-input-fill:var(--el-fill-color-light);--el-checkbox-disabled-icon-color:var(--el-text-color-placeholder);--el-checkbox-disabled-checked-input-fill:var(--el-border-color-extra-light);--el-checkbox-disabled-checked-input-border-color:var(--el-border-color);--el-checkbox-disabled-checked-icon-color:var(--el-text-color-placeholder);--el-checkbox-checked-text-color:var(--el-color-primary);--el-checkbox-checked-input-border-color:var(--el-color-primary);--el-checkbox-checked-bg-color:var(--el-color-primary);--el-checkbox-checked-icon-color:var(--el-color-white);--el-checkbox-input-border-color-hover:var(--el-color-primary)}.el-checkbox{color:var(--el-checkbox-text-color);font-weight:var(--el-checkbox-font-weight);font-size:var(--el-font-size-base);position:relative;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin-right:30px;height:var(--el-checkbox-height,32px)}.el-checkbox.is-disabled{cursor:not-allowed}.el-checkbox.is-bordered{padding:0 15px 0 9px;border-radius:var(--el-border-radius-base);border:var(--el-border);box-sizing:border-box}.el-checkbox.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-checkbox.is-bordered.is-disabled{border-color:var(--el-border-color-lighter)}.el-checkbox.is-bordered.el-checkbox--large{padding:0 19px 0 11px;border-radius:var(--el-border-radius-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__label{font-size:var(--el-font-size-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.is-bordered.el-checkbox--small{padding:0 11px 0 7px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox input:focus-visible+.el-checkbox__inner{outline:2px solid var(--el-checkbox-input-border-color-hover);outline-offset:1px;border-radius:var(--el-checkbox-border-radius)}.el-checkbox__input{white-space:nowrap;cursor:pointer;outline:0;display:inline-flex;position:relative}.el-checkbox__input.is-disabled .el-checkbox__inner{background-color:var(--el-checkbox-disabled-input-fill);border-color:var(--el-checkbox-disabled-border-color);cursor:not-allowed}.el-checkbox__input.is-disabled .el-checkbox__inner:after{cursor:not-allowed;border-color:var(--el-checkbox-disabled-icon-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-disabled-checked-icon-color);border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled+span.el-checkbox__label{color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox__input.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-checked .el-checkbox__inner:after{transform:rotate(45deg) scaleY(1);border-color:var(--el-checkbox-checked-icon-color)}.el-checkbox__input.is-checked+.el-checkbox__label{color:var(--el-checkbox-checked-text-color)}.el-checkbox__input.is-focus:not(.is-checked) .el-checkbox__original:not(:focus-visible){border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__input.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:before{content:"";position:absolute;display:block;background-color:var(--el-checkbox-checked-icon-color);height:2px;transform:scale(.5);left:0;right:0;top:5px}.el-checkbox__input.is-indeterminate .el-checkbox__inner:after{display:none}.el-checkbox__inner{display:inline-block;position:relative;border:var(--el-checkbox-input-border);border-radius:var(--el-checkbox-border-radius);box-sizing:border-box;width:var(--el-checkbox-input-width);height:var(--el-checkbox-input-height);background-color:var(--el-checkbox-bg-color);z-index:var(--el-index-normal);transition:border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46),outline .25s cubic-bezier(.71,-.46,.29,1.46)}.el-checkbox__inner:hover{border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__inner:after{box-sizing:content-box;content:"";border:1px solid transparent;border-left:0;border-top:0;height:7px;left:4px;position:absolute;top:1px;transform:rotate(45deg) scaleY(0);width:3px;transition:transform .15s ease-in 50ms;transform-origin:center}.el-checkbox__original{opacity:0;outline:0;position:absolute;margin:0;width:0;height:0;z-index:-1}.el-checkbox__label{display:inline-block;padding-left:8px;line-height:1;font-size:var(--el-checkbox-font-size)}.el-checkbox.el-checkbox--large{height:40px}.el-checkbox.el-checkbox--large .el-checkbox__label{font-size:14px}.el-checkbox.el-checkbox--large .el-checkbox__inner{width:14px;height:14px}.el-checkbox.el-checkbox--small{height:24px}.el-checkbox.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.el-checkbox--small .el-checkbox__inner{width:12px;height:12px}.el-checkbox.el-checkbox--small .el-checkbox__input.is-indeterminate .el-checkbox__inner:before{top:4px}.el-checkbox.el-checkbox--small .el-checkbox__inner:after{width:2px;height:6px}.el-checkbox:last-of-type{margin-right:0}.el-form{--el-form-label-font-size:var(--el-font-size-base);--el-form-inline-content-width:220px}.el-form--label-left .el-form-item__label{justify-content:flex-start}.el-form--label-top .el-form-item{display:block}.el-form--label-top .el-form-item .el-form-item__label{display:block;height:auto;text-align:left;margin-bottom:8px;line-height:22px}.el-form--inline .el-form-item{display:inline-flex;vertical-align:middle;margin-right:32px}.el-form--inline.el-form--label-top{display:flex;flex-wrap:wrap}.el-form--inline.el-form--label-top .el-form-item{display:block}.el-form--large.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:12px;line-height:22px}.el-form--default.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:8px;line-height:22px}.el-form--small.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:4px;line-height:20px}.el-form-item{display:flex;--font-size:14px;margin-bottom:18px}.el-form-item .el-form-item{margin-bottom:0}.el-form-item .el-input__validateIcon{display:none}.el-form-item--large{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:22px}.el-form-item--large .el-form-item__label{height:40px;line-height:40px}.el-form-item--large .el-form-item__content{line-height:40px}.el-form-item--large .el-form-item__error{padding-top:4px}.el-form-item--default{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--default .el-form-item__label{height:32px;line-height:32px}.el-form-item--default .el-form-item__content{line-height:32px}.el-form-item--default .el-form-item__error{padding-top:2px}.el-form-item--small{--font-size:12px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--small .el-form-item__label{height:24px;line-height:24px}.el-form-item--small .el-form-item__content{line-height:24px}.el-form-item--small .el-form-item__error{padding-top:2px}.el-form-item__label-wrap{display:flex}.el-form-item__label{display:inline-flex;justify-content:flex-end;align-items:flex-start;flex:0 0 auto;font-size:var(--el-form-label-font-size);color:var(--el-text-color-regular);height:32px;line-height:32px;padding:0 12px 0 0;box-sizing:border-box}.el-form-item__content{display:flex;flex-wrap:wrap;align-items:center;flex:1;line-height:32px;position:relative;font-size:var(--font-size);min-width:0}.el-form-item__content .el-input-group{vertical-align:top}.el-form-item__error{color:var(--el-color-danger);font-size:12px;line-height:1;padding-top:2px;position:absolute;top:100%;left:0}.el-form-item__error--inline{position:relative;top:auto;left:auto;display:inline-block;margin-left:10px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label-wrap>.el-form-item__label:before,.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label:before{content:"*";color:var(--el-color-danger);margin-right:4px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label-wrap>.el-form-item__label:after,.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label:after{content:"*";color:var(--el-color-danger);margin-left:4px}.el-form-item.is-error .el-select-v2__wrapper.is-focused{border-color:transparent}.el-form-item.is-error .el-select-v2__wrapper,.el-form-item.is-error .el-select-v2__wrapper:focus,.el-form-item.is-error .el-textarea__inner,.el-form-item.is-error .el-textarea__inner:focus{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input-group__append .el-input__wrapper,.el-form-item.is-error .el-input-group__prepend .el-input__wrapper{box-shadow:0 0 0 1px transparent inset}.el-form-item.is-error .el-input__validateIcon{color:var(--el-color-danger)}.el-form-item--feedback .el-input__validateIcon{display:inline-flex}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%}.el-textarea{position:relative;display:inline-block;width:100%;vertical-align:bottom;font-size:var(--el-font-size-base)}.el-textarea__inner{position:relative;display:block;resize:vertical;padding:5px 11px;line-height:1.5;box-sizing:border-box;width:100%;font-size:inherit;font-family:inherit;color:var(--el-input-text-color,var(--el-text-color-regular));background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;-webkit-appearance:none;box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));transition:var(--el-transition-box-shadow);border:none}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{outline:0;box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-textarea .el-input__count{color:var(--el-color-info);background:var(--el-fill-color-blank);position:absolute;font-size:12px;line-height:14px;bottom:5px;right:10px}.el-textarea.is-disabled .el-textarea__inner{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%}.el-input{--el-input-height:var(--el-component-size);position:relative;font-size:var(--el-font-size-base);display:inline-flex;width:var(--el-input-width);line-height:var(--el-input-height);box-sizing:border-box;vertical-align:middle}.el-input::-webkit-scrollbar{z-index:11;width:6px}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{border-radius:5px;width:6px;background:var(--el-text-color-disabled)}.el-input::-webkit-scrollbar-corner{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);font-size:14px;cursor:pointer}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{height:100%;display:inline-flex;align-items:center;color:var(--el-color-info);font-size:12px}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);line-height:initial;display:inline-block;padding-left:8px}.el-input__wrapper{display:inline-flex;flex-grow:1;align-items:center;justify-content:center;padding:1px 11px;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));cursor:text;transition:var(--el-transition-box-shadow);transform:translateZ(0);box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px);width:100%;flex-grow:1;-webkit-appearance:none;color:var(--el-input-text-color,var(--el-text-color-regular));font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);padding:0;outline:0;border:none;background:0 0;box-sizing:border-box}.el-input__inner:focus{outline:0}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__prefix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__prefix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__suffix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{height:inherit;line-height:inherit;display:flex;justify-content:center;align-items:center;transition:all var(--el-transition-duration);margin-left:8px}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color,) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{display:inline-flex;width:100%;align-items:stretch}.el-input-group__append,.el-input-group__prepend{background-color:var(--el-fill-color-light);color:var(--el-color-info);position:relative;display:inline-flex;align-items:center;justify-content:center;min-height:100%;border-radius:var(--el-input-border-radius);padding:0 20px;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:0}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-input__wrapper,.el-input-group__append div.el-select:hover .el-input__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-input__wrapper,.el-input-group__prepend div.el-select:hover .el-input__wrapper{border-color:transparent;background-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-right:0;border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-left:0;border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-input .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select .el-input .el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__wrapper{box-shadow:1px 0 0 0 var(--el-input-focus-border-color) inset,1px 0 0 0 var(--el-input-focus-border-color),0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important;z-index:2}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__wrapper:focus{outline:0;z-index:2;box-shadow:1px 0 0 0 var(--el-input-focus-border-color) inset,1px 0 0 0 var(--el-input-focus-border-color),0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important}.el-input-group--prepend .el-input-group__prepend .el-select:hover .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select:hover .el-input__wrapper{z-index:1;box-shadow:1px 0 0 0 var(--el-input-hover-border-color) inset,1px 0 0 0 var(--el-input-hover-border-color),0 1px 0 0 var(--el-input-hover-border-color) inset,0 -1px 0 0 var(--el-input-hover-border-color) inset!important}.el-input-group--append>.el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-input .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select .el-input .el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--append .el-input-group__append .el-select .el-input.is-focus .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select .el-input.is-focus .el-input__wrapper{z-index:2;box-shadow:-1px 0 0 0 var(--el-input-focus-border-color),-1px 0 0 0 var(--el-input-focus-border-color) inset,0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important}.el-input-group--append .el-input-group__append .el-select:hover .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select:hover .el-input__wrapper{z-index:1;box-shadow:-1px 0 0 0 var(--el-input-hover-border-color),-1px 0 0 0 var(--el-input-hover-border-color) inset,0 1px 0 0 var(--el-input-hover-border-color) inset,0 -1px 0 0 var(--el-input-hover-border-color) inset!important}.el-tag{--el-tag-font-size:12px;--el-tag-border-radius:4px;--el-tag-border-radius-rounded:9999px}.el-tag{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary);--el-tag-text-color:var(--el-color-primary);background-color:var(--el-tag-bg-color);border-color:var(--el-tag-border-color);color:var(--el-tag-text-color);display:inline-flex;justify-content:center;align-items:center;vertical-align:middle;height:24px;padding:0 9px;font-size:var(--el-tag-font-size);line-height:1;border-width:1px;border-style:solid;border-radius:var(--el-tag-border-radius);box-sizing:border-box;white-space:nowrap;--el-icon-size:14px}.el-tag.el-tag--primary{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-bg-color:var(--el-color-success-light-9);--el-tag-border-color:var(--el-color-success-light-8);--el-tag-hover-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-bg-color:var(--el-color-warning-light-9);--el-tag-border-color:var(--el-color-warning-light-8);--el-tag-hover-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-bg-color:var(--el-color-danger-light-9);--el-tag-border-color:var(--el-color-danger-light-8);--el-tag-hover-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-bg-color:var(--el-color-error-light-9);--el-tag-border-color:var(--el-color-error-light-8);--el-tag-hover-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-bg-color:var(--el-color-info-light-9);--el-tag-border-color:var(--el-color-info-light-8);--el-tag-hover-color:var(--el-color-info)}.el-tag.el-tag--primary{--el-tag-text-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-text-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-text-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-text-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-text-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-text-color:var(--el-color-info)}.el-tag.is-hit{border-color:var(--el-color-primary)}.el-tag.is-round{border-radius:var(--el-tag-border-radius-rounded)}.el-tag .el-tag__close{color:var(--el-tag-text-color)}.el-tag .el-tag__close:hover{color:var(--el-color-white);background-color:var(--el-tag-hover-color)}.el-tag .el-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--el-icon-size) - 2px);height:var(--el-icon-size);width:var(--el-icon-size)}.el-tag .el-tag__close{margin-left:6px}.el-tag--dark{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3);--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--primary{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3)}.el-tag--dark.el-tag--success{--el-tag-bg-color:var(--el-color-success);--el-tag-border-color:var(--el-color-success);--el-tag-hover-color:var(--el-color-success-light-3)}.el-tag--dark.el-tag--warning{--el-tag-bg-color:var(--el-color-warning);--el-tag-border-color:var(--el-color-warning);--el-tag-hover-color:var(--el-color-warning-light-3)}.el-tag--dark.el-tag--danger{--el-tag-bg-color:var(--el-color-danger);--el-tag-border-color:var(--el-color-danger);--el-tag-hover-color:var(--el-color-danger-light-3)}.el-tag--dark.el-tag--error{--el-tag-bg-color:var(--el-color-error);--el-tag-border-color:var(--el-color-error);--el-tag-hover-color:var(--el-color-error-light-3)}.el-tag--dark.el-tag--info{--el-tag-bg-color:var(--el-color-info);--el-tag-border-color:var(--el-color-info);--el-tag-hover-color:var(--el-color-info-light-3)}.el-tag--dark.el-tag--primary,.el-tag--dark.el-tag--success,.el-tag--dark.el-tag--warning,.el-tag--dark.el-tag--danger,.el-tag--dark.el-tag--error,.el-tag--dark.el-tag--info{--el-tag-text-color:var(--el-color-white)}.el-tag--plain{--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary);--el-tag-bg-color:var(--el-fill-color-blank)}.el-tag--plain.el-tag--primary{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary)}.el-tag--plain.el-tag--success{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-success-light-5);--el-tag-hover-color:var(--el-color-success)}.el-tag--plain.el-tag--warning{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-warning-light-5);--el-tag-hover-color:var(--el-color-warning)}.el-tag--plain.el-tag--danger{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-danger-light-5);--el-tag-hover-color:var(--el-color-danger)}.el-tag--plain.el-tag--error{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-error-light-5);--el-tag-hover-color:var(--el-color-error)}.el-tag--plain.el-tag--info{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-info-light-5);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-closable{padding-right:5px}.el-tag--large{padding:0 11px;height:32px;--el-icon-size:16px}.el-tag--large .el-tag__close{margin-left:8px}.el-tag--large.is-closable{padding-right:7px}.el-tag--small{padding:0 7px;height:20px;--el-icon-size:12px}.el-tag--small .el-tag__close{margin-left:4px}.el-tag--small.is-closable{padding-right:3px}.el-tag--small .el-icon-close{transform:scale(.8)}.el-tag.el-tag--primary.is-hit{border-color:var(--el-color-primary)}.el-tag.el-tag--success.is-hit{border-color:var(--el-color-success)}.el-tag.el-tag--warning.is-hit{border-color:var(--el-color-warning)}.el-tag.el-tag--danger.is-hit{border-color:var(--el-color-danger)}.el-tag.el-tag--error.is-hit{border-color:var(--el-color-error)}.el-tag.el-tag--info.is-hit{border-color:var(--el-color-info)}.el-select-dropdown__item{font-size:var(--el-font-size-base);padding:0 32px 0 20px;position:relative;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--el-text-color-regular);height:34px;line-height:34px;box-sizing:border-box;cursor:pointer}.el-select-dropdown__item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select-dropdown__item.hover,.el-select-dropdown__item:hover{background-color:var(--el-fill-color-light)}.el-select-dropdown__item.selected{color:var(--el-color-primary);font-weight:700}.el-scrollbar{--el-scrollbar-opacity:.3;--el-scrollbar-bg-color:var(--el-text-color-secondary);--el-scrollbar-hover-opacity:.5;--el-scrollbar-hover-bg-color:var(--el-text-color-secondary)}.el-scrollbar{overflow:hidden;position:relative;height:100%}.el-scrollbar__wrap{overflow:auto;height:100%}.el-scrollbar__wrap--hidden-default{scrollbar-width:none}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.el-scrollbar__thumb{position:relative;display:block;width:0;height:0;cursor:pointer;border-radius:inherit;background-color:var(--el-scrollbar-bg-color,var(--el-text-color-secondary));transition:var(--el-transition-duration) background-color;opacity:var(--el-scrollbar-opacity,.3)}.el-scrollbar__thumb:hover{background-color:var(--el-scrollbar-hover-bg-color,var(--el-text-color-secondary));opacity:var(--el-scrollbar-hover-opacity,.5)}.el-scrollbar__bar{position:absolute;right:2px;bottom:2px;z-index:1;border-radius:4px}.el-scrollbar__bar.is-vertical{width:6px;top:2px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar-fade-enter-active{transition:opacity .34s ease-out}.el-scrollbar-fade-leave-active{transition:opacity .12s ease-out}.el-scrollbar-fade-enter-from,.el-scrollbar-fade-leave-active{opacity:0}.el-popper{--el-popper-border-radius:var(--el-popover-border-radius, 4px)}.el-popper{position:absolute;border-radius:var(--el-popper-border-radius);padding:5px 11px;z-index:2000;font-size:12px;line-height:20px;min-width:10px;word-wrap:break-word;visibility:visible}.el-popper.is-dark{color:var(--el-bg-color);background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary)}.el-popper.is-dark .el-popper__arrow:before{border:1px solid var(--el-text-color-primary);background:var(--el-text-color-primary);right:0}.el-popper.is-light{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light .el-popper__arrow:before{border:1px solid var(--el-border-color-light);background:var(--el-bg-color-overlay);right:0}.el-popper.is-pure{padding:0}.el-popper__arrow{position:absolute;width:10px;height:10px;z-index:-1}.el-popper__arrow:before{position:absolute;width:10px;height:10px;z-index:-1;content:" ";transform:rotate(45deg);background:var(--el-text-color-primary);box-sizing:border-box}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent!important;border-bottom-color:transparent!important}.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent!important;border-top-color:transparent!important}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected{color:var(--el-color-primary);background-color:var(--el-bg-color-overlay)}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected.hover{background-color:var(--el-fill-color-light)}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected:after{content:"";position:absolute;top:50%;right:20px;border-top:none;border-right:none;background-repeat:no-repeat;background-position:center;background-color:var(--el-color-primary);-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;transform:translateY(-50%);width:12px;height:12px}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected.is-disabled:after{background-color:var(--el-text-color-disabled)}.el-select-dropdown .el-select-dropdown__option-item.is-selected:after{content:"";position:absolute;top:50%;right:20px;border-top:none;border-right:none;background-repeat:no-repeat;background-position:center;background-color:var(--el-color-primary);-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;transform:translateY(-50%);width:12px;height:12px}.el-select-dropdown .el-select-dropdown__item.is-disabled:hover{background-color:unset}.el-select-dropdown .el-select-dropdown__item.is-disabled.selected{color:var(--el-text-color-disabled)}.el-select-dropdown__list{list-style:none;padding:6px 0;margin:0;box-sizing:border-box}.el-select{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px}.el-select{display:inline-block;position:relative;vertical-align:middle;line-height:32px}.el-select__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-select__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-select__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent;border-left-color:transparent}.el-select__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-select__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent;border-bottom-color:transparent}.el-select__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-select .el-select-tags-wrapper.has-prefix{margin-left:6px}.el-select--large{line-height:40px}.el-select--large .el-select-tags-wrapper.has-prefix{margin-left:8px}.el-select--small{line-height:24px}.el-select--small .el-select-tags-wrapper.has-prefix{margin-left:4px}.el-select .el-select__tags>span{display:inline-block}.el-select:hover:not(.el-select--disabled) .el-input__wrapper{box-shadow:0 0 0 1px var(--el-select-border-color-hover) inset}.el-select .el-select__tags-text{display:inline-block;line-height:normal;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select .el-input__wrapper{cursor:pointer}.el-select .el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-select-input-focus-border-color) inset!important}.el-select .el-input__inner{cursor:pointer}.el-select .el-input{display:flex}.el-select .el-input .el-select__caret{color:var(--el-select-input-color);font-size:var(--el-select-input-font-size);transition:transform var(--el-transition-duration);transform:rotate(0);cursor:pointer}.el-select .el-input .el-select__caret.is-reverse{transform:rotate(-180deg)}.el-select .el-input .el-select__caret.is-show-close{font-size:var(--el-select-font-size);text-align:center;transform:rotate(0);border-radius:var(--el-border-radius-circle);color:var(--el-select-input-color);transition:var(--el-transition-color)}.el-select .el-input .el-select__caret.is-show-close:hover{color:var(--el-select-close-hover-color)}.el-select .el-input .el-select__caret.el-icon{position:relative;height:inherit;z-index:2}.el-select .el-input.is-disabled .el-input__wrapper{cursor:not-allowed}.el-select .el-input.is-disabled .el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select .el-input.is-disabled .el-input__inner,.el-select .el-input.is-disabled .el-select__caret{cursor:not-allowed}.el-select .el-input.is-focus .el-input__wrapper{box-shadow:0 0 0 1px var(--el-select-input-focus-border-color) inset!important}.el-select__input{border:none;outline:0;padding:0;margin-left:15px;color:var(--el-select-multiple-input-color);font-size:var(--el-select-font-size);-webkit-appearance:none;-moz-appearance:none;appearance:none;height:28px;background-color:transparent}.el-select__input.is-disabled{cursor:not-allowed}.el-select__input--iOS{position:absolute;left:0;top:0;z-index:6}.el-select__input.is-small{height:14px}.el-select__close{cursor:pointer;position:absolute;top:8px;z-index:var(--el-index-top);right:25px;color:var(--el-select-input-color);line-height:18px;font-size:var(--el-select-input-font-size)}.el-select__close:hover{color:var(--el-select-close-hover-color)}.el-select__tags{position:absolute;line-height:normal;top:50%;transform:translateY(-50%);white-space:normal;z-index:var(--el-index-normal);display:flex;align-items:center;flex-wrap:wrap;cursor:pointer}.el-select__tags .el-tag{box-sizing:border-box;border-color:transparent;margin:2px 6px 2px 0}.el-select__tags .el-tag:last-child{margin-right:0}.el-select__tags .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);right:-7px;top:0;color:#fff}.el-select__tags .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-select__tags .el-tag .el-icon-close:before{display:block;transform:translateY(.5px)}.el-select__tags .el-tag--info{background-color:var(--el-fill-color)}.el-select__tags.is-disabled{cursor:not-allowed}.el-select__collapse-tags{white-space:normal;z-index:var(--el-index-normal);display:flex;align-items:center;flex-wrap:wrap;cursor:pointer}.el-select__collapse-tags .el-tag{box-sizing:border-box;border-color:transparent;margin:2px 6px 2px 0}.el-select__collapse-tags .el-tag:last-child{margin-right:0}.el-select__collapse-tags .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);right:-7px;top:0;color:#fff}.el-select__collapse-tags .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-select__collapse-tags .el-tag .el-icon-close:before{display:block;transform:translateY(.5px)}.el-select__collapse-tags .el-tag--info{background-color:var(--el-fill-color)}.el-select__collapse-tag{line-height:inherit;height:inherit;display:flex}.side-button[data-v-c2c57aa8]{position:relative;width:24px;aspect-ratio:1;display:flex;justify-content:center;align-items:center;font-size:18px}.side-button.add-match-item[data-v-c2c57aa8]{color:green}.side-button.remove-match-item[data-v-c2c57aa8]{color:red}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center top}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center bottom}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transition:var(--el-transition-md-fade);transform-origin:top left}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-tree{--el-tree-node-content-height:26px;--el-tree-node-hover-bg-color:var(--el-fill-color-light);--el-tree-text-color:var(--el-text-color-regular);--el-tree-expand-icon-color:var(--el-text-color-placeholder)}.el-tree{position:relative;cursor:default;background:var(--el-fill-color-blank);color:var(--el-tree-text-color);font-size:var(--el-font-size-base)}.el-tree__empty-block{position:relative;min-height:60px;text-align:center;width:100%;height:100%}.el-tree__empty-text{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:var(--el-text-color-secondary);font-size:var(--el-font-size-base)}.el-tree__drop-indicator{position:absolute;left:0;right:0;height:1px;background-color:var(--el-color-primary)}.el-tree-node{white-space:nowrap;outline:0}.el-tree-node:focus>.el-tree-node__content{background-color:var(--el-tree-node-hover-bg-color)}.el-tree-node.is-drop-inner>.el-tree-node__content .el-tree-node__label{background-color:var(--el-color-primary);color:#fff}.el-tree-node__content{--el-checkbox-height:var(--el-tree-node-content-height);display:flex;align-items:center;height:var(--el-tree-node-content-height);cursor:pointer}.el-tree-node__content>.el-tree-node__expand-icon{padding:6px;box-sizing:content-box}.el-tree-node__content>label.el-checkbox{margin-right:8px}.el-tree-node__content:hover{background-color:var(--el-tree-node-hover-bg-color)}.el-tree.is-dragging .el-tree-node__content{cursor:move}.el-tree.is-dragging .el-tree-node__content *{pointer-events:none}.el-tree.is-dragging.is-drop-not-allow .el-tree-node__content{cursor:not-allowed}.el-tree-node__expand-icon{cursor:pointer;color:var(--el-tree-expand-icon-color);font-size:12px;transform:rotate(0);transition:transform var(--el-transition-duration) ease-in-out}.el-tree-node__expand-icon.expanded{transform:rotate(90deg)}.el-tree-node__expand-icon.is-leaf{color:transparent;cursor:default}.el-tree-node__expand-icon.is-hidden{visibility:hidden}.el-tree-node__loading-icon{margin-right:8px;font-size:var(--el-font-size-base);color:var(--el-tree-expand-icon-color)}.el-tree-node>.el-tree-node__children{overflow:hidden;background-color:transparent}.el-tree-node.is-expanded>.el-tree-node__children{display:block}.el-tree--highlight-current .el-tree-node.is-current>.el-tree-node__content{background-color:var(--el-color-primary-light-9)}.el-vl__wrapper{position:relative}.el-vl__wrapper:hover .el-virtual-scrollbar,.el-vl__wrapper.always-on .el-virtual-scrollbar{opacity:1}.el-vl__window{scrollbar-width:none}.el-vl__window::-webkit-scrollbar{display:none}.el-virtual-scrollbar{opacity:0;transition:opacity .34s ease-out}.el-virtual-scrollbar.always-on{opacity:1}.el-vg__wrapper{position:relative}.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255, 255, 255, .5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-color-info);--el-button-active-color:var(--el-text-color-primary)}.el-button{display:inline-flex;justify-content:center;align-items:center;line-height:1;height:32px;white-space:nowrap;cursor:pointer;color:var(--el-button-text-color);text-align:center;box-sizing:border-box;outline:0;transition:.1s;font-weight:var(--el-button-font-weight);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);padding:8px 15px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button:focus,.el-button:hover{color:var(--el-button-hover-text-color);border-color:var(--el-button-hover-border-color);background-color:var(--el-button-hover-bg-color);outline:0}.el-button:active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button>span{display:inline-flex;align-items:center}.el-button+.el-button{margin-left:12px}.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button.is-disabled,.el-button.is-disabled:focus,.el-button.is-disabled:hover{color:var(--el-button-disabled-text-color);cursor:not-allowed;background-image:none;background-color:var(--el-button-disabled-bg-color);border-color:var(--el-button-disabled-border-color)}.el-button.is-loading{position:relative;pointer-events:none}.el-button.is-loading:before{z-index:1;pointer-events:none;content:"";position:absolute;left:-1px;top:-1px;right:-1px;bottom:-1px;border-radius:inherit;background-color:var(--el-mask-color-extra-light)}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{border-radius:50%;padding:8px}.el-button.is-text{color:var(--el-button-text-color);border:0 solid transparent;background-color:transparent}.el-button.is-text.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important}.el-button.is-text:not(.is-disabled):focus,.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:focus,.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{border-color:transparent;color:var(--el-button-text-color);background:0 0;padding:2px;height:auto}.el-button.is-link:focus,.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.el-button.is-link:not(.is-disabled):focus,.el-button.is-link:not(.is-disabled):hover{border-color:transparent;background-color:transparent}.el-button.is-link:not(.is-disabled):active{color:var(--el-button-active-color);border-color:transparent;background-color:transparent}.el-button--text{border-color:transparent;background:0 0;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.el-button--text:not(.is-disabled):focus,.el-button--text:not(.is-disabled):hover{color:var(--el-color-primary-light-3);border-color:transparent;background-color:transparent}.el-button--text:not(.is-disabled):active{color:var(--el-color-primary-dark-2);border-color:transparent;background-color:transparent}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{color:var(--el-color-primary-light-5);background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{color:var(--el-color-success-light-5);background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{color:var(--el-color-warning-light-5);background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{color:var(--el-color-danger-light-5);background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{color:var(--el-color-info-light-5);background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8)}.el-button--large{--el-button-size:40px;height:var(--el-button-size);padding:12px 19px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{width:var(--el-button-size);padding:12px}.el-button--small{--el-button-size:24px;height:var(--el-button-size);padding:5px 11px;font-size:12px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{width:var(--el-button-size);padding:5px}.el-image__error,.el-image__inner,.el-image__placeholder,.el-image__wrapper{width:100%;height:100%}.el-image{position:relative;display:inline-block;overflow:hidden}.el-image__inner{vertical-align:top;opacity:1}.el-image__inner.is-loading{opacity:0}.el-image__wrapper{position:absolute;top:0;left:0}.el-image__placeholder{background:var(--el-fill-color-light)}.el-image__error{display:flex;justify-content:center;align-items:center;font-size:14px;background:var(--el-fill-color-light);color:var(--el-text-color-placeholder);vertical-align:middle}.el-image__preview{cursor:pointer}.el-image-viewer__wrapper{position:fixed;top:0;right:0;bottom:0;left:0}.el-image-viewer__btn{position:absolute;z-index:1;display:flex;align-items:center;justify-content:center;border-radius:50%;opacity:.8;cursor:pointer;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-image-viewer__btn .el-icon{font-size:inherit;cursor:pointer}.el-image-viewer__close{top:40px;right:40px;width:40px;height:40px;font-size:40px}.el-image-viewer__canvas{position:static;width:100%;height:100%;display:flex;justify-content:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-image-viewer__actions{left:50%;bottom:30px;transform:translate(-50%);width:282px;height:44px;padding:0 23px;background-color:var(--el-text-color-regular);border-color:#fff;border-radius:22px}.el-image-viewer__actions__inner{width:100%;height:100%;text-align:justify;cursor:default;font-size:23px;color:#fff;display:flex;align-items:center;justify-content:space-around}.el-image-viewer__prev{top:50%;transform:translateY(-50%);left:40px;width:44px;height:44px;font-size:24px;color:#fff;background-color:var(--el-text-color-regular);border-color:#fff}.el-image-viewer__next{top:50%;transform:translateY(-50%);right:40px;text-indent:2px;width:44px;height:44px;font-size:24px;color:#fff;background-color:var(--el-text-color-regular);border-color:#fff}.el-image-viewer__close{width:44px;height:44px;font-size:24px;color:#fff;background-color:var(--el-text-color-regular);border-color:#fff}.el-image-viewer__mask{position:absolute;width:100%;height:100%;top:0;left:0;opacity:.5;background:#000}.viewer-fade-enter-active{-webkit-animation:viewer-fade-in var(--el-transition-duration);animation:viewer-fade-in var(--el-transition-duration)}.viewer-fade-leave-active{-webkit-animation:viewer-fade-out var(--el-transition-duration);animation:viewer-fade-out var(--el-transition-duration)}@-webkit-keyframes viewer-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes viewer-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@-webkit-keyframes viewer-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}@keyframes viewer-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}.el-badge{--el-badge-bg-color:var(--el-color-danger);--el-badge-radius:10px;--el-badge-font-size:12px;--el-badge-padding:6px;--el-badge-size:18px;position:relative;vertical-align:middle;display:inline-block;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content}.el-badge__content{background-color:var(--el-badge-bg-color);border-radius:var(--el-badge-radius);color:var(--el-color-white);display:inline-flex;justify-content:center;align-items:center;font-size:var(--el-badge-font-size);height:var(--el-badge-size);padding:0 var(--el-badge-padding);white-space:nowrap;border:1px solid var(--el-bg-color)}.el-badge__content.is-fixed{position:absolute;top:0;right:calc(1px + var(--el-badge-size)/ 2);transform:translateY(-50%) translate(100%);z-index:var(--el-index-normal)}.el-badge__content.is-fixed.is-dot{right:5px}.el-badge__content.is-dot{height:8px;width:8px;padding:0;right:0;border-radius:50%}.el-badge__content--primary{background-color:var(--el-color-primary)}.el-badge__content--success{background-color:var(--el-color-success)}.el-badge__content--warning{background-color:var(--el-color-warning)}.el-badge__content--info{background-color:var(--el-color-info)}.el-badge__content--danger{background-color:var(--el-color-danger)}.el-message{--el-message-bg-color:var(--el-color-info-light-9);--el-message-border-color:var(--el-border-color-lighter);--el-message-padding:15px 19px;--el-message-close-size:16px;--el-message-close-icon-color:var(--el-text-color-placeholder);--el-message-close-hover-color:var(--el-text-color-secondary)}.el-message{width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;max-width:calc(100% - 32px);box-sizing:border-box;border-radius:var(--el-border-radius-base);border-width:var(--el-border-width);border-style:var(--el-border-style);border-color:var(--el-message-border-color);position:fixed;left:50%;top:20px;transform:translate(-50%);background-color:var(--el-message-bg-color);transition:opacity var(--el-transition-duration),transform .4s,top .4s;padding:var(--el-message-padding);display:flex;align-items:center}.el-message.is-center{justify-content:center}.el-message.is-closable .el-message__content{padding-right:31px}.el-message p{margin:0}.el-message--success{--el-message-bg-color:var(--el-color-success-light-9);--el-message-border-color:var(--el-color-success-light-8);--el-message-text-color:var(--el-color-success)}.el-message--success .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--success{color:var(--el-message-text-color)}.el-message--info{--el-message-bg-color:var(--el-color-info-light-9);--el-message-border-color:var(--el-color-info-light-8);--el-message-text-color:var(--el-color-info)}.el-message--info .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--info{color:var(--el-message-text-color)}.el-message--warning{--el-message-bg-color:var(--el-color-warning-light-9);--el-message-border-color:var(--el-color-warning-light-8);--el-message-text-color:var(--el-color-warning)}.el-message--warning .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--warning{color:var(--el-message-text-color)}.el-message--error{--el-message-bg-color:var(--el-color-error-light-9);--el-message-border-color:var(--el-color-error-light-8);--el-message-text-color:var(--el-color-error)}.el-message--error .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--error{color:var(--el-message-text-color)}.el-message__icon{margin-right:10px}.el-message .el-message__badge{position:absolute;top:-8px;right:-8px}.el-message__content{padding:0;font-size:14px;line-height:1}.el-message__content:focus{outline-width:0}.el-message .el-message__closeBtn{position:absolute;top:50%;right:19px;transform:translateY(-50%);cursor:pointer;color:var(--el-message-close-icon-color);font-size:var(--el-message-close-size)}.el-message .el-message__closeBtn:focus{outline-width:0}.el-message .el-message__closeBtn:hover{color:var(--el-message-close-hover-color)}.el-message-fade-enter-from,.el-message-fade-leave-to{opacity:0;transform:translate(-50%,-100%)}:root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:.5}.v-modal-enter{-webkit-animation:v-modal-in var(--el-transition-duration-fast) ease;animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{-webkit-animation:v-modal-out var(--el-transition-duration-fast) ease forwards;animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@-webkit-keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-in{0%{opacity:0}}@-webkit-keyframes v-modal-out{to{opacity:0}}@keyframes v-modal-out{to{opacity:0}}.v-modal{position:fixed;left:0;top:0;width:100%;height:100%;opacity:var(--el-popup-modal-opacity);background:var(--el-popup-modal-bg-color)}.el-popup-parent--hidden{overflow:hidden}.el-message-box{--el-messagebox-title-color:var(--el-text-color-primary);--el-messagebox-width:420px;--el-messagebox-border-radius:4px;--el-messagebox-font-size:var(--el-font-size-large);--el-messagebox-content-font-size:var(--el-font-size-base);--el-messagebox-content-color:var(--el-text-color-regular);--el-messagebox-error-font-size:12px;--el-messagebox-padding-primary:15px}.el-message-box{display:inline-block;max-width:var(--el-messagebox-width);width:100%;padding-bottom:10px;vertical-align:middle;background-color:var(--el-bg-color);border-radius:var(--el-messagebox-border-radius);border:1px solid var(--el-border-color-lighter);font-size:var(--el-messagebox-font-size);box-shadow:var(--el-box-shadow-light);text-align:left;overflow:hidden;-webkit-backface-visibility:hidden;backface-visibility:hidden;box-sizing:border-box}.el-message-box:focus{outline:0!important}.el-overlay.is-message-box .el-overlay-message-box{text-align:center;position:fixed;top:0;right:0;bottom:0;left:0;padding:16px;overflow:auto}.el-overlay.is-message-box .el-overlay-message-box:after{content:"";display:inline-block;height:100%;width:0;vertical-align:middle}.el-message-box.is-draggable .el-message-box__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-message-box__header{position:relative;padding:var(--el-messagebox-padding-primary);padding-bottom:10px}.el-message-box__title{padding-left:0;margin-bottom:0;font-size:var(--el-messagebox-font-size);line-height:1;color:var(--el-messagebox-title-color)}.el-message-box__headerbtn{position:absolute;top:var(--el-messagebox-padding-primary);right:var(--el-messagebox-padding-primary);padding:0;border:none;outline:0;background:0 0;font-size:var(--el-message-close-size,16px);cursor:pointer}.el-message-box__headerbtn .el-message-box__close{color:var(--el-color-info);font-size:inherit}.el-message-box__headerbtn:focus .el-message-box__close,.el-message-box__headerbtn:hover .el-message-box__close{color:var(--el-color-primary)}.el-message-box__content{padding:10px var(--el-messagebox-padding-primary);color:var(--el-messagebox-content-color);font-size:var(--el-messagebox-content-font-size)}.el-message-box__container{position:relative}.el-message-box__input{padding-top:15px}.el-message-box__input div.invalid>input{border-color:var(--el-color-error)}.el-message-box__input div.invalid>input:focus{border-color:var(--el-color-error)}.el-message-box__status{position:absolute;top:50%;transform:translateY(-50%);font-size:24px!important}.el-message-box__status:before{padding-left:1px}.el-message-box__status.el-icon{position:absolute}.el-message-box__status+.el-message-box__message{padding-left:36px;padding-right:12px;word-break:break-word}.el-message-box__status.el-message-box-icon--success{--el-messagebox-color:var(--el-color-success);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--info{--el-messagebox-color:var(--el-color-info);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--warning{--el-messagebox-color:var(--el-color-warning);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--error{--el-messagebox-color:var(--el-color-error);color:var(--el-messagebox-color)}.el-message-box__message{margin:0}.el-message-box__message p{margin:0;line-height:24px}.el-message-box__errormsg{color:var(--el-color-error);font-size:var(--el-messagebox-error-font-size);min-height:18px;margin-top:2px}.el-message-box__btns{padding:5px 15px 0;display:flex;flex-wrap:wrap;justify-content:flex-end;align-items:center}.el-message-box__btns button:nth-child(2){margin-left:10px}.el-message-box__btns-reverse{flex-direction:row-reverse}.el-message-box--center .el-message-box__title{position:relative;display:flex;align-items:center;justify-content:center}.el-message-box--center .el-message-box__status{position:relative;top:auto;padding-right:5px;text-align:center;transform:translateY(-1px)}.el-message-box--center .el-message-box__message{margin-left:0}.el-message-box--center .el-message-box__btns{justify-content:center}.el-message-box--center .el-message-box__content{padding-left:calc(var(--el-messagebox-padding-primary) + 12px);padding-right:calc(var(--el-messagebox-padding-primary) + 12px);text-align:center}.fade-in-linear-enter-active .el-overlay-message-box{-webkit-animation:msgbox-fade-in var(--el-transition-duration);animation:msgbox-fade-in var(--el-transition-duration)}.fade-in-linear-leave-active .el-overlay-message-box{animation:msgbox-fade-in var(--el-transition-duration) reverse}@-webkit-keyframes msgbox-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes msgbox-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@-webkit-keyframes msgbox-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}@keyframes msgbox-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}.onlineGallery-RuleEditor-modal{pointer-events:none!important}.onlineGallery-RuleEditor-modal .el-dialog__header{padding:15px 10px 5px 20px}.onlineGallery-RuleEditor-modal .el-dialog__header .el-dialog__headerbtn{top:0;right:0;width:50px;height:50px}.onlineGallery-RuleEditor-modal .el-dialog__body{padding:10px}.onlineGallery-RuleEditor-modal .el-dialog__body .el-container{position:relative;height:max-content;min-height:300px}.onlineGallery-RuleEditor-modal .el-dialog__body .el-container .el-tabs{height:90%}.onlineGallery-RuleEditor-modal .el-dialog__body .tree-item{display:flex;align-items:center;justify-content:space-between;overflow:hidden}.onlineGallery-RuleEditor-modal .el-dialog__body .tree-item.tree-item-normal{position:relative;flex-grow:1}.onlineGallery-RuleEditor-modal .el-dialog__body .tree-item.tree-item-normal>.label-ruleName{flex-grow:1;padding-left:4px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.onlineGallery-RuleEditor-modal .el-dialog__body .tree-item.tree-item-normal>.icon-button-deleteRule{right:2px;display:flex;justify-content:center;align-items:center;color:red;font-size:medium}.onlineGallery-RuleEditor-modal .el-dialog__body .tree-item.tree-item-add-button>button{width:100%}.onlineGallery-RuleEditor-modal .el-dialog__footer{padding:10px}.el-popover{--el-popover-bg-color:var(--el-bg-color-overlay);--el-popover-font-size:var(--el-font-size-base);--el-popover-border-color:var(--el-border-color-lighter);--el-popover-padding:12px;--el-popover-padding-large:18px 20px;--el-popover-title-font-size:16px;--el-popover-title-text-color:var(--el-text-color-primary);--el-popover-border-radius:4px}.el-popover.el-popper{background:var(--el-popover-bg-color);min-width:150px;border-radius:var(--el-popover-border-radius);border:1px solid var(--el-popover-border-color);padding:var(--el-popover-padding);z-index:var(--el-index-popper);color:var(--el-text-color-regular);line-height:1.4;text-align:justify;font-size:var(--el-popover-font-size);box-shadow:var(--el-box-shadow-light);word-break:break-all;box-sizing:border-box}.el-popover.el-popper--plain{padding:var(--el-popover-padding-large)}.el-popover__title{color:var(--el-popover-title-text-color);font-size:var(--el-popover-title-font-size);line-height:1;margin-bottom:12px}.el-popover__reference:focus:hover,.el-popover__reference:focus:not(.focusing){outline-width:0}.el-popover.el-popper.is-dark{--el-popover-bg-color:var(--el-text-color-primary);--el-popover-border-color:var(--el-text-color-primary);--el-popover-title-text-color:var(--el-bg-color);color:var(--el-bg-color)}.el-popover.el-popper:focus,.el-popover.el-popper:focus:active{outline-width:0}*[data-v-b78ae3cf]{margin:0!important;padding:0!important;border:0!important;box-sizing:border-box!important;z-index:0!important}[data-show=true][data-v-b78ae3cf]{opacity:1;filter:blur(0px);transition:1s}[data-show=false][data-v-b78ae3cf]{opacity:0;filter:blur(10px);transition:1s}*[data-v-fbee18ec]{border:0;margin:0;box-sizing:border-box}.card[data-v-fbee18ec]{border:0!important;margin:0!important;padding:0!important;scroll-snap-align:start;position:relative;border-radius:4px;box-shadow:var(--el-box-shadow-dark);aspect-ratio:var(--aspect-ratio);max-width:100%;max-height:var(--cardMaxHeight);width:calc(var(--cardMaxHeight) * var(--aspect-ratio))!important;background-color:transparent;overflow:hidden;cursor:pointer;transition:.5s}.card[data-v-fbee18ec]:hover{box-shadow:1px 2px 12px 6px #00000080}.card .content[data-v-fbee18ec]{border:0!important;margin:0!important;padding:0!important;width:100%;height:auto;object-position:center;-webkit-user-drag:none;background-position:center;background-repeat:repeat;background-size:contain}.card .button-group[data-v-fbee18ec]{position:absolute;margin:4px;top:0;right:0;width:24px;height:24px;border-radius:12px;transition:.15s}.card .button-group .button[data-v-fbee18ec]{position:absolute;margin:auto;padding:0;left:0;top:0;right:0;width:100%!important;height:auto!important;aspect-ratio:1!important;font-size:medium;box-shadow:var(--el-box-shadow-light);transition:.15s}.card .button-group[data-v-fbee18ec]:hover{height:50px}.card .button-group:hover .button.download[data-v-fbee18ec]{transform:translateY(26px)}.card .checkbox[data-v-fbee18ec]{position:absolute!important;height:fit-content;top:4px!important;left:4px!important;box-shadow:var(--el-box-shadow-light)}.card .tag-group[data-v-fbee18ec]{position:absolute;width:100%!important;bottom:0px;left:0px;padding:4px;display:flex;flex-flow:row wrap;gap:2px}.card .tag-group .el-tag[data-v-fbee18ec]{max-width:100%;justify-content:start;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}*[data-v-f25bdb68]{border:0;margin:0;box-sizing:border-box}.onlineGallery-listBody[data-v-f25bdb68]{width:100%;padding:10px;display:flex;flex-flow:row wrap;justify-content:center;align-items:stretch;align-content:start;gap:8px;transition:1s;-webkit-user-select:none;user-select:none;-webkit-user-drag:none}.onlineGallery-backTop[data-v-f25bdb68]{--el-backtop-bg-color: var(--el-bg-color-overlay);--el-backtop-text-color: var(--el-color-primary);--el-backtop-hover-bg-color: var(--el-border-color-extra-light);position:absolute;width:40px;height:40px;right:40px;bottom:40px;border-radius:50%;background-color:var(--el-bg-color-overlay);color:var(--el-color-primary);display:flex;align-items:center;justify-content:center;font-size:20px;box-shadow:var(--el-box-shadow-lighter);cursor:pointer;z-index:5;transition:.5s}.onlineGallery-backTop[data-v-f25bdb68]:hover{background-color:var(--el-border-color-extra-light)}.backTop-enter-active[data-v-f25bdb68],.backTop-leave-active[data-v-f25bdb68]{transition:opacity .5s ease}.backTop-enter-from[data-v-f25bdb68],.backTop-leave-to[data-v-f25bdb68]{opacity:0}.list-move[data-v-f25bdb68],.list-enter-active[data-v-f25bdb68],.list-leave-active[data-v-f25bdb68]{transition:all .5s ease}.list-enter-from[data-v-f25bdb68],.list-leave-to[data-v-f25bdb68]{opacity:0;transform:translate(30px)}.list-leave-active[data-v-f25bdb68]{position:absolute}.el-button-group{display:inline-block;vertical-align:middle}.el-button-group:after,.el-button-group:before{display:table;content:""}.el-button-group:after{clear:both}.el-button-group>.el-button{float:left;position:relative}.el-button-group>.el-button+.el-button{margin-left:0}.el-button-group>.el-button:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.el-button-group>.el-button:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.el-button-group>.el-button:first-child:last-child{border-top-right-radius:var(--el-border-radius-base);border-bottom-right-radius:var(--el-border-radius-base);border-top-left-radius:var(--el-border-radius-base);border-bottom-left-radius:var(--el-border-radius-base)}.el-button-group>.el-button:first-child:last-child.is-round{border-radius:var(--el-border-radius-round)}.el-button-group>.el-button:first-child:last-child.is-circle{border-radius:50%}.el-button-group>.el-button:not(:first-child):not(:last-child){border-radius:0}.el-button-group>.el-button:not(:last-child){margin-right:-1px}.el-button-group>.el-button:active,.el-button-group>.el-button:focus,.el-button-group>.el-button:hover{z-index:1}.el-button-group>.el-button.is-active{z-index:1}.el-button-group>.el-dropdown>.el-button{border-top-left-radius:0;border-bottom-left-radius:0;border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-dropdown{--el-dropdown-menu-box-shadow:var(--el-box-shadow-light);--el-dropdown-menuItem-hover-fill:var(--el-color-primary-light-9);--el-dropdown-menuItem-hover-color:var(--el-color-primary);--el-dropdown-menu-index:10;display:inline-flex;position:relative;color:var(--el-text-color-regular);font-size:var(--el-font-size-base);line-height:1;vertical-align:top}.el-dropdown.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-dropdown__popper{--el-dropdown-menu-box-shadow:var(--el-box-shadow-light);--el-dropdown-menuItem-hover-fill:var(--el-color-primary-light-9);--el-dropdown-menuItem-hover-color:var(--el-color-primary);--el-dropdown-menu-index:10}.el-dropdown__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-dropdown-menu-box-shadow)}.el-dropdown__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-dropdown__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent;border-left-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent;border-bottom-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-dropdown__popper .el-dropdown-menu{border:none}.el-dropdown__popper .el-dropdown__popper-selfdefine{outline:0}.el-dropdown__popper .el-scrollbar__bar{z-index:calc(var(--el-dropdown-menu-index) + 1)}.el-dropdown__popper .el-dropdown__list{list-style:none;padding:0;margin:0;box-sizing:border-box}.el-dropdown .el-dropdown__caret-button{padding-left:0;padding-right:0;display:inline-flex;justify-content:center;align-items:center;width:32px;border-left:none}.el-dropdown .el-dropdown__caret-button>span{display:inline-flex}.el-dropdown .el-dropdown__caret-button:before{content:"";position:absolute;display:block;width:1px;top:-1px;bottom:-1px;left:0;background:var(--el-overlay-color-lighter)}.el-dropdown .el-dropdown__caret-button.el-button:before{background:var(--el-border-color);opacity:.5}.el-dropdown .el-dropdown__caret-button .el-dropdown__icon{font-size:inherit;padding-left:0}.el-dropdown .el-dropdown-selfdefine{outline:0}.el-dropdown--large .el-dropdown__caret-button{width:40px}.el-dropdown--small .el-dropdown__caret-button{width:24px}.el-dropdown-menu{position:relative;top:0;left:0;z-index:var(--el-dropdown-menu-index);padding:5px 0;margin:0;background-color:var(--el-bg-color-overlay);border:none;border-radius:var(--el-border-radius-base);box-shadow:none;list-style:none}.el-dropdown-menu__item{display:flex;align-items:center;white-space:nowrap;list-style:none;line-height:22px;padding:5px 16px;margin:0;font-size:var(--el-font-size-base);color:var(--el-text-color-regular);cursor:pointer;outline:0}.el-dropdown-menu__item:not(.is-disabled):focus{background-color:var(--el-dropdown-menuItem-hover-fill);color:var(--el-dropdown-menuItem-hover-color)}.el-dropdown-menu__item i{margin-right:5px}.el-dropdown-menu__item--divided{margin:6px 0;border-top:1px solid var(--el-border-color-lighter)}.el-dropdown-menu__item.is-disabled{cursor:not-allowed;color:var(--el-text-color-disabled)}.el-dropdown-menu--large{padding:7px 0}.el-dropdown-menu--large .el-dropdown-menu__item{padding:7px 20px;line-height:22px;font-size:14px}.el-dropdown-menu--large .el-dropdown-menu__item--divided{margin:8px 0}.el-dropdown-menu--small{padding:3px 0}.el-dropdown-menu--small .el-dropdown-menu__item{padding:2px 12px;line-height:20px;font-size:12px}.el-dropdown-menu--small .el-dropdown-menu__item--divided{margin:4px 0}.el-input-number{position:relative;display:inline-flex;width:150px;line-height:30px}.el-input-number .el-input__wrapper{padding-left:42px;padding-right:42px}.el-input-number .el-input__inner{-webkit-appearance:none;-moz-appearance:textfield;text-align:center;line-height:1}.el-input-number .el-input__inner::-webkit-inner-spin-button,.el-input-number .el-input__inner::-webkit-outer-spin-button{margin:0;-webkit-appearance:none}.el-input-number__decrease,.el-input-number__increase{display:flex;justify-content:center;align-items:center;height:auto;position:absolute;z-index:1;top:1px;bottom:1px;width:32px;background:var(--el-fill-color-light);color:var(--el-text-color-regular);cursor:pointer;font-size:13px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-input-number__decrease:hover,.el-input-number__increase:hover{color:var(--el-color-primary)}.el-input-number__decrease:hover~.el-input:not(.is-disabled) .el-input__wrapper,.el-input-number__increase:hover~.el-input:not(.is-disabled) .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-input-number__decrease.is-disabled,.el-input-number__increase.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-input-number__increase{right:1px;border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0;border-left:var(--el-border)}.el-input-number__decrease{left:1px;border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);border-right:var(--el-border)}.el-input-number.is-disabled .el-input-number__decrease,.el-input-number.is-disabled .el-input-number__increase{border-color:var(--el-disabled-border-color);color:var(--el-disabled-border-color)}.el-input-number.is-disabled .el-input-number__decrease:hover,.el-input-number.is-disabled .el-input-number__increase:hover{color:var(--el-disabled-border-color);cursor:not-allowed}.el-input-number--large{width:180px;line-height:38px}.el-input-number--large .el-input-number__decrease,.el-input-number--large .el-input-number__increase{width:40px;font-size:14px}.el-input-number--large .el-input__wrapper{padding-left:47px;padding-right:47px}.el-input-number--small{width:120px;line-height:22px}.el-input-number--small .el-input-number__decrease,.el-input-number--small .el-input-number__increase{width:24px;font-size:12px}.el-input-number--small .el-input__wrapper{padding-left:31px;padding-right:31px}.el-input-number--small .el-input-number__decrease [class*=el-icon],.el-input-number--small .el-input-number__increase [class*=el-icon]{transform:scale(.9)}.el-input-number.is-without-controls .el-input__wrapper{padding-left:15px;padding-right:15px}.el-input-number.is-controls-right .el-input__wrapper{padding-left:15px;padding-right:42px}.el-input-number.is-controls-right .el-input-number__decrease,.el-input-number.is-controls-right .el-input-number__increase{--el-input-number-controls-height:15px;height:var(--el-input-number-controls-height);line-height:var(--el-input-number-controls-height)}.el-input-number.is-controls-right .el-input-number__decrease [class*=el-icon],.el-input-number.is-controls-right .el-input-number__increase [class*=el-icon]{transform:scale(.8)}.el-input-number.is-controls-right .el-input-number__increase{bottom:auto;left:auto;border-radius:0 var(--el-border-radius-base) 0 0;border-bottom:var(--el-border)}.el-input-number.is-controls-right .el-input-number__decrease{right:1px;top:auto;left:auto;border-right:none;border-left:var(--el-border);border-radius:0 0 var(--el-border-radius-base) 0}.el-input-number.is-controls-right[class*=large] [class*=decrease],.el-input-number.is-controls-right[class*=large] [class*=increase]{--el-input-number-controls-height:19px}.el-input-number.is-controls-right[class*=small] [class*=decrease],.el-input-number.is-controls-right[class*=small] [class*=increase]{--el-input-number-controls-height:11px}.el-select-dropdown{z-index:calc(var(--el-index-top) + 1);border-radius:var(--el-border-radius-base);box-sizing:border-box}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown__option-item.is-selected:not(.is-multiple).is-disabled{color:var(--el-text-color-disabled)}.el-select-dropdown__option-item.is-selected:not(.is-multiple).is-disabled:after{background-color:var(--el-text-color-disabled)}.el-select-dropdown__option-item:hover:not(.hover){background-color:transparent}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-disabled.is-selected{color:var(--el-text-color-disabled)}.el-select-dropdown__empty{padding:10px 0;margin:0;text-align:center;color:var(--el-text-color-secondary);font-size:var(--el-select-font-size)}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{list-style:none;margin:6px 0!important;padding:0!important;box-sizing:border-box}.el-select-dropdown__option-item{font-size:var(--el-select-font-size);padding:0 32px 0 20px;position:relative;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--el-text-color-regular);height:34px;line-height:34px;box-sizing:border-box;cursor:pointer}.el-select-dropdown__option-item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select-dropdown__option-item.is-disabled:hover{background-color:var(--el-bg-color)}.el-select-dropdown__option-item.is-selected{background-color:var(--el-fill-color-light);font-weight:700}.el-select-dropdown__option-item.is-selected:not(.is-multiple){color:var(--el-color-primary)}.el-select-dropdown__option-item.hover{background-color:var(--el-fill-color-light)!important}.el-select-dropdown__option-item:hover{background-color:var(--el-fill-color-light)}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-selected{color:var(--el-color-primary);background-color:var(--el-bg-color-overlay)}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-selected .el-icon{position:absolute;right:20px;top:0;height:inherit;font-size:12px}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-selected .el-icon svg{height:inherit;vertical-align:middle}.el-select-group{margin:0;padding:0}.el-select-group__wrap{position:relative;list-style:none;margin:0;padding:0}.el-select-group__wrap:not(:last-of-type){padding-bottom:24px}.el-select-group__wrap:not(:last-of-type):after{content:"";position:absolute;display:block;left:20px;right:20px;bottom:12px;height:1px;background:var(--el-border-color-light)}.el-select-group__split-dash{position:absolute;left:20px;right:20px;height:1px;background:var(--el-border-color-light)}.el-select-group__title{padding-left:20px;font-size:12px;color:var(--el-color-info);line-height:30px}.el-select-group .el-select-dropdown__item{padding-left:20px}.el-select-v2{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px}.el-select-v2{display:inline-block;position:relative;vertical-align:middle;font-size:14px}.el-select-v2__wrapper{display:flex;align-items:center;flex-wrap:wrap;position:relative;box-sizing:border-box;cursor:pointer;padding:1px 30px 1px 0;border:1px solid var(--el-border-color);border-radius:var(--el-border-radius-base);background-color:var(--el-fill-color-blank);transition:var(--el-transition-duration)}.el-select-v2__wrapper:hover{border-color:var(--el-text-color-placeholder)}.el-select-v2__wrapper.is-filterable{cursor:text}.el-select-v2__wrapper.is-focused{border-color:var(--el-color-primary)}.el-select-v2__wrapper.is-hovering:not(.is-focused){border-color:var(--el-border-color-hover)}.el-select-v2__wrapper.is-disabled{cursor:not-allowed;background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);border-color:var(--el-select-disabled-border)}.el-select-v2__wrapper.is-disabled:hover{border-color:var(--el-select-disabled-border)}.el-select-v2__wrapper.is-disabled.is-focus{border-color:var(--el-input-focus-border-color)}.el-select-v2__wrapper.is-disabled .is-transparent{opacity:1;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-select-v2__wrapper.is-disabled .el-select-v2__caret,.el-select-v2__wrapper.is-disabled .el-select-v2__combobox-input{cursor:not-allowed}.el-select-v2__wrapper .el-select-v2__input-wrapper{box-sizing:border-box;position:relative;-webkit-margin-start:12px;margin-inline-start:12px;max-width:100%;overflow:hidden}.el-select-v2__wrapper,.el-select-v2__wrapper .el-select-v2__input-wrapper{line-height:32px}.el-select-v2__wrapper .el-select-v2__input-wrapper input{--el-input-inner-height:calc(var(--el-component-size, 32px) - 8px);height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);min-width:4px;width:100%;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none;background:0 0;border:none;margin:2px 0;outline:0;padding:0}.el-select-v2 .el-select-v2__tags-text{display:inline-block;line-height:normal;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select-v2__empty{padding:10px 0;margin:0;text-align:center;color:var(--el-text-color-secondary);font-size:14px}.el-select-v2__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-select-v2__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-select-v2__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent;border-left-color:transparent}.el-select-v2__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-select-v2__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent;border-bottom-color:transparent}.el-select-v2__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-select-v2--large .el-select-v2__wrapper .el-select-v2__combobox-input{height:32px}.el-select-v2--large .el-select-v2__caret,.el-select-v2--large .el-select-v2__suffix{height:40px}.el-select-v2--large .el-select-v2__placeholder{font-size:14px;line-height:40px}.el-select-v2--small .el-select-v2__wrapper .el-select-v2__combobox-input{height:16px}.el-select-v2--small .el-select-v2__caret,.el-select-v2--small .el-select-v2__suffix{height:24px}.el-select-v2--small .el-select-v2__placeholder{font-size:12px;line-height:24px}.el-select-v2 .el-select-v2__selection>span{display:inline-block}.el-select-v2:hover .el-select-v2__combobox-input{border-color:var(--el-select-border-color-hover)}.el-select-v2 .el-select__selection-text{text-overflow:ellipsis;display:inline-block;overflow-x:hidden;vertical-align:bottom}.el-select-v2 .el-select-v2__combobox-input{padding-right:35px;display:block;color:var(--el-text-color-regular)}.el-select-v2 .el-select-v2__combobox-input:focus{border-color:var(--el-select-input-focus-border-color)}.el-select-v2__input{border:none;outline:0;padding:0;margin-left:15px;color:var(--el-select-multiple-input-color);font-size:var(--el-select-font-size);-webkit-appearance:none;-moz-appearance:none;appearance:none;height:28px}.el-select-v2__input.is-small{height:14px}.el-select-v2__close{cursor:pointer;position:absolute;top:8px;z-index:var(--el-index-top);right:25px;color:var(--el-select-input-color);line-height:18px;font-size:var(--el-select-input-font-size)}.el-select-v2__close:hover{color:var(--el-select-close-hover-color)}.el-select-v2__suffix{display:inline-flex;position:absolute;right:12px;height:32px;top:50%;transform:translateY(-50%);color:var(--el-input-icon-color,var(--el-text-color-placeholder))}.el-select-v2__suffix .el-input__icon{height:inherit}.el-select-v2__suffix .el-input__icon:not(:first-child){margin-left:8px}.el-select-v2__caret{color:var(--el-select-input-color);font-size:var(--el-select-input-font-size);transition:var(--el-transition-duration);transform:rotate(180deg);cursor:pointer}.el-select-v2__caret.is-reverse{transform:rotate(0)}.el-select-v2__caret.is-show-close{font-size:var(--el-select-font-size);text-align:center;transform:rotate(180deg);border-radius:var(--el-border-radius-circle);color:var(--el-select-input-color);transition:var(--el-transition-color)}.el-select-v2__caret.is-show-close:hover{color:var(--el-select-close-hover-color)}.el-select-v2__caret.el-icon{height:inherit}.el-select-v2__caret.el-icon svg{vertical-align:middle}.el-select-v2__selection{white-space:normal;z-index:var(--el-index-normal);display:flex;align-items:center;flex-wrap:wrap;width:100%}.el-select-v2__input-calculator{left:0;position:absolute;top:0;visibility:hidden;white-space:pre;z-index:999}.el-select-v2__selected-item{line-height:inherit;height:inherit;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-wrap:wrap}.el-select-v2__placeholder{position:absolute;top:50%;transform:translateY(-50%);-webkit-margin-start:12px;margin-inline-start:12px;width:calc(100% - 52px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--el-input-text-color,var(--el-text-color-regular))}.el-select-v2__placeholder.is-transparent{color:var(--el-text-color-placeholder)}.el-select-v2 .el-select-v2__selection .el-tag{box-sizing:border-box;border-color:transparent;margin:2px 0 2px 6px;background-color:var(--el-fill-color)}.el-select-v2 .el-select-v2__selection .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);right:-7px;color:var(--el-color-white)}.el-select-v2 .el-select-v2__selection .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-select-v2 .el-select-v2__selection .el-tag .el-icon-close:before{display:block;transform:translateY(.5px)}.el-select-v2.el-select-v2--small .el-select-v2__selection .el-tag{margin:1px 0 1px 6px;height:18px}.el-slider{--el-slider-main-bg-color:var(--el-color-primary);--el-slider-runway-bg-color:var(--el-border-color-light);--el-slider-stop-bg-color:var(--el-color-white);--el-slider-disabled-color:var(--el-text-color-placeholder);--el-slider-border-radius:3px;--el-slider-height:6px;--el-slider-button-size:20px;--el-slider-button-wrapper-size:36px;--el-slider-button-wrapper-offset:-15px}.el-slider{width:100%;height:32px;display:flex;align-items:center}.el-slider__runway{flex:1;height:var(--el-slider-height);background-color:var(--el-slider-runway-bg-color);border-radius:var(--el-slider-border-radius);position:relative;cursor:pointer}.el-slider__runway.show-input{margin-right:30px;width:auto}.el-slider__runway.is-disabled{cursor:default}.el-slider__runway.is-disabled .el-slider__bar{background-color:var(--el-slider-disabled-color)}.el-slider__runway.is-disabled .el-slider__button{border-color:var(--el-slider-disabled-color)}.el-slider__runway.is-disabled .el-slider__button-wrapper.hover,.el-slider__runway.is-disabled .el-slider__button-wrapper:hover,.el-slider__runway.is-disabled .el-slider__button-wrapper.dragging{cursor:not-allowed}.el-slider__runway.is-disabled .el-slider__button.dragging,.el-slider__runway.is-disabled .el-slider__button.hover,.el-slider__runway.is-disabled .el-slider__button:hover{transform:scale(1)}.el-slider__runway.is-disabled .el-slider__button.hover,.el-slider__runway.is-disabled .el-slider__button:hover,.el-slider__runway.is-disabled .el-slider__button.dragging{cursor:not-allowed}.el-slider__input{flex-shrink:0;width:130px}.el-slider__bar{height:var(--el-slider-height);background-color:var(--el-slider-main-bg-color);border-top-left-radius:var(--el-slider-border-radius);border-bottom-left-radius:var(--el-slider-border-radius);position:absolute}.el-slider__button-wrapper{height:var(--el-slider-button-wrapper-size);width:var(--el-slider-button-wrapper-size);position:absolute;z-index:1;top:var(--el-slider-button-wrapper-offset);transform:translate(-50%);background-color:transparent;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;line-height:normal;outline:0}.el-slider__button-wrapper:after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-slider__button-wrapper.hover,.el-slider__button-wrapper:hover{cursor:-webkit-grab;cursor:grab}.el-slider__button-wrapper.dragging{cursor:-webkit-grabbing;cursor:grabbing}.el-slider__button{display:inline-block;width:var(--el-slider-button-size);height:var(--el-slider-button-size);vertical-align:middle;border:solid 2px var(--el-slider-main-bg-color);background-color:var(--el-color-white);border-radius:50%;box-sizing:border-box;transition:var(--el-transition-duration-fast);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-slider__button.dragging,.el-slider__button.hover,.el-slider__button:hover{transform:scale(1.2)}.el-slider__button.hover,.el-slider__button:hover{cursor:-webkit-grab;cursor:grab}.el-slider__button.dragging{cursor:-webkit-grabbing;cursor:grabbing}.el-slider__stop{position:absolute;height:var(--el-slider-height);width:var(--el-slider-height);border-radius:var(--el-border-radius-circle);background-color:var(--el-slider-stop-bg-color);transform:translate(-50%)}.el-slider__marks{top:0;left:12px;width:18px;height:100%}.el-slider__marks-text{position:absolute;transform:translate(-50%);font-size:14px;color:var(--el-color-info);margin-top:15px;white-space:pre}.el-slider.is-vertical{position:relative;display:inline-flex;width:auto;height:100%;flex:0}.el-slider.is-vertical .el-slider__runway{width:var(--el-slider-height);height:100%;margin:0 16px}.el-slider.is-vertical .el-slider__bar{width:var(--el-slider-height);height:auto;border-radius:0 0 3px 3px}.el-slider.is-vertical .el-slider__button-wrapper{top:auto;left:var(--el-slider-button-wrapper-offset);transform:translateY(50%)}.el-slider.is-vertical .el-slider__stop{transform:translateY(50%)}.el-slider.is-vertical .el-slider__marks-text{margin-top:0;left:15px;transform:translateY(50%)}.el-slider--large{height:40px}.el-slider--small{height:24px}.el-statistic{--el-statistic-title-font-weight:400;--el-statistic-title-font-size:var(--el-font-size-extra-small);--el-statistic-title-color:var(--el-text-color-regular);--el-statistic-content-font-weight:400;--el-statistic-content-font-size:var(--el-font-size-extra-large);--el-statistic-content-color:var(--el-text-color-primary)}.el-statistic__head{font-weight:var(--el-statistic-title-font-weight);font-size:var(--el-statistic-title-font-size);color:var(--el-statistic-title-color);line-height:20px;margin-bottom:4px}.el-statistic__content{font-weight:var(--el-statistic-content-font-weight);font-size:var(--el-statistic-content-font-size);color:var(--el-statistic-content-color)}.el-statistic__value{display:inline-block}.el-statistic__prefix{margin-right:4px;display:inline-block}.el-statistic__suffix{margin-left:4px;display:inline-block}*[data-v-ec01773c]{font-family:win-bug-omega,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Hiragino Kaku Gothic ProN,Meiryo,sans-serif!important}.onlineGallery-toolBar[data-v-ec01773c]{position:relative;margin-top:10px;margin-bottom:10px;display:flex;flex-flow:row wrap;justify-content:start;align-items:center;gap:10px;color:#000;-webkit-user-select:none;user-select:none;-webkit-user-drag:none}@media (max-width: 500px){.onlineGallery-toolBar[data-v-ec01773c]{gap:4px;margin-top:4px;margin-bottom:8px;padding-left:10px;padding-right:10px}}.onlineGallery-toolBar .statistic[data-v-ec01773c]{flex-shrink:0;width:140px;font-size:14px!important;display:flex;flex-flow:column;justify-content:center;align-items:center}@media (max-width: 500px){.onlineGallery-toolBar .statistic[data-v-ec01773c]{width:100%;align-items:start}}.onlineGallery-toolBar .filter[data-v-ec01773c]{width:fit-content;width:220px;display:flex;flex-flow:column;justify-content:center;align-items:center}@media (max-width: 500px){.onlineGallery-toolBar .filter[data-v-ec01773c]{align-items:start;gap:2px}}.onlineGallery-toolBar .filter .size[data-v-ec01773c]{position:relative;width:100%;display:flex;flex-flow:column nowrap;justify-content:center;align-items:center}@media (max-width: 500px){.onlineGallery-toolBar .filter .size[data-v-ec01773c]{gap:2px}}.onlineGallery-toolBar .filter .size .row[data-v-ec01773c]{width:100%;display:flex;flex-flow:row nowrap;gap:8px;justify-content:start;align-items:center}.onlineGallery-toolBar .filter .size .row .slider[data-v-ec01773c]{flex-grow:1;padding-right:10px}.onlineGallery-toolBar .filter .size .row .label[data-v-ec01773c]{margin:0;white-space:nowrap;font-size:16px!important}.onlineGallery-toolBar .filter .format[data-v-ec01773c]{position:relative;width:100%;display:flex;flex-flow:row;justify-content:center;align-items:center;gap:8px}.onlineGallery-toolBar .filter .format .select[data-v-ec01773c]{flex-grow:1}.onlineGallery-toolBar .filter .format .label[data-v-ec01773c]{margin:0;text-align:center;white-space:nowrap;font-size:16px!important}.onlineGallery-toolBar .ruleSelector[data-v-ec01773c]{position:relative;width:fit-content;display:flex;flex-flow:row;justify-content:center;align-items:center;gap:8px}.onlineGallery-toolBar .ruleSelector .select[data-v-ec01773c]{width:160px}.onlineGallery-toolBar .ruleSelector .label[data-v-ec01773c]{margin:0;text-align:center;white-space:nowrap;font-size:16px!important}.onlineGallery-toolBar .list-control[data-v-ec01773c]{position:relative;width:fit-content;display:flex;flex-flow:column;justify-content:center;align-items:start;gap:8px}@media (max-width: 500px){.onlineGallery-toolBar .list-control[data-v-ec01773c]{flex-flow:row}}.onlineGallery-toolBar .list-control .zoom-slider[data-v-ec01773c]{position:relative;width:fit-content;display:flex;flex-flow:row;justify-content:center;align-items:center;gap:8px}.onlineGallery-toolBar .list-control .zoom-slider .input-number[data-v-ec01773c]{width:80px}.onlineGallery-toolBar .list-control .zoom-slider .label[data-v-ec01773c]{margin:0;text-align:center;white-space:nowrap;font-size:16px!important}.onlineGallery-toolBar .list-control .sort-method[data-v-ec01773c]{position:relative;width:fit-content;display:flex;flex-flow:row;justify-content:center;align-items:center;gap:8px}.onlineGallery-toolBar .list-control .sort-method .select[data-v-ec01773c]{width:120px}.onlineGallery-toolBar .list-control .sort-method .label[data-v-ec01773c]{margin:0;text-align:center;white-space:nowrap;font-size:16px!important}.onlineGallery-toolBar .button-group[data-v-ec01773c]{width:fit-content}.rule-item[data-v-ec01773c]{height:100%!important;display:flex;justify-content:start;align-items:center;gap:8px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.rule-icon[data-v-ec01773c]{flex-shrink:0;width:16px!important;aspect-ratio:1;display:flex;justify-content:center;align-items:center}.el-progress{position:relative;line-height:1;display:flex;align-items:center}.el-progress__text{font-size:14px;color:var(--el-text-color-regular);margin-left:5px;min-width:50px;line-height:1}.el-progress__text i{vertical-align:middle;display:block}.el-progress--circle,.el-progress--dashboard{display:inline-block}.el-progress--circle .el-progress__text,.el-progress--dashboard .el-progress__text{position:absolute;top:50%;left:0;width:100%;text-align:center;margin:0;transform:translateY(-50%)}.el-progress--circle .el-progress__text i,.el-progress--dashboard .el-progress__text i{vertical-align:middle;display:inline-block}.el-progress--without-text .el-progress__text{display:none}.el-progress--without-text .el-progress-bar{padding-right:0;margin-right:0;display:block}.el-progress--text-inside .el-progress-bar{padding-right:0;margin-right:0}.el-progress.is-success .el-progress-bar__inner{background-color:var(--el-color-success)}.el-progress.is-success .el-progress__text{color:var(--el-color-success)}.el-progress.is-warning .el-progress-bar__inner{background-color:var(--el-color-warning)}.el-progress.is-warning .el-progress__text{color:var(--el-color-warning)}.el-progress.is-exception .el-progress-bar__inner{background-color:var(--el-color-danger)}.el-progress.is-exception .el-progress__text{color:var(--el-color-danger)}.el-progress-bar{flex-grow:1;box-sizing:border-box}.el-progress-bar__outer{height:6px;border-radius:100px;background-color:var(--el-border-color-lighter);overflow:hidden;position:relative;vertical-align:middle}.el-progress-bar__inner{position:absolute;left:0;top:0;height:100%;background-color:var(--el-color-primary);text-align:right;border-radius:100px;line-height:1;white-space:nowrap;transition:width .6s ease}.el-progress-bar__inner:after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-progress-bar__inner--indeterminate{transform:translateZ(0);-webkit-animation:indeterminate 3s infinite;animation:indeterminate 3s infinite}.el-progress-bar__inner--striped{background-image:linear-gradient(45deg,rgba(0,0,0,.1) 25%,transparent 25%,transparent 50%,rgba(0,0,0,.1) 50%,rgba(0,0,0,.1) 75%,transparent 75%,transparent);background-size:1.25em 1.25em}.el-progress-bar__inner--striped.el-progress-bar__inner--striped-flow{-webkit-animation:striped-flow 3s linear infinite;animation:striped-flow 3s linear infinite}.el-progress-bar__innerText{display:inline-block;vertical-align:middle;color:#fff;font-size:12px;margin:0 5px}@-webkit-keyframes progress{0%{background-position:0 0}to{background-position:32px 0}}@keyframes progress{0%{background-position:0 0}to{background-position:32px 0}}@-webkit-keyframes indeterminate{0%{left:-100%}to{left:100%}}@keyframes indeterminate{0%{left:-100%}to{left:100%}}@-webkit-keyframes striped-flow{0%{background-position:-100%}to{background-position:100%}}@keyframes striped-flow{0%{background-position:-100%}to{background-position:100%}}*[data-v-66e65ea2]{border:0;margin:0;box-sizing:border-box}.onlineGallery-body[data-v-66e65ea2]{position:relative;width:100%;height:100%;display:flex;flex-flow:column;justify-content:stretch;align-items:center;--header-height: 80px}.onlineGallery-body .toolBar[data-v-66e65ea2]{flex-shrink:0;position:relative;max-width:100%;width:100%;height:max-content}.onlineGallery-body .listContainer[data-v-66e65ea2]{flex-grow:1;position:relative;width:100%;border-radius:6px;box-shadow:var(--el-box-shadow-light);overflow:hidden}.onlineGallery-body .loadingBar[data-v-66e65ea2]{position:absolute;margin:0 auto;top:2px;left:0;right:0;width:50%}@media (max-width: 500px){.onlineGallery-body .loadingBar[data-v-66e65ea2]{width:80%}}.el-notification{--el-notification-width:330px;--el-notification-padding:14px 26px 14px 13px;--el-notification-radius:8px;--el-notification-shadow:var(--el-box-shadow-light);--el-notification-border-color:var(--el-border-color-lighter);--el-notification-icon-size:24px;--el-notification-close-font-size:var(--el-message-close-size, 16px);--el-notification-group-margin-left:13px;--el-notification-group-margin-right:8px;--el-notification-content-font-size:var(--el-font-size-base);--el-notification-content-color:var(--el-text-color-regular);--el-notification-title-font-size:16px;--el-notification-title-color:var(--el-text-color-primary);--el-notification-close-color:var(--el-text-color-secondary);--el-notification-close-hover-color:var(--el-text-color-regular)}.el-notification{display:flex;width:var(--el-notification-width);padding:var(--el-notification-padding);border-radius:var(--el-notification-radius);box-sizing:border-box;border:1px solid var(--el-notification-border-color);position:fixed;background-color:var(--el-bg-color-overlay);box-shadow:var(--el-notification-shadow);transition:opacity var(--el-transition-duration),transform var(--el-transition-duration),left var(--el-transition-duration),right var(--el-transition-duration),top .4s,bottom var(--el-transition-duration);overflow-wrap:anywhere;overflow:hidden;z-index:9999}.el-notification.right{right:16px}.el-notification.left{left:16px}.el-notification__group{margin-left:var(--el-notification-group-margin-left);margin-right:var(--el-notification-group-margin-right)}.el-notification__title{font-weight:700;font-size:var(--el-notification-title-font-size);line-height:var(--el-notification-icon-size);color:var(--el-notification-title-color);margin:0}.el-notification__content{font-size:var(--el-notification-content-font-size);line-height:24px;margin:6px 0 0;color:var(--el-notification-content-color);text-align:justify}.el-notification__content p{margin:0}.el-notification .el-notification__icon{height:var(--el-notification-icon-size);width:var(--el-notification-icon-size);font-size:var(--el-notification-icon-size)}.el-notification .el-notification__closeBtn{position:absolute;top:18px;right:15px;cursor:pointer;color:var(--el-notification-close-color);font-size:var(--el-notification-close-font-size)}.el-notification .el-notification__closeBtn:hover{color:var(--el-notification-close-hover-color)}.el-notification .el-notification--success{--el-notification-icon-color:var(--el-color-success);color:var(--el-notification-icon-color)}.el-notification .el-notification--info{--el-notification-icon-color:var(--el-color-info);color:var(--el-notification-icon-color)}.el-notification .el-notification--warning{--el-notification-icon-color:var(--el-color-warning);color:var(--el-notification-icon-color)}.el-notification .el-notification--error{--el-notification-icon-color:var(--el-color-error);color:var(--el-notification-icon-color)}.el-notification-fade-enter-from.right{right:0;transform:translate(100%)}.el-notification-fade-enter-from.left{left:0;transform:translate(-100%)}.el-notification-fade-leave-to{opacity:0}*[data-v-186e1ab4]{box-sizing:border-box;border:0;pointer-events:auto}.onlineGallery-container[data-v-186e1ab4]{box-sizing:border-box;position:fixed;z-index:2147483646;padding:0 30px 20px;margin:0;left:calc(0px - var(--width));top:0!important;bottom:0;width:var(--width);max-width:100vw!important;background-color:#fffc;box-shadow:var(--el-box-shadow-dark);-webkit-backdrop-filter:blur(2px);backdrop-filter:blur(2px);display:flex;flex-flow:column;justify-content:start;align-items:center;transition:.5s ease}.onlineGallery-container[data-open=true][data-v-186e1ab4]{left:0px!important}.onlineGallery-container[data-v-186e1ab4]:focus{outline:none}@media (max-width: 500px){.onlineGallery-container[data-v-186e1ab4]{padding:4px}}.onlineGallery-button-drawerOpen[data-v-186e1ab4]{position:absolute;z-index:1;margin:auto 0;width:30px;height:60px;border-radius:0 30px 30px 0;right:0;top:0;bottom:0;cursor:pointer;display:flex;justify-content:center;align-items:center;font-size:xx-large}:root:has(.onlineGallery-container[data-open=false]) .onlineGallery-button-drawerOpen[data-v-186e1ab4]{border-radius:0 30px 30px 0!important;box-shadow:var(--el-box-shadow-light);right:-30px;transition:.25s .25s ease}:root:has(.onlineGallery-container[data-open=true]) .onlineGallery-button-drawerOpen[data-v-186e1ab4]{border-radius:30px 0 0 30px!important;background-color:transparent;box-shadow:none;transition:.25s .25s ease}.onlineGallery-button-drawerOpen i[data-v-186e1ab4]{transition:.25s .25s ease}:root:has(.onlineGallery-container[data-open=false]) .onlineGallery-button-drawerOpen i[data-v-186e1ab4]{transform:rotateY(0);color:auto}:root:has(.onlineGallery-container[data-open=true]) .onlineGallery-button-drawerOpen i[data-v-186e1ab4]{transform:rotateY(180deg);color:#409eff}@media (max-width: 500px){.onlineGallery-button-drawerOpen[data-v-186e1ab4]{right:-30px!important}.onlineGallery-button-drawerOpen i[data-v-186e1ab4]{transform:rotateY(0)!important}}.onlineGallery-button-close[data-v-186e1ab4]{position:absolute;right:10px;top:10px;width:fit-content;height:fit-content;box-shadow:var(--el-box-shadow-light)}.onlineGallery-child-window-container[data-v-186e1ab4]{position:fixed;z-index:2147483646;overflow:visible} `);

(function (JSZip$1) {
  'use strict';

  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var require_main_001 = __commonJS({
    "main-150f1e51.js"(exports, module) {
      function makeMap(str, expectsLowerCase) {
        const map = /* @__PURE__ */ Object.create(null);
        const list = str.split(",");
        for (let i2 = 0; i2 < list.length; i2++) {
          map[list[i2]] = true;
        }
        return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
      }
      const EMPTY_OBJ = {};
      const EMPTY_ARR = [];
      const NOOP = () => {
      };
      const NO = () => false;
      const onRE = /^on[^a-z]/;
      const isOn = (key) => onRE.test(key);
      const isModelListener = (key) => key.startsWith("onUpdate:");
      const extend = Object.assign;
      const remove = (arr, el) => {
        const i2 = arr.indexOf(el);
        if (i2 > -1) {
          arr.splice(i2, 1);
        }
      };
      const hasOwnProperty$d = Object.prototype.hasOwnProperty;
      const hasOwn = (val, key) => hasOwnProperty$d.call(val, key);
      const isArray$2 = Array.isArray;
      const isMap$2 = (val) => toTypeString(val) === "[object Map]";
      const isSet$2 = (val) => toTypeString(val) === "[object Set]";
      const isDate = (val) => toTypeString(val) === "[object Date]";
      const isFunction$1 = (val) => typeof val === "function";
      const isString$1 = (val) => typeof val === "string";
      const isSymbol$1 = (val) => typeof val === "symbol";
      const isObject$1 = (val) => val !== null && typeof val === "object";
      const isPromise = (val) => {
        return isObject$1(val) && isFunction$1(val.then) && isFunction$1(val.catch);
      };
      const objectToString$1 = Object.prototype.toString;
      const toTypeString = (value) => objectToString$1.call(value);
      const toRawType = (value) => {
        return toTypeString(value).slice(8, -1);
      };
      const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
      const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
      const isReservedProp = /* @__PURE__ */ makeMap(
        // the leading comma is intentional so empty string "" is also included
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
      );
      const cacheStringFunction = (fn2) => {
        const cache2 = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache2[str];
          return hit || (cache2[str] = fn2(str));
        };
      };
      const camelizeRE = /-(\w)/g;
      const camelize = cacheStringFunction((str) => {
        return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
      });
      const hyphenateRE = /\B([A-Z])/g;
      const hyphenate = cacheStringFunction(
        (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
      );
      const capitalize$1 = cacheStringFunction(
        (str) => str.charAt(0).toUpperCase() + str.slice(1)
      );
      const toHandlerKey = cacheStringFunction(
        (str) => str ? `on${capitalize$1(str)}` : ``
      );
      const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
      const invokeArrayFns = (fns, arg) => {
        for (let i2 = 0; i2 < fns.length; i2++) {
          fns[i2](arg);
        }
      };
      const def = (obj, key, value) => {
        Object.defineProperty(obj, key, {
          configurable: true,
          enumerable: false,
          value
        });
      };
      const looseToNumber = (val) => {
        const n2 = parseFloat(val);
        return isNaN(n2) ? val : n2;
      };
      const toNumber$1 = (val) => {
        const n2 = isString$1(val) ? Number(val) : NaN;
        return isNaN(n2) ? val : n2;
      };
      let _globalThis;
      const getGlobalThis = () => {
        return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
      };
      function normalizeStyle(value) {
        if (isArray$2(value)) {
          const res = {};
          for (let i2 = 0; i2 < value.length; i2++) {
            const item = value[i2];
            const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) {
              for (const key in normalized) {
                res[key] = normalized[key];
              }
            }
          }
          return res;
        } else if (isString$1(value)) {
          return value;
        } else if (isObject$1(value)) {
          return value;
        }
      }
      const listDelimiterRE = /;(?![^(]*\))/g;
      const propertyDelimiterRE = /:([^]+)/;
      const styleCommentRE = /\/\*[^]*?\*\//g;
      function parseStringStyle(cssText) {
        const ret = {};
        cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
          if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
          }
        });
        return ret;
      }
      function normalizeClass(value) {
        let res = "";
        if (isString$1(value)) {
          res = value;
        } else if (isArray$2(value)) {
          for (let i2 = 0; i2 < value.length; i2++) {
            const normalized = normalizeClass(value[i2]);
            if (normalized) {
              res += normalized + " ";
            }
          }
        } else if (isObject$1(value)) {
          for (const name in value) {
            if (value[name]) {
              res += name + " ";
            }
          }
        }
        return res.trim();
      }
      function normalizeProps(props) {
        if (!props)
          return null;
        let { class: klass, style } = props;
        if (klass && !isString$1(klass)) {
          props.class = normalizeClass(klass);
        }
        if (style) {
          props.style = normalizeStyle(style);
        }
        return props;
      }
      const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
      const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
      function includeBooleanAttr(value) {
        return !!value || value === "";
      }
      function looseCompareArrays(a2, b2) {
        if (a2.length !== b2.length)
          return false;
        let equal = true;
        for (let i2 = 0; equal && i2 < a2.length; i2++) {
          equal = looseEqual(a2[i2], b2[i2]);
        }
        return equal;
      }
      function looseEqual(a2, b2) {
        if (a2 === b2)
          return true;
        let aValidType = isDate(a2);
        let bValidType = isDate(b2);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
        }
        aValidType = isSymbol$1(a2);
        bValidType = isSymbol$1(b2);
        if (aValidType || bValidType) {
          return a2 === b2;
        }
        aValidType = isArray$2(a2);
        bValidType = isArray$2(b2);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
        }
        aValidType = isObject$1(a2);
        bValidType = isObject$1(b2);
        if (aValidType || bValidType) {
          if (!aValidType || !bValidType) {
            return false;
          }
          const aKeysCount = Object.keys(a2).length;
          const bKeysCount = Object.keys(b2).length;
          if (aKeysCount !== bKeysCount) {
            return false;
          }
          for (const key in a2) {
            const aHasKey = a2.hasOwnProperty(key);
            const bHasKey = b2.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b2[key])) {
              return false;
            }
          }
        }
        return String(a2) === String(b2);
      }
      function looseIndexOf(arr, val) {
        return arr.findIndex((item) => looseEqual(item, val));
      }
      const toDisplayString = (val) => {
        return isString$1(val) ? val : val == null ? "" : isArray$2(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
      };
      const replacer = (_key, val) => {
        if (val && val.__v_isRef) {
          return replacer(_key, val.value);
        } else if (isMap$2(val)) {
          return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
              entries[`${key} =>`] = val2;
              return entries;
            }, {})
          };
        } else if (isSet$2(val)) {
          return {
            [`Set(${val.size})`]: [...val.values()]
          };
        } else if (isObject$1(val) && !isArray$2(val) && !isPlainObject$1(val)) {
          return String(val);
        }
        return val;
      };
      let activeEffectScope;
      class EffectScope {
        constructor(detached = false) {
          this.detached = detached;
          this._active = true;
          this.effects = [];
          this.cleanups = [];
          this.parent = activeEffectScope;
          if (!detached && activeEffectScope) {
            this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
              this
            ) - 1;
          }
        }
        get active() {
          return this._active;
        }
        run(fn2) {
          if (this._active) {
            const currentEffectScope = activeEffectScope;
            try {
              activeEffectScope = this;
              return fn2();
            } finally {
              activeEffectScope = currentEffectScope;
            }
          }
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        on() {
          activeEffectScope = this;
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        off() {
          activeEffectScope = this.parent;
        }
        stop(fromParent) {
          if (this._active) {
            let i2, l2;
            for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
              this.effects[i2].stop();
            }
            for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
              this.cleanups[i2]();
            }
            if (this.scopes) {
              for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
                this.scopes[i2].stop(true);
              }
            }
            if (!this.detached && this.parent && !fromParent) {
              const last = this.parent.scopes.pop();
              if (last && last !== this) {
                this.parent.scopes[this.index] = last;
                last.index = this.index;
              }
            }
            this.parent = void 0;
            this._active = false;
          }
        }
      }
      function effectScope(detached) {
        return new EffectScope(detached);
      }
      function recordEffectScope(effect, scope = activeEffectScope) {
        if (scope && scope.active) {
          scope.effects.push(effect);
        }
      }
      function getCurrentScope() {
        return activeEffectScope;
      }
      function onScopeDispose(fn2) {
        if (activeEffectScope) {
          activeEffectScope.cleanups.push(fn2);
        }
      }
      const createDep = (effects) => {
        const dep = new Set(effects);
        dep.w = 0;
        dep.n = 0;
        return dep;
      };
      const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
      const newTracked = (dep) => (dep.n & trackOpBit) > 0;
      const initDepMarkers = ({ deps }) => {
        if (deps.length) {
          for (let i2 = 0; i2 < deps.length; i2++) {
            deps[i2].w |= trackOpBit;
          }
        }
      };
      const finalizeDepMarkers = (effect) => {
        const { deps } = effect;
        if (deps.length) {
          let ptr = 0;
          for (let i2 = 0; i2 < deps.length; i2++) {
            const dep = deps[i2];
            if (wasTracked(dep) && !newTracked(dep)) {
              dep.delete(effect);
            } else {
              deps[ptr++] = dep;
            }
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
          }
          deps.length = ptr;
        }
      };
      const targetMap = /* @__PURE__ */ new WeakMap();
      let effectTrackDepth = 0;
      let trackOpBit = 1;
      const maxMarkerBits = 30;
      let activeEffect;
      const ITERATE_KEY = Symbol("");
      const MAP_KEY_ITERATE_KEY = Symbol("");
      class ReactiveEffect {
        constructor(fn2, scheduler = null, scope) {
          this.fn = fn2;
          this.scheduler = scheduler;
          this.active = true;
          this.deps = [];
          this.parent = void 0;
          recordEffectScope(this, scope);
        }
        run() {
          if (!this.active) {
            return this.fn();
          }
          let parent = activeEffect;
          let lastShouldTrack = shouldTrack;
          while (parent) {
            if (parent === this) {
              return;
            }
            parent = parent.parent;
          }
          try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) {
              initDepMarkers(this);
            } else {
              cleanupEffect(this);
            }
            return this.fn();
          } finally {
            if (effectTrackDepth <= maxMarkerBits) {
              finalizeDepMarkers(this);
            }
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = void 0;
            if (this.deferStop) {
              this.stop();
            }
          }
        }
        stop() {
          if (activeEffect === this) {
            this.deferStop = true;
          } else if (this.active) {
            cleanupEffect(this);
            if (this.onStop) {
              this.onStop();
            }
            this.active = false;
          }
        }
      }
      function cleanupEffect(effect2) {
        const { deps } = effect2;
        if (deps.length) {
          for (let i2 = 0; i2 < deps.length; i2++) {
            deps[i2].delete(effect2);
          }
          deps.length = 0;
        }
      }
      let shouldTrack = true;
      const trackStack = [];
      function pauseTracking() {
        trackStack.push(shouldTrack);
        shouldTrack = false;
      }
      function resetTracking() {
        const last = trackStack.pop();
        shouldTrack = last === void 0 ? true : last;
      }
      function track(target, type2, key) {
        if (shouldTrack && activeEffect) {
          let depsMap = targetMap.get(target);
          if (!depsMap) {
            targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
          }
          let dep = depsMap.get(key);
          if (!dep) {
            depsMap.set(key, dep = createDep());
          }
          trackEffects(dep);
        }
      }
      function trackEffects(dep, debuggerEventExtraInfo) {
        let shouldTrack2 = false;
        if (effectTrackDepth <= maxMarkerBits) {
          if (!newTracked(dep)) {
            dep.n |= trackOpBit;
            shouldTrack2 = !wasTracked(dep);
          }
        } else {
          shouldTrack2 = !dep.has(activeEffect);
        }
        if (shouldTrack2) {
          dep.add(activeEffect);
          activeEffect.deps.push(dep);
        }
      }
      function trigger(target, type2, key, newValue, oldValue, oldTarget) {
        const depsMap = targetMap.get(target);
        if (!depsMap) {
          return;
        }
        let deps = [];
        if (type2 === "clear") {
          deps = [...depsMap.values()];
        } else if (key === "length" && isArray$2(target)) {
          const newLength = Number(newValue);
          depsMap.forEach((dep, key2) => {
            if (key2 === "length" || key2 >= newLength) {
              deps.push(dep);
            }
          });
        } else {
          if (key !== void 0) {
            deps.push(depsMap.get(key));
          }
          switch (type2) {
            case "add":
              if (!isArray$2(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
                if (isMap$2(target)) {
                  deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              } else if (isIntegerKey(key)) {
                deps.push(depsMap.get("length"));
              }
              break;
            case "delete":
              if (!isArray$2(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
                if (isMap$2(target)) {
                  deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              }
              break;
            case "set":
              if (isMap$2(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
              }
              break;
          }
        }
        if (deps.length === 1) {
          if (deps[0]) {
            {
              triggerEffects(deps[0]);
            }
          }
        } else {
          const effects = [];
          for (const dep of deps) {
            if (dep) {
              effects.push(...dep);
            }
          }
          {
            triggerEffects(createDep(effects));
          }
        }
      }
      function triggerEffects(dep, debuggerEventExtraInfo) {
        const effects = isArray$2(dep) ? dep : [...dep];
        for (const effect2 of effects) {
          if (effect2.computed) {
            triggerEffect(effect2);
          }
        }
        for (const effect2 of effects) {
          if (!effect2.computed) {
            triggerEffect(effect2);
          }
        }
      }
      function triggerEffect(effect2, debuggerEventExtraInfo) {
        if (effect2 !== activeEffect || effect2.allowRecurse) {
          if (effect2.scheduler) {
            effect2.scheduler();
          } else {
            effect2.run();
          }
        }
      }
      function getDepFromReactive(object2, key) {
        var _a2;
        return (_a2 = targetMap.get(object2)) == null ? void 0 : _a2.get(key);
      }
      const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
      const builtInSymbols = new Set(
        /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
      );
      const get$1 = /* @__PURE__ */ createGetter();
      const shallowGet = /* @__PURE__ */ createGetter(false, true);
      const readonlyGet = /* @__PURE__ */ createGetter(true);
      const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
      function createArrayInstrumentations() {
        const instrumentations = {};
        ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
          instrumentations[key] = function(...args) {
            const arr = toRaw(this);
            for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
              track(arr, "get", i2 + "");
            }
            const res = arr[key](...args);
            if (res === -1 || res === false) {
              return arr[key](...args.map(toRaw));
            } else {
              return res;
            }
          };
        });
        ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
          instrumentations[key] = function(...args) {
            pauseTracking();
            const res = toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
          };
        });
        return instrumentations;
      }
      function hasOwnProperty$c(key) {
        const obj = toRaw(this);
        track(obj, "has", key);
        return obj.hasOwnProperty(key);
      }
      function createGetter(isReadonly2 = false, shallow = false) {
        return function get2(target, key, receiver) {
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_isShallow") {
            return shallow;
          } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
            return target;
          }
          const targetIsArray = isArray$2(target);
          if (!isReadonly2) {
            if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
              return Reflect.get(arrayInstrumentations, key, receiver);
            }
            if (key === "hasOwnProperty") {
              return hasOwnProperty$c;
            }
          }
          const res = Reflect.get(target, key, receiver);
          if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
          }
          if (!isReadonly2) {
            track(target, "get", key);
          }
          if (shallow) {
            return res;
          }
          if (isRef(res)) {
            return targetIsArray && isIntegerKey(key) ? res : res.value;
          }
          if (isObject$1(res)) {
            return isReadonly2 ? readonly(res) : reactive(res);
          }
          return res;
        };
      }
      const set$1 = /* @__PURE__ */ createSetter();
      const shallowSet = /* @__PURE__ */ createSetter(true);
      function createSetter(shallow = false) {
        return function set2(target, key, value, receiver) {
          let oldValue = target[key];
          if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
            return false;
          }
          if (!shallow) {
            if (!isShallow(value) && !isReadonly(value)) {
              oldValue = toRaw(oldValue);
              value = toRaw(value);
            }
            if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
              oldValue.value = value;
              return true;
            }
          }
          const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
          const result = Reflect.set(target, key, value, receiver);
          if (target === toRaw(receiver)) {
            if (!hadKey) {
              trigger(target, "add", key, value);
            } else if (hasChanged(value, oldValue)) {
              trigger(target, "set", key, value);
            }
          }
          return result;
        };
      }
      function deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      }
      function has$1(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      function ownKeys(target) {
        track(target, "iterate", isArray$2(target) ? "length" : ITERATE_KEY);
        return Reflect.ownKeys(target);
      }
      const mutableHandlers = {
        get: get$1,
        set: set$1,
        deleteProperty,
        has: has$1,
        ownKeys
      };
      const readonlyHandlers = {
        get: readonlyGet,
        set(target, key) {
          return true;
        },
        deleteProperty(target, key) {
          return true;
        }
      };
      const shallowReactiveHandlers = /* @__PURE__ */ extend(
        {},
        mutableHandlers,
        {
          get: shallowGet,
          set: shallowSet
        }
      );
      const toShallow = (value) => value;
      const getProto = (v2) => Reflect.getPrototypeOf(v2);
      function get$2(target, key, isReadonly2 = false, isShallow2 = false) {
        target = target["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!isReadonly2) {
          if (key !== rawKey) {
            track(rawTarget, "get", key);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has: has2 } = getProto(rawTarget);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        if (has2.call(rawTarget, key)) {
          return wrap(target.get(key));
        } else if (has2.call(rawTarget, rawKey)) {
          return wrap(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key);
        }
      }
      function has(key, isReadonly2 = false) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!isReadonly2) {
          if (key !== rawKey) {
            track(rawTarget, "has", key);
          }
          track(rawTarget, "has", rawKey);
        }
        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
      }
      function size(target, isReadonly2 = false) {
        target = target["__v_raw"];
        !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return Reflect.get(target, "size", target);
      }
      function add(value) {
        value = toRaw(value);
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      }
      function set$2(key, value) {
        value = toRaw(value);
        const target = toRaw(this);
        const { has: has2, get: get2 } = getProto(target);
        let hadKey = has2.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target, key);
        }
        const oldValue = get2.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      }
      function deleteEntry(key) {
        const target = toRaw(this);
        const { has: has2, get: get2 } = getProto(target);
        let hadKey = has2.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target, key);
        }
        get2 ? get2.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      }
      function clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(target, "clear", void 0, void 0);
        }
        return result;
      }
      function createForEach(isReadonly2, isShallow2) {
        return function forEach(callback, thisArg) {
          const observed = this;
          const target = observed["__v_raw"];
          const rawTarget = toRaw(target);
          const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
          !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
          return target.forEach((value, key) => {
            return callback.call(thisArg, wrap(value), wrap(key), observed);
          });
        };
      }
      function createIterableMethod(method2, isReadonly2, isShallow2) {
        return function(...args) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const targetIsMap = isMap$2(rawTarget);
          const isPair = method2 === "entries" || method2 === Symbol.iterator && targetIsMap;
          const isKeyOnly = method2 === "keys" && targetIsMap;
          const innerIterator = target[method2](...args);
          const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
          !isReadonly2 && track(
            rawTarget,
            "iterate",
            isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
          );
          return {
            // iterator protocol
            next() {
              const { value, done } = innerIterator.next();
              return done ? { value, done } : {
                value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                done
              };
            },
            // iterable protocol
            [Symbol.iterator]() {
              return this;
            }
          };
        };
      }
      function createReadonlyMethod(type2) {
        return function(...args) {
          return type2 === "delete" ? false : this;
        };
      }
      function createInstrumentations() {
        const mutableInstrumentations2 = {
          get(key) {
            return get$2(this, key);
          },
          get size() {
            return size(this);
          },
          has,
          add,
          set: set$2,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, false)
        };
        const shallowInstrumentations2 = {
          get(key) {
            return get$2(this, key, false, true);
          },
          get size() {
            return size(this);
          },
          has,
          add,
          set: set$2,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, true)
        };
        const readonlyInstrumentations2 = {
          get(key) {
            return get$2(this, key, true);
          },
          get size() {
            return size(this, true);
          },
          has(key) {
            return has.call(this, key, true);
          },
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear"),
          forEach: createForEach(true, false)
        };
        const shallowReadonlyInstrumentations2 = {
          get(key) {
            return get$2(this, key, true, true);
          },
          get size() {
            return size(this, true);
          },
          has(key) {
            return has.call(this, key, true);
          },
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear"),
          forEach: createForEach(true, true)
        };
        const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
        iteratorMethods.forEach((method2) => {
          mutableInstrumentations2[method2] = createIterableMethod(
            method2,
            false,
            false
          );
          readonlyInstrumentations2[method2] = createIterableMethod(
            method2,
            true,
            false
          );
          shallowInstrumentations2[method2] = createIterableMethod(
            method2,
            false,
            true
          );
          shallowReadonlyInstrumentations2[method2] = createIterableMethod(
            method2,
            true,
            true
          );
        });
        return [
          mutableInstrumentations2,
          readonlyInstrumentations2,
          shallowInstrumentations2,
          shallowReadonlyInstrumentations2
        ];
      }
      const [
        mutableInstrumentations,
        readonlyInstrumentations,
        shallowInstrumentations,
        shallowReadonlyInstrumentations
      ] = /* @__PURE__ */ createInstrumentations();
      function createInstrumentationGetter(isReadonly2, shallow) {
        const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
        return (target, key, receiver) => {
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_raw") {
            return target;
          }
          return Reflect.get(
            hasOwn(instrumentations, key) && key in target ? instrumentations : target,
            key,
            receiver
          );
        };
      }
      const mutableCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, false)
      };
      const shallowCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, true)
      };
      const readonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, false)
      };
      const reactiveMap = /* @__PURE__ */ new WeakMap();
      const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
      const readonlyMap = /* @__PURE__ */ new WeakMap();
      const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
      function targetTypeMap(rawType) {
        switch (rawType) {
          case "Object":
          case "Array":
            return 1;
          case "Map":
          case "Set":
          case "WeakMap":
          case "WeakSet":
            return 2;
          default:
            return 0;
        }
      }
      function getTargetType(value) {
        return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
      }
      function reactive(target) {
        if (isReadonly(target)) {
          return target;
        }
        return createReactiveObject(
          target,
          false,
          mutableHandlers,
          mutableCollectionHandlers,
          reactiveMap
        );
      }
      function shallowReactive(target) {
        return createReactiveObject(
          target,
          false,
          shallowReactiveHandlers,
          shallowCollectionHandlers,
          shallowReactiveMap
        );
      }
      function readonly(target) {
        return createReactiveObject(
          target,
          true,
          readonlyHandlers,
          readonlyCollectionHandlers,
          readonlyMap
        );
      }
      function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
        if (!isObject$1(target)) {
          return target;
        }
        if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
          return target;
        }
        const existingProxy = proxyMap.get(target);
        if (existingProxy) {
          return existingProxy;
        }
        const targetType = getTargetType(target);
        if (targetType === 0) {
          return target;
        }
        const proxy = new Proxy(
          target,
          targetType === 2 ? collectionHandlers : baseHandlers
        );
        proxyMap.set(target, proxy);
        return proxy;
      }
      function isReactive(value) {
        if (isReadonly(value)) {
          return isReactive(value["__v_raw"]);
        }
        return !!(value && value["__v_isReactive"]);
      }
      function isReadonly(value) {
        return !!(value && value["__v_isReadonly"]);
      }
      function isShallow(value) {
        return !!(value && value["__v_isShallow"]);
      }
      function isProxy(value) {
        return isReactive(value) || isReadonly(value);
      }
      function toRaw(observed) {
        const raw = observed && observed["__v_raw"];
        return raw ? toRaw(raw) : observed;
      }
      function markRaw(value) {
        def(value, "__v_skip", true);
        return value;
      }
      const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
      const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
      function trackRefValue(ref2) {
        if (shouldTrack && activeEffect) {
          ref2 = toRaw(ref2);
          {
            trackEffects(ref2.dep || (ref2.dep = createDep()));
          }
        }
      }
      function triggerRefValue(ref2, newVal) {
        ref2 = toRaw(ref2);
        const dep = ref2.dep;
        if (dep) {
          {
            triggerEffects(dep);
          }
        }
      }
      function isRef(r2) {
        return !!(r2 && r2.__v_isRef === true);
      }
      function ref(value) {
        return createRef(value, false);
      }
      function shallowRef(value) {
        return createRef(value, true);
      }
      function createRef(rawValue, shallow) {
        if (isRef(rawValue)) {
          return rawValue;
        }
        return new RefImpl(rawValue, shallow);
      }
      class RefImpl {
        constructor(value, __v_isShallow) {
          this.__v_isShallow = __v_isShallow;
          this.dep = void 0;
          this.__v_isRef = true;
          this._rawValue = __v_isShallow ? value : toRaw(value);
          this._value = __v_isShallow ? value : toReactive(value);
        }
        get value() {
          trackRefValue(this);
          return this._value;
        }
        set value(newVal) {
          const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
          newVal = useDirectValue ? newVal : toRaw(newVal);
          if (hasChanged(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = useDirectValue ? newVal : toReactive(newVal);
            triggerRefValue(this);
          }
        }
      }
      function triggerRef(ref2) {
        triggerRefValue(ref2);
      }
      function unref(ref2) {
        return isRef(ref2) ? ref2.value : ref2;
      }
      const shallowUnwrapHandlers = {
        get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
        set: (target, key, value, receiver) => {
          const oldValue = target[key];
          if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          } else {
            return Reflect.set(target, key, value, receiver);
          }
        }
      };
      function proxyRefs(objectWithRefs) {
        return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
      }
      class CustomRefImpl {
        constructor(factory) {
          this.dep = void 0;
          this.__v_isRef = true;
          const { get: get2, set: set2 } = factory(
            () => trackRefValue(this),
            () => triggerRefValue(this)
          );
          this._get = get2;
          this._set = set2;
        }
        get value() {
          return this._get();
        }
        set value(newVal) {
          this._set(newVal);
        }
      }
      function customRef(factory) {
        return new CustomRefImpl(factory);
      }
      function toRefs(object2) {
        const ret = isArray$2(object2) ? new Array(object2.length) : {};
        for (const key in object2) {
          ret[key] = propertyToRef(object2, key);
        }
        return ret;
      }
      class ObjectRefImpl {
        constructor(_object, _key, _defaultValue) {
          this._object = _object;
          this._key = _key;
          this._defaultValue = _defaultValue;
          this.__v_isRef = true;
        }
        get value() {
          const val = this._object[this._key];
          return val === void 0 ? this._defaultValue : val;
        }
        set value(newVal) {
          this._object[this._key] = newVal;
        }
        get dep() {
          return getDepFromReactive(toRaw(this._object), this._key);
        }
      }
      class GetterRefImpl {
        constructor(_getter) {
          this._getter = _getter;
          this.__v_isRef = true;
          this.__v_isReadonly = true;
        }
        get value() {
          return this._getter();
        }
      }
      function toRef$1(source, key, defaultValue) {
        if (isRef(source)) {
          return source;
        } else if (isFunction$1(source)) {
          return new GetterRefImpl(source);
        } else if (isObject$1(source) && arguments.length > 1) {
          return propertyToRef(source, key, defaultValue);
        } else {
          return ref(source);
        }
      }
      function propertyToRef(source, key, defaultValue) {
        const val = source[key];
        return isRef(val) ? val : new ObjectRefImpl(
          source,
          key,
          defaultValue
        );
      }
      class ComputedRefImpl {
        constructor(getter, _setter, isReadonly2, isSSR) {
          this._setter = _setter;
          this.dep = void 0;
          this.__v_isRef = true;
          this["__v_isReadonly"] = false;
          this._dirty = true;
          this.effect = new ReactiveEffect(getter, () => {
            if (!this._dirty) {
              this._dirty = true;
              triggerRefValue(this);
            }
          });
          this.effect.computed = this;
          this.effect.active = this._cacheable = !isSSR;
          this["__v_isReadonly"] = isReadonly2;
        }
        get value() {
          const self2 = toRaw(this);
          trackRefValue(self2);
          if (self2._dirty || !self2._cacheable) {
            self2._dirty = false;
            self2._value = self2.effect.run();
          }
          return self2._value;
        }
        set value(newValue) {
          this._setter(newValue);
        }
      }
      function computed$1(getterOrOptions, debugOptions, isSSR = false) {
        let getter;
        let setter;
        const onlyGetter = isFunction$1(getterOrOptions);
        if (onlyGetter) {
          getter = getterOrOptions;
          setter = NOOP;
        } else {
          getter = getterOrOptions.get;
          setter = getterOrOptions.set;
        }
        const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
        return cRef;
      }
      function warn(msg, ...args) {
        return;
      }
      function callWithErrorHandling(fn2, instance, type2, args) {
        let res;
        try {
          res = args ? fn2(...args) : fn2();
        } catch (err) {
          handleError(err, instance, type2);
        }
        return res;
      }
      function callWithAsyncErrorHandling(fn2, instance, type2, args) {
        if (isFunction$1(fn2)) {
          const res = callWithErrorHandling(fn2, instance, type2, args);
          if (res && isPromise(res)) {
            res.catch((err) => {
              handleError(err, instance, type2);
            });
          }
          return res;
        }
        const values = [];
        for (let i2 = 0; i2 < fn2.length; i2++) {
          values.push(callWithAsyncErrorHandling(fn2[i2], instance, type2, args));
        }
        return values;
      }
      function handleError(err, instance, type2, throwInDev = true) {
        const contextVNode = instance ? instance.vnode : null;
        if (instance) {
          let cur = instance.parent;
          const exposedInstance = instance.proxy;
          const errorInfo = type2;
          while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
              for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
                if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
                  return;
                }
              }
            }
            cur = cur.parent;
          }
          const appErrorHandler = instance.appContext.config.errorHandler;
          if (appErrorHandler) {
            callWithErrorHandling(
              appErrorHandler,
              null,
              10,
              [err, exposedInstance, errorInfo]
            );
            return;
          }
        }
        logError(err, type2, contextVNode, throwInDev);
      }
      function logError(err, type2, contextVNode, throwInDev = true) {
        {
          console.error(err);
        }
      }
      let isFlushing = false;
      let isFlushPending = false;
      const queue = [];
      let flushIndex = 0;
      const pendingPostFlushCbs = [];
      let activePostFlushCbs = null;
      let postFlushIndex = 0;
      const resolvedPromise = /* @__PURE__ */ Promise.resolve();
      let currentFlushPromise = null;
      function nextTick(fn2) {
        const p2 = currentFlushPromise || resolvedPromise;
        return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
      }
      function findInsertionIndex(id2) {
        let start = flushIndex + 1;
        let end2 = queue.length;
        while (start < end2) {
          const middle = start + end2 >>> 1;
          const middleJobId = getId(queue[middle]);
          middleJobId < id2 ? start = middle + 1 : end2 = middle;
        }
        return start;
      }
      function queueJob(job) {
        if (!queue.length || !queue.includes(
          job,
          isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
        )) {
          if (job.id == null) {
            queue.push(job);
          } else {
            queue.splice(findInsertionIndex(job.id), 0, job);
          }
          queueFlush();
        }
      }
      function queueFlush() {
        if (!isFlushing && !isFlushPending) {
          isFlushPending = true;
          currentFlushPromise = resolvedPromise.then(flushJobs);
        }
      }
      function invalidateJob(job) {
        const i2 = queue.indexOf(job);
        if (i2 > flushIndex) {
          queue.splice(i2, 1);
        }
      }
      function queuePostFlushCb(cb) {
        if (!isArray$2(cb)) {
          if (!activePostFlushCbs || !activePostFlushCbs.includes(
            cb,
            cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
          )) {
            pendingPostFlushCbs.push(cb);
          }
        } else {
          pendingPostFlushCbs.push(...cb);
        }
        queueFlush();
      }
      function flushPreFlushCbs(seen, i2 = isFlushing ? flushIndex + 1 : 0) {
        for (; i2 < queue.length; i2++) {
          const cb = queue[i2];
          if (cb && cb.pre) {
            queue.splice(i2, 1);
            i2--;
            cb();
          }
        }
      }
      function flushPostFlushCbs(seen) {
        if (pendingPostFlushCbs.length) {
          const deduped = [...new Set(pendingPostFlushCbs)];
          pendingPostFlushCbs.length = 0;
          if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
          }
          activePostFlushCbs = deduped;
          activePostFlushCbs.sort((a2, b2) => getId(a2) - getId(b2));
          for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            activePostFlushCbs[postFlushIndex]();
          }
          activePostFlushCbs = null;
          postFlushIndex = 0;
        }
      }
      const getId = (job) => job.id == null ? Infinity : job.id;
      const comparator = (a2, b2) => {
        const diff = getId(a2) - getId(b2);
        if (diff === 0) {
          if (a2.pre && !b2.pre)
            return -1;
          if (b2.pre && !a2.pre)
            return 1;
        }
        return diff;
      };
      function flushJobs(seen) {
        isFlushPending = false;
        isFlushing = true;
        queue.sort(comparator);
        try {
          for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job && job.active !== false) {
              if (false)
                ;
              callWithErrorHandling(job, null, 14);
            }
          }
        } finally {
          flushIndex = 0;
          queue.length = 0;
          flushPostFlushCbs();
          isFlushing = false;
          currentFlushPromise = null;
          if (queue.length || pendingPostFlushCbs.length) {
            flushJobs();
          }
        }
      }
      function emit(instance, event, ...rawArgs) {
        if (instance.isUnmounted)
          return;
        const props = instance.vnode.props || EMPTY_OBJ;
        let args = rawArgs;
        const isModelListener2 = event.startsWith("update:");
        const modelArg = isModelListener2 && event.slice(7);
        if (modelArg && modelArg in props) {
          const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
          const { number: number2, trim } = props[modifiersKey] || EMPTY_OBJ;
          if (trim) {
            args = rawArgs.map((a2) => isString$1(a2) ? a2.trim() : a2);
          }
          if (number2) {
            args = rawArgs.map(looseToNumber);
          }
        }
        let handlerName;
        let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
        props[handlerName = toHandlerKey(camelize(event))];
        if (!handler && isModelListener2) {
          handler = props[handlerName = toHandlerKey(hyphenate(event))];
        }
        if (handler) {
          callWithAsyncErrorHandling(
            handler,
            instance,
            6,
            args
          );
        }
        const onceHandler = props[handlerName + `Once`];
        if (onceHandler) {
          if (!instance.emitted) {
            instance.emitted = {};
          } else if (instance.emitted[handlerName]) {
            return;
          }
          instance.emitted[handlerName] = true;
          callWithAsyncErrorHandling(
            onceHandler,
            instance,
            6,
            args
          );
        }
      }
      function normalizeEmitsOptions(comp, appContext, asMixin = false) {
        const cache2 = appContext.emitsCache;
        const cached = cache2.get(comp);
        if (cached !== void 0) {
          return cached;
        }
        const raw = comp.emits;
        let normalized = {};
        let hasExtends = false;
        if (!isFunction$1(comp)) {
          const extendEmits = (raw2) => {
            const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
            if (normalizedFromExtend) {
              hasExtends = true;
              extend(normalized, normalizedFromExtend);
            }
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
          }
          if (comp.extends) {
            extendEmits(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
          }
        }
        if (!raw && !hasExtends) {
          if (isObject$1(comp)) {
            cache2.set(comp, null);
          }
          return null;
        }
        if (isArray$2(raw)) {
          raw.forEach((key) => normalized[key] = null);
        } else {
          extend(normalized, raw);
        }
        if (isObject$1(comp)) {
          cache2.set(comp, normalized);
        }
        return normalized;
      }
      function isEmitListener(options, key) {
        if (!options || !isOn(key)) {
          return false;
        }
        key = key.slice(2).replace(/Once$/, "");
        return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
      }
      let currentRenderingInstance = null;
      let currentScopeId = null;
      function setCurrentRenderingInstance(instance) {
        const prev = currentRenderingInstance;
        currentRenderingInstance = instance;
        currentScopeId = instance && instance.type.__scopeId || null;
        return prev;
      }
      function pushScopeId(id2) {
        currentScopeId = id2;
      }
      function popScopeId() {
        currentScopeId = null;
      }
      function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
        if (!ctx)
          return fn2;
        if (fn2._n) {
          return fn2;
        }
        const renderFnWithContext = (...args) => {
          if (renderFnWithContext._d) {
            setBlockTracking(-1);
          }
          const prevInstance = setCurrentRenderingInstance(ctx);
          let res;
          try {
            res = fn2(...args);
          } finally {
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) {
              setBlockTracking(1);
            }
          }
          return res;
        };
        renderFnWithContext._n = true;
        renderFnWithContext._c = true;
        renderFnWithContext._d = true;
        return renderFnWithContext;
      }
      function markAttrsAccessed() {
      }
      function renderComponentRoot(instance) {
        const {
          type: Component,
          vnode,
          proxy,
          withProxy,
          props,
          propsOptions: [propsOptions],
          slots,
          attrs,
          emit: emit2,
          render: render2,
          renderCache,
          data,
          setupState,
          ctx,
          inheritAttrs
        } = instance;
        let result;
        let fallthroughAttrs;
        const prev = setCurrentRenderingInstance(instance);
        try {
          if (vnode.shapeFlag & 4) {
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(
              render2.call(
                proxyToUse,
                proxyToUse,
                renderCache,
                props,
                setupState,
                data,
                ctx
              )
            );
            fallthroughAttrs = attrs;
          } else {
            const render22 = Component;
            if (false)
              ;
            result = normalizeVNode(
              render22.length > 1 ? render22(
                props,
                false ? {
                  get attrs() {
                    markAttrsAccessed();
                    return attrs;
                  },
                  slots,
                  emit: emit2
                } : { attrs, slots, emit: emit2 }
              ) : render22(
                props,
                null
                /* we know it doesn't need it */
              )
            );
            fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
          }
        } catch (err) {
          blockStack.length = 0;
          handleError(err, instance, 1);
          result = createVNode(Comment);
        }
        let root2 = result;
        if (fallthroughAttrs && inheritAttrs !== false) {
          const keys2 = Object.keys(fallthroughAttrs);
          const { shapeFlag } = root2;
          if (keys2.length) {
            if (shapeFlag & (1 | 6)) {
              if (propsOptions && keys2.some(isModelListener)) {
                fallthroughAttrs = filterModelListeners(
                  fallthroughAttrs,
                  propsOptions
                );
              }
              root2 = cloneVNode(root2, fallthroughAttrs);
            }
          }
        }
        if (vnode.dirs) {
          root2 = cloneVNode(root2);
          root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
        }
        if (vnode.transition) {
          root2.transition = vnode.transition;
        }
        {
          result = root2;
        }
        setCurrentRenderingInstance(prev);
        return result;
      }
      const getFunctionalFallthrough = (attrs) => {
        let res;
        for (const key in attrs) {
          if (key === "class" || key === "style" || isOn(key)) {
            (res || (res = {}))[key] = attrs[key];
          }
        }
        return res;
      };
      const filterModelListeners = (attrs, props) => {
        const res = {};
        for (const key in attrs) {
          if (!isModelListener(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
          }
        }
        return res;
      };
      function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
        const { props: prevProps, children: prevChildren, component } = prevVNode;
        const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
        const emits = component.emitsOptions;
        if (nextVNode.dirs || nextVNode.transition) {
          return true;
        }
        if (optimized && patchFlag >= 0) {
          if (patchFlag & 1024) {
            return true;
          }
          if (patchFlag & 16) {
            if (!prevProps) {
              return !!nextProps;
            }
            return hasPropsChanged(prevProps, nextProps, emits);
          } else if (patchFlag & 8) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i2 = 0; i2 < dynamicProps.length; i2++) {
              const key = dynamicProps[i2];
              if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
                return true;
              }
            }
          }
        } else {
          if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
              return true;
            }
          }
          if (prevProps === nextProps) {
            return false;
          }
          if (!prevProps) {
            return !!nextProps;
          }
          if (!nextProps) {
            return true;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        }
        return false;
      }
      function hasPropsChanged(prevProps, nextProps, emitsOptions) {
        const nextKeys = Object.keys(nextProps);
        if (nextKeys.length !== Object.keys(prevProps).length) {
          return true;
        }
        for (let i2 = 0; i2 < nextKeys.length; i2++) {
          const key = nextKeys[i2];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
            return true;
          }
        }
        return false;
      }
      function updateHOCHostEl({ vnode, parent }, el) {
        while (parent && parent.subTree === vnode) {
          (vnode = parent.vnode).el = el;
          parent = parent.parent;
        }
      }
      const isSuspense = (type2) => type2.__isSuspense;
      function queueEffectWithSuspense(fn2, suspense) {
        if (suspense && suspense.pendingBranch) {
          if (isArray$2(fn2)) {
            suspense.effects.push(...fn2);
          } else {
            suspense.effects.push(fn2);
          }
        } else {
          queuePostFlushCb(fn2);
        }
      }
      function watchEffect(effect, options) {
        return doWatch(effect, null, options);
      }
      const INITIAL_WATCHER_VALUE = {};
      function watch(source, cb, options) {
        return doWatch(source, cb, options);
      }
      function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
        var _a2;
        const instance = getCurrentScope() === ((_a2 = currentInstance) == null ? void 0 : _a2.scope) ? currentInstance : null;
        let getter;
        let forceTrigger = false;
        let isMultiSource = false;
        if (isRef(source)) {
          getter = () => source.value;
          forceTrigger = isShallow(source);
        } else if (isReactive(source)) {
          getter = () => source;
          deep = true;
        } else if (isArray$2(source)) {
          isMultiSource = true;
          forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
          getter = () => source.map((s2) => {
            if (isRef(s2)) {
              return s2.value;
            } else if (isReactive(s2)) {
              return traverse(s2);
            } else if (isFunction$1(s2)) {
              return callWithErrorHandling(s2, instance, 2);
            } else
              ;
          });
        } else if (isFunction$1(source)) {
          if (cb) {
            getter = () => callWithErrorHandling(source, instance, 2);
          } else {
            getter = () => {
              if (instance && instance.isUnmounted) {
                return;
              }
              if (cleanup) {
                cleanup();
              }
              return callWithAsyncErrorHandling(
                source,
                instance,
                3,
                [onCleanup]
              );
            };
          }
        } else {
          getter = NOOP;
        }
        if (cb && deep) {
          const baseGetter = getter;
          getter = () => traverse(baseGetter());
        }
        let cleanup;
        let onCleanup = (fn2) => {
          cleanup = effect.onStop = () => {
            callWithErrorHandling(fn2, instance, 4);
          };
        };
        let ssrCleanup;
        if (isInSSRComponentSetup) {
          onCleanup = NOOP;
          if (!cb) {
            getter();
          } else if (immediate) {
            callWithAsyncErrorHandling(cb, instance, 3, [
              getter(),
              isMultiSource ? [] : void 0,
              onCleanup
            ]);
          }
          if (flush === "sync") {
            const ctx = useSSRContext();
            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
          } else {
            return NOOP;
          }
        }
        let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
        const job = () => {
          if (!effect.active) {
            return;
          }
          if (cb) {
            const newValue = effect.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some(
              (v2, i2) => hasChanged(v2, oldValue[i2])
            ) : hasChanged(newValue, oldValue)) || false) {
              if (cleanup) {
                cleanup();
              }
              callWithAsyncErrorHandling(cb, instance, 3, [
                newValue,
                // pass undefined as the old value when it's changed for the first time
                oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                onCleanup
              ]);
              oldValue = newValue;
            }
          } else {
            effect.run();
          }
        };
        job.allowRecurse = !!cb;
        let scheduler;
        if (flush === "sync") {
          scheduler = job;
        } else if (flush === "post") {
          scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
        } else {
          job.pre = true;
          if (instance)
            job.id = instance.uid;
          scheduler = () => queueJob(job);
        }
        const effect = new ReactiveEffect(getter, scheduler);
        if (cb) {
          if (immediate) {
            job();
          } else {
            oldValue = effect.run();
          }
        } else if (flush === "post") {
          queuePostRenderEffect(
            effect.run.bind(effect),
            instance && instance.suspense
          );
        } else {
          effect.run();
        }
        const unwatch = () => {
          effect.stop();
          if (instance && instance.scope) {
            remove(instance.scope.effects, effect);
          }
        };
        if (ssrCleanup)
          ssrCleanup.push(unwatch);
        return unwatch;
      }
      function instanceWatch(source, value, options) {
        const publicThis = this.proxy;
        const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
        let cb;
        if (isFunction$1(value)) {
          cb = value;
        } else {
          cb = value.handler;
          options = value;
        }
        const cur = currentInstance;
        setCurrentInstance(this);
        const res = doWatch(getter, cb.bind(publicThis), options);
        if (cur) {
          setCurrentInstance(cur);
        } else {
          unsetCurrentInstance();
        }
        return res;
      }
      function createPathGetter(ctx, path) {
        const segments = path.split(".");
        return () => {
          let cur = ctx;
          for (let i2 = 0; i2 < segments.length && cur; i2++) {
            cur = cur[segments[i2]];
          }
          return cur;
        };
      }
      function traverse(value, seen) {
        if (!isObject$1(value) || value["__v_skip"]) {
          return value;
        }
        seen = seen || /* @__PURE__ */ new Set();
        if (seen.has(value)) {
          return value;
        }
        seen.add(value);
        if (isRef(value)) {
          traverse(value.value, seen);
        } else if (isArray$2(value)) {
          for (let i2 = 0; i2 < value.length; i2++) {
            traverse(value[i2], seen);
          }
        } else if (isSet$2(value) || isMap$2(value)) {
          value.forEach((v2) => {
            traverse(v2, seen);
          });
        } else if (isPlainObject$1(value)) {
          for (const key in value) {
            traverse(value[key], seen);
          }
        }
        return value;
      }
      function withDirectives(vnode, directives) {
        const internalInstance = currentRenderingInstance;
        if (internalInstance === null) {
          return vnode;
        }
        const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
        const bindings = vnode.dirs || (vnode.dirs = []);
        for (let i2 = 0; i2 < directives.length; i2++) {
          let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
          if (dir) {
            if (isFunction$1(dir)) {
              dir = {
                mounted: dir,
                updated: dir
              };
            }
            if (dir.deep) {
              traverse(value);
            }
            bindings.push({
              dir,
              instance,
              value,
              oldValue: void 0,
              arg,
              modifiers
            });
          }
        }
        return vnode;
      }
      function invokeDirectiveHook(vnode, prevVNode, instance, name) {
        const bindings = vnode.dirs;
        const oldBindings = prevVNode && prevVNode.dirs;
        for (let i2 = 0; i2 < bindings.length; i2++) {
          const binding = bindings[i2];
          if (oldBindings) {
            binding.oldValue = oldBindings[i2].value;
          }
          let hook = binding.dir[name];
          if (hook) {
            pauseTracking();
            callWithAsyncErrorHandling(hook, instance, 8, [
              vnode.el,
              binding,
              vnode,
              prevVNode
            ]);
            resetTracking();
          }
        }
      }
      function useTransitionState() {
        const state = {
          isMounted: false,
          isLeaving: false,
          isUnmounting: false,
          leavingVNodes: /* @__PURE__ */ new Map()
        };
        onMounted(() => {
          state.isMounted = true;
        });
        onBeforeUnmount(() => {
          state.isUnmounting = true;
        });
        return state;
      }
      const TransitionHookValidator = [Function, Array];
      const BaseTransitionPropsValidators = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
      };
      const BaseTransitionImpl = {
        name: `BaseTransition`,
        props: BaseTransitionPropsValidators,
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          let prevTransitionKey;
          return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
              return;
            }
            let child = children[0];
            if (children.length > 1) {
              for (const c2 of children) {
                if (c2.type !== Comment) {
                  child = c2;
                  break;
                }
              }
            }
            const rawProps = toRaw(props);
            const { mode } = rawProps;
            if (state.isLeaving) {
              return emptyPlaceholder(child);
            }
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
              return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(
              innerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
              const key = getTransitionKey();
              if (prevTransitionKey === void 0) {
                prevTransitionKey = key;
              } else if (key !== prevTransitionKey) {
                prevTransitionKey = key;
                transitionKeyChanged = true;
              }
            }
            if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
              const leavingHooks = resolveTransitionHooks(
                oldInnerChild,
                rawProps,
                state,
                instance
              );
              setTransitionHooks(oldInnerChild, leavingHooks);
              if (mode === "out-in") {
                state.isLeaving = true;
                leavingHooks.afterLeave = () => {
                  state.isLeaving = false;
                  if (instance.update.active !== false) {
                    instance.update();
                  }
                };
                return emptyPlaceholder(child);
              } else if (mode === "in-out" && innerChild.type !== Comment) {
                leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                  const leavingVNodesCache = getLeavingNodesForType(
                    state,
                    oldInnerChild
                  );
                  leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                  el._leaveCb = () => {
                    earlyRemove();
                    el._leaveCb = void 0;
                    delete enterHooks.delayedLeave;
                  };
                  enterHooks.delayedLeave = delayedLeave;
                };
              }
            }
            return child;
          };
        }
      };
      const BaseTransition = BaseTransitionImpl;
      function getLeavingNodesForType(state, vnode) {
        const { leavingVNodes } = state;
        let leavingVNodesCache = leavingVNodes.get(vnode.type);
        if (!leavingVNodesCache) {
          leavingVNodesCache = /* @__PURE__ */ Object.create(null);
          leavingVNodes.set(vnode.type, leavingVNodesCache);
        }
        return leavingVNodesCache;
      }
      function resolveTransitionHooks(vnode, props, state, instance) {
        const {
          appear,
          mode,
          persisted = false,
          onBeforeEnter,
          onEnter,
          onAfterEnter,
          onEnterCancelled,
          onBeforeLeave,
          onLeave,
          onAfterLeave,
          onLeaveCancelled,
          onBeforeAppear,
          onAppear,
          onAfterAppear,
          onAppearCancelled
        } = props;
        const key = String(vnode.key);
        const leavingVNodesCache = getLeavingNodesForType(state, vnode);
        const callHook2 = (hook, args) => {
          hook && callWithAsyncErrorHandling(
            hook,
            instance,
            9,
            args
          );
        };
        const callAsyncHook = (hook, args) => {
          const done = args[1];
          callHook2(hook, args);
          if (isArray$2(hook)) {
            if (hook.every((hook2) => hook2.length <= 1))
              done();
          } else if (hook.length <= 1) {
            done();
          }
        };
        const hooks = {
          mode,
          persisted,
          beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
              if (appear) {
                hook = onBeforeAppear || onBeforeEnter;
              } else {
                return;
              }
            }
            if (el._leaveCb) {
              el._leaveCb(
                true
                /* cancelled */
              );
            }
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
              leavingVNode.el._leaveCb();
            }
            callHook2(hook, [el]);
          },
          enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
              if (appear) {
                hook = onAppear || onEnter;
                afterHook = onAfterAppear || onAfterEnter;
                cancelHook = onAppearCancelled || onEnterCancelled;
              } else {
                return;
              }
            }
            let called = false;
            const done = el._enterCb = (cancelled) => {
              if (called)
                return;
              called = true;
              if (cancelled) {
                callHook2(cancelHook, [el]);
              } else {
                callHook2(afterHook, [el]);
              }
              if (hooks.delayedLeave) {
                hooks.delayedLeave();
              }
              el._enterCb = void 0;
            };
            if (hook) {
              callAsyncHook(hook, [el, done]);
            } else {
              done();
            }
          },
          leave(el, remove2) {
            const key2 = String(vnode.key);
            if (el._enterCb) {
              el._enterCb(
                true
                /* cancelled */
              );
            }
            if (state.isUnmounting) {
              return remove2();
            }
            callHook2(onBeforeLeave, [el]);
            let called = false;
            const done = el._leaveCb = (cancelled) => {
              if (called)
                return;
              called = true;
              remove2();
              if (cancelled) {
                callHook2(onLeaveCancelled, [el]);
              } else {
                callHook2(onAfterLeave, [el]);
              }
              el._leaveCb = void 0;
              if (leavingVNodesCache[key2] === vnode) {
                delete leavingVNodesCache[key2];
              }
            };
            leavingVNodesCache[key2] = vnode;
            if (onLeave) {
              callAsyncHook(onLeave, [el, done]);
            } else {
              done();
            }
          },
          clone(vnode2) {
            return resolveTransitionHooks(vnode2, props, state, instance);
          }
        };
        return hooks;
      }
      function emptyPlaceholder(vnode) {
        if (isKeepAlive(vnode)) {
          vnode = cloneVNode(vnode);
          vnode.children = null;
          return vnode;
        }
      }
      function getKeepAliveChild(vnode) {
        return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
      }
      function setTransitionHooks(vnode, hooks) {
        if (vnode.shapeFlag & 6 && vnode.component) {
          setTransitionHooks(vnode.component.subTree, hooks);
        } else if (vnode.shapeFlag & 128) {
          vnode.ssContent.transition = hooks.clone(vnode.ssContent);
          vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
        } else {
          vnode.transition = hooks;
        }
      }
      function getTransitionRawChildren(children, keepComment = false, parentKey) {
        let ret = [];
        let keyedFragmentCount = 0;
        for (let i2 = 0; i2 < children.length; i2++) {
          let child = children[i2];
          const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
          if (child.type === Fragment) {
            if (child.patchFlag & 128)
              keyedFragmentCount++;
            ret = ret.concat(
              getTransitionRawChildren(child.children, keepComment, key)
            );
          } else if (keepComment || child.type !== Comment) {
            ret.push(key != null ? cloneVNode(child, { key }) : child);
          }
        }
        if (keyedFragmentCount > 1) {
          for (let i2 = 0; i2 < ret.length; i2++) {
            ret[i2].patchFlag = -2;
          }
        }
        return ret;
      }
      function defineComponent(options, extraOptions) {
        return isFunction$1(options) ? (
          // #8326: extend call and options.name access are considered side-effects
          // by Rollup, so we have to wrap it in a pure-annotated IIFE.
          /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
        ) : options;
      }
      const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
      const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
      function onActivated(hook, target) {
        registerKeepAliveHook(hook, "a", target);
      }
      function onDeactivated(hook, target) {
        registerKeepAliveHook(hook, "da", target);
      }
      function registerKeepAliveHook(hook, type2, target = currentInstance) {
        const wrappedHook = hook.__wdc || (hook.__wdc = () => {
          let current = target;
          while (current) {
            if (current.isDeactivated) {
              return;
            }
            current = current.parent;
          }
          return hook();
        });
        injectHook(type2, wrappedHook, target);
        if (target) {
          let current = target.parent;
          while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
              injectToKeepAliveRoot(wrappedHook, type2, target, current);
            }
            current = current.parent;
          }
        }
      }
      function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
        const injected = injectHook(
          type2,
          hook,
          keepAliveRoot,
          true
          /* prepend */
        );
        onUnmounted(() => {
          remove(keepAliveRoot[type2], injected);
        }, target);
      }
      function injectHook(type2, hook, target = currentInstance, prepend = false) {
        if (target) {
          const hooks = target[type2] || (target[type2] = []);
          const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
            if (target.isUnmounted) {
              return;
            }
            pauseTracking();
            setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type2, args);
            unsetCurrentInstance();
            resetTracking();
            return res;
          });
          if (prepend) {
            hooks.unshift(wrappedHook);
          } else {
            hooks.push(wrappedHook);
          }
          return wrappedHook;
        }
      }
      const createHook = (lifecycle) => (hook, target = currentInstance) => (
        // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
        (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
      );
      const onBeforeMount = createHook("bm");
      const onMounted = createHook("m");
      const onBeforeUpdate = createHook("bu");
      const onUpdated = createHook("u");
      const onBeforeUnmount = createHook("bum");
      const onUnmounted = createHook("um");
      const onServerPrefetch = createHook("sp");
      const onRenderTriggered = createHook(
        "rtg"
      );
      const onRenderTracked = createHook(
        "rtc"
      );
      function onErrorCaptured(hook, target = currentInstance) {
        injectHook("ec", hook, target);
      }
      const COMPONENTS = "components";
      const DIRECTIVES = "directives";
      function resolveComponent(name, maybeSelfReference) {
        return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
      }
      const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
      function resolveDynamicComponent(component) {
        if (isString$1(component)) {
          return resolveAsset(COMPONENTS, component, false) || component;
        } else {
          return component || NULL_DYNAMIC_COMPONENT;
        }
      }
      function resolveDirective(name) {
        return resolveAsset(DIRECTIVES, name);
      }
      function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
        const instance = currentRenderingInstance || currentInstance;
        if (instance) {
          const Component = instance.type;
          if (type2 === COMPONENTS) {
            const selfName = getComponentName(
              Component,
              false
              /* do not include inferred name to avoid breaking existing code */
            );
            if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
              return Component;
            }
          }
          const res = (
            // local registration
            // check instance[type] first which is resolved for options API
            resolve(instance[type2] || Component[type2], name) || // global registration
            resolve(instance.appContext[type2], name)
          );
          if (!res && maybeSelfReference) {
            return Component;
          }
          return res;
        }
      }
      function resolve(registry, name) {
        return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
      }
      function renderList(source, renderItem, cache2, index) {
        let ret;
        const cached = cache2 && cache2[index];
        if (isArray$2(source) || isString$1(source)) {
          ret = new Array(source.length);
          for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
            ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
          }
        } else if (typeof source === "number") {
          ret = new Array(source);
          for (let i2 = 0; i2 < source; i2++) {
            ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
          }
        } else if (isObject$1(source)) {
          if (source[Symbol.iterator]) {
            ret = Array.from(
              source,
              (item, i2) => renderItem(item, i2, void 0, cached && cached[i2])
            );
          } else {
            const keys2 = Object.keys(source);
            ret = new Array(keys2.length);
            for (let i2 = 0, l2 = keys2.length; i2 < l2; i2++) {
              const key = keys2[i2];
              ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
            }
          }
        } else {
          ret = [];
        }
        if (cache2) {
          cache2[index] = ret;
        }
        return ret;
      }
      function createSlots(slots, dynamicSlots) {
        for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
          const slot = dynamicSlots[i2];
          if (isArray$2(slot)) {
            for (let j2 = 0; j2 < slot.length; j2++) {
              slots[slot[j2].name] = slot[j2].fn;
            }
          } else if (slot) {
            slots[slot.name] = slot.key ? (...args) => {
              const res = slot.fn(...args);
              if (res)
                res.key = slot.key;
              return res;
            } : slot.fn;
          }
        }
        return slots;
      }
      function renderSlot(slots, name, props = {}, fallback, noSlotted) {
        if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
          if (name !== "default")
            props.name = name;
          return createVNode("slot", props, fallback && fallback());
        }
        let slot = slots[name];
        if (slot && slot._c) {
          slot._d = false;
        }
        openBlock();
        const validSlotContent = slot && ensureValidVNode(slot(props));
        const rendered = createBlock(
          Fragment,
          {
            key: props.key || // slot content array of a dynamic conditional slot may have a branch
            // key attached in the `createSlots` helper, respect that
            validSlotContent && validSlotContent.key || `_${name}`
          },
          validSlotContent || (fallback ? fallback() : []),
          validSlotContent && slots._ === 1 ? 64 : -2
        );
        if (!noSlotted && rendered.scopeId) {
          rendered.slotScopeIds = [rendered.scopeId + "-s"];
        }
        if (slot && slot._c) {
          slot._d = true;
        }
        return rendered;
      }
      function ensureValidVNode(vnodes) {
        return vnodes.some((child) => {
          if (!isVNode(child))
            return true;
          if (child.type === Comment)
            return false;
          if (child.type === Fragment && !ensureValidVNode(child.children))
            return false;
          return true;
        }) ? vnodes : null;
      }
      const getPublicInstance = (i2) => {
        if (!i2)
          return null;
        if (isStatefulComponent(i2))
          return getExposeProxy(i2) || i2.proxy;
        return getPublicInstance(i2.parent);
      };
      const publicPropertiesMap = (
        // Move PURE marker to new line to workaround compiler discarding it
        // due to type annotation
        /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
          $: (i2) => i2,
          $el: (i2) => i2.vnode.el,
          $data: (i2) => i2.data,
          $props: (i2) => i2.props,
          $attrs: (i2) => i2.attrs,
          $slots: (i2) => i2.slots,
          $refs: (i2) => i2.refs,
          $parent: (i2) => getPublicInstance(i2.parent),
          $root: (i2) => getPublicInstance(i2.root),
          $emit: (i2) => i2.emit,
          $options: (i2) => resolveMergedOptions(i2),
          $forceUpdate: (i2) => i2.f || (i2.f = () => queueJob(i2.update)),
          $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
          $watch: (i2) => instanceWatch.bind(i2)
        })
      );
      const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
      const PublicInstanceProxyHandlers = {
        get({ _: instance }, key) {
          const { ctx, setupState, data, props, accessCache, type: type2, appContext } = instance;
          let normalizedProps;
          if (key[0] !== "$") {
            const n2 = accessCache[key];
            if (n2 !== void 0) {
              switch (n2) {
                case 1:
                  return setupState[key];
                case 2:
                  return data[key];
                case 4:
                  return ctx[key];
                case 3:
                  return props[key];
              }
            } else if (hasSetupBinding(setupState, key)) {
              accessCache[key] = 1;
              return setupState[key];
            } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
              accessCache[key] = 2;
              return data[key];
            } else if (
              // only cache other properties when instance has declared (thus stable)
              // props
              (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
            ) {
              accessCache[key] = 3;
              return props[key];
            } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
              accessCache[key] = 4;
              return ctx[key];
            } else if (shouldCacheAccess) {
              accessCache[key] = 0;
            }
          }
          const publicGetter = publicPropertiesMap[key];
          let cssModule, globalProperties;
          if (publicGetter) {
            if (key === "$attrs") {
              track(instance, "get", key);
            }
            return publicGetter(instance);
          } else if (
            // css module (injected by vue-loader)
            (cssModule = type2.__cssModules) && (cssModule = cssModule[key])
          ) {
            return cssModule;
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (
            // global properties
            globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
          ) {
            {
              return globalProperties[key];
            }
          } else
            ;
        },
        set({ _: instance }, key, value) {
          const { data, setupState, ctx } = instance;
          if (hasSetupBinding(setupState, key)) {
            setupState[key] = value;
            return true;
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            data[key] = value;
            return true;
          } else if (hasOwn(instance.props, key)) {
            return false;
          }
          if (key[0] === "$" && key.slice(1) in instance) {
            return false;
          } else {
            {
              ctx[key] = value;
            }
          }
          return true;
        },
        has({
          _: { data, setupState, accessCache, ctx, appContext, propsOptions }
        }, key) {
          let normalizedProps;
          return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
        },
        defineProperty(target, key, descriptor) {
          if (descriptor.get != null) {
            target._.accessCache[key] = 0;
          } else if (hasOwn(descriptor, "value")) {
            this.set(target, key, descriptor.value, null);
          }
          return Reflect.defineProperty(target, key, descriptor);
        }
      };
      function useSlots() {
        return getContext().slots;
      }
      function useAttrs$1() {
        return getContext().attrs;
      }
      function getContext() {
        const i2 = getCurrentInstance();
        return i2.setupContext || (i2.setupContext = createSetupContext(i2));
      }
      function normalizePropsOrEmits(props) {
        return isArray$2(props) ? props.reduce(
          (normalized, p2) => (normalized[p2] = null, normalized),
          {}
        ) : props;
      }
      let shouldCacheAccess = true;
      function applyOptions(instance) {
        const options = resolveMergedOptions(instance);
        const publicThis = instance.proxy;
        const ctx = instance.ctx;
        shouldCacheAccess = false;
        if (options.beforeCreate) {
          callHook$1(options.beforeCreate, instance, "bc");
        }
        const {
          // state
          data: dataOptions,
          computed: computedOptions,
          methods,
          watch: watchOptions,
          provide: provideOptions,
          inject: injectOptions,
          // lifecycle
          created,
          beforeMount,
          mounted,
          beforeUpdate,
          updated,
          activated,
          deactivated,
          beforeDestroy,
          beforeUnmount,
          destroyed,
          unmounted,
          render: render2,
          renderTracked,
          renderTriggered,
          errorCaptured,
          serverPrefetch,
          // public API
          expose,
          inheritAttrs,
          // assets
          components,
          directives,
          filters
        } = options;
        const checkDuplicateProperties = null;
        if (injectOptions) {
          resolveInjections(injectOptions, ctx, checkDuplicateProperties);
        }
        if (methods) {
          for (const key in methods) {
            const methodHandler = methods[key];
            if (isFunction$1(methodHandler)) {
              {
                ctx[key] = methodHandler.bind(publicThis);
              }
            }
          }
        }
        if (dataOptions) {
          const data = dataOptions.call(publicThis, publicThis);
          if (!isObject$1(data))
            ;
          else {
            instance.data = reactive(data);
          }
        }
        shouldCacheAccess = true;
        if (computedOptions) {
          for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
            const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
            const c2 = computed({
              get: get2,
              set: set2
            });
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => c2.value,
              set: (v2) => c2.value = v2
            });
          }
        }
        if (watchOptions) {
          for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
          }
        }
        if (provideOptions) {
          const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
          Reflect.ownKeys(provides).forEach((key) => {
            provide(key, provides[key]);
          });
        }
        if (created) {
          callHook$1(created, instance, "c");
        }
        function registerLifecycleHook(register, hook) {
          if (isArray$2(hook)) {
            hook.forEach((_hook) => register(_hook.bind(publicThis)));
          } else if (hook) {
            register(hook.bind(publicThis));
          }
        }
        registerLifecycleHook(onBeforeMount, beforeMount);
        registerLifecycleHook(onMounted, mounted);
        registerLifecycleHook(onBeforeUpdate, beforeUpdate);
        registerLifecycleHook(onUpdated, updated);
        registerLifecycleHook(onActivated, activated);
        registerLifecycleHook(onDeactivated, deactivated);
        registerLifecycleHook(onErrorCaptured, errorCaptured);
        registerLifecycleHook(onRenderTracked, renderTracked);
        registerLifecycleHook(onRenderTriggered, renderTriggered);
        registerLifecycleHook(onBeforeUnmount, beforeUnmount);
        registerLifecycleHook(onUnmounted, unmounted);
        registerLifecycleHook(onServerPrefetch, serverPrefetch);
        if (isArray$2(expose)) {
          if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach((key) => {
              Object.defineProperty(exposed, key, {
                get: () => publicThis[key],
                set: (val) => publicThis[key] = val
              });
            });
          } else if (!instance.exposed) {
            instance.exposed = {};
          }
        }
        if (render2 && instance.render === NOOP) {
          instance.render = render2;
        }
        if (inheritAttrs != null) {
          instance.inheritAttrs = inheritAttrs;
        }
        if (components)
          instance.components = components;
        if (directives)
          instance.directives = directives;
      }
      function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
        if (isArray$2(injectOptions)) {
          injectOptions = normalizeInject(injectOptions);
        }
        for (const key in injectOptions) {
          const opt = injectOptions[key];
          let injected;
          if (isObject$1(opt)) {
            if ("default" in opt) {
              injected = inject(
                opt.from || key,
                opt.default,
                true
                /* treat default function as factory */
              );
            } else {
              injected = inject(opt.from || key);
            }
          } else {
            injected = inject(opt);
          }
          if (isRef(injected)) {
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => injected.value,
              set: (v2) => injected.value = v2
            });
          } else {
            ctx[key] = injected;
          }
        }
      }
      function callHook$1(hook, instance, type2) {
        callWithAsyncErrorHandling(
          isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
          instance,
          type2
        );
      }
      function createWatcher(raw, ctx, publicThis, key) {
        const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
        if (isString$1(raw)) {
          const handler = ctx[raw];
          if (isFunction$1(handler)) {
            watch(getter, handler);
          }
        } else if (isFunction$1(raw)) {
          watch(getter, raw.bind(publicThis));
        } else if (isObject$1(raw)) {
          if (isArray$2(raw)) {
            raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
          } else {
            const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if (isFunction$1(handler)) {
              watch(getter, handler, raw);
            }
          }
        } else
          ;
      }
      function resolveMergedOptions(instance) {
        const base2 = instance.type;
        const { mixins, extends: extendsOptions } = base2;
        const {
          mixins: globalMixins,
          optionsCache: cache2,
          config: { optionMergeStrategies }
        } = instance.appContext;
        const cached = cache2.get(base2);
        let resolved;
        if (cached) {
          resolved = cached;
        } else if (!globalMixins.length && !mixins && !extendsOptions) {
          {
            resolved = base2;
          }
        } else {
          resolved = {};
          if (globalMixins.length) {
            globalMixins.forEach(
              (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
            );
          }
          mergeOptions(resolved, base2, optionMergeStrategies);
        }
        if (isObject$1(base2)) {
          cache2.set(base2, resolved);
        }
        return resolved;
      }
      function mergeOptions(to, from, strats, asMixin = false) {
        const { mixins, extends: extendsOptions } = from;
        if (extendsOptions) {
          mergeOptions(to, extendsOptions, strats, true);
        }
        if (mixins) {
          mixins.forEach(
            (m2) => mergeOptions(to, m2, strats, true)
          );
        }
        for (const key in from) {
          if (asMixin && key === "expose")
            ;
          else {
            const strat = internalOptionMergeStrats[key] || strats && strats[key];
            to[key] = strat ? strat(to[key], from[key]) : from[key];
          }
        }
        return to;
      }
      const internalOptionMergeStrats = {
        data: mergeDataFn,
        props: mergeEmitsOrPropsOptions,
        emits: mergeEmitsOrPropsOptions,
        // objects
        methods: mergeObjectOptions,
        computed: mergeObjectOptions,
        // lifecycle
        beforeCreate: mergeAsArray,
        created: mergeAsArray,
        beforeMount: mergeAsArray,
        mounted: mergeAsArray,
        beforeUpdate: mergeAsArray,
        updated: mergeAsArray,
        beforeDestroy: mergeAsArray,
        beforeUnmount: mergeAsArray,
        destroyed: mergeAsArray,
        unmounted: mergeAsArray,
        activated: mergeAsArray,
        deactivated: mergeAsArray,
        errorCaptured: mergeAsArray,
        serverPrefetch: mergeAsArray,
        // assets
        components: mergeObjectOptions,
        directives: mergeObjectOptions,
        // watch
        watch: mergeWatchOptions,
        // provide / inject
        provide: mergeDataFn,
        inject: mergeInject
      };
      function mergeDataFn(to, from) {
        if (!from) {
          return to;
        }
        if (!to) {
          return from;
        }
        return function mergedDataFn() {
          return extend(
            isFunction$1(to) ? to.call(this, this) : to,
            isFunction$1(from) ? from.call(this, this) : from
          );
        };
      }
      function mergeInject(to, from) {
        return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
      }
      function normalizeInject(raw) {
        if (isArray$2(raw)) {
          const res = {};
          for (let i2 = 0; i2 < raw.length; i2++) {
            res[raw[i2]] = raw[i2];
          }
          return res;
        }
        return raw;
      }
      function mergeAsArray(to, from) {
        return to ? [...new Set([].concat(to, from))] : from;
      }
      function mergeObjectOptions(to, from) {
        return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
      }
      function mergeEmitsOrPropsOptions(to, from) {
        if (to) {
          if (isArray$2(to) && isArray$2(from)) {
            return [.../* @__PURE__ */ new Set([...to, ...from])];
          }
          return extend(
            /* @__PURE__ */ Object.create(null),
            normalizePropsOrEmits(to),
            normalizePropsOrEmits(from != null ? from : {})
          );
        } else {
          return from;
        }
      }
      function mergeWatchOptions(to, from) {
        if (!to)
          return from;
        if (!from)
          return to;
        const merged = extend(/* @__PURE__ */ Object.create(null), to);
        for (const key in from) {
          merged[key] = mergeAsArray(to[key], from[key]);
        }
        return merged;
      }
      function createAppContext() {
        return {
          app: null,
          config: {
            isNativeTag: NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
          },
          mixins: [],
          components: {},
          directives: {},
          provides: /* @__PURE__ */ Object.create(null),
          optionsCache: /* @__PURE__ */ new WeakMap(),
          propsCache: /* @__PURE__ */ new WeakMap(),
          emitsCache: /* @__PURE__ */ new WeakMap()
        };
      }
      let uid$1 = 0;
      function createAppAPI(render2, hydrate) {
        return function createApp2(rootComponent, rootProps = null) {
          if (!isFunction$1(rootComponent)) {
            rootComponent = extend({}, rootComponent);
          }
          if (rootProps != null && !isObject$1(rootProps)) {
            rootProps = null;
          }
          const context = createAppContext();
          const installedPlugins = /* @__PURE__ */ new Set();
          let isMounted = false;
          const app2 = context.app = {
            _uid: uid$1++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config() {
              return context.config;
            },
            set config(v2) {
            },
            use(plugin, ...options) {
              if (installedPlugins.has(plugin))
                ;
              else if (plugin && isFunction$1(plugin.install)) {
                installedPlugins.add(plugin);
                plugin.install(app2, ...options);
              } else if (isFunction$1(plugin)) {
                installedPlugins.add(plugin);
                plugin(app2, ...options);
              } else
                ;
              return app2;
            },
            mixin(mixin) {
              {
                if (!context.mixins.includes(mixin)) {
                  context.mixins.push(mixin);
                }
              }
              return app2;
            },
            component(name, component) {
              if (!component) {
                return context.components[name];
              }
              context.components[name] = component;
              return app2;
            },
            directive(name, directive) {
              if (!directive) {
                return context.directives[name];
              }
              context.directives[name] = directive;
              return app2;
            },
            mount(rootContainer, isHydrate, isSVG) {
              if (!isMounted) {
                const vnode = createVNode(
                  rootComponent,
                  rootProps
                );
                vnode.appContext = context;
                if (isHydrate && hydrate) {
                  hydrate(vnode, rootContainer);
                } else {
                  render2(vnode, rootContainer, isSVG);
                }
                isMounted = true;
                app2._container = rootContainer;
                rootContainer.__vue_app__ = app2;
                return getExposeProxy(vnode.component) || vnode.component.proxy;
              }
            },
            unmount() {
              if (isMounted) {
                render2(null, app2._container);
                delete app2._container.__vue_app__;
              }
            },
            provide(key, value) {
              context.provides[key] = value;
              return app2;
            },
            runWithContext(fn2) {
              currentApp = app2;
              try {
                return fn2();
              } finally {
                currentApp = null;
              }
            }
          };
          return app2;
        };
      }
      let currentApp = null;
      function provide(key, value) {
        if (!currentInstance)
          ;
        else {
          let provides = currentInstance.provides;
          const parentProvides = currentInstance.parent && currentInstance.parent.provides;
          if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
          }
          provides[key] = value;
        }
      }
      function inject(key, defaultValue, treatDefaultAsFactory = false) {
        const instance = currentInstance || currentRenderingInstance;
        if (instance || currentApp) {
          const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
          if (provides && key in provides) {
            return provides[key];
          } else if (arguments.length > 1) {
            return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
          } else
            ;
        }
      }
      function hasInjectionContext() {
        return !!(currentInstance || currentRenderingInstance || currentApp);
      }
      function initProps(instance, rawProps, isStateful, isSSR = false) {
        const props = {};
        const attrs = {};
        def(attrs, InternalObjectKey, 1);
        instance.propsDefaults = /* @__PURE__ */ Object.create(null);
        setFullProps(instance, rawProps, props, attrs);
        for (const key in instance.propsOptions[0]) {
          if (!(key in props)) {
            props[key] = void 0;
          }
        }
        if (isStateful) {
          instance.props = isSSR ? props : shallowReactive(props);
        } else {
          if (!instance.type.props) {
            instance.props = attrs;
          } else {
            instance.props = props;
          }
        }
        instance.attrs = attrs;
      }
      function updateProps(instance, rawProps, rawPrevProps, optimized) {
        const {
          props,
          attrs,
          vnode: { patchFlag }
        } = instance;
        const rawCurrentProps = toRaw(props);
        const [options] = instance.propsOptions;
        let hasAttrsChanged = false;
        if (
          // always force full diff in dev
          // - #1942 if hmr is enabled with sfc component
          // - vite#872 non-sfc component used by sfc component
          (optimized || patchFlag > 0) && !(patchFlag & 16)
        ) {
          if (patchFlag & 8) {
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
              let key = propsToUpdate[i2];
              if (isEmitListener(instance.emitsOptions, key)) {
                continue;
              }
              const value = rawProps[key];
              if (options) {
                if (hasOwn(attrs, key)) {
                  if (value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                  }
                } else {
                  const camelizedKey = camelize(key);
                  props[camelizedKey] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    camelizedKey,
                    value,
                    instance,
                    false
                    /* isAbsent */
                  );
                }
              } else {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              }
            }
          }
        } else {
          if (setFullProps(instance, rawProps, props, attrs)) {
            hasAttrsChanged = true;
          }
          let kebabKey;
          for (const key in rawCurrentProps) {
            if (!rawProps || // for camelCase
            !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
            // and converted to camelCase (#955)
            ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
              if (options) {
                if (rawPrevProps && // for camelCase
                (rawPrevProps[key] !== void 0 || // for kebab-case
                rawPrevProps[kebabKey] !== void 0)) {
                  props[key] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    key,
                    void 0,
                    instance,
                    true
                    /* isAbsent */
                  );
                }
              } else {
                delete props[key];
              }
            }
          }
          if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
              if (!rawProps || !hasOwn(rawProps, key) && true) {
                delete attrs[key];
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (hasAttrsChanged) {
          trigger(instance, "set", "$attrs");
        }
      }
      function setFullProps(instance, rawProps, props, attrs) {
        const [options, needCastKeys] = instance.propsOptions;
        let hasAttrsChanged = false;
        let rawCastValues;
        if (rawProps) {
          for (let key in rawProps) {
            if (isReservedProp(key)) {
              continue;
            }
            const value = rawProps[key];
            let camelKey;
            if (options && hasOwn(options, camelKey = camelize(key))) {
              if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                props[camelKey] = value;
              } else {
                (rawCastValues || (rawCastValues = {}))[camelKey] = value;
              }
            } else if (!isEmitListener(instance.emitsOptions, key)) {
              if (!(key in attrs) || value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (needCastKeys) {
          const rawCurrentProps = toRaw(props);
          const castValues = rawCastValues || EMPTY_OBJ;
          for (let i2 = 0; i2 < needCastKeys.length; i2++) {
            const key = needCastKeys[i2];
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              castValues[key],
              instance,
              !hasOwn(castValues, key)
            );
          }
        }
        return hasAttrsChanged;
      }
      function resolvePropValue(options, props, key, value, instance, isAbsent) {
        const opt = options[key];
        if (opt != null) {
          const hasDefault = hasOwn(opt, "default");
          if (hasDefault && value === void 0) {
            const defaultValue = opt.default;
            if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
              const { propsDefaults } = instance;
              if (key in propsDefaults) {
                value = propsDefaults[key];
              } else {
                setCurrentInstance(instance);
                value = propsDefaults[key] = defaultValue.call(
                  null,
                  props
                );
                unsetCurrentInstance();
              }
            } else {
              value = defaultValue;
            }
          }
          if (opt[
            0
            /* shouldCast */
          ]) {
            if (isAbsent && !hasDefault) {
              value = false;
            } else if (opt[
              1
              /* shouldCastTrue */
            ] && (value === "" || value === hyphenate(key))) {
              value = true;
            }
          }
        }
        return value;
      }
      function normalizePropsOptions(comp, appContext, asMixin = false) {
        const cache2 = appContext.propsCache;
        const cached = cache2.get(comp);
        if (cached) {
          return cached;
        }
        const raw = comp.props;
        const normalized = {};
        const needCastKeys = [];
        let hasExtends = false;
        if (!isFunction$1(comp)) {
          const extendProps = (raw2) => {
            hasExtends = true;
            const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
            extend(normalized, props);
            if (keys2)
              needCastKeys.push(...keys2);
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
          }
          if (comp.extends) {
            extendProps(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendProps);
          }
        }
        if (!raw && !hasExtends) {
          if (isObject$1(comp)) {
            cache2.set(comp, EMPTY_ARR);
          }
          return EMPTY_ARR;
        }
        if (isArray$2(raw)) {
          for (let i2 = 0; i2 < raw.length; i2++) {
            const normalizedKey = camelize(raw[i2]);
            if (validatePropName(normalizedKey)) {
              normalized[normalizedKey] = EMPTY_OBJ;
            }
          }
        } else if (raw) {
          for (const key in raw) {
            const normalizedKey = camelize(key);
            if (validatePropName(normalizedKey)) {
              const opt = raw[key];
              const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
              if (prop) {
                const booleanIndex = getTypeIndex(Boolean, prop.type);
                const stringIndex = getTypeIndex(String, prop.type);
                prop[
                  0
                  /* shouldCast */
                ] = booleanIndex > -1;
                prop[
                  1
                  /* shouldCastTrue */
                ] = stringIndex < 0 || booleanIndex < stringIndex;
                if (booleanIndex > -1 || hasOwn(prop, "default")) {
                  needCastKeys.push(normalizedKey);
                }
              }
            }
          }
        }
        const res = [normalized, needCastKeys];
        if (isObject$1(comp)) {
          cache2.set(comp, res);
        }
        return res;
      }
      function validatePropName(key) {
        if (key[0] !== "$") {
          return true;
        }
        return false;
      }
      function getType(ctor) {
        const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
        return match ? match[2] : ctor === null ? "null" : "";
      }
      function isSameType(a2, b2) {
        return getType(a2) === getType(b2);
      }
      function getTypeIndex(type2, expectedTypes) {
        if (isArray$2(expectedTypes)) {
          return expectedTypes.findIndex((t2) => isSameType(t2, type2));
        } else if (isFunction$1(expectedTypes)) {
          return isSameType(expectedTypes, type2) ? 0 : -1;
        }
        return -1;
      }
      const isInternalKey = (key) => key[0] === "_" || key === "$stable";
      const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
      const normalizeSlot = (key, rawSlot, ctx) => {
        if (rawSlot._n) {
          return rawSlot;
        }
        const normalized = withCtx((...args) => {
          if (false)
            ;
          return normalizeSlotValue(rawSlot(...args));
        }, ctx);
        normalized._c = false;
        return normalized;
      };
      const normalizeObjectSlots = (rawSlots, slots, instance) => {
        const ctx = rawSlots._ctx;
        for (const key in rawSlots) {
          if (isInternalKey(key))
            continue;
          const value = rawSlots[key];
          if (isFunction$1(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
          } else if (value != null) {
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
          }
        }
      };
      const normalizeVNodeSlots = (instance, children) => {
        const normalized = normalizeSlotValue(children);
        instance.slots.default = () => normalized;
      };
      const initSlots = (instance, children) => {
        if (instance.vnode.shapeFlag & 32) {
          const type2 = children._;
          if (type2) {
            instance.slots = toRaw(children);
            def(children, "_", type2);
          } else {
            normalizeObjectSlots(
              children,
              instance.slots = {}
            );
          }
        } else {
          instance.slots = {};
          if (children) {
            normalizeVNodeSlots(instance, children);
          }
        }
        def(instance.slots, InternalObjectKey, 1);
      };
      const updateSlots = (instance, children, optimized) => {
        const { vnode, slots } = instance;
        let needDeletionCheck = true;
        let deletionComparisonTarget = EMPTY_OBJ;
        if (vnode.shapeFlag & 32) {
          const type2 = children._;
          if (type2) {
            if (optimized && type2 === 1) {
              needDeletionCheck = false;
            } else {
              extend(slots, children);
              if (!optimized && type2 === 1) {
                delete slots._;
              }
            }
          } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
          }
          deletionComparisonTarget = children;
        } else if (children) {
          normalizeVNodeSlots(instance, children);
          deletionComparisonTarget = { default: 1 };
        }
        if (needDeletionCheck) {
          for (const key in slots) {
            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
              delete slots[key];
            }
          }
        }
      };
      function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
        if (isArray$2(rawRef)) {
          rawRef.forEach(
            (r2, i2) => setRef(
              r2,
              oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i2] : oldRawRef),
              parentSuspense,
              vnode,
              isUnmount
            )
          );
          return;
        }
        if (isAsyncWrapper(vnode) && !isUnmount) {
          return;
        }
        const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
        const value = isUnmount ? null : refValue;
        const { i: owner, r: ref2 } = rawRef;
        const oldRef = oldRawRef && oldRawRef.r;
        const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
        const setupState = owner.setupState;
        if (oldRef != null && oldRef !== ref2) {
          if (isString$1(oldRef)) {
            refs[oldRef] = null;
            if (hasOwn(setupState, oldRef)) {
              setupState[oldRef] = null;
            }
          } else if (isRef(oldRef)) {
            oldRef.value = null;
          }
        }
        if (isFunction$1(ref2)) {
          callWithErrorHandling(ref2, owner, 12, [value, refs]);
        } else {
          const _isString = isString$1(ref2);
          const _isRef = isRef(ref2);
          if (_isString || _isRef) {
            const doSet = () => {
              if (rawRef.f) {
                const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
                if (isUnmount) {
                  isArray$2(existing) && remove(existing, refValue);
                } else {
                  if (!isArray$2(existing)) {
                    if (_isString) {
                      refs[ref2] = [refValue];
                      if (hasOwn(setupState, ref2)) {
                        setupState[ref2] = refs[ref2];
                      }
                    } else {
                      ref2.value = [refValue];
                      if (rawRef.k)
                        refs[rawRef.k] = ref2.value;
                    }
                  } else if (!existing.includes(refValue)) {
                    existing.push(refValue);
                  }
                }
              } else if (_isString) {
                refs[ref2] = value;
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = value;
                }
              } else if (_isRef) {
                ref2.value = value;
                if (rawRef.k)
                  refs[rawRef.k] = value;
              } else
                ;
            };
            if (value) {
              doSet.id = -1;
              queuePostRenderEffect(doSet, parentSuspense);
            } else {
              doSet();
            }
          }
        }
      }
      const queuePostRenderEffect = queueEffectWithSuspense;
      function createRenderer(options) {
        return baseCreateRenderer(options);
      }
      function baseCreateRenderer(options, createHydrationFns) {
        const target = getGlobalThis();
        target.__VUE__ = true;
        const {
          insert: hostInsert,
          remove: hostRemove,
          patchProp: hostPatchProp,
          createElement: hostCreateElement,
          createText: hostCreateText,
          createComment: hostCreateComment,
          setText: hostSetText,
          setElementText: hostSetElementText,
          parentNode: hostParentNode,
          nextSibling: hostNextSibling,
          setScopeId: hostSetScopeId = NOOP,
          insertStaticContent: hostInsertStaticContent
        } = options;
        const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
          if (n1 === n2) {
            return;
          }
          if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
          }
          if (n2.patchFlag === -2) {
            optimized = false;
            n2.dynamicChildren = null;
          }
          const { type: type2, ref: ref2, shapeFlag } = n2;
          switch (type2) {
            case Text:
              processText(n1, n2, container, anchor);
              break;
            case Comment:
              processCommentNode(n1, n2, container, anchor);
              break;
            case Static:
              if (n1 == null) {
                mountStaticNode(n2, container, anchor, isSVG);
              }
              break;
            case Fragment:
              processFragment(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              break;
            default:
              if (shapeFlag & 1) {
                processElement(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else if (shapeFlag & 6) {
                processComponent(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else if (shapeFlag & 64) {
                type2.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized,
                  internals
                );
              } else if (shapeFlag & 128) {
                type2.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized,
                  internals
                );
              } else
                ;
          }
          if (ref2 != null && parentComponent) {
            setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
          }
        };
        const processText = (n1, n2, container, anchor) => {
          if (n1 == null) {
            hostInsert(
              n2.el = hostCreateText(n2.children),
              container,
              anchor
            );
          } else {
            const el = n2.el = n1.el;
            if (n2.children !== n1.children) {
              hostSetText(el, n2.children);
            }
          }
        };
        const processCommentNode = (n1, n2, container, anchor) => {
          if (n1 == null) {
            hostInsert(
              n2.el = hostCreateComment(n2.children || ""),
              container,
              anchor
            );
          } else {
            n2.el = n1.el;
          }
        };
        const mountStaticNode = (n2, container, anchor, isSVG) => {
          [n2.el, n2.anchor] = hostInsertStaticContent(
            n2.children,
            container,
            anchor,
            isSVG,
            n2.el,
            n2.anchor
          );
        };
        const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
          let next;
          while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
          }
          hostInsert(anchor, container, nextSibling);
        };
        const removeStaticNode = ({ el, anchor }) => {
          let next;
          while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
          }
          hostRemove(anchor);
        };
        const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          isSVG = isSVG || n2.type === "svg";
          if (n1 == null) {
            mountElement(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          } else {
            patchElement(
              n1,
              n2,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          }
        };
        const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          let el;
          let vnodeHook;
          const { type: type2, props, shapeFlag, transition, dirs } = vnode;
          el = vnode.el = hostCreateElement(
            vnode.type,
            isSVG,
            props && props.is,
            props
          );
          if (shapeFlag & 8) {
            hostSetElementText(el, vnode.children);
          } else if (shapeFlag & 16) {
            mountChildren(
              vnode.children,
              el,
              null,
              parentComponent,
              parentSuspense,
              isSVG && type2 !== "foreignObject",
              slotScopeIds,
              optimized
            );
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "created");
          }
          setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
          if (props) {
            for (const key in props) {
              if (key !== "value" && !isReservedProp(key)) {
                hostPatchProp(
                  el,
                  key,
                  null,
                  props[key],
                  isSVG,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
            if ("value" in props) {
              hostPatchProp(el, "value", null, props.value);
            }
            if (vnodeHook = props.onVnodeBeforeMount) {
              invokeVNodeHook(vnodeHook, parentComponent, vnode);
            }
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
          }
          const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
          if (needCallTransitionHooks) {
            transition.beforeEnter(el);
          }
          hostInsert(el, container, anchor);
          if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              needCallTransitionHooks && transition.enter(el);
              dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
          }
        };
        const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
          if (scopeId) {
            hostSetScopeId(el, scopeId);
          }
          if (slotScopeIds) {
            for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
              hostSetScopeId(el, slotScopeIds[i2]);
            }
          }
          if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (vnode === subTree) {
              const parentVNode = parentComponent.vnode;
              setScopeId(
                el,
                parentVNode,
                parentVNode.scopeId,
                parentVNode.slotScopeIds,
                parentComponent.parent
              );
            }
          }
        };
        const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
          for (let i2 = start; i2 < children.length; i2++) {
            const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
            patch(
              null,
              child,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          }
        };
        const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          const el = n2.el = n1.el;
          let { patchFlag, dynamicChildren, dirs } = n2;
          patchFlag |= n1.patchFlag & 16;
          const oldProps = n1.props || EMPTY_OBJ;
          const newProps = n2.props || EMPTY_OBJ;
          let vnodeHook;
          parentComponent && toggleRecurse(parentComponent, false);
          if (vnodeHook = newProps.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          }
          if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
          }
          parentComponent && toggleRecurse(parentComponent, true);
          const areChildrenSVG = isSVG && n2.type !== "foreignObject";
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              el,
              parentComponent,
              parentSuspense,
              areChildrenSVG,
              slotScopeIds
            );
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              el,
              null,
              parentComponent,
              parentSuspense,
              areChildrenSVG,
              slotScopeIds,
              false
            );
          }
          if (patchFlag > 0) {
            if (patchFlag & 16) {
              patchProps(
                el,
                n2,
                oldProps,
                newProps,
                parentComponent,
                parentSuspense,
                isSVG
              );
            } else {
              if (patchFlag & 2) {
                if (oldProps.class !== newProps.class) {
                  hostPatchProp(el, "class", null, newProps.class, isSVG);
                }
              }
              if (patchFlag & 4) {
                hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
              }
              if (patchFlag & 8) {
                const propsToUpdate = n2.dynamicProps;
                for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
                  const key = propsToUpdate[i2];
                  const prev = oldProps[key];
                  const next = newProps[key];
                  if (next !== prev || key === "value") {
                    hostPatchProp(
                      el,
                      key,
                      prev,
                      next,
                      isSVG,
                      n1.children,
                      parentComponent,
                      parentSuspense,
                      unmountChildren
                    );
                  }
                }
              }
            }
            if (patchFlag & 1) {
              if (n1.children !== n2.children) {
                hostSetElementText(el, n2.children);
              }
            }
          } else if (!optimized && dynamicChildren == null) {
            patchProps(
              el,
              n2,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              isSVG
            );
          }
          if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
              dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
            }, parentSuspense);
          }
        };
        const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
          for (let i2 = 0; i2 < newChildren.length; i2++) {
            const oldVNode = oldChildren[i2];
            const newVNode = newChildren[i2];
            const container = (
              // oldVNode may be an errored async setup() component inside Suspense
              // which will not have a mounted element
              oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
              // of the Fragment itself so it can move its children.
              (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
              // which also requires the correct parent container
              !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
              oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
                // In other cases, the parent container is not actually used so we
                // just pass the block element here to avoid a DOM parentNode call.
                fallbackContainer
              )
            );
            patch(
              oldVNode,
              newVNode,
              container,
              null,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              true
            );
          }
        };
        const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
          if (oldProps !== newProps) {
            if (oldProps !== EMPTY_OBJ) {
              for (const key in oldProps) {
                if (!isReservedProp(key) && !(key in newProps)) {
                  hostPatchProp(
                    el,
                    key,
                    oldProps[key],
                    null,
                    isSVG,
                    vnode.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
            }
            for (const key in newProps) {
              if (isReservedProp(key))
                continue;
              const next = newProps[key];
              const prev = oldProps[key];
              if (next !== prev && key !== "value") {
                hostPatchProp(
                  el,
                  key,
                  prev,
                  next,
                  isSVG,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
            if ("value" in newProps) {
              hostPatchProp(el, "value", oldProps.value, newProps.value);
            }
          }
        };
        const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
          const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
          let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
          if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
          }
          if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            mountChildren(
              n2.children,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          } else {
            if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
            // of renderSlot() with no valid children
            n1.dynamicChildren) {
              patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                container,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds
              );
              if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n2.key != null || parentComponent && n2 === parentComponent.subTree
              ) {
                traverseStaticChildren(
                  n1,
                  n2,
                  true
                  /* shallow */
                );
              }
            } else {
              patchChildren(
                n1,
                n2,
                container,
                fragmentEndAnchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            }
          }
        };
        const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          n2.slotScopeIds = slotScopeIds;
          if (n1 == null) {
            if (n2.shapeFlag & 512) {
              parentComponent.ctx.activate(
                n2,
                container,
                anchor,
                isSVG,
                optimized
              );
            } else {
              mountComponent(
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                optimized
              );
            }
          } else {
            updateComponent(n1, n2, optimized);
          }
        };
        const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
          const instance = initialVNode.component = createComponentInstance(
            initialVNode,
            parentComponent,
            parentSuspense
          );
          if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
          }
          {
            setupComponent(instance);
          }
          if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            if (!initialVNode.el) {
              const placeholder = instance.subTree = createVNode(Comment);
              processCommentNode(null, placeholder, container, anchor);
            }
            return;
          }
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            isSVG,
            optimized
          );
        };
        const updateComponent = (n1, n2, optimized) => {
          const instance = n2.component = n1.component;
          if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
              updateComponentPreRender(instance, n2, optimized);
              return;
            } else {
              instance.next = n2;
              invalidateJob(instance.update);
              instance.update();
            }
          } else {
            n2.el = n1.el;
            instance.vnode = n2;
          }
        };
        const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
          const componentUpdateFn = () => {
            if (!instance.isMounted) {
              let vnodeHook;
              const { el, props } = initialVNode;
              const { bm, m: m2, parent } = instance;
              const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
              toggleRecurse(instance, false);
              if (bm) {
                invokeArrayFns(bm);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHook, parent, initialVNode);
              }
              toggleRecurse(instance, true);
              if (el && hydrateNode) {
                const hydrateSubTree = () => {
                  instance.subTree = renderComponentRoot(instance);
                  hydrateNode(
                    el,
                    instance.subTree,
                    instance,
                    parentSuspense,
                    null
                  );
                };
                if (isAsyncWrapperVNode) {
                  initialVNode.type.__asyncLoader().then(
                    // note: we are moving the render call into an async callback,
                    // which means it won't track dependencies - but it's ok because
                    // a server-rendered async wrapper is already in resolved state
                    // and it will never need to change.
                    () => !instance.isUnmounted && hydrateSubTree()
                  );
                } else {
                  hydrateSubTree();
                }
              } else {
                const subTree = instance.subTree = renderComponentRoot(instance);
                patch(
                  null,
                  subTree,
                  container,
                  anchor,
                  instance,
                  parentSuspense,
                  isSVG
                );
                initialVNode.el = subTree.el;
              }
              if (m2) {
                queuePostRenderEffect(m2, parentSuspense);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                const scopedInitialVNode = initialVNode;
                queuePostRenderEffect(
                  () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                  parentSuspense
                );
              }
              if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
                instance.a && queuePostRenderEffect(instance.a, parentSuspense);
              }
              instance.isMounted = true;
              initialVNode = container = anchor = null;
            } else {
              let { next, bu, u: u2, parent, vnode } = instance;
              let originNext = next;
              let vnodeHook;
              toggleRecurse(instance, false);
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              } else {
                next = vnode;
              }
              if (bu) {
                invokeArrayFns(bu);
              }
              if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
                invokeVNodeHook(vnodeHook, parent, next, vnode);
              }
              toggleRecurse(instance, true);
              const nextTree = renderComponentRoot(instance);
              const prevTree = instance.subTree;
              instance.subTree = nextTree;
              patch(
                prevTree,
                nextTree,
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el),
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree),
                instance,
                parentSuspense,
                isSVG
              );
              next.el = nextTree.el;
              if (originNext === null) {
                updateHOCHostEl(instance, nextTree.el);
              }
              if (u2) {
                queuePostRenderEffect(u2, parentSuspense);
              }
              if (vnodeHook = next.props && next.props.onVnodeUpdated) {
                queuePostRenderEffect(
                  () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                  parentSuspense
                );
              }
            }
          };
          const effect = instance.effect = new ReactiveEffect(
            componentUpdateFn,
            () => queueJob(update),
            instance.scope
            // track it in component's effect scope
          );
          const update = instance.update = () => effect.run();
          update.id = instance.uid;
          toggleRecurse(instance, true);
          update();
        };
        const updateComponentPreRender = (instance, nextVNode, optimized) => {
          nextVNode.component = instance;
          const prevProps = instance.vnode.props;
          instance.vnode = nextVNode;
          instance.next = null;
          updateProps(instance, nextVNode.props, prevProps, optimized);
          updateSlots(instance, nextVNode.children, optimized);
          pauseTracking();
          flushPreFlushCbs();
          resetTracking();
        };
        const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
          const c1 = n1 && n1.children;
          const prevShapeFlag = n1 ? n1.shapeFlag : 0;
          const c2 = n2.children;
          const { patchFlag, shapeFlag } = n2;
          if (patchFlag > 0) {
            if (patchFlag & 128) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              return;
            } else if (patchFlag & 256) {
              patchUnkeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              return;
            }
          }
          if (shapeFlag & 8) {
            if (prevShapeFlag & 16) {
              unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
              hostSetElementText(container, c2);
            }
          } else {
            if (prevShapeFlag & 16) {
              if (shapeFlag & 16) {
                patchKeyedChildren(
                  c1,
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else {
                unmountChildren(c1, parentComponent, parentSuspense, true);
              }
            } else {
              if (prevShapeFlag & 8) {
                hostSetElementText(container, "");
              }
              if (shapeFlag & 16) {
                mountChildren(
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              }
            }
          }
        };
        const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          c1 = c1 || EMPTY_ARR;
          c2 = c2 || EMPTY_ARR;
          const oldLength = c1.length;
          const newLength = c2.length;
          const commonLength = Math.min(oldLength, newLength);
          let i2;
          for (i2 = 0; i2 < commonLength; i2++) {
            const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
            patch(
              c1[i2],
              nextChild,
              container,
              null,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          }
          if (oldLength > newLength) {
            unmountChildren(
              c1,
              parentComponent,
              parentSuspense,
              true,
              false,
              commonLength
            );
          } else {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized,
              commonLength
            );
          }
        };
        const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          let i2 = 0;
          const l2 = c2.length;
          let e1 = c1.length - 1;
          let e2 = l2 - 1;
          while (i2 <= e1 && i2 <= e2) {
            const n1 = c1[i2];
            const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
            if (isSameVNodeType(n1, n2)) {
              patch(
                n1,
                n2,
                container,
                null,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            } else {
              break;
            }
            i2++;
          }
          while (i2 <= e1 && i2 <= e2) {
            const n1 = c1[e1];
            const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
            if (isSameVNodeType(n1, n2)) {
              patch(
                n1,
                n2,
                container,
                null,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            } else {
              break;
            }
            e1--;
            e2--;
          }
          if (i2 > e1) {
            if (i2 <= e2) {
              const nextPos = e2 + 1;
              const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
              while (i2 <= e2) {
                patch(
                  null,
                  c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                i2++;
              }
            }
          } else if (i2 > e2) {
            while (i2 <= e1) {
              unmount(c1[i2], parentComponent, parentSuspense, true);
              i2++;
            }
          } else {
            const s1 = i2;
            const s2 = i2;
            const keyToNewIndexMap = /* @__PURE__ */ new Map();
            for (i2 = s2; i2 <= e2; i2++) {
              const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
              if (nextChild.key != null) {
                keyToNewIndexMap.set(nextChild.key, i2);
              }
            }
            let j2;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            let maxNewIndexSoFar = 0;
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i2 = 0; i2 < toBePatched; i2++)
              newIndexToOldIndexMap[i2] = 0;
            for (i2 = s1; i2 <= e1; i2++) {
              const prevChild = c1[i2];
              if (patched >= toBePatched) {
                unmount(prevChild, parentComponent, parentSuspense, true);
                continue;
              }
              let newIndex;
              if (prevChild.key != null) {
                newIndex = keyToNewIndexMap.get(prevChild.key);
              } else {
                for (j2 = s2; j2 <= e2; j2++) {
                  if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
                    newIndex = j2;
                    break;
                  }
                }
              }
              if (newIndex === void 0) {
                unmount(prevChild, parentComponent, parentSuspense, true);
              } else {
                newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
                if (newIndex >= maxNewIndexSoFar) {
                  maxNewIndexSoFar = newIndex;
                } else {
                  moved = true;
                }
                patch(
                  prevChild,
                  c2[newIndex],
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                patched++;
              }
            }
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
            j2 = increasingNewIndexSequence.length - 1;
            for (i2 = toBePatched - 1; i2 >= 0; i2--) {
              const nextIndex = s2 + i2;
              const nextChild = c2[nextIndex];
              const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
              if (newIndexToOldIndexMap[i2] === 0) {
                patch(
                  null,
                  nextChild,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else if (moved) {
                if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
                  move(nextChild, container, anchor, 2);
                } else {
                  j2--;
                }
              }
            }
          }
        };
        const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
          const { el, type: type2, transition, children, shapeFlag } = vnode;
          if (shapeFlag & 6) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
          }
          if (shapeFlag & 128) {
            vnode.suspense.move(container, anchor, moveType);
            return;
          }
          if (shapeFlag & 64) {
            type2.move(vnode, container, anchor, internals);
            return;
          }
          if (type2 === Fragment) {
            hostInsert(el, container, anchor);
            for (let i2 = 0; i2 < children.length; i2++) {
              move(children[i2], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
          }
          if (type2 === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
          }
          const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
          if (needTransition) {
            if (moveType === 0) {
              transition.beforeEnter(el);
              hostInsert(el, container, anchor);
              queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            } else {
              const { leave, delayLeave, afterLeave } = transition;
              const remove22 = () => hostInsert(el, container, anchor);
              const performLeave = () => {
                leave(el, () => {
                  remove22();
                  afterLeave && afterLeave();
                });
              };
              if (delayLeave) {
                delayLeave(el, remove22, performLeave);
              } else {
                performLeave();
              }
            }
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
          const {
            type: type2,
            props,
            ref: ref2,
            children,
            dynamicChildren,
            shapeFlag,
            patchFlag,
            dirs
          } = vnode;
          if (ref2 != null) {
            setRef(ref2, null, parentSuspense, vnode, true);
          }
          if (shapeFlag & 256) {
            parentComponent.ctx.deactivate(vnode);
            return;
          }
          const shouldInvokeDirs = shapeFlag & 1 && dirs;
          const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
          let vnodeHook;
          if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
          if (shapeFlag & 6) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
          } else {
            if (shapeFlag & 128) {
              vnode.suspense.unmount(parentSuspense, doRemove);
              return;
            }
            if (shouldInvokeDirs) {
              invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
            }
            if (shapeFlag & 64) {
              vnode.type.remove(
                vnode,
                parentComponent,
                parentSuspense,
                optimized,
                internals,
                doRemove
              );
            } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
            (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
              unmountChildren(
                dynamicChildren,
                parentComponent,
                parentSuspense,
                false,
                true
              );
            } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
              unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
              remove2(vnode);
            }
          }
          if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
            }, parentSuspense);
          }
        };
        const remove2 = (vnode) => {
          const { type: type2, el, anchor, transition } = vnode;
          if (type2 === Fragment) {
            {
              removeFragment(el, anchor);
            }
            return;
          }
          if (type2 === Static) {
            removeStaticNode(vnode);
            return;
          }
          const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
              transition.afterLeave();
            }
          };
          if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
              delayLeave(vnode.el, performRemove, performLeave);
            } else {
              performLeave();
            }
          } else {
            performRemove();
          }
        };
        const removeFragment = (cur, end2) => {
          let next;
          while (cur !== end2) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
          }
          hostRemove(end2);
        };
        const unmountComponent = (instance, parentSuspense, doRemove) => {
          const { bum, scope, update, subTree, um } = instance;
          if (bum) {
            invokeArrayFns(bum);
          }
          scope.stop();
          if (update) {
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
          }
          if (um) {
            queuePostRenderEffect(um, parentSuspense);
          }
          queuePostRenderEffect(() => {
            instance.isUnmounted = true;
          }, parentSuspense);
          if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
              parentSuspense.resolve();
            }
          }
        };
        const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
          for (let i2 = start; i2 < children.length; i2++) {
            unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
          }
        };
        const getNextHostNode = (vnode) => {
          if (vnode.shapeFlag & 6) {
            return getNextHostNode(vnode.component.subTree);
          }
          if (vnode.shapeFlag & 128) {
            return vnode.suspense.next();
          }
          return hostNextSibling(vnode.anchor || vnode.el);
        };
        const render2 = (vnode, container, isSVG) => {
          if (vnode == null) {
            if (container._vnode) {
              unmount(container._vnode, null, null, true);
            }
          } else {
            patch(container._vnode || null, vnode, container, null, null, null, isSVG);
          }
          flushPreFlushCbs();
          flushPostFlushCbs();
          container._vnode = vnode;
        };
        const internals = {
          p: patch,
          um: unmount,
          m: move,
          r: remove2,
          mt: mountComponent,
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          n: getNextHostNode,
          o: options
        };
        let hydrate;
        let hydrateNode;
        if (createHydrationFns) {
          [hydrate, hydrateNode] = createHydrationFns(
            internals
          );
        }
        return {
          render: render2,
          hydrate,
          createApp: createAppAPI(render2, hydrate)
        };
      }
      function toggleRecurse({ effect, update }, allowed) {
        effect.allowRecurse = update.allowRecurse = allowed;
      }
      function traverseStaticChildren(n1, n2, shallow = false) {
        const ch1 = n1.children;
        const ch2 = n2.children;
        if (isArray$2(ch1) && isArray$2(ch2)) {
          for (let i2 = 0; i2 < ch1.length; i2++) {
            const c1 = ch1[i2];
            let c2 = ch2[i2];
            if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
              if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
                c2.el = c1.el;
              }
              if (!shallow)
                traverseStaticChildren(c1, c2);
            }
            if (c2.type === Text) {
              c2.el = c1.el;
            }
          }
        }
      }
      function getSequence(arr) {
        const p2 = arr.slice();
        const result = [0];
        let i2, j2, u2, v2, c2;
        const len = arr.length;
        for (i2 = 0; i2 < len; i2++) {
          const arrI = arr[i2];
          if (arrI !== 0) {
            j2 = result[result.length - 1];
            if (arr[j2] < arrI) {
              p2[i2] = j2;
              result.push(i2);
              continue;
            }
            u2 = 0;
            v2 = result.length - 1;
            while (u2 < v2) {
              c2 = u2 + v2 >> 1;
              if (arr[result[c2]] < arrI) {
                u2 = c2 + 1;
              } else {
                v2 = c2;
              }
            }
            if (arrI < arr[result[u2]]) {
              if (u2 > 0) {
                p2[i2] = result[u2 - 1];
              }
              result[u2] = i2;
            }
          }
        }
        u2 = result.length;
        v2 = result[u2 - 1];
        while (u2-- > 0) {
          result[u2] = v2;
          v2 = p2[v2];
        }
        return result;
      }
      const isTeleport = (type2) => type2.__isTeleport;
      const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
      const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
      const resolveTarget = (props, select) => {
        const targetSelector = props && props.to;
        if (isString$1(targetSelector)) {
          if (!select) {
            return null;
          } else {
            const target = select(targetSelector);
            return target;
          }
        } else {
          return targetSelector;
        }
      };
      const TeleportImpl = {
        __isTeleport: true,
        process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
          const {
            mc: mountChildren,
            pc: patchChildren,
            pbc: patchBlockChildren,
            o: { insert, querySelector, createText, createComment }
          } = internals;
          const disabled = isTeleportDisabled(n2.props);
          let { shapeFlag, children, dynamicChildren } = n2;
          if (n1 == null) {
            const placeholder = n2.el = createText("");
            const mainAnchor = n2.anchor = createText("");
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = n2.targetAnchor = createText("");
            if (target) {
              insert(targetAnchor, target);
              isSVG = isSVG || isTargetSVG(target);
            }
            const mount = (container2, anchor2) => {
              if (shapeFlag & 16) {
                mountChildren(
                  children,
                  container2,
                  anchor2,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              }
            };
            if (disabled) {
              mount(container, mainAnchor);
            } else if (target) {
              mount(target, targetAnchor);
            }
          } else {
            n2.el = n1.el;
            const mainAnchor = n2.anchor = n1.anchor;
            const target = n2.target = n1.target;
            const targetAnchor = n2.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
              patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                currentContainer,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds
              );
              traverseStaticChildren(n1, n2, true);
            } else if (!optimized) {
              patchChildren(
                n1,
                n2,
                currentContainer,
                currentAnchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                false
              );
            }
            if (disabled) {
              if (!wasDisabled) {
                moveTeleport(
                  n2,
                  container,
                  mainAnchor,
                  internals,
                  1
                );
              }
            } else {
              if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                const nextTarget = n2.target = resolveTarget(
                  n2.props,
                  querySelector
                );
                if (nextTarget) {
                  moveTeleport(
                    n2,
                    nextTarget,
                    null,
                    internals,
                    0
                  );
                }
              } else if (wasDisabled) {
                moveTeleport(
                  n2,
                  target,
                  targetAnchor,
                  internals,
                  1
                );
              }
            }
          }
          updateCssVars(n2);
        },
        remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
          const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
          if (target) {
            hostRemove(targetAnchor);
          }
          if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16) {
              for (let i2 = 0; i2 < children.length; i2++) {
                const child = children[i2];
                unmount(
                  child,
                  parentComponent,
                  parentSuspense,
                  true,
                  !!child.dynamicChildren
                );
              }
            }
          }
        },
        move: moveTeleport,
        hydrate: hydrateTeleport
      };
      function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
        if (moveType === 0) {
          insert(vnode.targetAnchor, container, parentAnchor);
        }
        const { el, anchor, shapeFlag, children, props } = vnode;
        const isReorder = moveType === 2;
        if (isReorder) {
          insert(el, container, parentAnchor);
        }
        if (!isReorder || isTeleportDisabled(props)) {
          if (shapeFlag & 16) {
            for (let i2 = 0; i2 < children.length; i2++) {
              move(
                children[i2],
                container,
                parentAnchor,
                2
              );
            }
          }
        }
        if (isReorder) {
          insert(anchor, container, parentAnchor);
        }
      }
      function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
        o: { nextSibling, parentNode, querySelector }
      }, hydrateChildren) {
        const target = vnode.target = resolveTarget(
          vnode.props,
          querySelector
        );
        if (target) {
          const targetNode = target._lpa || target.firstChild;
          if (vnode.shapeFlag & 16) {
            if (isTeleportDisabled(vnode.props)) {
              vnode.anchor = hydrateChildren(
                nextSibling(node),
                vnode,
                parentNode(node),
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
              vnode.targetAnchor = targetNode;
            } else {
              vnode.anchor = nextSibling(node);
              let targetAnchor = targetNode;
              while (targetAnchor) {
                targetAnchor = nextSibling(targetAnchor);
                if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                  vnode.targetAnchor = targetAnchor;
                  target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                  break;
                }
              }
              hydrateChildren(
                targetNode,
                vnode,
                target,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
            }
          }
          updateCssVars(vnode);
        }
        return vnode.anchor && nextSibling(vnode.anchor);
      }
      const Teleport = TeleportImpl;
      function updateCssVars(vnode) {
        const ctx = vnode.ctx;
        if (ctx && ctx.ut) {
          let node = vnode.children[0].el;
          while (node !== vnode.targetAnchor) {
            if (node.nodeType === 1)
              node.setAttribute("data-v-owner", ctx.uid);
            node = node.nextSibling;
          }
          ctx.ut();
        }
      }
      const Fragment = Symbol.for("v-fgt");
      const Text = Symbol.for("v-txt");
      const Comment = Symbol.for("v-cmt");
      const Static = Symbol.for("v-stc");
      const blockStack = [];
      let currentBlock = null;
      function openBlock(disableTracking = false) {
        blockStack.push(currentBlock = disableTracking ? null : []);
      }
      function closeBlock() {
        blockStack.pop();
        currentBlock = blockStack[blockStack.length - 1] || null;
      }
      let isBlockTreeEnabled = 1;
      function setBlockTracking(value) {
        isBlockTreeEnabled += value;
      }
      function setupBlock(vnode) {
        vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
        closeBlock();
        if (isBlockTreeEnabled > 0 && currentBlock) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
        return setupBlock(
          createBaseVNode(
            type2,
            props,
            children,
            patchFlag,
            dynamicProps,
            shapeFlag,
            true
            /* isBlock */
          )
        );
      }
      function createBlock(type2, props, children, patchFlag, dynamicProps) {
        return setupBlock(
          createVNode(
            type2,
            props,
            children,
            patchFlag,
            dynamicProps,
            true
            /* isBlock: prevent a block from tracking itself */
          )
        );
      }
      function isVNode(value) {
        return value ? value.__v_isVNode === true : false;
      }
      function isSameVNodeType(n1, n2) {
        return n1.type === n2.type && n1.key === n2.key;
      }
      const InternalObjectKey = `__vInternal`;
      const normalizeKey = ({ key }) => key != null ? key : null;
      const normalizeRef = ({
        ref: ref2,
        ref_key,
        ref_for
      }) => {
        if (typeof ref2 === "number") {
          ref2 = "" + ref2;
        }
        return ref2 != null ? isString$1(ref2) || isRef(ref2) || isFunction$1(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
      };
      function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
        const vnode = {
          __v_isVNode: true,
          __v_skip: true,
          type: type2,
          props,
          key: props && normalizeKey(props),
          ref: props && normalizeRef(props),
          scopeId: currentScopeId,
          slotScopeIds: null,
          children,
          component: null,
          suspense: null,
          ssContent: null,
          ssFallback: null,
          dirs: null,
          transition: null,
          el: null,
          anchor: null,
          target: null,
          targetAnchor: null,
          staticCount: 0,
          shapeFlag,
          patchFlag,
          dynamicProps,
          dynamicChildren: null,
          appContext: null,
          ctx: currentRenderingInstance
        };
        if (needFullChildrenNormalization) {
          normalizeChildren(vnode, children);
          if (shapeFlag & 128) {
            type2.normalize(vnode);
          }
        } else if (children) {
          vnode.shapeFlag |= isString$1(children) ? 8 : 16;
        }
        if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
        !isBlockNode && // has current parent block
        currentBlock && // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        vnode.patchFlag !== 32) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      const createVNode = _createVNode;
      function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
        if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
          type2 = Comment;
        }
        if (isVNode(type2)) {
          const cloned = cloneVNode(
            type2,
            props,
            true
            /* mergeRef: true */
          );
          if (children) {
            normalizeChildren(cloned, children);
          }
          if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6) {
              currentBlock[currentBlock.indexOf(type2)] = cloned;
            } else {
              currentBlock.push(cloned);
            }
          }
          cloned.patchFlag |= -2;
          return cloned;
        }
        if (isClassComponent(type2)) {
          type2 = type2.__vccOpts;
        }
        if (props) {
          props = guardReactiveProps(props);
          let { class: klass, style } = props;
          if (klass && !isString$1(klass)) {
            props.class = normalizeClass(klass);
          }
          if (isObject$1(style)) {
            if (isProxy(style) && !isArray$2(style)) {
              style = extend({}, style);
            }
            props.style = normalizeStyle(style);
          }
        }
        const shapeFlag = isString$1(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject$1(type2) ? 4 : isFunction$1(type2) ? 2 : 0;
        return createBaseVNode(
          type2,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          isBlockNode,
          true
        );
      }
      function guardReactiveProps(props) {
        if (!props)
          return null;
        return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
      }
      function cloneVNode(vnode, extraProps, mergeRef = false) {
        const { props, ref: ref2, patchFlag, children } = vnode;
        const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
        const cloned = {
          __v_isVNode: true,
          __v_skip: true,
          type: vnode.type,
          props: mergedProps,
          key: mergedProps && normalizeKey(mergedProps),
          ref: extraProps && extraProps.ref ? (
            // #2078 in the case of <component :is="vnode" ref="extra"/>
            // if the vnode itself already has a ref, cloneVNode will need to merge
            // the refs so the single vnode can be set on multiple refs
            mergeRef && ref2 ? isArray$2(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
          ) : ref2,
          scopeId: vnode.scopeId,
          slotScopeIds: vnode.slotScopeIds,
          children,
          target: vnode.target,
          targetAnchor: vnode.targetAnchor,
          staticCount: vnode.staticCount,
          shapeFlag: vnode.shapeFlag,
          // if the vnode is cloned with extra props, we can no longer assume its
          // existing patch flag to be reliable and need to add the FULL_PROPS flag.
          // note: preserve flag for fragments since they use the flag for children
          // fast paths only.
          patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
          dynamicProps: vnode.dynamicProps,
          dynamicChildren: vnode.dynamicChildren,
          appContext: vnode.appContext,
          dirs: vnode.dirs,
          transition: vnode.transition,
          // These should technically only be non-null on mounted VNodes. However,
          // they *should* be copied for kept-alive vnodes. So we just always copy
          // them since them being non-null during a mount doesn't affect the logic as
          // they will simply be overwritten.
          component: vnode.component,
          suspense: vnode.suspense,
          ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
          ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
          el: vnode.el,
          anchor: vnode.anchor,
          ctx: vnode.ctx,
          ce: vnode.ce
        };
        return cloned;
      }
      function createTextVNode(text = " ", flag = 0) {
        return createVNode(Text, null, text, flag);
      }
      function createCommentVNode(text = "", asBlock = false) {
        return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
      }
      function normalizeVNode(child) {
        if (child == null || typeof child === "boolean") {
          return createVNode(Comment);
        } else if (isArray$2(child)) {
          return createVNode(
            Fragment,
            null,
            // #3666, avoid reference pollution when reusing vnode
            child.slice()
          );
        } else if (typeof child === "object") {
          return cloneIfMounted(child);
        } else {
          return createVNode(Text, null, String(child));
        }
      }
      function cloneIfMounted(child) {
        return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
      }
      function normalizeChildren(vnode, children) {
        let type2 = 0;
        const { shapeFlag } = vnode;
        if (children == null) {
          children = null;
        } else if (isArray$2(children)) {
          type2 = 16;
        } else if (typeof children === "object") {
          if (shapeFlag & (1 | 64)) {
            const slot = children.default;
            if (slot) {
              slot._c && (slot._d = false);
              normalizeChildren(vnode, slot());
              slot._c && (slot._d = true);
            }
            return;
          } else {
            type2 = 32;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) {
              children._ctx = currentRenderingInstance;
            } else if (slotFlag === 3 && currentRenderingInstance) {
              if (currentRenderingInstance.slots._ === 1) {
                children._ = 1;
              } else {
                children._ = 2;
                vnode.patchFlag |= 1024;
              }
            }
          }
        } else if (isFunction$1(children)) {
          children = { default: children, _ctx: currentRenderingInstance };
          type2 = 32;
        } else {
          children = String(children);
          if (shapeFlag & 64) {
            type2 = 16;
            children = [createTextVNode(children)];
          } else {
            type2 = 8;
          }
        }
        vnode.children = children;
        vnode.shapeFlag |= type2;
      }
      function mergeProps(...args) {
        const ret = {};
        for (let i2 = 0; i2 < args.length; i2++) {
          const toMerge = args[i2];
          for (const key in toMerge) {
            if (key === "class") {
              if (ret.class !== toMerge.class) {
                ret.class = normalizeClass([ret.class, toMerge.class]);
              }
            } else if (key === "style") {
              ret.style = normalizeStyle([ret.style, toMerge.style]);
            } else if (isOn(key)) {
              const existing = ret[key];
              const incoming = toMerge[key];
              if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
                ret[key] = existing ? [].concat(existing, incoming) : incoming;
              }
            } else if (key !== "") {
              ret[key] = toMerge[key];
            }
          }
        }
        return ret;
      }
      function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
        callWithAsyncErrorHandling(hook, instance, 7, [
          vnode,
          prevVNode
        ]);
      }
      const emptyAppContext = createAppContext();
      let uid = 0;
      function createComponentInstance(vnode, parent, suspense) {
        const type2 = vnode.type;
        const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
        const instance = {
          uid: uid++,
          vnode,
          type: type2,
          parent,
          appContext,
          root: null,
          // to be immediately set
          next: null,
          subTree: null,
          // will be set synchronously right after creation
          effect: null,
          update: null,
          // will be set synchronously right after creation
          scope: new EffectScope(
            true
            /* detached */
          ),
          render: null,
          proxy: null,
          exposed: null,
          exposeProxy: null,
          withProxy: null,
          provides: parent ? parent.provides : Object.create(appContext.provides),
          accessCache: null,
          renderCache: [],
          // local resolved assets
          components: null,
          directives: null,
          // resolved props and emits options
          propsOptions: normalizePropsOptions(type2, appContext),
          emitsOptions: normalizeEmitsOptions(type2, appContext),
          // emit
          emit: null,
          // to be set immediately
          emitted: null,
          // props default value
          propsDefaults: EMPTY_OBJ,
          // inheritAttrs
          inheritAttrs: type2.inheritAttrs,
          // state
          ctx: EMPTY_OBJ,
          data: EMPTY_OBJ,
          props: EMPTY_OBJ,
          attrs: EMPTY_OBJ,
          slots: EMPTY_OBJ,
          refs: EMPTY_OBJ,
          setupState: EMPTY_OBJ,
          setupContext: null,
          attrsProxy: null,
          slotsProxy: null,
          // suspense related
          suspense,
          suspenseId: suspense ? suspense.pendingId : 0,
          asyncDep: null,
          asyncResolved: false,
          // lifecycle hooks
          // not using enums here because it results in computed properties
          isMounted: false,
          isUnmounted: false,
          isDeactivated: false,
          bc: null,
          c: null,
          bm: null,
          m: null,
          bu: null,
          u: null,
          um: null,
          bum: null,
          da: null,
          a: null,
          rtg: null,
          rtc: null,
          ec: null,
          sp: null
        };
        {
          instance.ctx = { _: instance };
        }
        instance.root = parent ? parent.root : instance;
        instance.emit = emit.bind(null, instance);
        if (vnode.ce) {
          vnode.ce(instance);
        }
        return instance;
      }
      let currentInstance = null;
      const getCurrentInstance = () => currentInstance || currentRenderingInstance;
      let internalSetCurrentInstance;
      let globalCurrentInstanceSetters;
      let settersKey = "__VUE_INSTANCE_SETTERS__";
      {
        if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
          globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
        }
        globalCurrentInstanceSetters.push((i2) => currentInstance = i2);
        internalSetCurrentInstance = (instance) => {
          if (globalCurrentInstanceSetters.length > 1) {
            globalCurrentInstanceSetters.forEach((s2) => s2(instance));
          } else {
            globalCurrentInstanceSetters[0](instance);
          }
        };
      }
      const setCurrentInstance = (instance) => {
        internalSetCurrentInstance(instance);
        instance.scope.on();
      };
      const unsetCurrentInstance = () => {
        currentInstance && currentInstance.scope.off();
        internalSetCurrentInstance(null);
      };
      function isStatefulComponent(instance) {
        return instance.vnode.shapeFlag & 4;
      }
      let isInSSRComponentSetup = false;
      function setupComponent(instance, isSSR = false) {
        isInSSRComponentSetup = isSSR;
        const { props, children } = instance.vnode;
        const isStateful = isStatefulComponent(instance);
        initProps(instance, props, isStateful, isSSR);
        initSlots(instance, children);
        const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
        isInSSRComponentSetup = false;
        return setupResult;
      }
      function setupStatefulComponent(instance, isSSR) {
        const Component = instance.type;
        instance.accessCache = /* @__PURE__ */ Object.create(null);
        instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
        const { setup } = Component;
        if (setup) {
          const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
          setCurrentInstance(instance);
          pauseTracking();
          const setupResult = callWithErrorHandling(
            setup,
            instance,
            0,
            [instance.props, setupContext]
          );
          resetTracking();
          unsetCurrentInstance();
          if (isPromise(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
              return setupResult.then((resolvedResult) => {
                handleSetupResult(instance, resolvedResult, isSSR);
              }).catch((e2) => {
                handleError(e2, instance, 0);
              });
            } else {
              instance.asyncDep = setupResult;
            }
          } else {
            handleSetupResult(instance, setupResult, isSSR);
          }
        } else {
          finishComponentSetup(instance, isSSR);
        }
      }
      function handleSetupResult(instance, setupResult, isSSR) {
        if (isFunction$1(setupResult)) {
          if (instance.type.__ssrInlineRender) {
            instance.ssrRender = setupResult;
          } else {
            instance.render = setupResult;
          }
        } else if (isObject$1(setupResult)) {
          instance.setupState = proxyRefs(setupResult);
        } else
          ;
        finishComponentSetup(instance, isSSR);
      }
      let compile;
      function finishComponentSetup(instance, isSSR, skipOptions) {
        const Component = instance.type;
        if (!instance.render) {
          if (!isSSR && compile && !Component.render) {
            const template = Component.template || resolveMergedOptions(instance).template;
            if (template) {
              const { isCustomElement, compilerOptions } = instance.appContext.config;
              const { delimiters, compilerOptions: componentCompilerOptions } = Component;
              const finalCompilerOptions = extend(
                extend(
                  {
                    isCustomElement,
                    delimiters
                  },
                  compilerOptions
                ),
                componentCompilerOptions
              );
              Component.render = compile(template, finalCompilerOptions);
            }
          }
          instance.render = Component.render || NOOP;
        }
        {
          setCurrentInstance(instance);
          pauseTracking();
          applyOptions(instance);
          resetTracking();
          unsetCurrentInstance();
        }
      }
      function getAttrsProxy(instance) {
        return instance.attrsProxy || (instance.attrsProxy = new Proxy(
          instance.attrs,
          {
            get(target, key) {
              track(instance, "get", "$attrs");
              return target[key];
            }
          }
        ));
      }
      function createSetupContext(instance) {
        const expose = (exposed) => {
          instance.exposed = exposed || {};
        };
        {
          return {
            get attrs() {
              return getAttrsProxy(instance);
            },
            slots: instance.slots,
            emit: instance.emit,
            expose
          };
        }
      }
      function getExposeProxy(instance) {
        if (instance.exposed) {
          return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
            get(target, key) {
              if (key in target) {
                return target[key];
              } else if (key in publicPropertiesMap) {
                return publicPropertiesMap[key](instance);
              }
            },
            has(target, key) {
              return key in target || key in publicPropertiesMap;
            }
          }));
        }
      }
      function getComponentName(Component, includeInferred = true) {
        return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
      }
      function isClassComponent(value) {
        return isFunction$1(value) && "__vccOpts" in value;
      }
      const computed = (getterOrOptions, debugOptions) => {
        return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
      };
      function h$1(type2, propsOrChildren, children) {
        const l2 = arguments.length;
        if (l2 === 2) {
          if (isObject$1(propsOrChildren) && !isArray$2(propsOrChildren)) {
            if (isVNode(propsOrChildren)) {
              return createVNode(type2, null, [propsOrChildren]);
            }
            return createVNode(type2, propsOrChildren);
          } else {
            return createVNode(type2, null, propsOrChildren);
          }
        } else {
          if (l2 > 3) {
            children = Array.prototype.slice.call(arguments, 2);
          } else if (l2 === 3 && isVNode(children)) {
            children = [children];
          }
          return createVNode(type2, propsOrChildren, children);
        }
      }
      const ssrContextKey = Symbol.for("v-scx");
      const useSSRContext = () => {
        {
          const ctx = inject(ssrContextKey);
          return ctx;
        }
      };
      const version = "3.3.4";
      const svgNS = "http://www.w3.org/2000/svg";
      const doc = typeof document !== "undefined" ? document : null;
      const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
      const nodeOps = {
        insert: (child, parent, anchor) => {
          parent.insertBefore(child, anchor || null);
        },
        remove: (child) => {
          const parent = child.parentNode;
          if (parent) {
            parent.removeChild(child);
          }
        },
        createElement: (tag, isSVG, is, props) => {
          const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
          if (tag === "select" && props && props.multiple != null) {
            el.setAttribute("multiple", props.multiple);
          }
          return el;
        },
        createText: (text) => doc.createTextNode(text),
        createComment: (text) => doc.createComment(text),
        setText: (node, text) => {
          node.nodeValue = text;
        },
        setElementText: (el, text) => {
          el.textContent = text;
        },
        parentNode: (node) => node.parentNode,
        nextSibling: (node) => node.nextSibling,
        querySelector: (selector) => doc.querySelector(selector),
        setScopeId(el, id2) {
          el.setAttribute(id2, "");
        },
        // __UNSAFE__
        // Reason: innerHTML.
        // Static content here can only come from compiled templates.
        // As long as the user only uses trusted templates, this is safe.
        insertStaticContent(content, parent, anchor, isSVG, start, end2) {
          const before = anchor ? anchor.previousSibling : parent.lastChild;
          if (start && (start === end2 || start.nextSibling)) {
            while (true) {
              parent.insertBefore(start.cloneNode(true), anchor);
              if (start === end2 || !(start = start.nextSibling))
                break;
            }
          } else {
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template = templateContainer.content;
            if (isSVG) {
              const wrapper = template.firstChild;
              while (wrapper.firstChild) {
                template.appendChild(wrapper.firstChild);
              }
              template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
          }
          return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
          ];
        }
      };
      function patchClass(el, value, isSVG) {
        const transitionClasses = el._vtc;
        if (transitionClasses) {
          value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
        }
        if (value == null) {
          el.removeAttribute("class");
        } else if (isSVG) {
          el.setAttribute("class", value);
        } else {
          el.className = value;
        }
      }
      function patchStyle(el, prev, next) {
        const style = el.style;
        const isCssString = isString$1(next);
        if (next && !isCssString) {
          if (prev && !isString$1(prev)) {
            for (const key in prev) {
              if (next[key] == null) {
                setStyle(style, key, "");
              }
            }
          }
          for (const key in next) {
            setStyle(style, key, next[key]);
          }
        } else {
          const currentDisplay = style.display;
          if (isCssString) {
            if (prev !== next) {
              style.cssText = next;
            }
          } else if (prev) {
            el.removeAttribute("style");
          }
          if ("_vod" in el) {
            style.display = currentDisplay;
          }
        }
      }
      const importantRE = /\s*!important$/;
      function setStyle(style, name, val) {
        if (isArray$2(val)) {
          val.forEach((v2) => setStyle(style, name, v2));
        } else {
          if (val == null)
            val = "";
          if (name.startsWith("--")) {
            style.setProperty(name, val);
          } else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
              style.setProperty(
                hyphenate(prefixed),
                val.replace(importantRE, ""),
                "important"
              );
            } else {
              style[prefixed] = val;
            }
          }
        }
      }
      const prefixes = ["Webkit", "Moz", "ms"];
      const prefixCache = {};
      function autoPrefix(style, rawName) {
        const cached = prefixCache[rawName];
        if (cached) {
          return cached;
        }
        let name = camelize(rawName);
        if (name !== "filter" && name in style) {
          return prefixCache[rawName] = name;
        }
        name = capitalize$1(name);
        for (let i2 = 0; i2 < prefixes.length; i2++) {
          const prefixed = prefixes[i2] + name;
          if (prefixed in style) {
            return prefixCache[rawName] = prefixed;
          }
        }
        return rawName;
      }
      const xlinkNS = "http://www.w3.org/1999/xlink";
      function patchAttr(el, key, value, isSVG, instance) {
        if (isSVG && key.startsWith("xlink:")) {
          if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
          } else {
            el.setAttributeNS(xlinkNS, key, value);
          }
        } else {
          const isBoolean2 = isSpecialBooleanAttr(key);
          if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
            el.removeAttribute(key);
          } else {
            el.setAttribute(key, isBoolean2 ? "" : value);
          }
        }
      }
      function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
        if (key === "innerHTML" || key === "textContent") {
          if (prevChildren) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
          }
          el[key] = value == null ? "" : value;
          return;
        }
        const tag = el.tagName;
        if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
        !tag.includes("-")) {
          el._value = value;
          const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
          const newValue = value == null ? "" : value;
          if (oldValue !== newValue) {
            el.value = newValue;
          }
          if (value == null) {
            el.removeAttribute(key);
          }
          return;
        }
        let needRemove = false;
        if (value === "" || value == null) {
          const type2 = typeof el[key];
          if (type2 === "boolean") {
            value = includeBooleanAttr(value);
          } else if (value == null && type2 === "string") {
            value = "";
            needRemove = true;
          } else if (type2 === "number") {
            value = 0;
            needRemove = true;
          }
        }
        try {
          el[key] = value;
        } catch (e2) {
        }
        needRemove && el.removeAttribute(key);
      }
      function addEventListener(el, event, handler, options) {
        el.addEventListener(event, handler, options);
      }
      function removeEventListener(el, event, handler, options) {
        el.removeEventListener(event, handler, options);
      }
      function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
        const invokers = el._vei || (el._vei = {});
        const existingInvoker = invokers[rawName];
        if (nextValue && existingInvoker) {
          existingInvoker.value = nextValue;
        } else {
          const [name, options] = parseName(rawName);
          if (nextValue) {
            const invoker = invokers[rawName] = createInvoker(nextValue, instance);
            addEventListener(el, name, invoker, options);
          } else if (existingInvoker) {
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = void 0;
          }
        }
      }
      const optionsModifierRE = /(?:Once|Passive|Capture)$/;
      function parseName(name) {
        let options;
        if (optionsModifierRE.test(name)) {
          options = {};
          let m2;
          while (m2 = name.match(optionsModifierRE)) {
            name = name.slice(0, name.length - m2[0].length);
            options[m2[0].toLowerCase()] = true;
          }
        }
        const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
        return [event, options];
      }
      let cachedNow = 0;
      const p$1 = /* @__PURE__ */ Promise.resolve();
      const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
      function createInvoker(initialValue, instance) {
        const invoker = (e2) => {
          if (!e2._vts) {
            e2._vts = Date.now();
          } else if (e2._vts <= invoker.attached) {
            return;
          }
          callWithAsyncErrorHandling(
            patchStopImmediatePropagation(e2, invoker.value),
            instance,
            5,
            [e2]
          );
        };
        invoker.value = initialValue;
        invoker.attached = getNow();
        return invoker;
      }
      function patchStopImmediatePropagation(e2, value) {
        if (isArray$2(value)) {
          const originalStop = e2.stopImmediatePropagation;
          e2.stopImmediatePropagation = () => {
            originalStop.call(e2);
            e2._stopped = true;
          };
          return value.map((fn2) => (e22) => !e22._stopped && fn2 && fn2(e22));
        } else {
          return value;
        }
      }
      const nativeOnRE = /^on[a-z]/;
      const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
        if (key === "class") {
          patchClass(el, nextValue, isSVG);
        } else if (key === "style") {
          patchStyle(el, prevValue, nextValue);
        } else if (isOn(key)) {
          if (!isModelListener(key)) {
            patchEvent(el, key, prevValue, nextValue, parentComponent);
          }
        } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
          patchDOMProp(
            el,
            key,
            nextValue,
            prevChildren,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        } else {
          if (key === "true-value") {
            el._trueValue = nextValue;
          } else if (key === "false-value") {
            el._falseValue = nextValue;
          }
          patchAttr(el, key, nextValue, isSVG);
        }
      };
      function shouldSetAsProp(el, key, value, isSVG) {
        if (isSVG) {
          if (key === "innerHTML" || key === "textContent") {
            return true;
          }
          if (key in el && nativeOnRE.test(key) && isFunction$1(value)) {
            return true;
          }
          return false;
        }
        if (key === "spellcheck" || key === "draggable" || key === "translate") {
          return false;
        }
        if (key === "form") {
          return false;
        }
        if (key === "list" && el.tagName === "INPUT") {
          return false;
        }
        if (key === "type" && el.tagName === "TEXTAREA") {
          return false;
        }
        if (nativeOnRE.test(key) && isString$1(value)) {
          return false;
        }
        return key in el;
      }
      const TRANSITION = "transition";
      const ANIMATION = "animation";
      const Transition = (props, { slots }) => h$1(BaseTransition, resolveTransitionProps(props), slots);
      Transition.displayName = "Transition";
      const DOMTransitionPropsValidators = {
        name: String,
        type: String,
        css: {
          type: Boolean,
          default: true
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
      };
      const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
        {},
        BaseTransitionPropsValidators,
        DOMTransitionPropsValidators
      );
      const callHook = (hook, args = []) => {
        if (isArray$2(hook)) {
          hook.forEach((h2) => h2(...args));
        } else if (hook) {
          hook(...args);
        }
      };
      const hasExplicitCallback = (hook) => {
        return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
      };
      function resolveTransitionProps(rawProps) {
        const baseProps = {};
        for (const key in rawProps) {
          if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
          }
        }
        if (rawProps.css === false) {
          return baseProps;
        }
        const {
          name = "v",
          type: type2,
          duration,
          enterFromClass = `${name}-enter-from`,
          enterActiveClass = `${name}-enter-active`,
          enterToClass = `${name}-enter-to`,
          appearFromClass = enterFromClass,
          appearActiveClass = enterActiveClass,
          appearToClass = enterToClass,
          leaveFromClass = `${name}-leave-from`,
          leaveActiveClass = `${name}-leave-active`,
          leaveToClass = `${name}-leave-to`
        } = rawProps;
        const durations = normalizeDuration(duration);
        const enterDuration = durations && durations[0];
        const leaveDuration = durations && durations[1];
        const {
          onBeforeEnter,
          onEnter,
          onEnterCancelled,
          onLeave,
          onLeaveCancelled,
          onBeforeAppear = onBeforeEnter,
          onAppear = onEnter,
          onAppearCancelled = onEnterCancelled
        } = baseProps;
        const finishEnter = (el, isAppear, done) => {
          removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
          removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
          done && done();
        };
        const finishLeave = (el, done) => {
          el._isLeaving = false;
          removeTransitionClass(el, leaveFromClass);
          removeTransitionClass(el, leaveToClass);
          removeTransitionClass(el, leaveActiveClass);
          done && done();
        };
        const makeEnterHook = (isAppear) => {
          return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve2 = () => finishEnter(el, isAppear, done);
            callHook(hook, [el, resolve2]);
            nextFrame(() => {
              removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
              addTransitionClass(el, isAppear ? appearToClass : enterToClass);
              if (!hasExplicitCallback(hook)) {
                whenTransitionEnds(el, type2, enterDuration, resolve2);
              }
            });
          };
        };
        return extend(baseProps, {
          onBeforeEnter(el) {
            callHook(onBeforeEnter, [el]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
          },
          onBeforeAppear(el) {
            callHook(onBeforeAppear, [el]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
          },
          onEnter: makeEnterHook(false),
          onAppear: makeEnterHook(true),
          onLeave(el, done) {
            el._isLeaving = true;
            const resolve2 = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
              if (!el._isLeaving) {
                return;
              }
              removeTransitionClass(el, leaveFromClass);
              addTransitionClass(el, leaveToClass);
              if (!hasExplicitCallback(onLeave)) {
                whenTransitionEnds(el, type2, leaveDuration, resolve2);
              }
            });
            callHook(onLeave, [el, resolve2]);
          },
          onEnterCancelled(el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [el]);
          },
          onAppearCancelled(el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [el]);
          },
          onLeaveCancelled(el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [el]);
          }
        });
      }
      function normalizeDuration(duration) {
        if (duration == null) {
          return null;
        } else if (isObject$1(duration)) {
          return [NumberOf(duration.enter), NumberOf(duration.leave)];
        } else {
          const n2 = NumberOf(duration);
          return [n2, n2];
        }
      }
      function NumberOf(val) {
        const res = toNumber$1(val);
        return res;
      }
      function addTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
        (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
      }
      function removeTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
        const { _vtc } = el;
        if (_vtc) {
          _vtc.delete(cls);
          if (!_vtc.size) {
            el._vtc = void 0;
          }
        }
      }
      function nextFrame(cb) {
        requestAnimationFrame(() => {
          requestAnimationFrame(cb);
        });
      }
      let endId = 0;
      function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
        const id2 = el._endId = ++endId;
        const resolveIfNotStale = () => {
          if (id2 === el._endId) {
            resolve2();
          }
        };
        if (explicitTimeout) {
          return setTimeout(resolveIfNotStale, explicitTimeout);
        }
        const { type: type2, timeout, propCount } = getTransitionInfo(el, expectedType);
        if (!type2) {
          return resolve2();
        }
        const endEvent = type2 + "end";
        let ended = 0;
        const end2 = () => {
          el.removeEventListener(endEvent, onEnd);
          resolveIfNotStale();
        };
        const onEnd = (e2) => {
          if (e2.target === el && ++ended >= propCount) {
            end2();
          }
        };
        setTimeout(() => {
          if (ended < propCount) {
            end2();
          }
        }, timeout + 1);
        el.addEventListener(endEvent, onEnd);
      }
      function getTransitionInfo(el, expectedType) {
        const styles = window.getComputedStyle(el);
        const getStyleProperties = (key) => (styles[key] || "").split(", ");
        const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
        const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
        const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
        const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
        const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
        const animationTimeout = getTimeout(animationDelays, animationDurations);
        let type2 = null;
        let timeout = 0;
        let propCount = 0;
        if (expectedType === TRANSITION) {
          if (transitionTimeout > 0) {
            type2 = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
          }
        } else if (expectedType === ANIMATION) {
          if (animationTimeout > 0) {
            type2 = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
          }
        } else {
          timeout = Math.max(transitionTimeout, animationTimeout);
          type2 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
          propCount = type2 ? type2 === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
        }
        const hasTransform = type2 === TRANSITION && /\b(transform|all)(,|$)/.test(
          getStyleProperties(`${TRANSITION}Property`).toString()
        );
        return {
          type: type2,
          timeout,
          propCount,
          hasTransform
        };
      }
      function getTimeout(delays, durations) {
        while (delays.length < durations.length) {
          delays = delays.concat(delays);
        }
        return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
      }
      function toMs(s2) {
        return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
      }
      function forceReflow() {
        return document.body.offsetHeight;
      }
      const positionMap = /* @__PURE__ */ new WeakMap();
      const newPositionMap = /* @__PURE__ */ new WeakMap();
      const TransitionGroupImpl = {
        name: "TransitionGroup",
        props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
          tag: String,
          moveClass: String
        }),
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          let prevChildren;
          let children;
          onUpdated(() => {
            if (!prevChildren.length) {
              return;
            }
            const moveClass = props.moveClass || `${props.name || "v"}-move`;
            if (!hasCSSTransform(
              prevChildren[0].el,
              instance.vnode.el,
              moveClass
            )) {
              return;
            }
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            forceReflow();
            movedChildren.forEach((c2) => {
              const el = c2.el;
              const style = el.style;
              addTransitionClass(el, moveClass);
              style.transform = style.webkitTransform = style.transitionDuration = "";
              const cb = el._moveCb = (e2) => {
                if (e2 && e2.target !== el) {
                  return;
                }
                if (!e2 || /transform$/.test(e2.propertyName)) {
                  el.removeEventListener("transitionend", cb);
                  el._moveCb = null;
                  removeTransitionClass(el, moveClass);
                }
              };
              el.addEventListener("transitionend", cb);
            });
          });
          return () => {
            const rawProps = toRaw(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || Fragment;
            prevChildren = children;
            children = slots.default ? getTransitionRawChildren(slots.default()) : [];
            for (let i2 = 0; i2 < children.length; i2++) {
              const child = children[i2];
              if (child.key != null) {
                setTransitionHooks(
                  child,
                  resolveTransitionHooks(child, cssTransitionProps, state, instance)
                );
              }
            }
            if (prevChildren) {
              for (let i2 = 0; i2 < prevChildren.length; i2++) {
                const child = prevChildren[i2];
                setTransitionHooks(
                  child,
                  resolveTransitionHooks(child, cssTransitionProps, state, instance)
                );
                positionMap.set(child, child.el.getBoundingClientRect());
              }
            }
            return createVNode(tag, null, children);
          };
        }
      };
      const removeMode = (props) => delete props.mode;
      /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
      const TransitionGroup = TransitionGroupImpl;
      function callPendingCbs(c2) {
        const el = c2.el;
        if (el._moveCb) {
          el._moveCb();
        }
        if (el._enterCb) {
          el._enterCb();
        }
      }
      function recordPosition(c2) {
        newPositionMap.set(c2, c2.el.getBoundingClientRect());
      }
      function applyTranslation(c2) {
        const oldPos = positionMap.get(c2);
        const newPos = newPositionMap.get(c2);
        const dx = oldPos.left - newPos.left;
        const dy = oldPos.top - newPos.top;
        if (dx || dy) {
          const s2 = c2.el.style;
          s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
          s2.transitionDuration = "0s";
          return c2;
        }
      }
      function hasCSSTransform(el, root2, moveClass) {
        const clone2 = el.cloneNode();
        if (el._vtc) {
          el._vtc.forEach((cls) => {
            cls.split(/\s+/).forEach((c2) => c2 && clone2.classList.remove(c2));
          });
        }
        moveClass.split(/\s+/).forEach((c2) => c2 && clone2.classList.add(c2));
        clone2.style.display = "none";
        const container = root2.nodeType === 1 ? root2 : root2.parentNode;
        container.appendChild(clone2);
        const { hasTransform } = getTransitionInfo(clone2);
        container.removeChild(clone2);
        return hasTransform;
      }
      const getModelAssigner = (vnode) => {
        const fn2 = vnode.props["onUpdate:modelValue"] || false;
        return isArray$2(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
      };
      function onCompositionStart(e2) {
        e2.target.composing = true;
      }
      function onCompositionEnd(e2) {
        const target = e2.target;
        if (target.composing) {
          target.composing = false;
          target.dispatchEvent(new Event("input"));
        }
      }
      const vModelText = {
        created(el, { modifiers: { lazy, trim, number: number2 } }, vnode) {
          el._assign = getModelAssigner(vnode);
          const castToNumber = number2 || vnode.props && vnode.props.type === "number";
          addEventListener(el, lazy ? "change" : "input", (e2) => {
            if (e2.target.composing)
              return;
            let domValue = el.value;
            if (trim) {
              domValue = domValue.trim();
            }
            if (castToNumber) {
              domValue = looseToNumber(domValue);
            }
            el._assign(domValue);
          });
          if (trim) {
            addEventListener(el, "change", () => {
              el.value = el.value.trim();
            });
          }
          if (!lazy) {
            addEventListener(el, "compositionstart", onCompositionStart);
            addEventListener(el, "compositionend", onCompositionEnd);
            addEventListener(el, "change", onCompositionEnd);
          }
        },
        // set value on mounted so it's after min/max for type="range"
        mounted(el, { value }) {
          el.value = value == null ? "" : value;
        },
        beforeUpdate(el, { value, modifiers: { lazy, trim, number: number2 } }, vnode) {
          el._assign = getModelAssigner(vnode);
          if (el.composing)
            return;
          if (document.activeElement === el && el.type !== "range") {
            if (lazy) {
              return;
            }
            if (trim && el.value.trim() === value) {
              return;
            }
            if ((number2 || el.type === "number") && looseToNumber(el.value) === value) {
              return;
            }
          }
          const newValue = value == null ? "" : value;
          if (el.value !== newValue) {
            el.value = newValue;
          }
        }
      };
      const vModelCheckbox = {
        // #4096 array checkboxes need to be deep traversed
        deep: true,
        created(el, _2, vnode) {
          el._assign = getModelAssigner(vnode);
          addEventListener(el, "change", () => {
            const modelValue = el._modelValue;
            const elementValue = getValue$2(el);
            const checked = el.checked;
            const assign2 = el._assign;
            if (isArray$2(modelValue)) {
              const index = looseIndexOf(modelValue, elementValue);
              const found = index !== -1;
              if (checked && !found) {
                assign2(modelValue.concat(elementValue));
              } else if (!checked && found) {
                const filtered = [...modelValue];
                filtered.splice(index, 1);
                assign2(filtered);
              }
            } else if (isSet$2(modelValue)) {
              const cloned = new Set(modelValue);
              if (checked) {
                cloned.add(elementValue);
              } else {
                cloned.delete(elementValue);
              }
              assign2(cloned);
            } else {
              assign2(getCheckboxValue(el, checked));
            }
          });
        },
        // set initial checked on mount to wait for true-value/false-value
        mounted: setChecked,
        beforeUpdate(el, binding, vnode) {
          el._assign = getModelAssigner(vnode);
          setChecked(el, binding, vnode);
        }
      };
      function setChecked(el, { value, oldValue }, vnode) {
        el._modelValue = value;
        if (isArray$2(value)) {
          el.checked = looseIndexOf(value, vnode.props.value) > -1;
        } else if (isSet$2(value)) {
          el.checked = value.has(vnode.props.value);
        } else if (value !== oldValue) {
          el.checked = looseEqual(value, getCheckboxValue(el, true));
        }
      }
      function getValue$2(el) {
        return "_value" in el ? el._value : el.value;
      }
      function getCheckboxValue(el, checked) {
        const key = checked ? "_trueValue" : "_falseValue";
        return key in el ? el[key] : checked;
      }
      const systemModifiers = ["ctrl", "shift", "alt", "meta"];
      const modifierGuards = {
        stop: (e2) => e2.stopPropagation(),
        prevent: (e2) => e2.preventDefault(),
        self: (e2) => e2.target !== e2.currentTarget,
        ctrl: (e2) => !e2.ctrlKey,
        shift: (e2) => !e2.shiftKey,
        alt: (e2) => !e2.altKey,
        meta: (e2) => !e2.metaKey,
        left: (e2) => "button" in e2 && e2.button !== 0,
        middle: (e2) => "button" in e2 && e2.button !== 1,
        right: (e2) => "button" in e2 && e2.button !== 2,
        exact: (e2, modifiers) => systemModifiers.some((m2) => e2[`${m2}Key`] && !modifiers.includes(m2))
      };
      const withModifiers = (fn2, modifiers) => {
        return (event, ...args) => {
          for (let i2 = 0; i2 < modifiers.length; i2++) {
            const guard = modifierGuards[modifiers[i2]];
            if (guard && guard(event, modifiers))
              return;
          }
          return fn2(event, ...args);
        };
      };
      const keyNames = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
      };
      const withKeys = (fn2, modifiers) => {
        return (event) => {
          if (!("key" in event)) {
            return;
          }
          const eventKey = hyphenate(event.key);
          if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
            return fn2(event);
          }
        };
      };
      const vShow = {
        beforeMount(el, { value }, { transition }) {
          el._vod = el.style.display === "none" ? "" : el.style.display;
          if (transition && value) {
            transition.beforeEnter(el);
          } else {
            setDisplay(el, value);
          }
        },
        mounted(el, { value }, { transition }) {
          if (transition && value) {
            transition.enter(el);
          }
        },
        updated(el, { value, oldValue }, { transition }) {
          if (!value === !oldValue)
            return;
          if (transition) {
            if (value) {
              transition.beforeEnter(el);
              setDisplay(el, true);
              transition.enter(el);
            } else {
              transition.leave(el, () => {
                setDisplay(el, false);
              });
            }
          } else {
            setDisplay(el, value);
          }
        },
        beforeUnmount(el, { value }) {
          setDisplay(el, value);
        }
      };
      function setDisplay(el, value) {
        el.style.display = value ? el._vod : "none";
      }
      const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
      let renderer;
      function ensureRenderer() {
        return renderer || (renderer = createRenderer(rendererOptions));
      }
      const render$i = (...args) => {
        ensureRenderer().render(...args);
      };
      const createApp = (...args) => {
        const app2 = ensureRenderer().createApp(...args);
        const { mount } = app2;
        app2.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (!container)
            return;
          const component = app2._component;
          if (!isFunction$1(component) && !component.render && !component.template) {
            component.template = container.innerHTML;
          }
          container.innerHTML = "";
          const proxy = mount(container, false, container instanceof SVGElement);
          if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
          }
          return proxy;
        };
        return app2;
      };
      function normalizeContainer(container) {
        if (isString$1(container)) {
          const res = document.querySelector(container);
          return res;
        }
        return container;
      }
      function touchX(event) {
        if (event.type.indexOf("mouse") !== -1) {
          return event.clientX;
        }
        return event.touches[0].clientX;
      }
      function touchY(event) {
        if (event.type.indexOf("mouse") !== -1) {
          return event.clientY;
        }
        return event.touches[0].clientY;
      }
      var isPassiveSupported = function() {
        var supportsPassive = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supportsPassive = true;
            }
          });
          window.addEventListener("test", null, opts);
        } catch (e2) {
        }
        return supportsPassive;
      }();
      var vueTouchEvents = {
        install: function(app2, constructorOptions) {
          var globalOptions = Object.assign({}, {
            disableClick: false,
            tapTolerance: 10,
            // px
            swipeTolerance: 30,
            // px
            touchHoldTolerance: 400,
            // ms
            longTapTimeInterval: 400,
            // ms
            touchClass: "",
            dragFrequency: 100,
            // ms
            rollOverFrequency: 100
            // ms
          }, constructorOptions);
          function touchStartEvent(event) {
            var $this = this.$$touchObj, isTouchEvent = event.type.indexOf("touch") >= 0, isMouseEvent = event.type.indexOf("mouse") >= 0, $el = this;
            if (isTouchEvent) {
              $this.lastTouchStartTime = event.timeStamp;
            }
            if (isMouseEvent && $this.lastTouchStartTime && event.timeStamp - $this.lastTouchStartTime < 350) {
              return;
            }
            if ($this.touchStarted) {
              return;
            }
            addTouchClass(this);
            $this.touchStarted = true;
            $this.touchMoved = false;
            $this.swipeOutBounded = false;
            $this.startX = touchX(event);
            $this.startY = touchY(event);
            $this.currentX = 0;
            $this.currentY = 0;
            $this.touchStartTime = event.timeStamp;
            $this.hasSwipe = hasEvent(this, "swipe") || hasEvent(this, "swipe.left") || hasEvent(this, "swipe.right") || hasEvent(this, "swipe.top") || hasEvent(this, "swipe.bottom");
            if (hasEvent(this, "hold")) {
              $this.touchHoldTimer = setTimeout(function() {
                $this.touchHoldTimer = null;
                triggerEvent(event, $el, "hold");
              }, $this.options.touchHoldTolerance);
            }
            triggerEvent(event, this, "press");
          }
          function touchMoveEvent(event) {
            var $this = this.$$touchObj;
            var curX = touchX(event);
            var curY = touchY(event);
            var movedAgain = $this.currentX != curX || $this.currentY != curY;
            $this.currentX = curX;
            $this.currentY = curY;
            if (!$this.touchMoved) {
              var tapTolerance = $this.options.tapTolerance;
              $this.touchMoved = Math.abs($this.startX - $this.currentX) > tapTolerance || Math.abs($this.startY - $this.currentY) > tapTolerance;
              if ($this.touchMoved) {
                cancelTouchHoldTimer($this);
                triggerEvent(event, this, "drag.once");
              }
            } else if ($this.hasSwipe && !$this.swipeOutBounded) {
              var swipeOutBounded = $this.options.swipeTolerance;
              $this.swipeOutBounded = Math.abs($this.startX - $this.currentX) > swipeOutBounded && Math.abs($this.startY - $this.currentY) > swipeOutBounded;
            }
            if (hasEvent(this, "rollover") && movedAgain) {
              var now2 = event.timeStamp;
              var throttle2 = $this.options.rollOverFrequency;
              if ($this.touchRollTime == null || now2 > $this.touchRollTime + throttle2) {
                $this.touchRollTime = now2;
                triggerEvent(event, this, "rollover");
              }
            }
            if (hasEvent(this, "drag") && $this.touchStarted && $this.touchMoved && movedAgain) {
              var now2 = event.timeStamp;
              var throttle2 = $this.options.dragFrequency;
              if ($this.touchDragTime == null || now2 > $this.touchDragTime + throttle2) {
                $this.touchDragTime = now2;
                triggerEvent(event, this, "drag");
              }
            }
          }
          function touchCancelEvent() {
            var $this = this.$$touchObj;
            cancelTouchHoldTimer($this);
            removeTouchClass(this);
            $this.touchStarted = $this.touchMoved = false;
            $this.startX = $this.startY = 0;
          }
          function touchEndEvent(event) {
            var $this = this.$$touchObj, isTouchEvent = event.type.indexOf("touch") >= 0, isMouseEvent = event.type.indexOf("mouse") >= 0;
            if (isTouchEvent) {
              $this.lastTouchEndTime = event.timeStamp;
            }
            var touchholdEnd = isTouchEvent && !$this.touchHoldTimer;
            cancelTouchHoldTimer($this);
            $this.touchStarted = false;
            removeTouchClass(this);
            if (isMouseEvent && $this.lastTouchEndTime && event.timeStamp - $this.lastTouchEndTime < 350) {
              return;
            }
            triggerEvent(event, this, "release");
            if (!$this.touchMoved) {
              if (hasEvent(this, "longtap") && event.timeStamp - $this.touchStartTime > $this.options.longTapTimeInterval) {
                if (event.cancelable) {
                  event.preventDefault();
                }
                triggerEvent(event, this, "longtap");
              } else if (hasEvent(this, "hold") && touchholdEnd) {
                if (event.cancelable) {
                  event.preventDefault();
                }
                return;
              } else {
                triggerEvent(event, this, "tap");
              }
            } else if ($this.hasSwipe && !$this.swipeOutBounded) {
              var swipeOutBounded = $this.options.swipeTolerance, direction2, distanceY = Math.abs($this.startY - $this.currentY), distanceX = Math.abs($this.startX - $this.currentX);
              if (distanceY > swipeOutBounded || distanceX > swipeOutBounded) {
                if (distanceY > swipeOutBounded) {
                  direction2 = $this.startY > $this.currentY ? "top" : "bottom";
                } else {
                  direction2 = $this.startX > $this.currentX ? "left" : "right";
                }
                if (hasEvent(this, "swipe." + direction2)) {
                  triggerEvent(event, this, "swipe." + direction2, direction2);
                } else {
                  triggerEvent(event, this, "swipe", direction2);
                }
              }
            }
          }
          function mouseEnterEvent() {
            addTouchClass(this);
          }
          function mouseLeaveEvent() {
            removeTouchClass(this);
          }
          function hasEvent($el, eventType) {
            var callbacks = $el.$$touchObj.callbacks[eventType];
            return callbacks != null && callbacks.length > 0;
          }
          function triggerEvent(e2, $el, eventType, param) {
            var $this = $el.$$touchObj;
            var callbacks = $this.callbacks[eventType];
            if (callbacks == null || callbacks.length === 0) {
              return null;
            }
            for (var i2 = 0; i2 < callbacks.length; i2++) {
              var binding = callbacks[i2];
              if (binding.modifiers.stop) {
                e2.stopPropagation();
              }
              if (binding.modifiers.prevent) {
                e2.preventDefault();
              }
              if (binding.modifiers.self && e2.target !== e2.currentTarget) {
                continue;
              }
              if (typeof binding.value === "function") {
                if (param) {
                  binding.value(param, e2);
                } else {
                  binding.value(e2);
                }
              }
            }
          }
          function addTouchClass($el) {
            var className = $el.$$touchObj.options.touchClass;
            className && $el.classList.add(className);
          }
          function removeTouchClass($el) {
            var className = $el.$$touchObj.options.touchClass;
            className && $el.classList.remove(className);
          }
          function cancelTouchHoldTimer($this) {
            if ($this.touchHoldTimer) {
              clearTimeout($this.touchHoldTimer);
              $this.touchHoldTimer = null;
            }
          }
          function buildTouchObj($el, extraOptions) {
            var touchObj = $el.$$touchObj || {
              // an object contains all callbacks registered,
              // key is event name, value is an array
              callbacks: {},
              // prevent bind twice, set to true when event bound
              hasBindTouchEvents: false,
              // default options, would be override by v-touch-options
              options: globalOptions
            };
            if (extraOptions) {
              touchObj.options = Object.assign({}, touchObj.options, extraOptions);
            }
            $el.$$touchObj = touchObj;
            return $el.$$touchObj;
          }
          app2.directive("touch", {
            beforeMount: function($el, binding) {
              var $this = buildTouchObj($el);
              var passiveOpt = isPassiveSupported ? { passive: true } : false;
              var eventType = binding.arg || "tap";
              switch (eventType) {
                case "swipe":
                  var _m = binding.modifiers;
                  if (_m.left || _m.right || _m.top || _m.bottom) {
                    for (var i2 in binding.modifiers) {
                      if (["left", "right", "top", "bottom"].indexOf(i2) >= 0) {
                        var _e = "swipe." + i2;
                        $this.callbacks[_e] = $this.callbacks[_e] || [];
                        $this.callbacks[_e].push(binding);
                      }
                    }
                  } else {
                    $this.callbacks.swipe = $this.callbacks.swipe || [];
                    $this.callbacks.swipe.push(binding);
                  }
                  break;
                case "press":
                case "drag":
                  if (binding.modifiers.disablePassive) {
                    passiveOpt = false;
                  }
                default:
                  $this.callbacks[eventType] = $this.callbacks[eventType] || [];
                  $this.callbacks[eventType].push(binding);
              }
              if ($this.hasBindTouchEvents) {
                return;
              }
              $el.addEventListener("touchstart", touchStartEvent, passiveOpt);
              $el.addEventListener("touchmove", touchMoveEvent, passiveOpt);
              $el.addEventListener("touchcancel", touchCancelEvent);
              $el.addEventListener("touchend", touchEndEvent);
              if (!$this.options.disableClick) {
                $el.addEventListener("mousedown", touchStartEvent);
                $el.addEventListener("mousemove", touchMoveEvent);
                $el.addEventListener("mouseup", touchEndEvent);
                $el.addEventListener("mouseenter", mouseEnterEvent);
                $el.addEventListener("mouseleave", mouseLeaveEvent);
              }
              $this.hasBindTouchEvents = true;
            },
            unmounted: function($el) {
              $el.removeEventListener("touchstart", touchStartEvent);
              $el.removeEventListener("touchmove", touchMoveEvent);
              $el.removeEventListener("touchcancel", touchCancelEvent);
              $el.removeEventListener("touchend", touchEndEvent);
              if ($el.$$touchObj && !$el.$$touchObj.options.disableClick) {
                $el.removeEventListener("mousedown", touchStartEvent);
                $el.removeEventListener("mousemove", touchMoveEvent);
                $el.removeEventListener("mouseup", touchEndEvent);
                $el.removeEventListener("mouseenter", mouseEnterEvent);
                $el.removeEventListener("mouseleave", mouseLeaveEvent);
              }
              delete $el.$$touchObj;
            }
          });
          app2.directive("touch-class", {
            beforeMount: function($el, binding) {
              buildTouchObj($el, {
                touchClass: binding.value
              });
            }
          });
          app2.directive("touch-options", {
            beforeMount: function($el, binding) {
              buildTouchObj($el, binding.value);
            }
          });
        }
      };
      var isVue2 = false;
      /*!
        * pinia v2.1.4
        * (c) 2023 Eduardo San Martin Morote
        * @license MIT
        */
      let activePinia;
      const setActivePinia = (pinia2) => activePinia = pinia2;
      const piniaSymbol = (
        /* istanbul ignore next */
        Symbol()
      );
      function isPlainObject(o2) {
        return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
      }
      var MutationType;
      (function(MutationType2) {
        MutationType2["direct"] = "direct";
        MutationType2["patchObject"] = "patch object";
        MutationType2["patchFunction"] = "patch function";
      })(MutationType || (MutationType = {}));
      function createPinia() {
        const scope = effectScope(true);
        const state = scope.run(() => ref({}));
        let _p = [];
        let toBeInstalled = [];
        const pinia2 = markRaw({
          install(app2) {
            setActivePinia(pinia2);
            {
              pinia2._a = app2;
              app2.provide(piniaSymbol, pinia2);
              app2.config.globalProperties.$pinia = pinia2;
              toBeInstalled.forEach((plugin) => _p.push(plugin));
              toBeInstalled = [];
            }
          },
          use(plugin) {
            if (!this._a && !isVue2) {
              toBeInstalled.push(plugin);
            } else {
              _p.push(plugin);
            }
            return this;
          },
          _p,
          // it's actually undefined here
          // @ts-expect-error
          _a: null,
          _e: scope,
          _s: /* @__PURE__ */ new Map(),
          state
        });
        return pinia2;
      }
      const noop$2 = () => {
      };
      function addSubscription(subscriptions, callback, detached, onCleanup = noop$2) {
        subscriptions.push(callback);
        const removeSubscription = () => {
          const idx = subscriptions.indexOf(callback);
          if (idx > -1) {
            subscriptions.splice(idx, 1);
            onCleanup();
          }
        };
        if (!detached && getCurrentScope()) {
          onScopeDispose(removeSubscription);
        }
        return removeSubscription;
      }
      function triggerSubscriptions(subscriptions, ...args) {
        subscriptions.slice().forEach((callback) => {
          callback(...args);
        });
      }
      const fallbackRunWithContext = (fn2) => fn2();
      function mergeReactiveObjects(target, patchToApply) {
        if (target instanceof Map && patchToApply instanceof Map) {
          patchToApply.forEach((value, key) => target.set(key, value));
        }
        if (target instanceof Set && patchToApply instanceof Set) {
          patchToApply.forEach(target.add, target);
        }
        for (const key in patchToApply) {
          if (!patchToApply.hasOwnProperty(key))
            continue;
          const subPatch = patchToApply[key];
          const targetValue = target[key];
          if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
            target[key] = mergeReactiveObjects(targetValue, subPatch);
          } else {
            target[key] = subPatch;
          }
        }
        return target;
      }
      const skipHydrateSymbol = (
        /* istanbul ignore next */
        Symbol()
      );
      function shouldHydrate(obj) {
        return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
      }
      const { assign } = Object;
      function isComputed(o2) {
        return !!(isRef(o2) && o2.effect);
      }
      function createOptionsStore(id2, options, pinia2, hot) {
        const { state, actions, getters } = options;
        const initialState = pinia2.state.value[id2];
        let store;
        function setup() {
          if (!initialState && true) {
            {
              pinia2.state.value[id2] = state ? state() : {};
            }
          }
          const localState = toRefs(pinia2.state.value[id2]);
          return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
            computedGetters[name] = markRaw(computed(() => {
              setActivePinia(pinia2);
              const store2 = pinia2._s.get(id2);
              return getters[name].call(store2, store2);
            }));
            return computedGetters;
          }, {}));
        }
        store = createSetupStore(id2, setup, options, pinia2, hot, true);
        return store;
      }
      function createSetupStore($id, setup, options = {}, pinia2, hot, isOptionsStore) {
        let scope;
        const optionsForPlugin = assign({ actions: {} }, options);
        const $subscribeOptions = {
          deep: true
          // flush: 'post',
        };
        let isListening;
        let isSyncListening;
        let subscriptions = [];
        let actionSubscriptions = [];
        let debuggerEvents;
        const initialState = pinia2.state.value[$id];
        if (!isOptionsStore && !initialState && true) {
          {
            pinia2.state.value[$id] = {};
          }
        }
        ref({});
        let activeListener;
        function $patch(partialStateOrMutator) {
          let subscriptionMutation;
          isListening = isSyncListening = false;
          if (typeof partialStateOrMutator === "function") {
            partialStateOrMutator(pinia2.state.value[$id]);
            subscriptionMutation = {
              type: MutationType.patchFunction,
              storeId: $id,
              events: debuggerEvents
            };
          } else {
            mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
            subscriptionMutation = {
              type: MutationType.patchObject,
              payload: partialStateOrMutator,
              storeId: $id,
              events: debuggerEvents
            };
          }
          const myListenerId = activeListener = Symbol();
          nextTick().then(() => {
            if (activeListener === myListenerId) {
              isListening = true;
            }
          });
          isSyncListening = true;
          triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
        }
        const $reset = isOptionsStore ? function $reset2() {
          const { state } = options;
          const newState = state ? state() : {};
          this.$patch(($state) => {
            assign($state, newState);
          });
        } : (
          /* istanbul ignore next */
          noop$2
        );
        function $dispose() {
          scope.stop();
          subscriptions = [];
          actionSubscriptions = [];
          pinia2._s.delete($id);
        }
        function wrapAction(name, action) {
          return function() {
            setActivePinia(pinia2);
            const args = Array.from(arguments);
            const afterCallbackList = [];
            const onErrorCallbackList = [];
            function after(callback) {
              afterCallbackList.push(callback);
            }
            function onError(callback) {
              onErrorCallbackList.push(callback);
            }
            triggerSubscriptions(actionSubscriptions, {
              args,
              name,
              store,
              after,
              onError
            });
            let ret;
            try {
              ret = action.apply(this && this.$id === $id ? this : store, args);
            } catch (error) {
              triggerSubscriptions(onErrorCallbackList, error);
              throw error;
            }
            if (ret instanceof Promise) {
              return ret.then((value) => {
                triggerSubscriptions(afterCallbackList, value);
                return value;
              }).catch((error) => {
                triggerSubscriptions(onErrorCallbackList, error);
                return Promise.reject(error);
              });
            }
            triggerSubscriptions(afterCallbackList, ret);
            return ret;
          };
        }
        const partialStore = {
          _p: pinia2,
          // _s: scope,
          $id,
          $onAction: addSubscription.bind(null, actionSubscriptions),
          $patch,
          $reset,
          $subscribe(callback, options2 = {}) {
            const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
            const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
              if (options2.flush === "sync" ? isSyncListening : isListening) {
                callback({
                  storeId: $id,
                  type: MutationType.direct,
                  events: debuggerEvents
                }, state);
              }
            }, assign({}, $subscribeOptions, options2)));
            return removeSubscription;
          },
          $dispose
        };
        const store = reactive(partialStore);
        pinia2._s.set($id, store);
        const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
        const setupStore = pinia2._e.run(() => {
          scope = effectScope();
          return runWithContext(() => scope.run(setup));
        });
        for (const key in setupStore) {
          const prop = setupStore[key];
          if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
            if (!isOptionsStore) {
              if (initialState && shouldHydrate(prop)) {
                if (isRef(prop)) {
                  prop.value = initialState[key];
                } else {
                  mergeReactiveObjects(prop, initialState[key]);
                }
              }
              {
                pinia2.state.value[$id][key] = prop;
              }
            }
          } else if (typeof prop === "function") {
            const actionValue = wrapAction(key, prop);
            {
              setupStore[key] = actionValue;
            }
            optionsForPlugin.actions[key] = prop;
          } else
            ;
        }
        {
          assign(store, setupStore);
          assign(toRaw(store), setupStore);
        }
        Object.defineProperty(store, "$state", {
          get: () => pinia2.state.value[$id],
          set: (state) => {
            $patch(($state) => {
              assign($state, state);
            });
          }
        });
        pinia2._p.forEach((extender) => {
          {
            assign(store, scope.run(() => extender({
              store,
              app: pinia2._a,
              pinia: pinia2,
              options: optionsForPlugin
            })));
          }
        });
        if (initialState && isOptionsStore && options.hydrate) {
          options.hydrate(store.$state, initialState);
        }
        isListening = true;
        isSyncListening = true;
        return store;
      }
      function defineStore(idOrOptions, setup, setupOptions) {
        let id2;
        let options;
        const isSetupStore = typeof setup === "function";
        if (typeof idOrOptions === "string") {
          id2 = idOrOptions;
          options = isSetupStore ? setupOptions : setup;
        } else {
          options = idOrOptions;
          id2 = idOrOptions.id;
        }
        function useStore(pinia2, hot) {
          const hasContext = hasInjectionContext();
          pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
          // pinia instance with getActivePinia()
          pinia2 || (hasContext ? inject(piniaSymbol, null) : null);
          if (pinia2)
            setActivePinia(pinia2);
          pinia2 = activePinia;
          if (!pinia2._s.has(id2)) {
            if (isSetupStore) {
              createSetupStore(id2, setup, options, pinia2);
            } else {
              createOptionsStore(id2, options, pinia2);
            }
          }
          const store = pinia2._s.get(id2);
          return store;
        }
        useStore.$id = id2;
        return useStore;
      }
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      var FileSaver_min = { exports: {} };
      (function(module2, exports2) {
        (function(a2, b2) {
          b2();
        })(commonjsGlobal, function() {
          function b2(a3, b3) {
            return "undefined" == typeof b3 ? b3 = { autoBom: false } : "object" != typeof b3 && (console.warn("Deprecated: Expected third argument to be a object"), b3 = { autoBom: !b3 }), b3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a3.type) ? new Blob(["\uFEFF", a3], { type: a3.type }) : a3;
          }
          function c2(a3, b3, c3) {
            var d3 = new XMLHttpRequest();
            d3.open("GET", a3), d3.responseType = "blob", d3.onload = function() {
              g2(d3.response, b3, c3);
            }, d3.onerror = function() {
              console.error("could not download file");
            }, d3.send();
          }
          function d2(a3) {
            var b3 = new XMLHttpRequest();
            b3.open("HEAD", a3, false);
            try {
              b3.send();
            } catch (a4) {
            }
            return 200 <= b3.status && 299 >= b3.status;
          }
          function e2(a3) {
            try {
              a3.dispatchEvent(new MouseEvent("click"));
            } catch (c3) {
              var b3 = document.createEvent("MouseEvents");
              b3.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a3.dispatchEvent(b3);
            }
          }
          var f2 = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof commonjsGlobal && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0, a2 = f2.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g2 = f2.saveAs || ("object" != typeof window || window !== f2 ? function() {
          } : "download" in HTMLAnchorElement.prototype && !a2 ? function(b3, g3, h2) {
            var i2 = f2.URL || f2.webkitURL, j2 = document.createElement("a");
            g3 = g3 || b3.name || "download", j2.download = g3, j2.rel = "noopener", "string" == typeof b3 ? (j2.href = b3, j2.origin === location.origin ? e2(j2) : d2(j2.href) ? c2(b3, g3, h2) : e2(j2, j2.target = "_blank")) : (j2.href = i2.createObjectURL(b3), setTimeout(function() {
              i2.revokeObjectURL(j2.href);
            }, 4e4), setTimeout(function() {
              e2(j2);
            }, 0));
          } : "msSaveOrOpenBlob" in navigator ? function(f3, g3, h2) {
            if (g3 = g3 || f3.name || "download", "string" != typeof f3)
              navigator.msSaveOrOpenBlob(b2(f3, h2), g3);
            else if (d2(f3))
              c2(f3, g3, h2);
            else {
              var i2 = document.createElement("a");
              i2.href = f3, i2.target = "_blank", setTimeout(function() {
                e2(i2);
              });
            }
          } : function(b3, d3, e3, g3) {
            if (g3 = g3 || open("", "_blank"), g3 && (g3.document.title = g3.document.body.innerText = "downloading..."), "string" == typeof b3)
              return c2(b3, d3, e3);
            var h2 = "application/octet-stream" === b3.type, i2 = /constructor/i.test(f2.HTMLElement) || f2.safari, j2 = /CriOS\/[\d]+/.test(navigator.userAgent);
            if ((j2 || h2 && i2 || a2) && "undefined" != typeof FileReader) {
              var k2 = new FileReader();
              k2.onloadend = function() {
                var a3 = k2.result;
                a3 = j2 ? a3 : a3.replace(/^data:[^;]*;/, "data:attachment/file;"), g3 ? g3.location.href = a3 : location = a3, g3 = null;
              }, k2.readAsDataURL(b3);
            } else {
              var l2 = f2.URL || f2.webkitURL, m2 = l2.createObjectURL(b3);
              g3 ? g3.location = m2 : location.href = m2, g3 = null, setTimeout(function() {
                l2.revokeObjectURL(m2);
              }, 4e4);
            }
          });
          f2.saveAs = g2.saveAs = g2, module2.exports = g2;
        });
      })(FileSaver_min);
      var FileSaver_minExports = FileSaver_min.exports;
      const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
      const isVisible = (element) => {
        const computed2 = getComputedStyle(element);
        return computed2.position === "fixed" ? false : element.offsetParent !== null;
      };
      const obtainAllFocusableElements$1 = (element) => {
        return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter((item) => isFocusable(item) && isVisible(item));
      };
      const isFocusable = (element) => {
        if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
          return true;
        }
        if (element.disabled) {
          return false;
        }
        switch (element.nodeName) {
          case "A": {
            return !!element.href && element.rel !== "ignore";
          }
          case "INPUT": {
            return !(element.type === "hidden" || element.type === "file");
          }
          case "BUTTON":
          case "SELECT":
          case "TEXTAREA": {
            return true;
          }
          default: {
            return false;
          }
        }
      };
      const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
        const handleEvent = (event) => {
          const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
          if (checkForDefaultPrevented === false || !shouldPrevent) {
            return oursHandler == null ? void 0 : oursHandler(event);
          }
        };
        return handleEvent;
      };
      const whenMouse = (handler) => {
        return (e2) => e2.pointerType === "mouse" ? handler(e2) : void 0;
      };
      var __defProp$9 = Object.defineProperty;
      var __defProps$6 = Object.defineProperties;
      var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
      var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
      var __hasOwnProp$b = Object.prototype.hasOwnProperty;
      var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
      var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues$9 = (a2, b2) => {
        for (var prop in b2 || (b2 = {}))
          if (__hasOwnProp$b.call(b2, prop))
            __defNormalProp$9(a2, prop, b2[prop]);
        if (__getOwnPropSymbols$b)
          for (var prop of __getOwnPropSymbols$b(b2)) {
            if (__propIsEnum$b.call(b2, prop))
              __defNormalProp$9(a2, prop, b2[prop]);
          }
        return a2;
      };
      var __spreadProps$6 = (a2, b2) => __defProps$6(a2, __getOwnPropDescs$6(b2));
      function computedEager(fn2, options) {
        var _a2;
        const result = shallowRef();
        watchEffect(() => {
          result.value = fn2();
        }, __spreadProps$6(__spreadValues$9({}, options), {
          flush: (_a2 = options == null ? void 0 : options.flush) != null ? _a2 : "sync"
        }));
        return readonly(result);
      }
      var _a;
      const isClient$1 = typeof window !== "undefined";
      const isString = (val) => typeof val === "string";
      const noop$1 = () => {
      };
      const isIOS = isClient$1 && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
      function resolveUnref(r2) {
        return typeof r2 === "function" ? r2() : unref(r2);
      }
      function createFilterWrapper(filter, fn2) {
        function wrapper(...args) {
          return new Promise((resolve2, reject) => {
            Promise.resolve(filter(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve2).catch(reject);
          });
        }
        return wrapper;
      }
      function debounceFilter(ms, options = {}) {
        let timer;
        let maxTimer;
        let lastRejector = noop$1;
        const _clearTimeout = (timer2) => {
          clearTimeout(timer2);
          lastRejector();
          lastRejector = noop$1;
        };
        const filter = (invoke) => {
          const duration = resolveUnref(ms);
          const maxDuration = resolveUnref(options.maxWait);
          if (timer)
            _clearTimeout(timer);
          if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
            if (maxTimer) {
              _clearTimeout(maxTimer);
              maxTimer = null;
            }
            return Promise.resolve(invoke());
          }
          return new Promise((resolve2, reject) => {
            lastRejector = options.rejectOnCancel ? reject : resolve2;
            if (maxDuration && !maxTimer) {
              maxTimer = setTimeout(() => {
                if (timer)
                  _clearTimeout(timer);
                maxTimer = null;
                resolve2(invoke());
              }, maxDuration);
            }
            timer = setTimeout(() => {
              if (maxTimer)
                _clearTimeout(maxTimer);
              maxTimer = null;
              resolve2(invoke());
            }, duration);
          });
        };
        return filter;
      }
      function throttleFilter(ms, trailing = true, leading = true, rejectOnCancel = false) {
        let lastExec = 0;
        let timer;
        let isLeading = true;
        let lastRejector = noop$1;
        let lastValue;
        const clear2 = () => {
          if (timer) {
            clearTimeout(timer);
            timer = void 0;
            lastRejector();
            lastRejector = noop$1;
          }
        };
        const filter = (_invoke) => {
          const duration = resolveUnref(ms);
          const elapsed = Date.now() - lastExec;
          const invoke = () => {
            return lastValue = _invoke();
          };
          clear2();
          if (duration <= 0) {
            lastExec = Date.now();
            return invoke();
          }
          if (elapsed > duration && (leading || !isLeading)) {
            lastExec = Date.now();
            invoke();
          } else if (trailing) {
            lastValue = new Promise((resolve2, reject) => {
              lastRejector = rejectOnCancel ? reject : resolve2;
              timer = setTimeout(() => {
                lastExec = Date.now();
                isLeading = true;
                resolve2(invoke());
                clear2();
              }, Math.max(0, duration - elapsed));
            });
          }
          if (!leading && !timer)
            timer = setTimeout(() => isLeading = true, duration);
          isLeading = false;
          return lastValue;
        };
        return filter;
      }
      function identity$1(arg) {
        return arg;
      }
      function tryOnScopeDispose$1(fn2) {
        if (getCurrentScope()) {
          onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      function useDebounceFn(fn2, ms = 200, options = {}) {
        return createFilterWrapper(debounceFilter(ms, options), fn2);
      }
      function refDebounced(value, ms = 200, options = {}) {
        const debounced = ref(value.value);
        const updater = useDebounceFn(() => {
          debounced.value = value.value;
        }, ms, options);
        watch(value, () => updater());
        return debounced;
      }
      function useThrottleFn(fn2, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {
        return createFilterWrapper(throttleFilter(ms, trailing, leading, rejectOnCancel), fn2);
      }
      function tryOnMounted$1(fn2, sync = true) {
        if (getCurrentInstance())
          onMounted(fn2);
        else if (sync)
          fn2();
        else
          nextTick(fn2);
      }
      function useTimeoutFn$1(cb, interval, options = {}) {
        const {
          immediate = true
        } = options;
        const isPending = ref(false);
        let timer = null;
        function clear2() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function stop() {
          isPending.value = false;
          clear2();
        }
        function start(...args) {
          clear2();
          isPending.value = true;
          timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            cb(...args);
          }, resolveUnref(interval));
        }
        if (immediate) {
          isPending.value = true;
          if (isClient$1)
            start();
        }
        tryOnScopeDispose$1(stop);
        return {
          isPending: readonly(isPending),
          start,
          stop
        };
      }
      function unrefElement$1(elRef) {
        var _a2;
        const plain = resolveUnref(elRef);
        return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
      }
      const defaultWindow$1 = isClient$1 ? window : void 0;
      const defaultDocument = isClient$1 ? window.document : void 0;
      function useEventListener$1(...args) {
        let target;
        let events;
        let listeners;
        let options;
        if (isString(args[0]) || Array.isArray(args[0])) {
          [events, listeners, options] = args;
          target = defaultWindow$1;
        } else {
          [target, events, listeners, options] = args;
        }
        if (!target)
          return noop$1;
        if (!Array.isArray(events))
          events = [events];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = watch(() => [unrefElement$1(target), resolveUnref(options)], ([el, options2]) => {
          cleanup();
          if (!el)
            return;
          cleanups.push(...events.flatMap((event) => {
            return listeners.map((listener) => register(el, event, listener, options2));
          }));
        }, { immediate: true, flush: "post" });
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose$1(stop);
        return stop;
      }
      let _iOSWorkaround = false;
      function onClickOutside(target, handler, options = {}) {
        const { window: window2 = defaultWindow$1, ignore = [], capture = true, detectIframe = false } = options;
        if (!window2)
          return;
        if (isIOS && !_iOSWorkaround) {
          _iOSWorkaround = true;
          Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop$1));
        }
        let shouldListen = true;
        const shouldIgnore = (event) => {
          return ignore.some((target2) => {
            if (typeof target2 === "string") {
              return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
            } else {
              const el = unrefElement$1(target2);
              return el && (event.target === el || event.composedPath().includes(el));
            }
          });
        };
        const listener = (event) => {
          const el = unrefElement$1(target);
          if (!el || el === event.target || event.composedPath().includes(el))
            return;
          if (event.detail === 0)
            shouldListen = !shouldIgnore(event);
          if (!shouldListen) {
            shouldListen = true;
            return;
          }
          handler(event);
        };
        const cleanup = [
          useEventListener$1(window2, "click", listener, { passive: true, capture }),
          useEventListener$1(window2, "pointerdown", (e2) => {
            const el = unrefElement$1(target);
            if (el)
              shouldListen = !e2.composedPath().includes(el) && !shouldIgnore(e2);
          }, { passive: true }),
          detectIframe && useEventListener$1(window2, "blur", (event) => {
            var _a2;
            const el = unrefElement$1(target);
            if (((_a2 = window2.document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
              handler(event);
          })
        ].filter(Boolean);
        const stop = () => cleanup.forEach((fn2) => fn2());
        return stop;
      }
      function useSupported$1(callback, sync = false) {
        const isSupported = ref();
        const update = () => isSupported.value = Boolean(callback());
        update();
        tryOnMounted$1(update, sync);
        return isSupported;
      }
      const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      const globalKey = "__vueuse_ssr_handlers__";
      _global[globalKey] = _global[globalKey] || {};
      function useDocumentVisibility({ document: document2 = defaultDocument } = {}) {
        if (!document2)
          return ref("visible");
        const visibility = ref(document2.visibilityState);
        useEventListener$1(document2, "visibilitychange", () => {
          visibility.value = document2.visibilityState;
        });
        return visibility;
      }
      var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
      var __hasOwnProp$g = Object.prototype.hasOwnProperty;
      var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
      var __objRest$2 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$g)
          for (var prop of __getOwnPropSymbols$g(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useResizeObserver(target, callback, options = {}) {
        const _a2 = options, { window: window2 = defaultWindow$1 } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
        let observer;
        const isSupported = useSupported$1(() => window2 && "ResizeObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = watch(() => unrefElement$1(target), (el) => {
          cleanup();
          if (isSupported.value && window2 && el) {
            observer = new ResizeObserver(callback);
            observer.observe(el, observerOptions);
          }
        }, { immediate: true, flush: "post" });
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose$1(stop);
        return {
          isSupported,
          stop
        };
      }
      var SwipeDirection;
      (function(SwipeDirection2) {
        SwipeDirection2["UP"] = "UP";
        SwipeDirection2["RIGHT"] = "RIGHT";
        SwipeDirection2["DOWN"] = "DOWN";
        SwipeDirection2["LEFT"] = "LEFT";
        SwipeDirection2["NONE"] = "NONE";
      })(SwipeDirection || (SwipeDirection = {}));
      var __defProp2 = Object.defineProperty;
      var __getOwnPropSymbols = Object.getOwnPropertySymbols;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __propIsEnum = Object.prototype.propertyIsEnumerable;
      var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues = (a2, b2) => {
        for (var prop in b2 || (b2 = {}))
          if (__hasOwnProp.call(b2, prop))
            __defNormalProp2(a2, prop, b2[prop]);
        if (__getOwnPropSymbols)
          for (var prop of __getOwnPropSymbols(b2)) {
            if (__propIsEnum.call(b2, prop))
              __defNormalProp2(a2, prop, b2[prop]);
          }
        return a2;
      };
      const _TransitionPresets = {
        easeInSine: [0.12, 0, 0.39, 0],
        easeOutSine: [0.61, 1, 0.88, 1],
        easeInOutSine: [0.37, 0, 0.63, 1],
        easeInQuad: [0.11, 0, 0.5, 0],
        easeOutQuad: [0.5, 1, 0.89, 1],
        easeInOutQuad: [0.45, 0, 0.55, 1],
        easeInCubic: [0.32, 0, 0.67, 0],
        easeOutCubic: [0.33, 1, 0.68, 1],
        easeInOutCubic: [0.65, 0, 0.35, 1],
        easeInQuart: [0.5, 0, 0.75, 0],
        easeOutQuart: [0.25, 1, 0.5, 1],
        easeInOutQuart: [0.76, 0, 0.24, 1],
        easeInQuint: [0.64, 0, 0.78, 0],
        easeOutQuint: [0.22, 1, 0.36, 1],
        easeInOutQuint: [0.83, 0, 0.17, 1],
        easeInExpo: [0.7, 0, 0.84, 0],
        easeOutExpo: [0.16, 1, 0.3, 1],
        easeInOutExpo: [0.87, 0, 0.13, 1],
        easeInCirc: [0.55, 0, 1, 0.45],
        easeOutCirc: [0, 0.55, 0.45, 1],
        easeInOutCirc: [0.85, 0, 0.15, 1],
        easeInBack: [0.36, 0, 0.66, -0.56],
        easeOutBack: [0.34, 1.56, 0.64, 1],
        easeInOutBack: [0.68, -0.6, 0.32, 1.6]
      };
      __spreadValues({
        linear: identity$1
      }, _TransitionPresets);
      function useWindowFocus({ window: window2 = defaultWindow$1 } = {}) {
        if (!window2)
          return ref(false);
        const focused = ref(window2.document.hasFocus());
        useEventListener$1(window2, "blur", () => {
          focused.value = false;
        });
        useEventListener$1(window2, "focus", () => {
          focused.value = true;
        });
        return focused;
      }
      const isFirefox = () => isClient$1 && /firefox/i.test(window.navigator.userAgent);
      const isInContainer = (el, container) => {
        if (!isClient$1 || !el || !container)
          return false;
        const elRect = el.getBoundingClientRect();
        let containerRect;
        if (container instanceof Element) {
          containerRect = container.getBoundingClientRect();
        } else {
          containerRect = {
            top: 0,
            right: window.innerWidth,
            bottom: window.innerHeight,
            left: 0
          };
        }
        return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;
      };
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      const freeGlobal$1 = freeGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal$1 || freeSelf || Function("return this")();
      const root$1 = root;
      var Symbol$1 = root$1.Symbol;
      const Symbol$2 = Symbol$1;
      var objectProto$e = Object.prototype;
      var hasOwnProperty$b = objectProto$e.hasOwnProperty;
      var nativeObjectToString$1 = objectProto$e.toString;
      var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e2) {
        }
        var result = nativeObjectToString$1.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result;
      }
      var objectProto$d = Object.prototype;
      var nativeObjectToString = objectProto$d.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var symbolTag$3 = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
      }
      function arrayMap(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array2[index], index, array2);
        }
        return result;
      }
      var isArray = Array.isArray;
      const isArray$1 = isArray;
      var INFINITY$1 = 1 / 0;
      var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray$1(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
      }
      var reWhitespace = /\s/;
      function trimmedEndIndex(string2) {
        var index = string2.length;
        while (index-- && reWhitespace.test(string2.charAt(index))) {
        }
        return index;
      }
      var reTrimStart = /^\s+/;
      function baseTrim(string2) {
        return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
      }
      function isObject(value) {
        var type2 = typeof value;
        return value != null && (type2 == "object" || type2 == "function");
      }
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function identity(value) {
        return value;
      }
      var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
      }
      var coreJsData = root$1["__core-js_shared__"];
      const coreJsData$1 = coreJsData;
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var funcProto$1 = Function.prototype;
      var funcToString$1 = funcProto$1.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString$1.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype, objectProto$c = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty$a = objectProto$c.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern2 = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern2.test(toSource(value));
      }
      function getValue$1(object2, key) {
        return object2 == null ? void 0 : object2[key];
      }
      function getNative(object2, key) {
        var value = getValue$1(object2, key);
        return baseIsNative(value) ? value : void 0;
      }
      var WeakMap$1 = getNative(root$1, "WeakMap");
      const WeakMap$2 = WeakMap$1;
      var objectCreate = Object.create;
      var baseCreate = function() {
        function object2() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object2.prototype = proto;
          var result = new object2();
          object2.prototype = void 0;
          return result;
        };
      }();
      const baseCreate$1 = baseCreate;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function copyArray(source, array2) {
        var index = -1, length = source.length;
        array2 || (array2 = Array(length));
        while (++index < length) {
          array2[index] = source[index];
        }
        return array2;
      }
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      const defineProperty$1 = defineProperty;
      var baseSetToString = !defineProperty$1 ? identity : function(func, string2) {
        return defineProperty$1(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string2),
          "writable": true
        });
      };
      const baseSetToString$1 = baseSetToString;
      var setToString = shortOut(baseSetToString$1);
      const setToString$1 = setToString;
      function arrayEach(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (iteratee(array2[index], index, array2) === false) {
            break;
          }
        }
        return array2;
      }
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type2 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER$1 : length;
        return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function baseAssignValue(object2, key, value) {
        if (key == "__proto__" && defineProperty$1) {
          defineProperty$1(object2, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object2[key] = value;
        }
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var objectProto$b = Object.prototype;
      var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
      function assignValue(object2, key, value) {
        var objValue = object2[key];
        if (!(hasOwnProperty$9.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
          baseAssignValue(object2, key, value);
        }
      }
      function copyObject(source, props, object2, customizer) {
        var isNew = !object2;
        object2 || (object2 = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object2, key, newValue);
          } else {
            assignValue(object2, key, newValue);
          }
        }
        return object2;
      }
      var nativeMax$1 = Math.max;
      function overRest(func, start, transform) {
        start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array2 = Array(length);
          while (++index < length) {
            array2[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array2);
          return apply(func, this, otherArgs);
        };
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      var objectProto$a = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
        return value === proto;
      }
      function baseTimes(n2, iteratee) {
        var index = -1, result = Array(n2);
        while (++index < n2) {
          result[index] = iteratee(index);
        }
        return result;
      }
      var argsTag$3 = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag$3;
      }
      var objectProto$9 = Object.prototype;
      var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
      var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
      };
      const isArguments$1 = isArguments;
      function stubFalse() {
        return false;
      }
      var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
      var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;
      var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      const isBuffer$1 = isBuffer;
      var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
      var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
      typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var freeProcess = moduleExports$1 && freeGlobal$1.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      const nodeUtil$1 = nodeUtil;
      var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      const isTypedArray$1 = isTypedArray;
      var objectProto$8 = Object.prototype;
      var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var nativeKeys = overArg(Object.keys, Object);
      const nativeKeys$1 = nativeKeys;
      var objectProto$7 = Object.prototype;
      var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
      function baseKeys(object2) {
        if (!isPrototype(object2)) {
          return nativeKeys$1(object2);
        }
        var result = [];
        for (var key in Object(object2)) {
          if (hasOwnProperty$6.call(object2, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function keys(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
      }
      function nativeKeysIn(object2) {
        var result = [];
        if (object2 != null) {
          for (var key in Object(object2)) {
            result.push(key);
          }
        }
        return result;
      }
      var objectProto$6 = Object.prototype;
      var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
      function baseKeysIn(object2) {
        if (!isObject(object2)) {
          return nativeKeysIn(object2);
        }
        var isProto = isPrototype(object2), result = [];
        for (var key in object2) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty$5.call(object2, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function keysIn(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
      }
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
      function isKey(value, object2) {
        if (isArray$1(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
      }
      var nativeCreate = getNative(Object, "create");
      const nativeCreate$1 = nativeCreate;
      function hashClear() {
        this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
      var objectProto$5 = Object.prototype;
      var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate$1) {
          var result = data[key];
          return result === HASH_UNDEFINED$2 ? void 0 : result;
        }
        return hasOwnProperty$4.call(data, key) ? data[key] : void 0;
      }
      var objectProto$4 = Object.prototype;
      var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$3.call(data, key);
      }
      var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
        return this;
      }
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function assocIndexOf(array2, key) {
        var length = array2.length;
        while (length--) {
          if (eq(array2[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      var Map$1 = getNative(root$1, "Map");
      const Map$2 = Map$1;
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map$2 || ListCache)(),
          "string": new Hash()
        };
      }
      function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      var FUNC_ERROR_TEXT$2 = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$2);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache2.set(key, result) || cache2;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result.cache;
        return result;
      }
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string2) {
        var result = [];
        if (string2.charCodeAt(0) === 46) {
          result.push("");
        }
        string2.replace(rePropName, function(match, number2, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
        });
        return result;
      });
      const stringToPath$1 = stringToPath;
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      function castPath(value, object2) {
        if (isArray$1(value)) {
          return value;
        }
        return isKey(value, object2) ? [value] : stringToPath$1(toString(value));
      }
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function baseGet(object2, path) {
        path = castPath(path, object2);
        var index = 0, length = path.length;
        while (object2 != null && index < length) {
          object2 = object2[toKey(path[index++])];
        }
        return index && index == length ? object2 : void 0;
      }
      function get(object2, path, defaultValue) {
        var result = object2 == null ? void 0 : baseGet(object2, path);
        return result === void 0 ? defaultValue : result;
      }
      function arrayPush(array2, values) {
        var index = -1, length = values.length, offset = array2.length;
        while (++index < length) {
          array2[offset + index] = values[index];
        }
        return array2;
      }
      var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray$1(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function baseFlatten(array2, depth, predicate, isStrict, result) {
        var index = -1, length = array2.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array2[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      function flatten(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseFlatten(array2, 1) : [];
      }
      function flatRest(func) {
        return setToString$1(overRest(func, void 0, flatten), func + "");
      }
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      const getPrototype$1 = getPrototype;
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray$1(value) ? value : [value];
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function baseAssign(object2, source) {
        return object2 && copyObject(source, keys(source), object2);
      }
      function baseAssignIn(object2, source) {
        return object2 && copyObject(source, keysIn(source), object2);
      }
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      function arrayFilter(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (predicate(value, index, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function stubArray() {
        return [];
      }
      var objectProto$3 = Object.prototype;
      var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
      var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object2) {
        if (object2 == null) {
          return [];
        }
        object2 = Object(object2);
        return arrayFilter(nativeGetSymbols$1(object2), function(symbol) {
          return propertyIsEnumerable.call(object2, symbol);
        });
      };
      const getSymbols$1 = getSymbols;
      function copySymbols(source, object2) {
        return copyObject(source, getSymbols$1(source), object2);
      }
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
        var result = [];
        while (object2) {
          arrayPush(result, getSymbols$1(object2));
          object2 = getPrototype$1(object2);
        }
        return result;
      };
      const getSymbolsIn$1 = getSymbolsIn;
      function copySymbolsIn(source, object2) {
        return copyObject(source, getSymbolsIn$1(source), object2);
      }
      function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
        var result = keysFunc(object2);
        return isArray$1(object2) ? result : arrayPush(result, symbolsFunc(object2));
      }
      function getAllKeys(object2) {
        return baseGetAllKeys(object2, keys, getSymbols$1);
      }
      function getAllKeysIn(object2) {
        return baseGetAllKeys(object2, keysIn, getSymbolsIn$1);
      }
      var DataView = getNative(root$1, "DataView");
      const DataView$1 = DataView;
      var Promise$1 = getNative(root$1, "Promise");
      const Promise$2 = Promise$1;
      var Set$1 = getNative(root$1, "Set");
      const Set$2 = Set$1;
      var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
      var dataViewTag$3 = "[object DataView]";
      var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
      var getTag = baseGetTag;
      if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$2 && getTag(new Map$2()) != mapTag$4 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$4 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag$3;
              case mapCtorString:
                return mapTag$4;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag$4;
              case weakMapCtorString:
                return weakMapTag$1;
            }
          }
          return result;
        };
      }
      const getTag$1 = getTag;
      var objectProto$2 = Object.prototype;
      var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
      function initCloneArray(array2) {
        var length = array2.length, result = new array2.constructor(length);
        if (length && typeof array2[0] == "string" && hasOwnProperty$2.call(array2, "index")) {
          result.index = array2.index;
          result.input = array2.input;
        }
        return result;
      }
      var Uint8Array2 = root$1.Uint8Array;
      const Uint8Array$1 = Uint8Array2;
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
        return result;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      var reFlags = /\w*$/;
      function cloneRegExp(regexp2) {
        var result = new regexp2.constructor(regexp2.source, reFlags.exec(regexp2));
        result.lastIndex = regexp2.lastIndex;
        return result;
      }
      var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
      var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
      function initCloneByTag(object2, tag, isDeep) {
        var Ctor = object2.constructor;
        switch (tag) {
          case arrayBufferTag$2:
            return cloneArrayBuffer(object2);
          case boolTag$2:
          case dateTag$2:
            return new Ctor(+object2);
          case dataViewTag$2:
            return cloneDataView(object2, isDeep);
          case float32Tag$1:
          case float64Tag$1:
          case int8Tag$1:
          case int16Tag$1:
          case int32Tag$1:
          case uint8Tag$1:
          case uint8ClampedTag$1:
          case uint16Tag$1:
          case uint32Tag$1:
            return cloneTypedArray(object2, isDeep);
          case mapTag$3:
            return new Ctor();
          case numberTag$2:
          case stringTag$2:
            return new Ctor(object2);
          case regexpTag$2:
            return cloneRegExp(object2);
          case setTag$3:
            return new Ctor();
          case symbolTag$2:
            return cloneSymbol(object2);
        }
      }
      function initCloneObject(object2) {
        return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate$1(getPrototype$1(object2)) : {};
      }
      var mapTag$2 = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag$1(value) == mapTag$2;
      }
      var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      const isMap$1 = isMap;
      var setTag$2 = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag$1(value) == setTag$2;
      }
      var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      const isSet$1 = isSet;
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
      var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
      var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object2, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
        if (customizer) {
          result = object2 ? customizer(value, key, object2, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray$1(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer$1(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object2) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object2 ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet$1(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap$1(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? void 0 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result;
      }
      var CLONE_SYMBOLS_FLAG = 4;
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function arraySome(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (predicate(array2[index], index, array2)) {
            return true;
          }
        }
        return false;
      }
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
      function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array2);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array2;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
        stack.set(array2, other);
        stack.set(other, array2);
        while (++index < arrLength) {
          var arrValue = array2[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array2);
        stack["delete"](other);
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
      var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
      var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
              return false;
            }
            object2 = object2.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object2), new Uint8Array$1(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object2, +other);
          case errorTag:
            return object2.name == other.name && object2.message == other.message;
          case regexpTag:
          case stringTag:
            return object2 == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
            convert || (convert = setToArray);
            if (object2.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object2);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object2, other);
            var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object2);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object2) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      var COMPARE_PARTIAL_FLAG$1 = 1;
      var objectProto$1 = Object.prototype;
      var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
      function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object2);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object2;
        }
        var result = true;
        stack.set(object2, other);
        stack.set(other, object2);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object2[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object2.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object2);
        stack["delete"](other);
        return result;
      }
      var COMPARE_PARTIAL_FLAG = 1;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray$1(object2), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object2), othTag = othIsArr ? arrayTag : getTag$1(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer$1(object2)) {
          if (!isBuffer$1(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray$1(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseHasIn(object2, key) {
        return object2 != null && key in Object(object2);
      }
      function hasPath(object2, path, hasFunc) {
        path = castPath(path, object2);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object2 != null && hasFunc(object2, key))) {
            break;
          }
          object2 = object2[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object2 == null ? 0 : object2.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object2) || isArguments$1(object2));
      }
      function hasIn(object2, path) {
        return object2 != null && hasPath(object2, path, baseHasIn);
      }
      var now = function() {
        return root$1.Date.now();
      };
      const now$1 = now;
      var FUNC_ERROR_TEXT$1 = "Expected a function";
      var nativeMax = Math.max, nativeMin = Math.min;
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$1);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now$1();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now$1());
        }
        function debounced() {
          var time = now$1(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
        while (++index < length) {
          var pair = pairs[index];
          result[pair[0]] = pair[1];
        }
        return result;
      }
      function isEqual$1(value, other) {
        return baseIsEqual(value, other);
      }
      function isNil(value) {
        return value == null;
      }
      function isUndefined$1(value) {
        return value === void 0;
      }
      function baseSet(object2, path, value, customizer) {
        if (!isObject(object2)) {
          return object2;
        }
        path = castPath(path, object2);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object2;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object2;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object2;
      }
      function basePickBy(object2, paths, predicate) {
        var index = -1, length = paths.length, result = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object2, path);
          if (predicate(value, path)) {
            baseSet(result, castPath(path, object2), value);
          }
        }
        return result;
      }
      function basePick(object2, paths) {
        return basePickBy(object2, paths, function(value, path) {
          return hasIn(object2, path);
        });
      }
      var pick = flatRest(function(object2, paths) {
        return object2 == null ? {} : basePick(object2, paths);
      });
      const pick$1 = pick;
      function set(object2, path, value) {
        return object2 == null ? object2 : baseSet(object2, path, value);
      }
      var FUNC_ERROR_TEXT = "Expected a function";
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      const isUndefined = (val) => val === void 0;
      const isBoolean = (val) => typeof val === "boolean";
      const isNumber = (val) => typeof val === "number";
      const isElement = (e2) => {
        if (typeof Element === "undefined")
          return false;
        return e2 instanceof Element;
      };
      const isStringNumber = (val) => {
        if (!isString$1(val)) {
          return false;
        }
        return !Number.isNaN(Number(val));
      };
      const escapeStringRegexp = (string2 = "") => string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      const capitalize = (str) => capitalize$1(str);
      const keysOf = (arr) => Object.keys(arr);
      const getProp = (obj, path, defaultValue) => {
        return {
          get value() {
            return get(obj, path, defaultValue);
          },
          set value(val) {
            set(obj, path, val);
          }
        };
      };
      class ElementPlusError extends Error {
        constructor(m2) {
          super(m2);
          this.name = "ElementPlusError";
        }
      }
      function throwError(scope, m2) {
        throw new ElementPlusError(`[${scope}] ${m2}`);
      }
      function debugWarn(scope, message2) {
      }
      const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
      const hasClass = (el, cls) => {
        if (!el || !cls)
          return false;
        if (cls.includes(" "))
          throw new Error("className should not contain space.");
        return el.classList.contains(cls);
      };
      const addClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.add(...classNameToArray(cls));
      };
      const removeClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.remove(...classNameToArray(cls));
      };
      const getStyle = (element, styleName) => {
        var _a2;
        if (!isClient$1 || !element || !styleName)
          return "";
        let key = camelize(styleName);
        if (key === "float")
          key = "cssFloat";
        try {
          const style = element.style[key];
          if (style)
            return style;
          const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
          return computed2 ? computed2[key] : "";
        } catch (e2) {
          return element.style[key];
        }
      };
      function addUnit(value, defaultUnit = "px") {
        if (!value)
          return "";
        if (isNumber(value) || isStringNumber(value)) {
          return `${value}${defaultUnit}`;
        } else if (isString$1(value)) {
          return value;
        }
      }
      const isScroll = (el, isVertical) => {
        if (!isClient$1)
          return false;
        const key = {
          undefined: "overflow",
          true: "overflow-y",
          false: "overflow-x"
        }[String(isVertical)];
        const overflow = getStyle(el, key);
        return ["scroll", "auto", "overlay"].some((s2) => overflow.includes(s2));
      };
      const getScrollContainer = (el, isVertical) => {
        if (!isClient$1)
          return;
        let parent = el;
        while (parent) {
          if ([window, document, document.documentElement].includes(parent))
            return window;
          if (isScroll(parent, isVertical))
            return parent;
          parent = parent.parentNode;
        }
        return parent;
      };
      let scrollBarWidth;
      const getScrollBarWidth = (namespace) => {
        var _a2;
        if (!isClient$1)
          return 0;
        if (scrollBarWidth !== void 0)
          return scrollBarWidth;
        const outer = document.createElement("div");
        outer.className = `${namespace}-scrollbar__wrap`;
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        outer.style.position = "absolute";
        outer.style.top = "-9999px";
        document.body.appendChild(outer);
        const widthNoScroll = outer.offsetWidth;
        outer.style.overflow = "scroll";
        const inner = document.createElement("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        const widthWithScroll = inner.offsetWidth;
        (_a2 = outer.parentNode) == null ? void 0 : _a2.removeChild(outer);
        scrollBarWidth = widthNoScroll - widthWithScroll;
        return scrollBarWidth;
      };
      function scrollIntoView(container, selected) {
        if (!isClient$1)
          return;
        if (!selected) {
          container.scrollTop = 0;
          return;
        }
        const offsetParents = [];
        let pointer = selected.offsetParent;
        while (pointer !== null && container !== pointer && container.contains(pointer)) {
          offsetParents.push(pointer);
          pointer = pointer.offsetParent;
        }
        const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
        const bottom = top + selected.offsetHeight;
        const viewRectTop = container.scrollTop;
        const viewRectBottom = viewRectTop + container.clientHeight;
        if (top < viewRectTop) {
          container.scrollTop = top;
        } else if (bottom > viewRectBottom) {
          container.scrollTop = bottom - container.clientHeight;
        }
      }
      /*! Element Plus Icons Vue v2.1.0 */
      var export_helper_default = (sfc, props) => {
        let target = sfc.__vccOpts || sfc;
        for (let [key, val] of props)
          target[key] = val;
        return target;
      };
      var arrow_down_vue_vue_type_script_lang_default = {
        name: "ArrowDown"
      };
      var _hoisted_16$2 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_26$1 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_36 = [
        _hoisted_26$1
      ];
      function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_16$2, _hoisted_36);
      }
      var arrow_down_default = /* @__PURE__ */ export_helper_default(arrow_down_vue_vue_type_script_lang_default, [["render", _sfc_render6], ["__file", "arrow-down.vue"]]);
      var arrow_left_vue_vue_type_script_lang_default = {
        name: "ArrowLeft"
      };
      var _hoisted_18$2 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_28$1 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_38 = [
        _hoisted_28$1
      ];
      function _sfc_render8(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_18$2, _hoisted_38);
      }
      var arrow_left_default = /* @__PURE__ */ export_helper_default(arrow_left_vue_vue_type_script_lang_default, [["render", _sfc_render8], ["__file", "arrow-left.vue"]]);
      var arrow_right_vue_vue_type_script_lang_default = {
        name: "ArrowRight"
      };
      var _hoisted_110 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_210 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_310 = [
        _hoisted_210
      ];
      function _sfc_render10(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_110, _hoisted_310);
      }
      var arrow_right_default = /* @__PURE__ */ export_helper_default(arrow_right_vue_vue_type_script_lang_default, [["render", _sfc_render10], ["__file", "arrow-right.vue"]]);
      var arrow_up_vue_vue_type_script_lang_default = {
        name: "ArrowUp"
      };
      var _hoisted_112 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_212 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_312 = [
        _hoisted_212
      ];
      function _sfc_render12(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_112, _hoisted_312);
      }
      var arrow_up_default = /* @__PURE__ */ export_helper_default(arrow_up_vue_vue_type_script_lang_default, [["render", _sfc_render12], ["__file", "arrow-up.vue"]]);
      var caret_right_vue_vue_type_script_lang_default = {
        name: "CaretRight"
      };
      var _hoisted_134 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_234 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M384 192v640l384-320.064z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_333 = [
        _hoisted_234
      ];
      function _sfc_render34(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_134, _hoisted_333);
      }
      var caret_right_default = /* @__PURE__ */ export_helper_default(caret_right_vue_vue_type_script_lang_default, [["render", _sfc_render34], ["__file", "caret-right.vue"]]);
      var check_vue_vue_type_script_lang_default = {
        name: "Check"
      };
      var _hoisted_143 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_243 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_342 = [
        _hoisted_243
      ];
      function _sfc_render43(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_143, _hoisted_342);
      }
      var check_default = /* @__PURE__ */ export_helper_default(check_vue_vue_type_script_lang_default, [["render", _sfc_render43], ["__file", "check.vue"]]);
      var circle_check_vue_vue_type_script_lang_default = {
        name: "CircleCheck"
      };
      var _hoisted_149 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_249 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_348 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_415 = [
        _hoisted_249,
        _hoisted_348
      ];
      function _sfc_render49(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_149, _hoisted_415);
      }
      var circle_check_default = /* @__PURE__ */ export_helper_default(circle_check_vue_vue_type_script_lang_default, [["render", _sfc_render49], ["__file", "circle-check.vue"]]);
      var circle_close_filled_vue_vue_type_script_lang_default = {
        name: "CircleCloseFilled"
      };
      var _hoisted_150 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_250 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_349 = [
        _hoisted_250
      ];
      function _sfc_render50(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_150, _hoisted_349);
      }
      var circle_close_filled_default = /* @__PURE__ */ export_helper_default(circle_close_filled_vue_vue_type_script_lang_default, [["render", _sfc_render50], ["__file", "circle-close-filled.vue"]]);
      var circle_close_vue_vue_type_script_lang_default = {
        name: "CircleClose"
      };
      var _hoisted_151 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_251 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_350 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_416 = [
        _hoisted_251,
        _hoisted_350
      ];
      function _sfc_render51(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_151, _hoisted_416);
      }
      var circle_close_default = /* @__PURE__ */ export_helper_default(circle_close_vue_vue_type_script_lang_default, [["render", _sfc_render51], ["__file", "circle-close.vue"]]);
      var close_vue_vue_type_script_lang_default = {
        name: "Close"
      };
      var _hoisted_156 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_256 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_355 = [
        _hoisted_256
      ];
      function _sfc_render56(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_156, _hoisted_355);
      }
      var close_default = /* @__PURE__ */ export_helper_default(close_vue_vue_type_script_lang_default, [["render", _sfc_render56], ["__file", "close.vue"]]);
      var full_screen_vue_vue_type_script_lang_default = {
        name: "FullScreen"
      };
      var _hoisted_1118 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2118 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64v.064zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64l-192 .192zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64v-.064z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3117 = [
        _hoisted_2118
      ];
      function _sfc_render118(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1118, _hoisted_3117);
      }
      var full_screen_default = /* @__PURE__ */ export_helper_default(full_screen_vue_vue_type_script_lang_default, [["render", _sfc_render118], ["__file", "full-screen.vue"]]);
      var hide_vue_vue_type_script_lang_default = {
        name: "Hide"
      };
      var _hoisted_1133 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2133 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3132 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_438 = [
        _hoisted_2133,
        _hoisted_3132
      ];
      function _sfc_render133(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1133, _hoisted_438);
      }
      var hide_default = /* @__PURE__ */ export_helper_default(hide_vue_vue_type_script_lang_default, [["render", _sfc_render133], ["__file", "hide.vue"]]);
      var info_filled_vue_vue_type_script_lang_default = {
        name: "InfoFilled"
      };
      var _hoisted_1143 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2143 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3142 = [
        _hoisted_2143
      ];
      function _sfc_render143(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1143, _hoisted_3142);
      }
      var info_filled_default = /* @__PURE__ */ export_helper_default(info_filled_vue_vue_type_script_lang_default, [["render", _sfc_render143], ["__file", "info-filled.vue"]]);
      var loading_vue_vue_type_script_lang_default = {
        name: "Loading"
      };
      var _hoisted_1150 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2150 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3149 = [
        _hoisted_2150
      ];
      function _sfc_render150(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1150, _hoisted_3149);
      }
      var loading_default = /* @__PURE__ */ export_helper_default(loading_vue_vue_type_script_lang_default, [["render", _sfc_render150], ["__file", "loading.vue"]]);
      var minus_vue_vue_type_script_lang_default = {
        name: "Minus"
      };
      var _hoisted_1169 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2169 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3168 = [
        _hoisted_2169
      ];
      function _sfc_render169(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1169, _hoisted_3168);
      }
      var minus_default = /* @__PURE__ */ export_helper_default(minus_vue_vue_type_script_lang_default, [["render", _sfc_render169], ["__file", "minus.vue"]]);
      var plus_vue_vue_type_script_lang_default = {
        name: "Plus"
      };
      var _hoisted_1201 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2201 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64h352z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3200 = [
        _hoisted_2201
      ];
      function _sfc_render201(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1201, _hoisted_3200);
      }
      var plus_default = /* @__PURE__ */ export_helper_default(plus_vue_vue_type_script_lang_default, [["render", _sfc_render201], ["__file", "plus.vue"]]);
      var refresh_left_vue_vue_type_script_lang_default = {
        name: "RefreshLeft"
      };
      var _hoisted_1215 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2215 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3214 = [
        _hoisted_2215
      ];
      function _sfc_render215(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1215, _hoisted_3214);
      }
      var refresh_left_default = /* @__PURE__ */ export_helper_default(refresh_left_vue_vue_type_script_lang_default, [["render", _sfc_render215], ["__file", "refresh-left.vue"]]);
      var refresh_right_vue_vue_type_script_lang_default = {
        name: "RefreshRight"
      };
      var _hoisted_1216 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2216 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3215 = [
        _hoisted_2216
      ];
      function _sfc_render216(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1216, _hoisted_3215);
      }
      var refresh_right_default = /* @__PURE__ */ export_helper_default(refresh_right_vue_vue_type_script_lang_default, [["render", _sfc_render216], ["__file", "refresh-right.vue"]]);
      var scale_to_original_vue_vue_type_script_lang_default = {
        name: "ScaleToOriginal"
      };
      var _hoisted_1222 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2222 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zM512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412zM512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3221 = [
        _hoisted_2222
      ];
      function _sfc_render222(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1222, _hoisted_3221);
      }
      var scale_to_original_default = /* @__PURE__ */ export_helper_default(scale_to_original_vue_vue_type_script_lang_default, [["render", _sfc_render222], ["__file", "scale-to-original.vue"]]);
      var success_filled_vue_vue_type_script_lang_default = {
        name: "SuccessFilled"
      };
      var _hoisted_1249 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2249 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3248 = [
        _hoisted_2249
      ];
      function _sfc_render249(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1249, _hoisted_3248);
      }
      var success_filled_default = /* @__PURE__ */ export_helper_default(success_filled_vue_vue_type_script_lang_default, [["render", _sfc_render249], ["__file", "success-filled.vue"]]);
      var view_vue_vue_type_script_lang_default = {
        name: "View"
      };
      var _hoisted_1283 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2283 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3282 = [
        _hoisted_2283
      ];
      function _sfc_render283(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1283, _hoisted_3282);
      }
      var view_default = /* @__PURE__ */ export_helper_default(view_vue_vue_type_script_lang_default, [["render", _sfc_render283], ["__file", "view.vue"]]);
      var warning_filled_vue_vue_type_script_lang_default = {
        name: "WarningFilled"
      };
      var _hoisted_1287 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2287 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3286 = [
        _hoisted_2287
      ];
      function _sfc_render287(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1287, _hoisted_3286);
      }
      var warning_filled_default = /* @__PURE__ */ export_helper_default(warning_filled_vue_vue_type_script_lang_default, [["render", _sfc_render287], ["__file", "warning-filled.vue"]]);
      var zoom_in_vue_vue_type_script_lang_default = {
        name: "ZoomIn"
      };
      var _hoisted_1292 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2292 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zm-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3291 = [
        _hoisted_2292
      ];
      function _sfc_render292(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1292, _hoisted_3291);
      }
      var zoom_in_default = /* @__PURE__ */ export_helper_default(zoom_in_vue_vue_type_script_lang_default, [["render", _sfc_render292], ["__file", "zoom-in.vue"]]);
      var zoom_out_vue_vue_type_script_lang_default = {
        name: "ZoomOut"
      };
      var _hoisted_1293 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2293 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zM352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3292 = [
        _hoisted_2293
      ];
      function _sfc_render293(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1293, _hoisted_3292);
      }
      var zoom_out_default = /* @__PURE__ */ export_helper_default(zoom_out_vue_vue_type_script_lang_default, [["render", _sfc_render293], ["__file", "zoom-out.vue"]]);
      const epPropKey = "__epPropKey";
      const definePropType = (val) => val;
      const isEpProp = (val) => isObject$1(val) && !!val[epPropKey];
      const buildProp = (prop, key) => {
        if (!isObject$1(prop) || isEpProp(prop))
          return prop;
        const { values, required: required2, default: defaultValue, type: type2, validator } = prop;
        const _validator = values || validator ? (val) => {
          let valid = false;
          let allowedValues = [];
          if (values) {
            allowedValues = Array.from(values);
            if (hasOwn(prop, "default")) {
              allowedValues.push(defaultValue);
            }
            valid || (valid = allowedValues.includes(val));
          }
          if (validator)
            valid || (valid = validator(val));
          if (!valid && allowedValues.length > 0) {
            const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
            warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
          }
          return valid;
        } : void 0;
        const epProp = {
          type: type2,
          required: !!required2,
          validator: _validator,
          [epPropKey]: true
        };
        if (hasOwn(prop, "default"))
          epProp.default = defaultValue;
        return epProp;
      };
      const buildProps = (props) => fromPairs(Object.entries(props).map(([key, option]) => [
        key,
        buildProp(option, key)
      ]));
      const iconPropType = definePropType([
        String,
        Object,
        Function
      ]);
      const CloseComponents = {
        Close: close_default
      };
      const TypeComponents = {
        Close: close_default,
        SuccessFilled: success_filled_default,
        InfoFilled: info_filled_default,
        WarningFilled: warning_filled_default,
        CircleCloseFilled: circle_close_filled_default
      };
      const TypeComponentsMap = {
        success: success_filled_default,
        warning: warning_filled_default,
        error: circle_close_filled_default,
        info: info_filled_default
      };
      const ValidateComponentsMap = {
        validating: loading_default,
        success: circle_check_default,
        error: circle_close_default
      };
      const withInstall = (main, extra) => {
        main.install = (app2) => {
          for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
            app2.component(comp.name, comp);
          }
        };
        if (extra) {
          for (const [key, comp] of Object.entries(extra)) {
            main[key] = comp;
          }
        }
        return main;
      };
      const withInstallFunction = (fn2, name) => {
        fn2.install = (app2) => {
          fn2._context = app2._context;
          app2.config.globalProperties[name] = fn2;
        };
        return fn2;
      };
      const withInstallDirective = (directive, name) => {
        directive.install = (app2) => {
          app2.directive(name, directive);
        };
        return directive;
      };
      const withNoopInstall = (component) => {
        component.install = NOOP;
        return component;
      };
      const composeRefs = (...refs) => {
        return (el) => {
          refs.forEach((ref2) => {
            if (isFunction$1(ref2)) {
              ref2(el);
            } else {
              ref2.value = el;
            }
          });
        };
      };
      const EVENT_CODE = {
        tab: "Tab",
        enter: "Enter",
        space: "Space",
        left: "ArrowLeft",
        up: "ArrowUp",
        right: "ArrowRight",
        down: "ArrowDown",
        esc: "Escape",
        delete: "Delete",
        backspace: "Backspace",
        numpadEnter: "NumpadEnter",
        pageUp: "PageUp",
        pageDown: "PageDown",
        home: "Home",
        end: "End"
      };
      const UPDATE_MODEL_EVENT = "update:modelValue";
      const CHANGE_EVENT = "change";
      const INPUT_EVENT = "input";
      const componentSizes = ["", "default", "small", "large"];
      const componentSizeMap = {
        large: 40,
        default: 32,
        small: 24
      };
      const getComponentSize = (size2) => {
        return componentSizeMap[size2 || "default"];
      };
      const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
      var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
        PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
        PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
        PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
        PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
        PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
        PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
        PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
        PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
        PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
        PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
        PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
        return PatchFlags2;
      })(PatchFlags || {});
      const flattedChildren = (children) => {
        const vNodes = isArray$2(children) ? children : [children];
        const result = [];
        vNodes.forEach((child) => {
          var _a2;
          if (isArray$2(child)) {
            result.push(...flattedChildren(child));
          } else if (isVNode(child) && isArray$2(child.children)) {
            result.push(...flattedChildren(child.children));
          } else {
            result.push(child);
            if (isVNode(child) && ((_a2 = child.component) == null ? void 0 : _a2.subTree)) {
              result.push(...flattedChildren(child.component.subTree));
            }
          }
        });
        return result;
      };
      const isKorean = (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text);
      const rAF = (fn2) => isClient$1 ? window.requestAnimationFrame(fn2) : setTimeout(fn2, 16);
      const cAF = (handle) => isClient$1 ? window.cancelAnimationFrame(handle) : clearTimeout(handle);
      const mutable = (val) => val;
      const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
      const LISTENER_PREFIX = /^on[A-Z]/;
      const useAttrs = (params = {}) => {
        const { excludeListeners = false, excludeKeys } = params;
        const allExcludeKeys = computed(() => {
          return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
        });
        const instance = getCurrentInstance();
        if (!instance) {
          return computed(() => ({}));
        }
        return computed(() => {
          var _a2;
          return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
        });
      };
      const useDeprecated = ({ from, replacement, scope, version: version2, ref: ref2, type: type2 = "API" }, condition) => {
        watch(() => unref(condition), (val) => {
        }, {
          immediate: true
        });
      };
      const useDraggable = (targetRef, dragRef, draggable) => {
        let transform = {
          offsetX: 0,
          offsetY: 0
        };
        const onMousedown = (e2) => {
          const downX = e2.clientX;
          const downY = e2.clientY;
          const { offsetX, offsetY } = transform;
          const targetRect = targetRef.value.getBoundingClientRect();
          const targetLeft = targetRect.left;
          const targetTop = targetRect.top;
          const targetWidth = targetRect.width;
          const targetHeight = targetRect.height;
          const clientWidth = document.documentElement.clientWidth;
          const clientHeight = document.documentElement.clientHeight;
          const minLeft = -targetLeft + offsetX;
          const minTop = -targetTop + offsetY;
          const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
          const maxTop = clientHeight - targetTop - targetHeight + offsetY;
          const onMousemove = (e22) => {
            const moveX = Math.min(Math.max(offsetX + e22.clientX - downX, minLeft), maxLeft);
            const moveY = Math.min(Math.max(offsetY + e22.clientY - downY, minTop), maxTop);
            transform = {
              offsetX: moveX,
              offsetY: moveY
            };
            targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
          };
          const onMouseup = () => {
            document.removeEventListener("mousemove", onMousemove);
            document.removeEventListener("mouseup", onMouseup);
          };
          document.addEventListener("mousemove", onMousemove);
          document.addEventListener("mouseup", onMouseup);
        };
        const onDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.addEventListener("mousedown", onMousedown);
          }
        };
        const offDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.removeEventListener("mousedown", onMousedown);
          }
        };
        onMounted(() => {
          watchEffect(() => {
            if (draggable.value) {
              onDraggable();
            } else {
              offDraggable();
            }
          });
        });
        onBeforeUnmount(() => {
          offDraggable();
        });
      };
      const useFocus = (el) => {
        return {
          focus: () => {
            var _a2, _b;
            (_b = (_a2 = el.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          }
        };
      };
      var English = {
        name: "en",
        el: {
          colorpicker: {
            confirm: "OK",
            clear: "Clear",
            defaultLabel: "color picker",
            description: "current color is {color}. press enter to select a new color."
          },
          datepicker: {
            now: "Now",
            today: "Today",
            cancel: "Cancel",
            clear: "Clear",
            confirm: "OK",
            dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
            monthTablePrompt: "Use the arrow keys and enter to select the month",
            yearTablePrompt: "Use the arrow keys and enter to select the year",
            selectedDate: "Selected date",
            selectDate: "Select date",
            selectTime: "Select time",
            startDate: "Start Date",
            startTime: "Start Time",
            endDate: "End Date",
            endTime: "End Time",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            year: "",
            month1: "January",
            month2: "February",
            month3: "March",
            month4: "April",
            month5: "May",
            month6: "June",
            month7: "July",
            month8: "August",
            month9: "September",
            month10: "October",
            month11: "November",
            month12: "December",
            week: "week",
            weeks: {
              sun: "Sun",
              mon: "Mon",
              tue: "Tue",
              wed: "Wed",
              thu: "Thu",
              fri: "Fri",
              sat: "Sat"
            },
            weeksFull: {
              sun: "Sunday",
              mon: "Monday",
              tue: "Tuesday",
              wed: "Wednesday",
              thu: "Thursday",
              fri: "Friday",
              sat: "Saturday"
            },
            months: {
              jan: "Jan",
              feb: "Feb",
              mar: "Mar",
              apr: "Apr",
              may: "May",
              jun: "Jun",
              jul: "Jul",
              aug: "Aug",
              sep: "Sep",
              oct: "Oct",
              nov: "Nov",
              dec: "Dec"
            }
          },
          inputNumber: {
            decrease: "decrease number",
            increase: "increase number"
          },
          select: {
            loading: "Loading",
            noMatch: "No matching data",
            noData: "No data",
            placeholder: "Select"
          },
          dropdown: {
            toggleDropdown: "Toggle Dropdown"
          },
          cascader: {
            noMatch: "No matching data",
            loading: "Loading",
            placeholder: "Select",
            noData: "No data"
          },
          pagination: {
            goto: "Go to",
            pagesize: "/page",
            total: "Total {total}",
            pageClassifier: "",
            page: "Page",
            prev: "Go to previous page",
            next: "Go to next page",
            currentPage: "page {pager}",
            prevPages: "Previous {pager} pages",
            nextPages: "Next {pager} pages",
            deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
          },
          dialog: {
            close: "Close this dialog"
          },
          drawer: {
            close: "Close this dialog"
          },
          messagebox: {
            title: "Message",
            confirm: "OK",
            cancel: "Cancel",
            error: "Illegal input",
            close: "Close this dialog"
          },
          upload: {
            deleteTip: "press delete to remove",
            delete: "Delete",
            preview: "Preview",
            continue: "Continue"
          },
          slider: {
            defaultLabel: "slider between {min} and {max}",
            defaultRangeStartLabel: "pick start value",
            defaultRangeEndLabel: "pick end value"
          },
          table: {
            emptyText: "No Data",
            confirmFilter: "Confirm",
            resetFilter: "Reset",
            clearFilter: "All",
            sumText: "Sum"
          },
          tree: {
            emptyText: "No Data"
          },
          transfer: {
            noMatch: "No matching data",
            noData: "No data",
            titles: ["List 1", "List 2"],
            filterPlaceholder: "Enter keyword",
            noCheckedFormat: "{total} items",
            hasCheckedFormat: "{checked}/{total} checked"
          },
          image: {
            error: "FAILED"
          },
          pageHeader: {
            title: "Back"
          },
          popconfirm: {
            confirmButtonText: "Yes",
            cancelButtonText: "No"
          }
        }
      };
      const buildTranslator = (locale) => (path, option) => translate(path, option, unref(locale));
      const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_2, key) => {
        var _a2;
        return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
      });
      const buildLocaleContext = (locale) => {
        const lang = computed(() => unref(locale).name);
        const localeRef = isRef(locale) ? locale : ref(locale);
        return {
          lang,
          locale: localeRef,
          t: buildTranslator(locale)
        };
      };
      const localeContextKey = Symbol("localeContextKey");
      const useLocale = (localeOverrides) => {
        const locale = localeOverrides || inject(localeContextKey, ref());
        return buildLocaleContext(computed(() => locale.value || English));
      };
      const defaultNamespace = "el";
      const statePrefix = "is-";
      const _bem = (namespace, block, blockSuffix, element, modifier) => {
        let cls = `${namespace}-${block}`;
        if (blockSuffix) {
          cls += `-${blockSuffix}`;
        }
        if (element) {
          cls += `__${element}`;
        }
        if (modifier) {
          cls += `--${modifier}`;
        }
        return cls;
      };
      const namespaceContextKey = Symbol("namespaceContextKey");
      const useGetDerivedNamespace = (namespaceOverrides) => {
        const derivedNamespace = namespaceOverrides || inject(namespaceContextKey, ref(defaultNamespace));
        const namespace = computed(() => {
          return unref(derivedNamespace) || defaultNamespace;
        });
        return namespace;
      };
      const useNamespace = (block, namespaceOverrides) => {
        const namespace = useGetDerivedNamespace(namespaceOverrides);
        const b2 = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
        const e2 = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
        const m2 = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
        const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
        const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
        const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
        const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
        const is = (name, ...args) => {
          const state = args.length >= 1 ? args[0] : true;
          return name && state ? `${statePrefix}${name}` : "";
        };
        const cssVar = (object2) => {
          const styles = {};
          for (const key in object2) {
            if (object2[key]) {
              styles[`--${namespace.value}-${key}`] = object2[key];
            }
          }
          return styles;
        };
        const cssVarBlock = (object2) => {
          const styles = {};
          for (const key in object2) {
            if (object2[key]) {
              styles[`--${namespace.value}-${block}-${key}`] = object2[key];
            }
          }
          return styles;
        };
        const cssVarName = (name) => `--${namespace.value}-${name}`;
        const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
        return {
          namespace,
          b: b2,
          e: e2,
          m: m2,
          be: be2,
          em,
          bm,
          bem,
          is,
          cssVar,
          cssVarName,
          cssVarBlock,
          cssVarBlockName
        };
      };
      const useLockscreen = (trigger2, options = {}) => {
        if (!isRef(trigger2)) {
          throwError("[useLockscreen]", "You need to pass a ref param to this function");
        }
        const ns = options.ns || useNamespace("popup");
        const hiddenCls = computed$1(() => ns.bm("parent", "hidden"));
        if (!isClient$1 || hasClass(document.body, hiddenCls.value)) {
          return;
        }
        let scrollBarWidth2 = 0;
        let withoutHiddenClass = false;
        let bodyWidth = "0";
        const cleanup = () => {
          setTimeout(() => {
            removeClass(document == null ? void 0 : document.body, hiddenCls.value);
            if (withoutHiddenClass && document) {
              document.body.style.width = bodyWidth;
            }
          }, 200);
        };
        watch(trigger2, (val) => {
          if (!val) {
            cleanup();
            return;
          }
          withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
          if (withoutHiddenClass) {
            bodyWidth = document.body.style.width;
          }
          scrollBarWidth2 = getScrollBarWidth(ns.namespace.value);
          const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          const bodyOverflowY = getStyle(document.body, "overflowY");
          if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
            document.body.style.width = `calc(100% - ${scrollBarWidth2}px)`;
          }
          addClass(document.body, hiddenCls.value);
        });
        onScopeDispose(() => cleanup());
      };
      const _prop = buildProp({
        type: definePropType(Boolean),
        default: null
      });
      const _event = buildProp({
        type: definePropType(Function)
      });
      const createModelToggleComposable = (name) => {
        const updateEventKey = `update:${name}`;
        const updateEventKeyRaw2 = `onUpdate:${name}`;
        const useModelToggleEmits2 = [updateEventKey];
        const useModelToggleProps2 = {
          [name]: _prop,
          [updateEventKeyRaw2]: _event
        };
        const useModelToggle2 = ({
          indicator,
          toggleReason,
          shouldHideWhenRouteChanges,
          shouldProceed,
          onShow,
          onHide
        }) => {
          const instance = getCurrentInstance();
          const { emit: emit2 } = instance;
          const props = instance.props;
          const hasUpdateHandler = computed(() => isFunction$1(props[updateEventKeyRaw2]));
          const isModelBindingAbsent = computed(() => props[name] === null);
          const doShow = (event) => {
            if (indicator.value === true) {
              return;
            }
            indicator.value = true;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$1(onShow)) {
              onShow(event);
            }
          };
          const doHide = (event) => {
            if (indicator.value === false) {
              return;
            }
            indicator.value = false;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$1(onHide)) {
              onHide(event);
            }
          };
          const show = (event) => {
            if (props.disabled === true || isFunction$1(shouldProceed) && !shouldProceed())
              return;
            const shouldEmit = hasUpdateHandler.value && isClient$1;
            if (shouldEmit) {
              emit2(updateEventKey, true);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doShow(event);
            }
          };
          const hide = (event) => {
            if (props.disabled === true || !isClient$1)
              return;
            const shouldEmit = hasUpdateHandler.value && isClient$1;
            if (shouldEmit) {
              emit2(updateEventKey, false);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doHide(event);
            }
          };
          const onChange = (val) => {
            if (!isBoolean(val))
              return;
            if (props.disabled && val) {
              if (hasUpdateHandler.value) {
                emit2(updateEventKey, false);
              }
            } else if (indicator.value !== val) {
              if (val) {
                doShow();
              } else {
                doHide();
              }
            }
          };
          const toggle = () => {
            if (indicator.value) {
              hide();
            } else {
              show();
            }
          };
          watch(() => props[name], onChange);
          if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
            watch(() => ({
              ...instance.proxy.$route
            }), () => {
              if (shouldHideWhenRouteChanges.value && indicator.value) {
                hide();
              }
            });
          }
          onMounted(() => {
            onChange(props[name]);
          });
          return {
            hide,
            show,
            toggle,
            hasUpdateHandler
          };
        };
        return {
          useModelToggle: useModelToggle2,
          useModelToggleProps: useModelToggleProps2,
          useModelToggleEmits: useModelToggleEmits2
        };
      };
      const useProp = (name) => {
        const vm = getCurrentInstance();
        return computed(() => {
          var _a2, _b;
          return (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$props) == null ? void 0 : _b[name];
        });
      };
      var E$1 = "top", R$1 = "bottom", W$1 = "right", P$1 = "left", me = "auto", G$1 = [E$1, R$1, W$1, P$1], U$1 = "start", J$1 = "end", Xe = "clippingParents", je = "viewport", K$1 = "popper", Ye = "reference", De = G$1.reduce(function(t2, e2) {
        return t2.concat([e2 + "-" + U$1, e2 + "-" + J$1]);
      }, []), Ee = [].concat(G$1, [me]).reduce(function(t2, e2) {
        return t2.concat([e2, e2 + "-" + U$1, e2 + "-" + J$1]);
      }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et$1 = "afterMain", tt$1 = "beforeWrite", nt$1 = "write", rt$1 = "afterWrite", ot$1 = [Ge, Je, Ke, Qe, Ze, et$1, tt$1, nt$1, rt$1];
      function C$1(t2) {
        return t2 ? (t2.nodeName || "").toLowerCase() : null;
      }
      function H$1(t2) {
        if (t2 == null)
          return window;
        if (t2.toString() !== "[object Window]") {
          var e2 = t2.ownerDocument;
          return e2 && e2.defaultView || window;
        }
        return t2;
      }
      function Q$1(t2) {
        var e2 = H$1(t2).Element;
        return t2 instanceof e2 || t2 instanceof Element;
      }
      function B$1(t2) {
        var e2 = H$1(t2).HTMLElement;
        return t2 instanceof e2 || t2 instanceof HTMLElement;
      }
      function Pe(t2) {
        if (typeof ShadowRoot == "undefined")
          return false;
        var e2 = H$1(t2).ShadowRoot;
        return t2 instanceof e2 || t2 instanceof ShadowRoot;
      }
      function Mt$1(t2) {
        var e2 = t2.state;
        Object.keys(e2.elements).forEach(function(n2) {
          var r2 = e2.styles[n2] || {}, o2 = e2.attributes[n2] || {}, i2 = e2.elements[n2];
          !B$1(i2) || !C$1(i2) || (Object.assign(i2.style, r2), Object.keys(o2).forEach(function(a2) {
            var s2 = o2[a2];
            s2 === false ? i2.removeAttribute(a2) : i2.setAttribute(a2, s2 === true ? "" : s2);
          }));
        });
      }
      function Rt$1(t2) {
        var e2 = t2.state, n2 = { popper: { position: e2.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
        return Object.assign(e2.elements.popper.style, n2.popper), e2.styles = n2, e2.elements.arrow && Object.assign(e2.elements.arrow.style, n2.arrow), function() {
          Object.keys(e2.elements).forEach(function(r2) {
            var o2 = e2.elements[r2], i2 = e2.attributes[r2] || {}, a2 = Object.keys(e2.styles.hasOwnProperty(r2) ? e2.styles[r2] : n2[r2]), s2 = a2.reduce(function(f2, c2) {
              return f2[c2] = "", f2;
            }, {});
            !B$1(o2) || !C$1(o2) || (Object.assign(o2.style, s2), Object.keys(i2).forEach(function(f2) {
              o2.removeAttribute(f2);
            }));
          });
        };
      }
      var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt$1, effect: Rt$1, requires: ["computeStyles"] };
      function q$1(t2) {
        return t2.split("-")[0];
      }
      var X$1 = Math.max, ve = Math.min, Z$1 = Math.round;
      function ee(t2, e2) {
        e2 === void 0 && (e2 = false);
        var n2 = t2.getBoundingClientRect(), r2 = 1, o2 = 1;
        if (B$1(t2) && e2) {
          var i2 = t2.offsetHeight, a2 = t2.offsetWidth;
          a2 > 0 && (r2 = Z$1(n2.width) / a2 || 1), i2 > 0 && (o2 = Z$1(n2.height) / i2 || 1);
        }
        return { width: n2.width / r2, height: n2.height / o2, top: n2.top / o2, right: n2.right / r2, bottom: n2.bottom / o2, left: n2.left / r2, x: n2.left / r2, y: n2.top / o2 };
      }
      function ke(t2) {
        var e2 = ee(t2), n2 = t2.offsetWidth, r2 = t2.offsetHeight;
        return Math.abs(e2.width - n2) <= 1 && (n2 = e2.width), Math.abs(e2.height - r2) <= 1 && (r2 = e2.height), { x: t2.offsetLeft, y: t2.offsetTop, width: n2, height: r2 };
      }
      function it$1(t2, e2) {
        var n2 = e2.getRootNode && e2.getRootNode();
        if (t2.contains(e2))
          return true;
        if (n2 && Pe(n2)) {
          var r2 = e2;
          do {
            if (r2 && t2.isSameNode(r2))
              return true;
            r2 = r2.parentNode || r2.host;
          } while (r2);
        }
        return false;
      }
      function N$1(t2) {
        return H$1(t2).getComputedStyle(t2);
      }
      function Wt(t2) {
        return ["table", "td", "th"].indexOf(C$1(t2)) >= 0;
      }
      function I$1(t2) {
        return ((Q$1(t2) ? t2.ownerDocument : t2.document) || window.document).documentElement;
      }
      function ge(t2) {
        return C$1(t2) === "html" ? t2 : t2.assignedSlot || t2.parentNode || (Pe(t2) ? t2.host : null) || I$1(t2);
      }
      function at$1(t2) {
        return !B$1(t2) || N$1(t2).position === "fixed" ? null : t2.offsetParent;
      }
      function Bt$1(t2) {
        var e2 = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n2 = navigator.userAgent.indexOf("Trident") !== -1;
        if (n2 && B$1(t2)) {
          var r2 = N$1(t2);
          if (r2.position === "fixed")
            return null;
        }
        var o2 = ge(t2);
        for (Pe(o2) && (o2 = o2.host); B$1(o2) && ["html", "body"].indexOf(C$1(o2)) < 0; ) {
          var i2 = N$1(o2);
          if (i2.transform !== "none" || i2.perspective !== "none" || i2.contain === "paint" || ["transform", "perspective"].indexOf(i2.willChange) !== -1 || e2 && i2.willChange === "filter" || e2 && i2.filter && i2.filter !== "none")
            return o2;
          o2 = o2.parentNode;
        }
        return null;
      }
      function se(t2) {
        for (var e2 = H$1(t2), n2 = at$1(t2); n2 && Wt(n2) && N$1(n2).position === "static"; )
          n2 = at$1(n2);
        return n2 && (C$1(n2) === "html" || C$1(n2) === "body" && N$1(n2).position === "static") ? e2 : n2 || Bt$1(t2) || e2;
      }
      function Le(t2) {
        return ["top", "bottom"].indexOf(t2) >= 0 ? "x" : "y";
      }
      function fe(t2, e2, n2) {
        return X$1(t2, ve(e2, n2));
      }
      function St$1(t2, e2, n2) {
        var r2 = fe(t2, e2, n2);
        return r2 > n2 ? n2 : r2;
      }
      function st$1() {
        return { top: 0, right: 0, bottom: 0, left: 0 };
      }
      function ft$1(t2) {
        return Object.assign({}, st$1(), t2);
      }
      function ct$1(t2, e2) {
        return e2.reduce(function(n2, r2) {
          return n2[r2] = t2, n2;
        }, {});
      }
      var Tt$1 = function(t2, e2) {
        return t2 = typeof t2 == "function" ? t2(Object.assign({}, e2.rects, { placement: e2.placement })) : t2, ft$1(typeof t2 != "number" ? t2 : ct$1(t2, G$1));
      };
      function Ht$1(t2) {
        var e2, n2 = t2.state, r2 = t2.name, o2 = t2.options, i2 = n2.elements.arrow, a2 = n2.modifiersData.popperOffsets, s2 = q$1(n2.placement), f2 = Le(s2), c2 = [P$1, W$1].indexOf(s2) >= 0, u2 = c2 ? "height" : "width";
        if (!(!i2 || !a2)) {
          var m2 = Tt$1(o2.padding, n2), v2 = ke(i2), l2 = f2 === "y" ? E$1 : P$1, h2 = f2 === "y" ? R$1 : W$1, p2 = n2.rects.reference[u2] + n2.rects.reference[f2] - a2[f2] - n2.rects.popper[u2], g2 = a2[f2] - n2.rects.reference[f2], x2 = se(i2), y2 = x2 ? f2 === "y" ? x2.clientHeight || 0 : x2.clientWidth || 0 : 0, $2 = p2 / 2 - g2 / 2, d2 = m2[l2], b2 = y2 - v2[u2] - m2[h2], w2 = y2 / 2 - v2[u2] / 2 + $2, O2 = fe(d2, w2, b2), j2 = f2;
          n2.modifiersData[r2] = (e2 = {}, e2[j2] = O2, e2.centerOffset = O2 - w2, e2);
        }
      }
      function Ct$1(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = n2.element, o2 = r2 === void 0 ? "[data-popper-arrow]" : r2;
        o2 != null && (typeof o2 == "string" && (o2 = e2.elements.popper.querySelector(o2), !o2) || !it$1(e2.elements.popper, o2) || (e2.elements.arrow = o2));
      }
      var pt$1 = { name: "arrow", enabled: true, phase: "main", fn: Ht$1, effect: Ct$1, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
      function te(t2) {
        return t2.split("-")[1];
      }
      var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
      function Vt(t2) {
        var e2 = t2.x, n2 = t2.y, r2 = window, o2 = r2.devicePixelRatio || 1;
        return { x: Z$1(e2 * o2) / o2 || 0, y: Z$1(n2 * o2) / o2 || 0 };
      }
      function ut$1(t2) {
        var e2, n2 = t2.popper, r2 = t2.popperRect, o2 = t2.placement, i2 = t2.variation, a2 = t2.offsets, s2 = t2.position, f2 = t2.gpuAcceleration, c2 = t2.adaptive, u2 = t2.roundOffsets, m2 = t2.isFixed, v2 = a2.x, l2 = v2 === void 0 ? 0 : v2, h2 = a2.y, p2 = h2 === void 0 ? 0 : h2, g2 = typeof u2 == "function" ? u2({ x: l2, y: p2 }) : { x: l2, y: p2 };
        l2 = g2.x, p2 = g2.y;
        var x2 = a2.hasOwnProperty("x"), y2 = a2.hasOwnProperty("y"), $2 = P$1, d2 = E$1, b2 = window;
        if (c2) {
          var w2 = se(n2), O2 = "clientHeight", j2 = "clientWidth";
          if (w2 === H$1(n2) && (w2 = I$1(n2), N$1(w2).position !== "static" && s2 === "absolute" && (O2 = "scrollHeight", j2 = "scrollWidth")), w2 = w2, o2 === E$1 || (o2 === P$1 || o2 === W$1) && i2 === J$1) {
            d2 = R$1;
            var A2 = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.height : w2[O2];
            p2 -= A2 - r2.height, p2 *= f2 ? 1 : -1;
          }
          if (o2 === P$1 || (o2 === E$1 || o2 === R$1) && i2 === J$1) {
            $2 = W$1;
            var k2 = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.width : w2[j2];
            l2 -= k2 - r2.width, l2 *= f2 ? 1 : -1;
          }
        }
        var D2 = Object.assign({ position: s2 }, c2 && qt), S2 = u2 === true ? Vt({ x: l2, y: p2 }) : { x: l2, y: p2 };
        if (l2 = S2.x, p2 = S2.y, f2) {
          var L2;
          return Object.assign({}, D2, (L2 = {}, L2[d2] = y2 ? "0" : "", L2[$2] = x2 ? "0" : "", L2.transform = (b2.devicePixelRatio || 1) <= 1 ? "translate(" + l2 + "px, " + p2 + "px)" : "translate3d(" + l2 + "px, " + p2 + "px, 0)", L2));
        }
        return Object.assign({}, D2, (e2 = {}, e2[d2] = y2 ? p2 + "px" : "", e2[$2] = x2 ? l2 + "px" : "", e2.transform = "", e2));
      }
      function Nt$1(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = n2.gpuAcceleration, o2 = r2 === void 0 ? true : r2, i2 = n2.adaptive, a2 = i2 === void 0 ? true : i2, s2 = n2.roundOffsets, f2 = s2 === void 0 ? true : s2, c2 = { placement: q$1(e2.placement), variation: te(e2.placement), popper: e2.elements.popper, popperRect: e2.rects.popper, gpuAcceleration: o2, isFixed: e2.options.strategy === "fixed" };
        e2.modifiersData.popperOffsets != null && (e2.styles.popper = Object.assign({}, e2.styles.popper, ut$1(Object.assign({}, c2, { offsets: e2.modifiersData.popperOffsets, position: e2.options.strategy, adaptive: a2, roundOffsets: f2 })))), e2.modifiersData.arrow != null && (e2.styles.arrow = Object.assign({}, e2.styles.arrow, ut$1(Object.assign({}, c2, { offsets: e2.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f2 })))), e2.attributes.popper = Object.assign({}, e2.attributes.popper, { "data-popper-placement": e2.placement });
      }
      var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt$1, data: {} }, ye = { passive: true };
      function It$1(t2) {
        var e2 = t2.state, n2 = t2.instance, r2 = t2.options, o2 = r2.scroll, i2 = o2 === void 0 ? true : o2, a2 = r2.resize, s2 = a2 === void 0 ? true : a2, f2 = H$1(e2.elements.popper), c2 = [].concat(e2.scrollParents.reference, e2.scrollParents.popper);
        return i2 && c2.forEach(function(u2) {
          u2.addEventListener("scroll", n2.update, ye);
        }), s2 && f2.addEventListener("resize", n2.update, ye), function() {
          i2 && c2.forEach(function(u2) {
            u2.removeEventListener("scroll", n2.update, ye);
          }), s2 && f2.removeEventListener("resize", n2.update, ye);
        };
      }
      var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
      }, effect: It$1, data: {} }, _t$1 = { left: "right", right: "left", bottom: "top", top: "bottom" };
      function be(t2) {
        return t2.replace(/left|right|bottom|top/g, function(e2) {
          return _t$1[e2];
        });
      }
      var zt$1 = { start: "end", end: "start" };
      function lt$1(t2) {
        return t2.replace(/start|end/g, function(e2) {
          return zt$1[e2];
        });
      }
      function We(t2) {
        var e2 = H$1(t2), n2 = e2.pageXOffset, r2 = e2.pageYOffset;
        return { scrollLeft: n2, scrollTop: r2 };
      }
      function Be(t2) {
        return ee(I$1(t2)).left + We(t2).scrollLeft;
      }
      function Ft$1(t2) {
        var e2 = H$1(t2), n2 = I$1(t2), r2 = e2.visualViewport, o2 = n2.clientWidth, i2 = n2.clientHeight, a2 = 0, s2 = 0;
        return r2 && (o2 = r2.width, i2 = r2.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a2 = r2.offsetLeft, s2 = r2.offsetTop)), { width: o2, height: i2, x: a2 + Be(t2), y: s2 };
      }
      function Ut(t2) {
        var e2, n2 = I$1(t2), r2 = We(t2), o2 = (e2 = t2.ownerDocument) == null ? void 0 : e2.body, i2 = X$1(n2.scrollWidth, n2.clientWidth, o2 ? o2.scrollWidth : 0, o2 ? o2.clientWidth : 0), a2 = X$1(n2.scrollHeight, n2.clientHeight, o2 ? o2.scrollHeight : 0, o2 ? o2.clientHeight : 0), s2 = -r2.scrollLeft + Be(t2), f2 = -r2.scrollTop;
        return N$1(o2 || n2).direction === "rtl" && (s2 += X$1(n2.clientWidth, o2 ? o2.clientWidth : 0) - i2), { width: i2, height: a2, x: s2, y: f2 };
      }
      function Se(t2) {
        var e2 = N$1(t2), n2 = e2.overflow, r2 = e2.overflowX, o2 = e2.overflowY;
        return /auto|scroll|overlay|hidden/.test(n2 + o2 + r2);
      }
      function dt$1(t2) {
        return ["html", "body", "#document"].indexOf(C$1(t2)) >= 0 ? t2.ownerDocument.body : B$1(t2) && Se(t2) ? t2 : dt$1(ge(t2));
      }
      function ce(t2, e2) {
        var n2;
        e2 === void 0 && (e2 = []);
        var r2 = dt$1(t2), o2 = r2 === ((n2 = t2.ownerDocument) == null ? void 0 : n2.body), i2 = H$1(r2), a2 = o2 ? [i2].concat(i2.visualViewport || [], Se(r2) ? r2 : []) : r2, s2 = e2.concat(a2);
        return o2 ? s2 : s2.concat(ce(ge(a2)));
      }
      function Te(t2) {
        return Object.assign({}, t2, { left: t2.x, top: t2.y, right: t2.x + t2.width, bottom: t2.y + t2.height });
      }
      function Xt(t2) {
        var e2 = ee(t2);
        return e2.top = e2.top + t2.clientTop, e2.left = e2.left + t2.clientLeft, e2.bottom = e2.top + t2.clientHeight, e2.right = e2.left + t2.clientWidth, e2.width = t2.clientWidth, e2.height = t2.clientHeight, e2.x = e2.left, e2.y = e2.top, e2;
      }
      function ht$1(t2, e2) {
        return e2 === je ? Te(Ft$1(t2)) : Q$1(e2) ? Xt(e2) : Te(Ut(I$1(t2)));
      }
      function Yt(t2) {
        var e2 = ce(ge(t2)), n2 = ["absolute", "fixed"].indexOf(N$1(t2).position) >= 0, r2 = n2 && B$1(t2) ? se(t2) : t2;
        return Q$1(r2) ? e2.filter(function(o2) {
          return Q$1(o2) && it$1(o2, r2) && C$1(o2) !== "body";
        }) : [];
      }
      function Gt(t2, e2, n2) {
        var r2 = e2 === "clippingParents" ? Yt(t2) : [].concat(e2), o2 = [].concat(r2, [n2]), i2 = o2[0], a2 = o2.reduce(function(s2, f2) {
          var c2 = ht$1(t2, f2);
          return s2.top = X$1(c2.top, s2.top), s2.right = ve(c2.right, s2.right), s2.bottom = ve(c2.bottom, s2.bottom), s2.left = X$1(c2.left, s2.left), s2;
        }, ht$1(t2, i2));
        return a2.width = a2.right - a2.left, a2.height = a2.bottom - a2.top, a2.x = a2.left, a2.y = a2.top, a2;
      }
      function mt$1(t2) {
        var e2 = t2.reference, n2 = t2.element, r2 = t2.placement, o2 = r2 ? q$1(r2) : null, i2 = r2 ? te(r2) : null, a2 = e2.x + e2.width / 2 - n2.width / 2, s2 = e2.y + e2.height / 2 - n2.height / 2, f2;
        switch (o2) {
          case E$1:
            f2 = { x: a2, y: e2.y - n2.height };
            break;
          case R$1:
            f2 = { x: a2, y: e2.y + e2.height };
            break;
          case W$1:
            f2 = { x: e2.x + e2.width, y: s2 };
            break;
          case P$1:
            f2 = { x: e2.x - n2.width, y: s2 };
            break;
          default:
            f2 = { x: e2.x, y: e2.y };
        }
        var c2 = o2 ? Le(o2) : null;
        if (c2 != null) {
          var u2 = c2 === "y" ? "height" : "width";
          switch (i2) {
            case U$1:
              f2[c2] = f2[c2] - (e2[u2] / 2 - n2[u2] / 2);
              break;
            case J$1:
              f2[c2] = f2[c2] + (e2[u2] / 2 - n2[u2] / 2);
              break;
          }
        }
        return f2;
      }
      function ne(t2, e2) {
        e2 === void 0 && (e2 = {});
        var n2 = e2, r2 = n2.placement, o2 = r2 === void 0 ? t2.placement : r2, i2 = n2.boundary, a2 = i2 === void 0 ? Xe : i2, s2 = n2.rootBoundary, f2 = s2 === void 0 ? je : s2, c2 = n2.elementContext, u2 = c2 === void 0 ? K$1 : c2, m2 = n2.altBoundary, v2 = m2 === void 0 ? false : m2, l2 = n2.padding, h2 = l2 === void 0 ? 0 : l2, p2 = ft$1(typeof h2 != "number" ? h2 : ct$1(h2, G$1)), g2 = u2 === K$1 ? Ye : K$1, x2 = t2.rects.popper, y2 = t2.elements[v2 ? g2 : u2], $2 = Gt(Q$1(y2) ? y2 : y2.contextElement || I$1(t2.elements.popper), a2, f2), d2 = ee(t2.elements.reference), b2 = mt$1({ reference: d2, element: x2, strategy: "absolute", placement: o2 }), w2 = Te(Object.assign({}, x2, b2)), O2 = u2 === K$1 ? w2 : d2, j2 = { top: $2.top - O2.top + p2.top, bottom: O2.bottom - $2.bottom + p2.bottom, left: $2.left - O2.left + p2.left, right: O2.right - $2.right + p2.right }, A2 = t2.modifiersData.offset;
        if (u2 === K$1 && A2) {
          var k2 = A2[o2];
          Object.keys(j2).forEach(function(D2) {
            var S2 = [W$1, R$1].indexOf(D2) >= 0 ? 1 : -1, L2 = [E$1, R$1].indexOf(D2) >= 0 ? "y" : "x";
            j2[D2] += k2[L2] * S2;
          });
        }
        return j2;
      }
      function Jt(t2, e2) {
        e2 === void 0 && (e2 = {});
        var n2 = e2, r2 = n2.placement, o2 = n2.boundary, i2 = n2.rootBoundary, a2 = n2.padding, s2 = n2.flipVariations, f2 = n2.allowedAutoPlacements, c2 = f2 === void 0 ? Ee : f2, u2 = te(r2), m2 = u2 ? s2 ? De : De.filter(function(h2) {
          return te(h2) === u2;
        }) : G$1, v2 = m2.filter(function(h2) {
          return c2.indexOf(h2) >= 0;
        });
        v2.length === 0 && (v2 = m2);
        var l2 = v2.reduce(function(h2, p2) {
          return h2[p2] = ne(t2, { placement: p2, boundary: o2, rootBoundary: i2, padding: a2 })[q$1(p2)], h2;
        }, {});
        return Object.keys(l2).sort(function(h2, p2) {
          return l2[h2] - l2[p2];
        });
      }
      function Kt(t2) {
        if (q$1(t2) === me)
          return [];
        var e2 = be(t2);
        return [lt$1(t2), e2, lt$1(e2)];
      }
      function Qt(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = t2.name;
        if (!e2.modifiersData[r2]._skip) {
          for (var o2 = n2.mainAxis, i2 = o2 === void 0 ? true : o2, a2 = n2.altAxis, s2 = a2 === void 0 ? true : a2, f2 = n2.fallbackPlacements, c2 = n2.padding, u2 = n2.boundary, m2 = n2.rootBoundary, v2 = n2.altBoundary, l2 = n2.flipVariations, h2 = l2 === void 0 ? true : l2, p2 = n2.allowedAutoPlacements, g2 = e2.options.placement, x2 = q$1(g2), y2 = x2 === g2, $2 = f2 || (y2 || !h2 ? [be(g2)] : Kt(g2)), d2 = [g2].concat($2).reduce(function(z2, V2) {
            return z2.concat(q$1(V2) === me ? Jt(e2, { placement: V2, boundary: u2, rootBoundary: m2, padding: c2, flipVariations: h2, allowedAutoPlacements: p2 }) : V2);
          }, []), b2 = e2.rects.reference, w2 = e2.rects.popper, O2 = /* @__PURE__ */ new Map(), j2 = true, A2 = d2[0], k2 = 0; k2 < d2.length; k2++) {
            var D2 = d2[k2], S2 = q$1(D2), L2 = te(D2) === U$1, re = [E$1, R$1].indexOf(S2) >= 0, oe = re ? "width" : "height", M2 = ne(e2, { placement: D2, boundary: u2, rootBoundary: m2, altBoundary: v2, padding: c2 }), T2 = re ? L2 ? W$1 : P$1 : L2 ? R$1 : E$1;
            b2[oe] > w2[oe] && (T2 = be(T2));
            var pe = be(T2), _2 = [];
            if (i2 && _2.push(M2[S2] <= 0), s2 && _2.push(M2[T2] <= 0, M2[pe] <= 0), _2.every(function(z2) {
              return z2;
            })) {
              A2 = D2, j2 = false;
              break;
            }
            O2.set(D2, _2);
          }
          if (j2)
            for (var ue = h2 ? 3 : 1, xe = function(z2) {
              var V2 = d2.find(function(de) {
                var ae = O2.get(de);
                if (ae)
                  return ae.slice(0, z2).every(function(Y2) {
                    return Y2;
                  });
              });
              if (V2)
                return A2 = V2, "break";
            }, ie = ue; ie > 0; ie--) {
              var le = xe(ie);
              if (le === "break")
                break;
            }
          e2.placement !== A2 && (e2.modifiersData[r2]._skip = true, e2.placement = A2, e2.reset = true);
        }
      }
      var vt$1 = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
      function gt$1(t2, e2, n2) {
        return n2 === void 0 && (n2 = { x: 0, y: 0 }), { top: t2.top - e2.height - n2.y, right: t2.right - e2.width + n2.x, bottom: t2.bottom - e2.height + n2.y, left: t2.left - e2.width - n2.x };
      }
      function yt$1(t2) {
        return [E$1, W$1, R$1, P$1].some(function(e2) {
          return t2[e2] >= 0;
        });
      }
      function Zt(t2) {
        var e2 = t2.state, n2 = t2.name, r2 = e2.rects.reference, o2 = e2.rects.popper, i2 = e2.modifiersData.preventOverflow, a2 = ne(e2, { elementContext: "reference" }), s2 = ne(e2, { altBoundary: true }), f2 = gt$1(a2, r2), c2 = gt$1(s2, o2, i2), u2 = yt$1(f2), m2 = yt$1(c2);
        e2.modifiersData[n2] = { referenceClippingOffsets: f2, popperEscapeOffsets: c2, isReferenceHidden: u2, hasPopperEscaped: m2 }, e2.attributes.popper = Object.assign({}, e2.attributes.popper, { "data-popper-reference-hidden": u2, "data-popper-escaped": m2 });
      }
      var bt$1 = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
      function en(t2, e2, n2) {
        var r2 = q$1(t2), o2 = [P$1, E$1].indexOf(r2) >= 0 ? -1 : 1, i2 = typeof n2 == "function" ? n2(Object.assign({}, e2, { placement: t2 })) : n2, a2 = i2[0], s2 = i2[1];
        return a2 = a2 || 0, s2 = (s2 || 0) * o2, [P$1, W$1].indexOf(r2) >= 0 ? { x: s2, y: a2 } : { x: a2, y: s2 };
      }
      function tn(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = t2.name, o2 = n2.offset, i2 = o2 === void 0 ? [0, 0] : o2, a2 = Ee.reduce(function(u2, m2) {
          return u2[m2] = en(m2, e2.rects, i2), u2;
        }, {}), s2 = a2[e2.placement], f2 = s2.x, c2 = s2.y;
        e2.modifiersData.popperOffsets != null && (e2.modifiersData.popperOffsets.x += f2, e2.modifiersData.popperOffsets.y += c2), e2.modifiersData[r2] = a2;
      }
      var wt$1 = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
      function nn(t2) {
        var e2 = t2.state, n2 = t2.name;
        e2.modifiersData[n2] = mt$1({ reference: e2.rects.reference, element: e2.rects.popper, strategy: "absolute", placement: e2.placement });
      }
      var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
      function rn(t2) {
        return t2 === "x" ? "y" : "x";
      }
      function on(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = t2.name, o2 = n2.mainAxis, i2 = o2 === void 0 ? true : o2, a2 = n2.altAxis, s2 = a2 === void 0 ? false : a2, f2 = n2.boundary, c2 = n2.rootBoundary, u2 = n2.altBoundary, m2 = n2.padding, v2 = n2.tether, l2 = v2 === void 0 ? true : v2, h2 = n2.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g2 = ne(e2, { boundary: f2, rootBoundary: c2, padding: m2, altBoundary: u2 }), x2 = q$1(e2.placement), y2 = te(e2.placement), $2 = !y2, d2 = Le(x2), b2 = rn(d2), w2 = e2.modifiersData.popperOffsets, O2 = e2.rects.reference, j2 = e2.rects.popper, A2 = typeof p2 == "function" ? p2(Object.assign({}, e2.rects, { placement: e2.placement })) : p2, k2 = typeof A2 == "number" ? { mainAxis: A2, altAxis: A2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, A2), D2 = e2.modifiersData.offset ? e2.modifiersData.offset[e2.placement] : null, S2 = { x: 0, y: 0 };
        if (w2) {
          if (i2) {
            var L2, re = d2 === "y" ? E$1 : P$1, oe = d2 === "y" ? R$1 : W$1, M2 = d2 === "y" ? "height" : "width", T2 = w2[d2], pe = T2 + g2[re], _2 = T2 - g2[oe], ue = l2 ? -j2[M2] / 2 : 0, xe = y2 === U$1 ? O2[M2] : j2[M2], ie = y2 === U$1 ? -j2[M2] : -O2[M2], le = e2.elements.arrow, z2 = l2 && le ? ke(le) : { width: 0, height: 0 }, V2 = e2.modifiersData["arrow#persistent"] ? e2.modifiersData["arrow#persistent"].padding : st$1(), de = V2[re], ae = V2[oe], Y2 = fe(0, O2[M2], z2[M2]), jt2 = $2 ? O2[M2] / 2 - ue - Y2 - de - k2.mainAxis : xe - Y2 - de - k2.mainAxis, Dt2 = $2 ? -O2[M2] / 2 + ue + Y2 + ae + k2.mainAxis : ie + Y2 + ae + k2.mainAxis, Oe = e2.elements.arrow && se(e2.elements.arrow), Et2 = Oe ? d2 === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L2 = D2 == null ? void 0 : D2[d2]) != null ? L2 : 0, Pt2 = T2 + jt2 - Ce - Et2, At2 = T2 + Dt2 - Ce, qe = fe(l2 ? ve(pe, Pt2) : pe, T2, l2 ? X$1(_2, At2) : _2);
            w2[d2] = qe, S2[d2] = qe - T2;
          }
          if (s2) {
            var Ve, kt2 = d2 === "x" ? E$1 : P$1, Lt2 = d2 === "x" ? R$1 : W$1, F2 = w2[b2], he = b2 === "y" ? "height" : "width", Ne = F2 + g2[kt2], Ie = F2 - g2[Lt2], $e = [E$1, P$1].indexOf(x2) !== -1, _e = (Ve = D2 == null ? void 0 : D2[b2]) != null ? Ve : 0, ze = $e ? Ne : F2 - O2[he] - j2[he] - _e + k2.altAxis, Fe = $e ? F2 + O2[he] + j2[he] - _e - k2.altAxis : Ie, Ue = l2 && $e ? St$1(ze, F2, Fe) : fe(l2 ? ze : Ne, F2, l2 ? Fe : Ie);
            w2[b2] = Ue, S2[b2] = Ue - F2;
          }
          e2.modifiersData[r2] = S2;
        }
      }
      var xt$1 = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
      function an(t2) {
        return { scrollLeft: t2.scrollLeft, scrollTop: t2.scrollTop };
      }
      function sn(t2) {
        return t2 === H$1(t2) || !B$1(t2) ? We(t2) : an(t2);
      }
      function fn(t2) {
        var e2 = t2.getBoundingClientRect(), n2 = Z$1(e2.width) / t2.offsetWidth || 1, r2 = Z$1(e2.height) / t2.offsetHeight || 1;
        return n2 !== 1 || r2 !== 1;
      }
      function cn(t2, e2, n2) {
        n2 === void 0 && (n2 = false);
        var r2 = B$1(e2), o2 = B$1(e2) && fn(e2), i2 = I$1(e2), a2 = ee(t2, o2), s2 = { scrollLeft: 0, scrollTop: 0 }, f2 = { x: 0, y: 0 };
        return (r2 || !r2 && !n2) && ((C$1(e2) !== "body" || Se(i2)) && (s2 = sn(e2)), B$1(e2) ? (f2 = ee(e2, true), f2.x += e2.clientLeft, f2.y += e2.clientTop) : i2 && (f2.x = Be(i2))), { x: a2.left + s2.scrollLeft - f2.x, y: a2.top + s2.scrollTop - f2.y, width: a2.width, height: a2.height };
      }
      function pn(t2) {
        var e2 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Set(), r2 = [];
        t2.forEach(function(i2) {
          e2.set(i2.name, i2);
        });
        function o2(i2) {
          n2.add(i2.name);
          var a2 = [].concat(i2.requires || [], i2.requiresIfExists || []);
          a2.forEach(function(s2) {
            if (!n2.has(s2)) {
              var f2 = e2.get(s2);
              f2 && o2(f2);
            }
          }), r2.push(i2);
        }
        return t2.forEach(function(i2) {
          n2.has(i2.name) || o2(i2);
        }), r2;
      }
      function un(t2) {
        var e2 = pn(t2);
        return ot$1.reduce(function(n2, r2) {
          return n2.concat(e2.filter(function(o2) {
            return o2.phase === r2;
          }));
        }, []);
      }
      function ln(t2) {
        var e2;
        return function() {
          return e2 || (e2 = new Promise(function(n2) {
            Promise.resolve().then(function() {
              e2 = void 0, n2(t2());
            });
          })), e2;
        };
      }
      function dn(t2) {
        var e2 = t2.reduce(function(n2, r2) {
          var o2 = n2[r2.name];
          return n2[r2.name] = o2 ? Object.assign({}, o2, r2, { options: Object.assign({}, o2.options, r2.options), data: Object.assign({}, o2.data, r2.data) }) : r2, n2;
        }, {});
        return Object.keys(e2).map(function(n2) {
          return e2[n2];
        });
      }
      var Ot$1 = { placement: "bottom", modifiers: [], strategy: "absolute" };
      function $t() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++)
          e2[n2] = arguments[n2];
        return !e2.some(function(r2) {
          return !(r2 && typeof r2.getBoundingClientRect == "function");
        });
      }
      function we(t2) {
        t2 === void 0 && (t2 = {});
        var e2 = t2, n2 = e2.defaultModifiers, r2 = n2 === void 0 ? [] : n2, o2 = e2.defaultOptions, i2 = o2 === void 0 ? Ot$1 : o2;
        return function(a2, s2, f2) {
          f2 === void 0 && (f2 = i2);
          var c2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot$1, i2), modifiersData: {}, elements: { reference: a2, popper: s2 }, attributes: {}, styles: {} }, u2 = [], m2 = false, v2 = { state: c2, setOptions: function(p2) {
            var g2 = typeof p2 == "function" ? p2(c2.options) : p2;
            h2(), c2.options = Object.assign({}, i2, c2.options, g2), c2.scrollParents = { reference: Q$1(a2) ? ce(a2) : a2.contextElement ? ce(a2.contextElement) : [], popper: ce(s2) };
            var x2 = un(dn([].concat(r2, c2.options.modifiers)));
            return c2.orderedModifiers = x2.filter(function(y2) {
              return y2.enabled;
            }), l2(), v2.update();
          }, forceUpdate: function() {
            if (!m2) {
              var p2 = c2.elements, g2 = p2.reference, x2 = p2.popper;
              if ($t(g2, x2)) {
                c2.rects = { reference: cn(g2, se(x2), c2.options.strategy === "fixed"), popper: ke(x2) }, c2.reset = false, c2.placement = c2.options.placement, c2.orderedModifiers.forEach(function(j2) {
                  return c2.modifiersData[j2.name] = Object.assign({}, j2.data);
                });
                for (var y2 = 0; y2 < c2.orderedModifiers.length; y2++) {
                  if (c2.reset === true) {
                    c2.reset = false, y2 = -1;
                    continue;
                  }
                  var $2 = c2.orderedModifiers[y2], d2 = $2.fn, b2 = $2.options, w2 = b2 === void 0 ? {} : b2, O2 = $2.name;
                  typeof d2 == "function" && (c2 = d2({ state: c2, options: w2, name: O2, instance: v2 }) || c2);
                }
              }
            }
          }, update: ln(function() {
            return new Promise(function(p2) {
              v2.forceUpdate(), p2(c2);
            });
          }), destroy: function() {
            h2(), m2 = true;
          } };
          if (!$t(a2, s2))
            return v2;
          v2.setOptions(f2).then(function(p2) {
            !m2 && f2.onFirstUpdate && f2.onFirstUpdate(p2);
          });
          function l2() {
            c2.orderedModifiers.forEach(function(p2) {
              var g2 = p2.name, x2 = p2.options, y2 = x2 === void 0 ? {} : x2, $2 = p2.effect;
              if (typeof $2 == "function") {
                var d2 = $2({ state: c2, name: g2, instance: v2, options: y2 }), b2 = function() {
                };
                u2.push(d2 || b2);
              }
            });
          }
          function h2() {
            u2.forEach(function(p2) {
              return p2();
            }), u2 = [];
          }
          return v2;
        };
      }
      we();
      var mn = [Re, He, Me, Ae];
      we({ defaultModifiers: mn });
      var gn = [Re, He, Me, Ae, wt$1, vt$1, xt$1, pt$1, bt$1], yn = we({ defaultModifiers: gn });
      const usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
        const stateUpdater = {
          name: "updateState",
          enabled: true,
          phase: "write",
          fn: ({ state }) => {
            const derivedState = deriveState(state);
            Object.assign(states.value, derivedState);
          },
          requires: ["computeStyles"]
        };
        const options = computed(() => {
          const { onFirstUpdate, placement, strategy, modifiers } = unref(opts);
          return {
            onFirstUpdate,
            placement: placement || "bottom",
            strategy: strategy || "absolute",
            modifiers: [
              ...modifiers || [],
              stateUpdater,
              { name: "applyStyles", enabled: false }
            ]
          };
        });
        const instanceRef = shallowRef();
        const states = ref({
          styles: {
            popper: {
              position: unref(options).strategy,
              left: "0",
              top: "0"
            },
            arrow: {
              position: "absolute"
            }
          },
          attributes: {}
        });
        const destroy = () => {
          if (!instanceRef.value)
            return;
          instanceRef.value.destroy();
          instanceRef.value = void 0;
        };
        watch(options, (newOptions) => {
          const instance = unref(instanceRef);
          if (instance) {
            instance.setOptions(newOptions);
          }
        }, {
          deep: true
        });
        watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
          destroy();
          if (!referenceElement || !popperElement)
            return;
          instanceRef.value = yn(referenceElement, popperElement, unref(options));
        });
        onBeforeUnmount(() => {
          destroy();
        });
        return {
          state: computed(() => {
            var _a2;
            return { ...((_a2 = unref(instanceRef)) == null ? void 0 : _a2.state) || {} };
          }),
          styles: computed(() => unref(states).styles),
          attributes: computed(() => unref(states).attributes),
          update: () => {
            var _a2;
            return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.update();
          },
          forceUpdate: () => {
            var _a2;
            return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.forceUpdate();
          },
          instanceRef: computed(() => unref(instanceRef))
        };
      };
      function deriveState(state) {
        const elements = Object.keys(state.elements);
        const styles = fromPairs(elements.map((element) => [element, state.styles[element] || {}]));
        const attributes = fromPairs(elements.map((element) => [element, state.attributes[element]]));
        return {
          styles,
          attributes
        };
      }
      const useSameTarget = (handleClick) => {
        if (!handleClick) {
          return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
        }
        let mousedownTarget = false;
        let mouseupTarget = false;
        const onClick = (e2) => {
          if (mousedownTarget && mouseupTarget) {
            handleClick(e2);
          }
          mousedownTarget = mouseupTarget = false;
        };
        const onMousedown = (e2) => {
          mousedownTarget = e2.target === e2.currentTarget;
        };
        const onMouseup = (e2) => {
          mouseupTarget = e2.target === e2.currentTarget;
        };
        return { onClick, onMousedown, onMouseup };
      };
      function useTimeout() {
        let timeoutHandle;
        const registerTimeout = (fn2, delay) => {
          cancelTimeout();
          timeoutHandle = window.setTimeout(fn2, delay);
        };
        const cancelTimeout = () => window.clearTimeout(timeoutHandle);
        tryOnScopeDispose$1(() => cancelTimeout());
        return {
          registerTimeout,
          cancelTimeout
        };
      }
      const defaultIdInjection = {
        prefix: Math.floor(Math.random() * 1e4),
        current: 0
      };
      const ID_INJECTION_KEY = Symbol("elIdInjection");
      const useIdInjection = () => {
        return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
      };
      const useId = (deterministicId) => {
        const idInjection = useIdInjection();
        const namespace = useGetDerivedNamespace();
        const idRef = computed(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
        return idRef;
      };
      let registeredEscapeHandlers = [];
      const cachedHandler = (e2) => {
        const event = e2;
        if (event.key === EVENT_CODE.esc) {
          registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
        }
      };
      const useEscapeKeydown = (handler) => {
        onMounted(() => {
          if (registeredEscapeHandlers.length === 0) {
            document.addEventListener("keydown", cachedHandler);
          }
          if (isClient$1)
            registeredEscapeHandlers.push(handler);
        });
        onBeforeUnmount(() => {
          registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
          if (registeredEscapeHandlers.length === 0) {
            if (isClient$1)
              document.removeEventListener("keydown", cachedHandler);
          }
        });
      };
      let cachedContainer;
      const usePopperContainerId = () => {
        const namespace = useGetDerivedNamespace();
        const idInjection = useIdInjection();
        const id2 = computed(() => {
          return `${namespace.value}-popper-container-${idInjection.prefix}`;
        });
        const selector = computed(() => `#${id2.value}`);
        return {
          id: id2,
          selector
        };
      };
      const createContainer = (id2) => {
        const container = document.createElement("div");
        container.id = id2;
        document.body.appendChild(container);
        return container;
      };
      const usePopperContainer = () => {
        const { id: id2, selector } = usePopperContainerId();
        onBeforeMount(() => {
          if (!isClient$1)
            return;
          if (!cachedContainer && !document.body.querySelector(selector.value)) {
            cachedContainer = createContainer(id2.value);
          }
        });
        return {
          id: id2,
          selector
        };
      };
      const useDelayedToggleProps = buildProps({
        showAfter: {
          type: Number,
          default: 0
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        autoClose: {
          type: Number,
          default: 0
        }
      });
      const useDelayedToggle = ({
        showAfter,
        hideAfter,
        autoClose,
        open: open2,
        close: close2
      }) => {
        const { registerTimeout } = useTimeout();
        const {
          registerTimeout: registerTimeoutForAutoClose,
          cancelTimeout: cancelTimeoutForAutoClose
        } = useTimeout();
        const onOpen = (event) => {
          registerTimeout(() => {
            open2(event);
            const _autoClose = unref(autoClose);
            if (isNumber(_autoClose) && _autoClose > 0) {
              registerTimeoutForAutoClose(() => {
                close2(event);
              }, _autoClose);
            }
          }, unref(showAfter));
        };
        const onClose = (event) => {
          cancelTimeoutForAutoClose();
          registerTimeout(() => {
            close2(event);
          }, unref(hideAfter));
        };
        return {
          onOpen,
          onClose
        };
      };
      const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
      const useForwardRef = (forwardRef) => {
        const setForwardRef = (el) => {
          forwardRef.value = el;
        };
        provide(FORWARD_REF_INJECTION_KEY, {
          setForwardRef
        });
      };
      const useForwardRefDirective = (setForwardRef) => {
        return {
          mounted(el) {
            setForwardRef(el);
          },
          updated(el) {
            setForwardRef(el);
          },
          unmounted() {
            setForwardRef(null);
          }
        };
      };
      const zIndex = ref(0);
      const defaultInitialZIndex = 2e3;
      const zIndexContextKey = Symbol("zIndexContextKey");
      const useZIndex = (zIndexOverrides) => {
        const zIndexInjection = zIndexOverrides || inject(zIndexContextKey, void 0);
        const initialZIndex = computed(() => {
          const zIndexFromInjection = unref(zIndexInjection);
          return isNumber(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
        });
        const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
        const nextZIndex = () => {
          zIndex.value++;
          return currentZIndex.value;
        };
        return {
          initialZIndex,
          currentZIndex,
          nextZIndex
        };
      };
      function useCursor(input) {
        const selectionRef = ref();
        function recordCursor() {
          if (input.value == void 0)
            return;
          const { selectionStart, selectionEnd, value } = input.value;
          if (selectionStart == null || selectionEnd == null)
            return;
          const beforeTxt = value.slice(0, Math.max(0, selectionStart));
          const afterTxt = value.slice(Math.max(0, selectionEnd));
          selectionRef.value = {
            selectionStart,
            selectionEnd,
            value,
            beforeTxt,
            afterTxt
          };
        }
        function setCursor() {
          if (input.value == void 0 || selectionRef.value == void 0)
            return;
          const { value } = input.value;
          const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
          if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
            return;
          let startPos = value.length;
          if (value.endsWith(afterTxt)) {
            startPos = value.length - afterTxt.length;
          } else if (value.startsWith(beforeTxt)) {
            startPos = beforeTxt.length;
          } else {
            const beforeLastChar = beforeTxt[selectionStart - 1];
            const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
            if (newIndex !== -1) {
              startPos = newIndex + 1;
            }
          }
          input.value.setSelectionRange(startPos, startPos);
        }
        return [recordCursor, setCursor];
      }
      const getOrderedChildren = (vm, childComponentName, children) => {
        const nodes = flattedChildren(vm.subTree).filter((n2) => {
          var _a2;
          return isVNode(n2) && ((_a2 = n2.type) == null ? void 0 : _a2.name) === childComponentName && !!n2.component;
        });
        const uids = nodes.map((n2) => n2.component.uid);
        return uids.map((uid2) => children[uid2]).filter((p2) => !!p2);
      };
      const useOrderedChildren = (vm, childComponentName) => {
        const children = {};
        const orderedChildren = shallowRef([]);
        const addChild = (child) => {
          children[child.uid] = child;
          orderedChildren.value = getOrderedChildren(vm, childComponentName, children);
        };
        const removeChild = (uid2) => {
          delete children[uid2];
          orderedChildren.value = orderedChildren.value.filter((children2) => children2.uid !== uid2);
        };
        return {
          children: orderedChildren,
          addChild,
          removeChild
        };
      };
      const useSizeProp = buildProp({
        type: String,
        values: componentSizes,
        required: false
      });
      const SIZE_INJECTION_KEY = Symbol("size");
      const useGlobalSize = () => {
        const injectedSize = inject(SIZE_INJECTION_KEY, {});
        return computed(() => {
          return unref(injectedSize.size) || "";
        });
      };
      function useFocusController(target, { afterFocus, afterBlur } = {}) {
        const instance = getCurrentInstance();
        const { emit: emit2 } = instance;
        const wrapperRef = shallowRef();
        const isFocused = ref(false);
        const handleFocus = (event) => {
          if (isFocused.value)
            return;
          isFocused.value = true;
          emit2("focus", event);
          afterFocus == null ? void 0 : afterFocus();
        };
        const handleBlur = (event) => {
          var _a2;
          if (event.relatedTarget && ((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(event.relatedTarget)))
            return;
          isFocused.value = false;
          emit2("blur", event);
          afterBlur == null ? void 0 : afterBlur();
        };
        const handleClick = () => {
          var _a2;
          (_a2 = target.value) == null ? void 0 : _a2.focus();
        };
        watch(wrapperRef, (el) => {
          if (el) {
            el.setAttribute("role", "button");
            el.setAttribute("tabindex", "-1");
          }
        });
        useEventListener$1(wrapperRef, "click", handleClick);
        return {
          wrapperRef,
          isFocused,
          handleFocus,
          handleBlur
        };
      }
      const configProviderContextKey = Symbol();
      const globalConfig = ref();
      function useGlobalConfig(key, defaultValue = void 0) {
        const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
        if (key) {
          return computed(() => {
            var _a2, _b;
            return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
          });
        } else {
          return config;
        }
      }
      function useGlobalComponentSettings(block, sizeFallback) {
        const config = useGlobalConfig();
        const ns = useNamespace(block, computed(() => {
          var _a2;
          return ((_a2 = config.value) == null ? void 0 : _a2.namespace) || defaultNamespace;
        }));
        const locale = useLocale(computed(() => {
          var _a2;
          return (_a2 = config.value) == null ? void 0 : _a2.locale;
        }));
        const zIndex2 = useZIndex(computed(() => {
          var _a2;
          return ((_a2 = config.value) == null ? void 0 : _a2.zIndex) || defaultInitialZIndex;
        }));
        const size2 = computed(() => {
          var _a2;
          return unref(sizeFallback) || ((_a2 = config.value) == null ? void 0 : _a2.size) || "";
        });
        provideGlobalConfig(computed(() => unref(config) || {}));
        return {
          ns,
          locale,
          zIndex: zIndex2,
          size: size2
        };
      }
      const provideGlobalConfig = (config, app2, global2 = false) => {
        var _a2;
        const inSetup = !!getCurrentInstance();
        const oldConfig = inSetup ? useGlobalConfig() : void 0;
        const provideFn = (_a2 = app2 == null ? void 0 : app2.provide) != null ? _a2 : inSetup ? provide : void 0;
        if (!provideFn) {
          return;
        }
        const context = computed(() => {
          const cfg = unref(config);
          if (!(oldConfig == null ? void 0 : oldConfig.value))
            return cfg;
          return mergeConfig(oldConfig.value, cfg);
        });
        provideFn(configProviderContextKey, context);
        provideFn(localeContextKey, computed(() => context.value.locale));
        provideFn(namespaceContextKey, computed(() => context.value.namespace));
        provideFn(zIndexContextKey, computed(() => context.value.zIndex));
        provideFn(SIZE_INJECTION_KEY, {
          size: computed(() => context.value.size || "")
        });
        if (global2 || !globalConfig.value) {
          globalConfig.value = context.value;
        }
        return context;
      };
      const mergeConfig = (a2, b2) => {
        var _a2;
        const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a2), ...keysOf(b2)])];
        const obj = {};
        for (const key of keys2) {
          obj[key] = (_a2 = b2[key]) != null ? _a2 : a2[key];
        }
        return obj;
      };
      const messageConfig = {};
      var _export_sfc$1 = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };
      const iconProps = buildProps({
        size: {
          type: definePropType([Number, String])
        },
        color: {
          type: String
        }
      });
      const __default__$D = defineComponent({
        name: "ElIcon",
        inheritAttrs: false
      });
      const _sfc_main$14 = /* @__PURE__ */ defineComponent({
        ...__default__$D,
        props: iconProps,
        setup(__props) {
          const props = __props;
          const ns = useNamespace("icon");
          const style = computed(() => {
            const { size: size2, color } = props;
            if (!size2 && !color)
              return {};
            return {
              fontSize: isUndefined(size2) ? void 0 : addUnit(size2),
              "--color": color
            };
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("i", mergeProps({
              class: unref(ns).b(),
              style: unref(style)
            }, _ctx.$attrs), [
              renderSlot(_ctx.$slots, "default")
            ], 16);
          };
        }
      });
      var Icon = /* @__PURE__ */ _export_sfc$1(_sfc_main$14, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
      const ElIcon = withInstall(Icon);
      const formContextKey = Symbol("formContextKey");
      const formItemContextKey = Symbol("formItemContextKey");
      const useFormSize = (fallback, ignore = {}) => {
        const emptyRef = ref(void 0);
        const size2 = ignore.prop ? emptyRef : useProp("size");
        const globalConfig2 = ignore.global ? emptyRef : useGlobalSize();
        const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
        const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
        return computed(() => size2.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
      };
      const useFormDisabled = (fallback) => {
        const disabled = useProp("disabled");
        const form = inject(formContextKey, void 0);
        return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
      };
      const useFormItem = () => {
        const form = inject(formContextKey, void 0);
        const formItem = inject(formItemContextKey, void 0);
        return {
          form,
          formItem
        };
      };
      const useFormItemInputId = (props, {
        formItemContext,
        disableIdGeneration,
        disableIdManagement
      }) => {
        if (!disableIdGeneration) {
          disableIdGeneration = ref(false);
        }
        if (!disableIdManagement) {
          disableIdManagement = ref(false);
        }
        const inputId = ref();
        let idUnwatch = void 0;
        const isLabeledByFormItem = computed(() => {
          var _a2;
          return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
        });
        onMounted(() => {
          idUnwatch = watch([toRef$1(props, "id"), disableIdGeneration], ([id2, disableIdGeneration2]) => {
            const newId = id2 != null ? id2 : !disableIdGeneration2 ? useId().value : void 0;
            if (newId !== inputId.value) {
              if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
                inputId.value && formItemContext.removeInputId(inputId.value);
                if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                  formItemContext.addInputId(newId);
                }
              }
              inputId.value = newId;
            }
          }, { immediate: true });
        });
        onUnmounted(() => {
          idUnwatch && idUnwatch();
          if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
            inputId.value && formItemContext.removeInputId(inputId.value);
          }
        });
        return {
          isLabeledByFormItem,
          inputId
        };
      };
      const formMetaProps = buildProps({
        size: {
          type: String,
          values: componentSizes
        },
        disabled: Boolean
      });
      const formProps = buildProps({
        ...formMetaProps,
        model: Object,
        rules: {
          type: definePropType(Object)
        },
        labelPosition: {
          type: String,
          values: ["left", "right", "top"],
          default: "right"
        },
        requireAsteriskPosition: {
          type: String,
          values: ["left", "right"],
          default: "left"
        },
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        labelSuffix: {
          type: String,
          default: ""
        },
        inline: Boolean,
        inlineMessage: Boolean,
        statusIcon: Boolean,
        showMessage: {
          type: Boolean,
          default: true
        },
        validateOnRuleChange: {
          type: Boolean,
          default: true
        },
        hideRequiredAsterisk: Boolean,
        scrollToError: Boolean,
        scrollIntoViewOptions: {
          type: [Object, Boolean]
        }
      });
      const formEmits = {
        validate: (prop, isValid, message2) => (isArray$2(prop) || isString$1(prop)) && isBoolean(isValid) && isString$1(message2)
      };
      function useFormLabelWidth() {
        const potentialLabelWidthArr = ref([]);
        const autoLabelWidth = computed(() => {
          if (!potentialLabelWidthArr.value.length)
            return "0";
          const max = Math.max(...potentialLabelWidthArr.value);
          return max ? `${max}px` : "";
        });
        function getLabelWidthIndex(width) {
          const index = potentialLabelWidthArr.value.indexOf(width);
          if (index === -1 && autoLabelWidth.value === "0")
            ;
          return index;
        }
        function registerLabelWidth(val, oldVal) {
          if (val && oldVal) {
            const index = getLabelWidthIndex(oldVal);
            potentialLabelWidthArr.value.splice(index, 1, val);
          } else if (val) {
            potentialLabelWidthArr.value.push(val);
          }
        }
        function deregisterLabelWidth(val) {
          const index = getLabelWidthIndex(val);
          if (index > -1) {
            potentialLabelWidthArr.value.splice(index, 1);
          }
        }
        return {
          autoLabelWidth,
          registerLabelWidth,
          deregisterLabelWidth
        };
      }
      const filterFields = (fields, props) => {
        const normalized = castArray(props);
        return normalized.length > 0 ? fields.filter((field) => field.prop && normalized.includes(field.prop)) : fields;
      };
      const COMPONENT_NAME$7 = "ElForm";
      const __default__$C = defineComponent({
        name: COMPONENT_NAME$7
      });
      const _sfc_main$13 = /* @__PURE__ */ defineComponent({
        ...__default__$C,
        props: formProps,
        emits: formEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const fields = [];
          const formSize = useFormSize();
          const ns = useNamespace("form");
          const formClasses = computed(() => {
            const { labelPosition, inline } = props;
            return [
              ns.b(),
              ns.m(formSize.value || "default"),
              {
                [ns.m(`label-${labelPosition}`)]: labelPosition,
                [ns.m("inline")]: inline
              }
            ];
          });
          const addField = (field) => {
            fields.push(field);
          };
          const removeField = (field) => {
            if (field.prop) {
              fields.splice(fields.indexOf(field), 1);
            }
          };
          const resetFields = (properties = []) => {
            if (!props.model) {
              return;
            }
            filterFields(fields, properties).forEach((field) => field.resetField());
          };
          const clearValidate = (props2 = []) => {
            filterFields(fields, props2).forEach((field) => field.clearValidate());
          };
          const isValidatable = computed(() => {
            const hasModel = !!props.model;
            return hasModel;
          });
          const obtainValidateFields = (props2) => {
            if (fields.length === 0)
              return [];
            const filteredFields = filterFields(fields, props2);
            if (!filteredFields.length) {
              return [];
            }
            return filteredFields;
          };
          const validate = async (callback) => validateField(void 0, callback);
          const doValidateField = async (props2 = []) => {
            if (!isValidatable.value)
              return false;
            const fields2 = obtainValidateFields(props2);
            if (fields2.length === 0)
              return true;
            let validationErrors = {};
            for (const field of fields2) {
              try {
                await field.validate("");
              } catch (fields3) {
                validationErrors = {
                  ...validationErrors,
                  ...fields3
                };
              }
            }
            if (Object.keys(validationErrors).length === 0)
              return true;
            return Promise.reject(validationErrors);
          };
          const validateField = async (modelProps = [], callback) => {
            const shouldThrow = !isFunction$1(callback);
            try {
              const result = await doValidateField(modelProps);
              if (result === true) {
                callback == null ? void 0 : callback(result);
              }
              return result;
            } catch (e2) {
              if (e2 instanceof Error)
                throw e2;
              const invalidFields = e2;
              if (props.scrollToError) {
                scrollToField(Object.keys(invalidFields)[0]);
              }
              callback == null ? void 0 : callback(false, invalidFields);
              return shouldThrow && Promise.reject(invalidFields);
            }
          };
          const scrollToField = (prop) => {
            var _a2;
            const field = filterFields(fields, prop)[0];
            if (field) {
              (_a2 = field.$el) == null ? void 0 : _a2.scrollIntoView(props.scrollIntoViewOptions);
            }
          };
          watch(() => props.rules, () => {
            if (props.validateOnRuleChange) {
              validate().catch((err) => debugWarn());
            }
          }, { deep: true });
          provide(formContextKey, reactive({
            ...toRefs(props),
            emit: emit2,
            resetFields,
            clearValidate,
            validateField,
            addField,
            removeField,
            ...useFormLabelWidth()
          }));
          expose({
            validate,
            validateField,
            resetFields,
            clearValidate,
            scrollToField
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("form", {
              class: normalizeClass(unref(formClasses))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Form = /* @__PURE__ */ _export_sfc$1(_sfc_main$13, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form.vue"]]);
      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o2) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
          return o3.__proto__ || Object.getPrototypeOf(o3);
        };
        return _getPrototypeOf(o2);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e2) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a2 = [null];
            a2.push.apply(a2, args2);
            var Constructor = Function.bind.apply(Parent2, a2);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn2) {
        return Function.toString.call(fn2).indexOf("[native code]") !== -1;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2))
            return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2))
              return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      var formatRegExp = /%[sdj%]/g;
      var warning = function warning2() {
      };
      if (typeof process !== "undefined" && process.env && false) {
        warning = function warning2(type2, errors) {
          if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
            if (errors.every(function(e2) {
              return typeof e2 === "string";
            })) {
              console.warn(type2, errors);
            }
          }
        };
      }
      function convertFieldsError(errors) {
        if (!errors || !errors.length)
          return null;
        var fields = {};
        errors.forEach(function(error) {
          var field = error.field;
          fields[field] = fields[field] || [];
          fields[field].push(error);
        });
        return fields;
      }
      function format(template) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var i2 = 0;
        var len = args.length;
        if (typeof template === "function") {
          return template.apply(null, args);
        }
        if (typeof template === "string") {
          var str = template.replace(formatRegExp, function(x2) {
            if (x2 === "%%") {
              return "%";
            }
            if (i2 >= len) {
              return x2;
            }
            switch (x2) {
              case "%s":
                return String(args[i2++]);
              case "%d":
                return Number(args[i2++]);
              case "%j":
                try {
                  return JSON.stringify(args[i2++]);
                } catch (_2) {
                  return "[Circular]";
                }
                break;
              default:
                return x2;
            }
          });
          return str;
        }
        return template;
      }
      function isNativeStringType(type2) {
        return type2 === "string" || type2 === "url" || type2 === "hex" || type2 === "email" || type2 === "date" || type2 === "pattern";
      }
      function isEmptyValue(value, type2) {
        if (value === void 0 || value === null) {
          return true;
        }
        if (type2 === "array" && Array.isArray(value) && !value.length) {
          return true;
        }
        if (isNativeStringType(type2) && typeof value === "string" && !value) {
          return true;
        }
        return false;
      }
      function asyncParallelArray(arr, func, callback) {
        var results = [];
        var total2 = 0;
        var arrLength = arr.length;
        function count(errors) {
          results.push.apply(results, errors || []);
          total2++;
          if (total2 === arrLength) {
            callback(results);
          }
        }
        arr.forEach(function(a2) {
          func(a2, count);
        });
      }
      function asyncSerialArray(arr, func, callback) {
        var index = 0;
        var arrLength = arr.length;
        function next(errors) {
          if (errors && errors.length) {
            callback(errors);
            return;
          }
          var original = index;
          index = index + 1;
          if (original < arrLength) {
            func(arr[original], next);
          } else {
            callback([]);
          }
        }
        next([]);
      }
      function flattenObjArr(objArr) {
        var ret = [];
        Object.keys(objArr).forEach(function(k2) {
          ret.push.apply(ret, objArr[k2] || []);
        });
        return ret;
      }
      var AsyncValidationError = /* @__PURE__ */ function(_Error) {
        _inheritsLoose(AsyncValidationError2, _Error);
        function AsyncValidationError2(errors, fields) {
          var _this;
          _this = _Error.call(this, "Async Validation Error") || this;
          _this.errors = errors;
          _this.fields = fields;
          return _this;
        }
        return AsyncValidationError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      function asyncMap(objArr, option, func, callback, source) {
        if (option.first) {
          var _pending = new Promise(function(resolve2, reject) {
            var next = function next2(errors) {
              callback(errors);
              return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source);
            };
            var flattenArr = flattenObjArr(objArr);
            asyncSerialArray(flattenArr, func, next);
          });
          _pending["catch"](function(e2) {
            return e2;
          });
          return _pending;
        }
        var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
        var objArrKeys = Object.keys(objArr);
        var objArrLength = objArrKeys.length;
        var total2 = 0;
        var results = [];
        var pending = new Promise(function(resolve2, reject) {
          var next = function next2(errors) {
            results.push.apply(results, errors);
            total2++;
            if (total2 === objArrLength) {
              callback(results);
              return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source);
            }
          };
          if (!objArrKeys.length) {
            callback(results);
            resolve2(source);
          }
          objArrKeys.forEach(function(key) {
            var arr = objArr[key];
            if (firstFields.indexOf(key) !== -1) {
              asyncSerialArray(arr, func, next);
            } else {
              asyncParallelArray(arr, func, next);
            }
          });
        });
        pending["catch"](function(e2) {
          return e2;
        });
        return pending;
      }
      function isErrorObj(obj) {
        return !!(obj && obj.message !== void 0);
      }
      function getValue(value, path) {
        var v2 = value;
        for (var i2 = 0; i2 < path.length; i2++) {
          if (v2 == void 0) {
            return v2;
          }
          v2 = v2[path[i2]];
        }
        return v2;
      }
      function complementError(rule, source) {
        return function(oe) {
          var fieldValue;
          if (rule.fullFields) {
            fieldValue = getValue(source, rule.fullFields);
          } else {
            fieldValue = source[oe.field || rule.fullField];
          }
          if (isErrorObj(oe)) {
            oe.field = oe.field || rule.fullField;
            oe.fieldValue = fieldValue;
            return oe;
          }
          return {
            message: typeof oe === "function" ? oe() : oe,
            fieldValue,
            field: oe.field || rule.fullField
          };
        };
      }
      function deepMerge(target, source) {
        if (source) {
          for (var s2 in source) {
            if (source.hasOwnProperty(s2)) {
              var value = source[s2];
              if (typeof value === "object" && typeof target[s2] === "object") {
                target[s2] = _extends({}, target[s2], value);
              } else {
                target[s2] = value;
              }
            }
          }
        }
        return target;
      }
      var required$1 = function required2(rule, value, source, errors, options, type2) {
        if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type2 || rule.type))) {
          errors.push(format(options.messages.required, rule.fullField));
        }
      };
      var whitespace = function whitespace2(rule, value, source, errors, options) {
        if (/^\s+$/.test(value) || value === "") {
          errors.push(format(options.messages.whitespace, rule.fullField));
        }
      };
      var urlReg;
      var getUrlRegex = function() {
        if (urlReg) {
          return urlReg;
        }
        var word = "[a-fA-F\\d:]";
        var b2 = function b3(options) {
          return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
        };
        var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
        var v6seg = "[a-fA-F\\d]{1,4}";
        var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
        var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
        var v4exact = new RegExp("^" + v4 + "$");
        var v6exact = new RegExp("^" + v6 + "$");
        var ip = function ip2(options) {
          return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
        };
        ip.v4 = function(options) {
          return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
        };
        ip.v6 = function(options) {
          return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
        };
        var protocol = "(?:(?:[a-z]+:)?//)";
        var auth = "(?:\\S+(?::\\S*)?@)?";
        var ipv4 = ip.v4().source;
        var ipv6 = ip.v6().source;
        var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
        var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
        var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
        var port = "(?::\\d{2,5})?";
        var path = '(?:[/?#][^\\s"]*)?';
        var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
        urlReg = new RegExp("(?:^" + regex + "$)", "i");
        return urlReg;
      };
      var pattern$2 = {
        // http://emailregex.com/
        email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
        // url: new RegExp(
        //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
        //   'i',
        // ),
        hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
      };
      var types = {
        integer: function integer2(value) {
          return types.number(value) && parseInt(value, 10) === value;
        },
        "float": function float(value) {
          return types.number(value) && !types.integer(value);
        },
        array: function array2(value) {
          return Array.isArray(value);
        },
        regexp: function regexp2(value) {
          if (value instanceof RegExp) {
            return true;
          }
          try {
            return !!new RegExp(value);
          } catch (e2) {
            return false;
          }
        },
        date: function date2(value) {
          return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
        },
        number: function number2(value) {
          if (isNaN(value)) {
            return false;
          }
          return typeof value === "number";
        },
        object: function object2(value) {
          return typeof value === "object" && !types.array(value);
        },
        method: function method2(value) {
          return typeof value === "function";
        },
        email: function email(value) {
          return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
        },
        url: function url(value) {
          return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
        },
        hex: function hex(value) {
          return typeof value === "string" && !!value.match(pattern$2.hex);
        }
      };
      var type$1 = function type2(rule, value, source, errors, options) {
        if (rule.required && value === void 0) {
          required$1(rule, value, source, errors, options);
          return;
        }
        var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
        var ruleType = rule.type;
        if (custom.indexOf(ruleType) > -1) {
          if (!types[ruleType](value)) {
            errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
          }
        } else if (ruleType && typeof value !== rule.type) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      };
      var range = function range2(rule, value, source, errors, options) {
        var len = typeof rule.len === "number";
        var min = typeof rule.min === "number";
        var max = typeof rule.max === "number";
        var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var val = value;
        var key = null;
        var num = typeof value === "number";
        var str = typeof value === "string";
        var arr = Array.isArray(value);
        if (num) {
          key = "number";
        } else if (str) {
          key = "string";
        } else if (arr) {
          key = "array";
        }
        if (!key) {
          return false;
        }
        if (arr) {
          val = value.length;
        }
        if (str) {
          val = value.replace(spRegexp, "_").length;
        }
        if (len) {
          if (val !== rule.len) {
            errors.push(format(options.messages[key].len, rule.fullField, rule.len));
          }
        } else if (min && !max && val < rule.min) {
          errors.push(format(options.messages[key].min, rule.fullField, rule.min));
        } else if (max && !min && val > rule.max) {
          errors.push(format(options.messages[key].max, rule.fullField, rule.max));
        } else if (min && max && (val < rule.min || val > rule.max)) {
          errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
        }
      };
      var ENUM$1 = "enum";
      var enumerable$1 = function enumerable2(rule, value, source, errors, options) {
        rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
        if (rule[ENUM$1].indexOf(value) === -1) {
          errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
        }
      };
      var pattern$1 = function pattern2(rule, value, source, errors, options) {
        if (rule.pattern) {
          if (rule.pattern instanceof RegExp) {
            rule.pattern.lastIndex = 0;
            if (!rule.pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          } else if (typeof rule.pattern === "string") {
            var _pattern = new RegExp(rule.pattern);
            if (!_pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          }
        }
      };
      var rules = {
        required: required$1,
        whitespace,
        type: type$1,
        range,
        "enum": enumerable$1,
        pattern: pattern$1
      };
      var string = function string2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "string");
          if (!isEmptyValue(value, "string")) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
            rules.pattern(rule, value, source, errors, options);
            if (rule.whitespace === true) {
              rules.whitespace(rule, value, source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var method = function method2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var number = function number2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (value === "") {
            value = void 0;
          }
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var _boolean = function _boolean2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var regexp = function regexp2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var integer = function integer2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var floatFn = function floatFn2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var array = function array2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if ((value === void 0 || value === null) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "array");
          if (value !== void 0 && value !== null) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var object = function object2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var ENUM = "enum";
      var enumerable = function enumerable2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules[ENUM](rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var pattern = function pattern2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "string")) {
            rules.pattern(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var date = function date2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "date") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "date")) {
            var dateObject;
            if (value instanceof Date) {
              dateObject = value;
            } else {
              dateObject = new Date(value);
            }
            rules.type(rule, dateObject, source, errors, options);
            if (dateObject) {
              rules.range(rule, dateObject.getTime(), source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var required = function required2(rule, value, callback, source, options) {
        var errors = [];
        var type2 = Array.isArray(value) ? "array" : typeof value;
        rules.required(rule, value, source, errors, options, type2);
        callback(errors);
      };
      var type = function type2(rule, value, callback, source, options) {
        var ruleType = rule.type;
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, ruleType) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, ruleType);
          if (!isEmptyValue(value, ruleType)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var any = function any2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
        }
        callback(errors);
      };
      var validators = {
        string,
        method,
        number,
        "boolean": _boolean,
        regexp,
        integer,
        "float": floatFn,
        array,
        object,
        "enum": enumerable,
        pattern,
        date,
        url: type,
        hex: type,
        email: type,
        required,
        any
      };
      function newMessages() {
        return {
          "default": "Validation error on field %s",
          required: "%s is required",
          "enum": "%s must be one of %s",
          whitespace: "%s cannot be empty",
          date: {
            format: "%s date %s is invalid for format %s",
            parse: "%s date could not be parsed, %s is invalid ",
            invalid: "%s date %s is invalid"
          },
          types: {
            string: "%s is not a %s",
            method: "%s is not a %s (function)",
            array: "%s is not an %s",
            object: "%s is not an %s",
            number: "%s is not a %s",
            date: "%s is not a %s",
            "boolean": "%s is not a %s",
            integer: "%s is not an %s",
            "float": "%s is not a %s",
            regexp: "%s is not a valid %s",
            email: "%s is not a valid %s",
            url: "%s is not a valid %s",
            hex: "%s is not a valid %s"
          },
          string: {
            len: "%s must be exactly %s characters",
            min: "%s must be at least %s characters",
            max: "%s cannot be longer than %s characters",
            range: "%s must be between %s and %s characters"
          },
          number: {
            len: "%s must equal %s",
            min: "%s cannot be less than %s",
            max: "%s cannot be greater than %s",
            range: "%s must be between %s and %s"
          },
          array: {
            len: "%s must be exactly %s in length",
            min: "%s cannot be less than %s in length",
            max: "%s cannot be greater than %s in length",
            range: "%s must be between %s and %s in length"
          },
          pattern: {
            mismatch: "%s value %s does not match pattern %s"
          },
          clone: function clone2() {
            var cloned = JSON.parse(JSON.stringify(this));
            cloned.clone = this.clone;
            return cloned;
          }
        };
      }
      var messages = newMessages();
      var Schema = /* @__PURE__ */ function() {
        function Schema2(descriptor) {
          this.rules = null;
          this._messages = messages;
          this.define(descriptor);
        }
        var _proto = Schema2.prototype;
        _proto.define = function define(rules2) {
          var _this = this;
          if (!rules2) {
            throw new Error("Cannot configure a schema with no rules");
          }
          if (typeof rules2 !== "object" || Array.isArray(rules2)) {
            throw new Error("Rules must be an object");
          }
          this.rules = {};
          Object.keys(rules2).forEach(function(name) {
            var item = rules2[name];
            _this.rules[name] = Array.isArray(item) ? item : [item];
          });
        };
        _proto.messages = function messages2(_messages) {
          if (_messages) {
            this._messages = deepMerge(newMessages(), _messages);
          }
          return this._messages;
        };
        _proto.validate = function validate(source_, o2, oc) {
          var _this2 = this;
          if (o2 === void 0) {
            o2 = {};
          }
          if (oc === void 0) {
            oc = function oc2() {
            };
          }
          var source = source_;
          var options = o2;
          var callback = oc;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          if (!this.rules || Object.keys(this.rules).length === 0) {
            if (callback) {
              callback(null, source);
            }
            return Promise.resolve(source);
          }
          function complete(results) {
            var errors = [];
            var fields = {};
            function add2(e2) {
              if (Array.isArray(e2)) {
                var _errors;
                errors = (_errors = errors).concat.apply(_errors, e2);
              } else {
                errors.push(e2);
              }
            }
            for (var i2 = 0; i2 < results.length; i2++) {
              add2(results[i2]);
            }
            if (!errors.length) {
              callback(null, source);
            } else {
              fields = convertFieldsError(errors);
              callback(errors, fields);
            }
          }
          if (options.messages) {
            var messages$1 = this.messages();
            if (messages$1 === messages) {
              messages$1 = newMessages();
            }
            deepMerge(messages$1, options.messages);
            options.messages = messages$1;
          } else {
            options.messages = this.messages();
          }
          var series = {};
          var keys2 = options.keys || Object.keys(this.rules);
          keys2.forEach(function(z2) {
            var arr = _this2.rules[z2];
            var value = source[z2];
            arr.forEach(function(r2) {
              var rule = r2;
              if (typeof rule.transform === "function") {
                if (source === source_) {
                  source = _extends({}, source);
                }
                value = source[z2] = rule.transform(value);
              }
              if (typeof rule === "function") {
                rule = {
                  validator: rule
                };
              } else {
                rule = _extends({}, rule);
              }
              rule.validator = _this2.getValidationMethod(rule);
              if (!rule.validator) {
                return;
              }
              rule.field = z2;
              rule.fullField = rule.fullField || z2;
              rule.type = _this2.getType(rule);
              series[z2] = series[z2] || [];
              series[z2].push({
                rule,
                value,
                source,
                field: z2
              });
            });
          });
          var errorFields = {};
          return asyncMap(series, options, function(data, doIt) {
            var rule = data.rule;
            var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
            deep = deep && (rule.required || !rule.required && data.value);
            rule.field = data.field;
            function addFullField(key, schema) {
              return _extends({}, schema, {
                fullField: rule.fullField + "." + key,
                fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
              });
            }
            function cb(e2) {
              if (e2 === void 0) {
                e2 = [];
              }
              var errorList = Array.isArray(e2) ? e2 : [e2];
              if (!options.suppressWarning && errorList.length) {
                Schema2.warning("async-validator:", errorList);
              }
              if (errorList.length && rule.message !== void 0) {
                errorList = [].concat(rule.message);
              }
              var filledErrors = errorList.map(complementError(rule, source));
              if (options.first && filledErrors.length) {
                errorFields[rule.field] = 1;
                return doIt(filledErrors);
              }
              if (!deep) {
                doIt(filledErrors);
              } else {
                if (rule.required && !data.value) {
                  if (rule.message !== void 0) {
                    filledErrors = [].concat(rule.message).map(complementError(rule, source));
                  } else if (options.error) {
                    filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                  }
                  return doIt(filledErrors);
                }
                var fieldsSchema = {};
                if (rule.defaultField) {
                  Object.keys(data.value).map(function(key) {
                    fieldsSchema[key] = rule.defaultField;
                  });
                }
                fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
                var paredFieldsSchema = {};
                Object.keys(fieldsSchema).forEach(function(field) {
                  var fieldSchema = fieldsSchema[field];
                  var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                  paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                });
                var schema = new Schema2(paredFieldsSchema);
                schema.messages(options.messages);
                if (data.rule.options) {
                  data.rule.options.messages = options.messages;
                  data.rule.options.error = options.error;
                }
                schema.validate(data.value, data.rule.options || options, function(errs) {
                  var finalErrors = [];
                  if (filledErrors && filledErrors.length) {
                    finalErrors.push.apply(finalErrors, filledErrors);
                  }
                  if (errs && errs.length) {
                    finalErrors.push.apply(finalErrors, errs);
                  }
                  doIt(finalErrors.length ? finalErrors : null);
                });
              }
            }
            var res;
            if (rule.asyncValidator) {
              res = rule.asyncValidator(rule, data.value, cb, data.source, options);
            } else if (rule.validator) {
              try {
                res = rule.validator(rule, data.value, cb, data.source, options);
              } catch (error) {
                console.error == null ? void 0 : console.error(error);
                if (!options.suppressValidatorError) {
                  setTimeout(function() {
                    throw error;
                  }, 0);
                }
                cb(error.message);
              }
              if (res === true) {
                cb();
              } else if (res === false) {
                cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
              } else if (res instanceof Array) {
                cb(res);
              } else if (res instanceof Error) {
                cb(res.message);
              }
            }
            if (res && res.then) {
              res.then(function() {
                return cb();
              }, function(e2) {
                return cb(e2);
              });
            }
          }, function(results) {
            complete(results);
          }, source);
        };
        _proto.getType = function getType2(rule) {
          if (rule.type === void 0 && rule.pattern instanceof RegExp) {
            rule.type = "pattern";
          }
          if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
            throw new Error(format("Unknown rule type %s", rule.type));
          }
          return rule.type || "string";
        };
        _proto.getValidationMethod = function getValidationMethod(rule) {
          if (typeof rule.validator === "function") {
            return rule.validator;
          }
          var keys2 = Object.keys(rule);
          var messageIndex = keys2.indexOf("message");
          if (messageIndex !== -1) {
            keys2.splice(messageIndex, 1);
          }
          if (keys2.length === 1 && keys2[0] === "required") {
            return validators.required;
          }
          return validators[this.getType(rule)] || void 0;
        };
        return Schema2;
      }();
      Schema.register = function register(type2, validator) {
        if (typeof validator !== "function") {
          throw new Error("Cannot register a validator by type, validator is not a function");
        }
        validators[type2] = validator;
      };
      Schema.warning = warning;
      Schema.messages = messages;
      Schema.validators = validators;
      const formItemValidateStates = [
        "",
        "error",
        "validating",
        "success"
      ];
      const formItemProps = buildProps({
        label: String,
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        prop: {
          type: definePropType([String, Array])
        },
        required: {
          type: Boolean,
          default: void 0
        },
        rules: {
          type: definePropType([Object, Array])
        },
        error: String,
        validateStatus: {
          type: String,
          values: formItemValidateStates
        },
        for: String,
        inlineMessage: {
          type: [String, Boolean],
          default: ""
        },
        showMessage: {
          type: Boolean,
          default: true
        },
        size: {
          type: String,
          values: componentSizes
        }
      });
      const COMPONENT_NAME$6 = "ElLabelWrap";
      var FormLabelWrap = defineComponent({
        name: COMPONENT_NAME$6,
        props: {
          isAutoWidth: Boolean,
          updateAll: Boolean
        },
        setup(props, {
          slots
        }) {
          const formContext = inject(formContextKey, void 0);
          const formItemContext = inject(formItemContextKey);
          if (!formItemContext)
            throwError(COMPONENT_NAME$6, "usage: <el-form-item><label-wrap /></el-form-item>");
          const ns = useNamespace("form");
          const el = ref();
          const computedWidth = ref(0);
          const getLabelWidth = () => {
            var _a2;
            if ((_a2 = el.value) == null ? void 0 : _a2.firstElementChild) {
              const width = window.getComputedStyle(el.value.firstElementChild).width;
              return Math.ceil(Number.parseFloat(width));
            } else {
              return 0;
            }
          };
          const updateLabelWidth = (action = "update") => {
            nextTick(() => {
              if (slots.default && props.isAutoWidth) {
                if (action === "update") {
                  computedWidth.value = getLabelWidth();
                } else if (action === "remove") {
                  formContext == null ? void 0 : formContext.deregisterLabelWidth(computedWidth.value);
                }
              }
            });
          };
          const updateLabelWidthFn = () => updateLabelWidth("update");
          onMounted(() => {
            updateLabelWidthFn();
          });
          onBeforeUnmount(() => {
            updateLabelWidth("remove");
          });
          onUpdated(() => updateLabelWidthFn());
          watch(computedWidth, (val, oldVal) => {
            if (props.updateAll) {
              formContext == null ? void 0 : formContext.registerLabelWidth(val, oldVal);
            }
          });
          useResizeObserver(computed(() => {
            var _a2, _b;
            return (_b = (_a2 = el.value) == null ? void 0 : _a2.firstElementChild) != null ? _b : null;
          }), updateLabelWidthFn);
          return () => {
            var _a2, _b;
            if (!slots)
              return null;
            const {
              isAutoWidth
            } = props;
            if (isAutoWidth) {
              const autoLabelWidth = formContext == null ? void 0 : formContext.autoLabelWidth;
              const hasLabel = formItemContext == null ? void 0 : formItemContext.hasLabel;
              const style = {};
              if (hasLabel && autoLabelWidth && autoLabelWidth !== "auto") {
                const marginWidth = Math.max(0, Number.parseInt(autoLabelWidth, 10) - computedWidth.value);
                const marginPosition = formContext.labelPosition === "left" ? "marginRight" : "marginLeft";
                if (marginWidth) {
                  style[marginPosition] = `${marginWidth}px`;
                }
              }
              return createVNode("div", {
                "ref": el,
                "class": [ns.be("item", "label-wrap")],
                "style": style
              }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
            } else {
              return createVNode(Fragment, {
                "ref": el
              }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
            }
          };
        }
      });
      const _hoisted_1$N = ["role", "aria-labelledby"];
      const __default__$B = defineComponent({
        name: "ElFormItem"
      });
      const _sfc_main$12 = /* @__PURE__ */ defineComponent({
        ...__default__$B,
        props: formItemProps,
        setup(__props, { expose }) {
          const props = __props;
          const slots = useSlots();
          const formContext = inject(formContextKey, void 0);
          const parentFormItemContext = inject(formItemContextKey, void 0);
          const _size = useFormSize(void 0, { formItem: false });
          const ns = useNamespace("form-item");
          const labelId = useId().value;
          const inputIds = ref([]);
          const validateState = ref("");
          const validateStateDebounced = refDebounced(validateState, 100);
          const validateMessage = ref("");
          const formItemRef = ref();
          let initialValue = void 0;
          let isResettingField = false;
          const labelStyle = computed(() => {
            if ((formContext == null ? void 0 : formContext.labelPosition) === "top") {
              return {};
            }
            const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (labelWidth)
              return { width: labelWidth };
            return {};
          });
          const contentStyle = computed(() => {
            if ((formContext == null ? void 0 : formContext.labelPosition) === "top" || (formContext == null ? void 0 : formContext.inline)) {
              return {};
            }
            if (!props.label && !props.labelWidth && isNested) {
              return {};
            }
            const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (!props.label && !slots.label) {
              return { marginLeft: labelWidth };
            }
            return {};
          });
          const formItemClasses = computed(() => [
            ns.b(),
            ns.m(_size.value),
            ns.is("error", validateState.value === "error"),
            ns.is("validating", validateState.value === "validating"),
            ns.is("success", validateState.value === "success"),
            ns.is("required", isRequired.value || props.required),
            ns.is("no-asterisk", formContext == null ? void 0 : formContext.hideRequiredAsterisk),
            (formContext == null ? void 0 : formContext.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
            { [ns.m("feedback")]: formContext == null ? void 0 : formContext.statusIcon }
          ]);
          const _inlineMessage = computed(() => isBoolean(props.inlineMessage) ? props.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);
          const validateClasses = computed(() => [
            ns.e("error"),
            { [ns.em("error", "inline")]: _inlineMessage.value }
          ]);
          const propString = computed(() => {
            if (!props.prop)
              return "";
            return isString$1(props.prop) ? props.prop : props.prop.join(".");
          });
          const hasLabel = computed(() => {
            return !!(props.label || slots.label);
          });
          const labelFor = computed(() => {
            return props.for || inputIds.value.length === 1 ? inputIds.value[0] : void 0;
          });
          const isGroup = computed(() => {
            return !labelFor.value && hasLabel.value;
          });
          const isNested = !!parentFormItemContext;
          const fieldValue = computed(() => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props.prop) {
              return;
            }
            return getProp(model, props.prop).value;
          });
          const normalizedRules = computed(() => {
            const { required: required2 } = props;
            const rules2 = [];
            if (props.rules) {
              rules2.push(...castArray(props.rules));
            }
            const formRules = formContext == null ? void 0 : formContext.rules;
            if (formRules && props.prop) {
              const _rules = getProp(formRules, props.prop).value;
              if (_rules) {
                rules2.push(...castArray(_rules));
              }
            }
            if (required2 !== void 0) {
              const requiredRules = rules2.map((rule, i2) => [rule, i2]).filter(([rule]) => Object.keys(rule).includes("required"));
              if (requiredRules.length > 0) {
                for (const [rule, i2] of requiredRules) {
                  if (rule.required === required2)
                    continue;
                  rules2[i2] = { ...rule, required: required2 };
                }
              } else {
                rules2.push({ required: required2 });
              }
            }
            return rules2;
          });
          const validateEnabled = computed(() => normalizedRules.value.length > 0);
          const getFilteredRule = (trigger2) => {
            const rules2 = normalizedRules.value;
            return rules2.filter((rule) => {
              if (!rule.trigger || !trigger2)
                return true;
              if (Array.isArray(rule.trigger)) {
                return rule.trigger.includes(trigger2);
              } else {
                return rule.trigger === trigger2;
              }
            }).map(({ trigger: trigger22, ...rule }) => rule);
          };
          const isRequired = computed(() => normalizedRules.value.some((rule) => rule.required));
          const shouldShowError = computed(() => {
            var _a2;
            return validateStateDebounced.value === "error" && props.showMessage && ((_a2 = formContext == null ? void 0 : formContext.showMessage) != null ? _a2 : true);
          });
          const currentLabel = computed(() => `${props.label || ""}${(formContext == null ? void 0 : formContext.labelSuffix) || ""}`);
          const setValidationState = (state) => {
            validateState.value = state;
          };
          const onValidationFailed = (error) => {
            var _a2, _b;
            const { errors, fields } = error;
            if (!errors || !fields) {
              console.error(error);
            }
            setValidationState("error");
            validateMessage.value = errors ? (_b = (_a2 = errors == null ? void 0 : errors[0]) == null ? void 0 : _a2.message) != null ? _b : `${props.prop} is required` : "";
            formContext == null ? void 0 : formContext.emit("validate", props.prop, false, validateMessage.value);
          };
          const onValidationSucceeded = () => {
            setValidationState("success");
            formContext == null ? void 0 : formContext.emit("validate", props.prop, true, "");
          };
          const doValidate = async (rules2) => {
            const modelName = propString.value;
            const validator = new Schema({
              [modelName]: rules2
            });
            return validator.validate({ [modelName]: fieldValue.value }, { firstFields: true }).then(() => {
              onValidationSucceeded();
              return true;
            }).catch((err) => {
              onValidationFailed(err);
              return Promise.reject(err);
            });
          };
          const validate = async (trigger2, callback) => {
            if (isResettingField || !props.prop) {
              return false;
            }
            const hasCallback = isFunction$1(callback);
            if (!validateEnabled.value) {
              callback == null ? void 0 : callback(false);
              return false;
            }
            const rules2 = getFilteredRule(trigger2);
            if (rules2.length === 0) {
              callback == null ? void 0 : callback(true);
              return true;
            }
            setValidationState("validating");
            return doValidate(rules2).then(() => {
              callback == null ? void 0 : callback(true);
              return true;
            }).catch((err) => {
              const { fields } = err;
              callback == null ? void 0 : callback(false, fields);
              return hasCallback ? false : Promise.reject(fields);
            });
          };
          const clearValidate = () => {
            setValidationState("");
            validateMessage.value = "";
            isResettingField = false;
          };
          const resetField = async () => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props.prop)
              return;
            const computedValue = getProp(model, props.prop);
            isResettingField = true;
            computedValue.value = clone(initialValue);
            await nextTick();
            clearValidate();
            isResettingField = false;
          };
          const addInputId = (id2) => {
            if (!inputIds.value.includes(id2)) {
              inputIds.value.push(id2);
            }
          };
          const removeInputId = (id2) => {
            inputIds.value = inputIds.value.filter((listId) => listId !== id2);
          };
          watch(() => props.error, (val) => {
            validateMessage.value = val || "";
            setValidationState(val ? "error" : "");
          }, { immediate: true });
          watch(() => props.validateStatus, (val) => setValidationState(val || ""));
          const context = reactive({
            ...toRefs(props),
            $el: formItemRef,
            size: _size,
            validateState,
            labelId,
            inputIds,
            isGroup,
            hasLabel,
            addInputId,
            removeInputId,
            resetField,
            clearValidate,
            validate
          });
          provide(formItemContextKey, context);
          onMounted(() => {
            if (props.prop) {
              formContext == null ? void 0 : formContext.addField(context);
              initialValue = clone(fieldValue.value);
            }
          });
          onBeforeUnmount(() => {
            formContext == null ? void 0 : formContext.removeField(context);
          });
          expose({
            size: _size,
            validateMessage,
            validateState,
            validate,
            clearValidate,
            resetField
          });
          return (_ctx, _cache) => {
            var _a2;
            return openBlock(), createElementBlock("div", {
              ref_key: "formItemRef",
              ref: formItemRef,
              class: normalizeClass(unref(formItemClasses)),
              role: unref(isGroup) ? "group" : void 0,
              "aria-labelledby": unref(isGroup) ? unref(labelId) : void 0
            }, [
              createVNode(unref(FormLabelWrap), {
                "is-auto-width": unref(labelStyle).width === "auto",
                "update-all": ((_a2 = unref(formContext)) == null ? void 0 : _a2.labelWidth) === "auto"
              }, {
                default: withCtx(() => [
                  unref(hasLabel) ? (openBlock(), createBlock(resolveDynamicComponent(unref(labelFor) ? "label" : "div"), {
                    key: 0,
                    id: unref(labelId),
                    for: unref(labelFor),
                    class: normalizeClass(unref(ns).e("label")),
                    style: normalizeStyle(unref(labelStyle))
                  }, {
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "label", { label: unref(currentLabel) }, () => [
                        createTextVNode(toDisplayString(unref(currentLabel)), 1)
                      ])
                    ]),
                    _: 3
                  }, 8, ["id", "for", "class", "style"])) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["is-auto-width", "update-all"]),
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).e("content")),
                style: normalizeStyle(unref(contentStyle))
              }, [
                renderSlot(_ctx.$slots, "default"),
                createVNode(TransitionGroup, {
                  name: `${unref(ns).namespace.value}-zoom-in-top`
                }, {
                  default: withCtx(() => [
                    unref(shouldShowError) ? renderSlot(_ctx.$slots, "error", {
                      key: 0,
                      error: validateMessage.value
                    }, () => [
                      createBaseVNode("div", {
                        class: normalizeClass(unref(validateClasses))
                      }, toDisplayString(validateMessage.value), 3)
                    ]) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["name"])
              ], 6)
            ], 10, _hoisted_1$N);
          };
        }
      });
      var FormItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$12, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form-item.vue"]]);
      const ElForm = withInstall(Form, {
        FormItem
      });
      const ElFormItem = withNoopInstall(FormItem);
      let hiddenTextarea = void 0;
      const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  ${isFirefox() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
      const CONTEXT_STYLE = [
        "letter-spacing",
        "line-height",
        "padding-top",
        "padding-bottom",
        "font-family",
        "font-weight",
        "font-size",
        "text-rendering",
        "text-transform",
        "width",
        "text-indent",
        "padding-left",
        "padding-right",
        "border-width",
        "box-sizing"
      ];
      function calculateNodeStyling(targetElement) {
        const style = window.getComputedStyle(targetElement);
        const boxSizing = style.getPropertyValue("box-sizing");
        const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
        const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
        const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
        return { contextStyle, paddingSize, borderSize, boxSizing };
      }
      function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
        var _a2;
        if (!hiddenTextarea) {
          hiddenTextarea = document.createElement("textarea");
          document.body.appendChild(hiddenTextarea);
        }
        const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
        hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
        hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
        let height = hiddenTextarea.scrollHeight;
        const result = {};
        if (boxSizing === "border-box") {
          height = height + borderSize;
        } else if (boxSizing === "content-box") {
          height = height - paddingSize;
        }
        hiddenTextarea.value = "";
        const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (isNumber(minRows)) {
          let minHeight = singleRowHeight * minRows;
          if (boxSizing === "border-box") {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
          result.minHeight = `${minHeight}px`;
        }
        if (isNumber(maxRows)) {
          let maxHeight = singleRowHeight * maxRows;
          if (boxSizing === "border-box") {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          height = Math.min(maxHeight, height);
        }
        result.height = `${height}px`;
        (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
        hiddenTextarea = void 0;
        return result;
      }
      const inputProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        size: useSizeProp,
        disabled: Boolean,
        modelValue: {
          type: definePropType([
            String,
            Number,
            Object
          ]),
          default: ""
        },
        type: {
          type: String,
          default: "text"
        },
        resize: {
          type: String,
          values: ["none", "both", "horizontal", "vertical"]
        },
        autosize: {
          type: definePropType([Boolean, Object]),
          default: false
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        formatter: {
          type: Function
        },
        parser: {
          type: Function
        },
        placeholder: {
          type: String
        },
        form: {
          type: String
        },
        readonly: {
          type: Boolean,
          default: false
        },
        clearable: {
          type: Boolean,
          default: false
        },
        showPassword: {
          type: Boolean,
          default: false
        },
        showWordLimit: {
          type: Boolean,
          default: false
        },
        suffixIcon: {
          type: iconPropType
        },
        prefixIcon: {
          type: iconPropType
        },
        containerRole: {
          type: String,
          default: void 0
        },
        label: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        inputStyle: {
          type: definePropType([Object, Array, String]),
          default: () => mutable({})
        }
      });
      const inputEmits = {
        [UPDATE_MODEL_EVENT]: (value) => isString$1(value),
        input: (value) => isString$1(value),
        change: (value) => isString$1(value),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true,
        mouseleave: (evt) => evt instanceof MouseEvent,
        mouseenter: (evt) => evt instanceof MouseEvent,
        keydown: (evt) => evt instanceof Event,
        compositionstart: (evt) => evt instanceof CompositionEvent,
        compositionupdate: (evt) => evt instanceof CompositionEvent,
        compositionend: (evt) => evt instanceof CompositionEvent
      };
      const _hoisted_1$M = ["role"];
      const _hoisted_2$B = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form"];
      const _hoisted_3$s = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form"];
      const __default__$A = defineComponent({
        name: "ElInput",
        inheritAttrs: false
      });
      const _sfc_main$11 = /* @__PURE__ */ defineComponent({
        ...__default__$A,
        props: inputProps,
        emits: inputEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const rawAttrs = useAttrs$1();
          const slots = useSlots();
          const containerAttrs = computed(() => {
            const comboBoxAttrs = {};
            if (props.containerRole === "combobox") {
              comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
              comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
              comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
            }
            return comboBoxAttrs;
          });
          const containerKls = computed(() => [
            props.type === "textarea" ? nsTextarea.b() : nsInput.b(),
            nsInput.m(inputSize.value),
            nsInput.is("disabled", inputDisabled.value),
            nsInput.is("exceed", inputExceed.value),
            {
              [nsInput.b("group")]: slots.prepend || slots.append,
              [nsInput.bm("group", "append")]: slots.append,
              [nsInput.bm("group", "prepend")]: slots.prepend,
              [nsInput.m("prefix")]: slots.prefix || props.prefixIcon,
              [nsInput.m("suffix")]: slots.suffix || props.suffixIcon || props.clearable || props.showPassword,
              [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value
            },
            rawAttrs.class
          ]);
          const wrapperKls = computed(() => [
            nsInput.e("wrapper"),
            nsInput.is("focus", isFocused.value)
          ]);
          const attrs = useAttrs({
            excludeKeys: computed(() => {
              return Object.keys(containerAttrs.value);
            })
          });
          const { form, formItem } = useFormItem();
          const { inputId } = useFormItemInputId(props, {
            formItemContext: formItem
          });
          const inputSize = useFormSize();
          const inputDisabled = useFormDisabled();
          const nsInput = useNamespace("input");
          const nsTextarea = useNamespace("textarea");
          const input = shallowRef();
          const textarea = shallowRef();
          const hovering = ref(false);
          const isComposing = ref(false);
          const passwordVisible = ref(false);
          const countStyle = ref();
          const textareaCalcStyle = shallowRef(props.inputStyle);
          const _ref = computed(() => input.value || textarea.value);
          const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
            afterBlur() {
              var _a2;
              if (props.validateEvent) {
                (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn());
              }
            }
          });
          const needStatusIcon = computed(() => {
            var _a2;
            return (_a2 = form == null ? void 0 : form.statusIcon) != null ? _a2 : false;
          });
          const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
          const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
          const passwordIcon = computed(() => passwordVisible.value ? view_default : hide_default);
          const containerStyle = computed(() => [
            rawAttrs.style,
            props.inputStyle
          ]);
          const textareaStyle = computed(() => [
            props.inputStyle,
            textareaCalcStyle.value,
            { resize: props.resize }
          ]);
          const nativeInputValue = computed(() => isNil(props.modelValue) ? "" : String(props.modelValue));
          const showClear = computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
          const showPwdVisible = computed(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || isFocused.value));
          const isWordLimitVisible = computed(() => props.showWordLimit && !!attrs.value.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
          const textLength = computed(() => nativeInputValue.value.length);
          const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(attrs.value.maxlength));
          const suffixVisible = computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
          const [recordCursor, setCursor] = useCursor(input);
          useResizeObserver(textarea, (entries) => {
            onceInitSizeTextarea();
            if (!isWordLimitVisible.value || props.resize !== "both")
              return;
            const entry = entries[0];
            const { width } = entry.contentRect;
            countStyle.value = {
              right: `calc(100% - ${width + 15 + 6}px)`
            };
          });
          const resizeTextarea = () => {
            const { type: type2, autosize } = props;
            if (!isClient$1 || type2 !== "textarea" || !textarea.value)
              return;
            if (autosize) {
              const minRows = isObject$1(autosize) ? autosize.minRows : void 0;
              const maxRows = isObject$1(autosize) ? autosize.maxRows : void 0;
              const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
              textareaCalcStyle.value = {
                overflowY: "hidden",
                ...textareaStyle2
              };
              nextTick(() => {
                textarea.value.offsetHeight;
                textareaCalcStyle.value = textareaStyle2;
              });
            } else {
              textareaCalcStyle.value = {
                minHeight: calcTextareaHeight(textarea.value).minHeight
              };
            }
          };
          const createOnceInitResize = (resizeTextarea2) => {
            let isInit = false;
            return () => {
              var _a2;
              if (isInit || !props.autosize)
                return;
              const isElHidden = ((_a2 = textarea.value) == null ? void 0 : _a2.offsetParent) === null;
              if (!isElHidden) {
                resizeTextarea2();
                isInit = true;
              }
            };
          };
          const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
          const setNativeInputValue = () => {
            const input2 = _ref.value;
            const formatterValue = props.formatter ? props.formatter(nativeInputValue.value) : nativeInputValue.value;
            if (!input2 || input2.value === formatterValue)
              return;
            input2.value = formatterValue;
          };
          const handleInput = async (event) => {
            recordCursor();
            let { value } = event.target;
            if (props.formatter) {
              value = props.parser ? props.parser(value) : value;
            }
            if (isComposing.value)
              return;
            if (value === nativeInputValue.value) {
              setNativeInputValue();
              return;
            }
            emit2(UPDATE_MODEL_EVENT, value);
            emit2("input", value);
            await nextTick();
            setNativeInputValue();
            setCursor();
          };
          const handleChange = (event) => {
            emit2("change", event.target.value);
          };
          const handleCompositionStart = (event) => {
            emit2("compositionstart", event);
            isComposing.value = true;
          };
          const handleCompositionUpdate = (event) => {
            var _a2;
            emit2("compositionupdate", event);
            const text = (_a2 = event.target) == null ? void 0 : _a2.value;
            const lastCharacter = text[text.length - 1] || "";
            isComposing.value = !isKorean(lastCharacter);
          };
          const handleCompositionEnd = (event) => {
            emit2("compositionend", event);
            if (isComposing.value) {
              isComposing.value = false;
              handleInput(event);
            }
          };
          const handlePasswordVisible = () => {
            passwordVisible.value = !passwordVisible.value;
            focus();
          };
          const focus = async () => {
            var _a2;
            await nextTick();
            (_a2 = _ref.value) == null ? void 0 : _a2.focus();
          };
          const blur = () => {
            var _a2;
            return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
          };
          const handleMouseLeave = (evt) => {
            hovering.value = false;
            emit2("mouseleave", evt);
          };
          const handleMouseEnter = (evt) => {
            hovering.value = true;
            emit2("mouseenter", evt);
          };
          const handleKeydown = (evt) => {
            emit2("keydown", evt);
          };
          const select = () => {
            var _a2;
            (_a2 = _ref.value) == null ? void 0 : _a2.select();
          };
          const clear2 = () => {
            emit2(UPDATE_MODEL_EVENT, "");
            emit2("change", "");
            emit2("clear");
            emit2("input", "");
          };
          watch(() => props.modelValue, () => {
            var _a2;
            nextTick(() => resizeTextarea());
            if (props.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
            }
          });
          watch(nativeInputValue, () => setNativeInputValue());
          watch(() => props.type, async () => {
            await nextTick();
            setNativeInputValue();
            resizeTextarea();
          });
          onMounted(() => {
            if (!props.formatter && props.parser)
              ;
            setNativeInputValue();
            nextTick(resizeTextarea);
          });
          expose({
            input,
            textarea,
            ref: _ref,
            textareaStyle,
            autosize: toRef$1(props, "autosize"),
            focus,
            blur,
            select,
            clear: clear2,
            resizeTextarea
          });
          return (_ctx, _cache) => {
            return withDirectives((openBlock(), createElementBlock("div", mergeProps(unref(containerAttrs), {
              class: unref(containerKls),
              style: unref(containerStyle),
              role: _ctx.containerRole,
              onMouseenter: handleMouseEnter,
              onMouseleave: handleMouseLeave
            }), [
              createCommentVNode(" input "),
              _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createCommentVNode(" prepend slot "),
                _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(nsInput).be("group", "prepend"))
                }, [
                  renderSlot(_ctx.$slots, "prepend")
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  ref_key: "wrapperRef",
                  ref: wrapperRef,
                  class: normalizeClass(unref(wrapperKls))
                }, [
                  createCommentVNode(" prefix slot "),
                  _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(nsInput).e("prefix"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(nsInput).e("prefix-inner"))
                    }, [
                      renderSlot(_ctx.$slots, "prefix"),
                      _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass(unref(nsInput).e("icon"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true),
                  createBaseVNode("input", mergeProps({
                    id: unref(inputId),
                    ref_key: "input",
                    ref: input,
                    class: unref(nsInput).e("inner")
                  }, unref(attrs), {
                    type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                    disabled: unref(inputDisabled),
                    formatter: _ctx.formatter,
                    parser: _ctx.parser,
                    readonly: _ctx.readonly,
                    autocomplete: _ctx.autocomplete,
                    tabindex: _ctx.tabindex,
                    "aria-label": _ctx.label,
                    placeholder: _ctx.placeholder,
                    style: _ctx.inputStyle,
                    form: props.form,
                    onCompositionstart: handleCompositionStart,
                    onCompositionupdate: handleCompositionUpdate,
                    onCompositionend: handleCompositionEnd,
                    onInput: handleInput,
                    onFocus: _cache[0] || (_cache[0] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                    onBlur: _cache[1] || (_cache[1] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                    onChange: handleChange,
                    onKeydown: handleKeydown
                  }), null, 16, _hoisted_2$B),
                  createCommentVNode(" suffix slot "),
                  unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(unref(nsInput).e("suffix"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(nsInput).e("suffix-inner"))
                    }, [
                      !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        renderSlot(_ctx.$slots, "suffix"),
                        _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                          key: 0,
                          class: normalizeClass(unref(nsInput).e("icon"))
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : createCommentVNode("v-if", true)
                      ], 64)) : createCommentVNode("v-if", true),
                      unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 1,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                        onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                        onClick: clear2
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(circle_close_default))
                        ]),
                        _: 1
                      }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                      unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 2,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                        onClick: handlePasswordVisible
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true),
                      unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                        key: 3,
                        class: normalizeClass(unref(nsInput).e("count"))
                      }, [
                        createBaseVNode("span", {
                          class: normalizeClass(unref(nsInput).e("count-inner"))
                        }, toDisplayString(unref(textLength)) + " / " + toDisplayString(unref(attrs).maxlength), 3)
                      ], 2)) : createCommentVNode("v-if", true),
                      unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 4,
                        class: normalizeClass([
                          unref(nsInput).e("icon"),
                          unref(nsInput).e("validateIcon"),
                          unref(nsInput).is("loading", unref(validateState) === "validating")
                        ])
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true)
                ], 2),
                createCommentVNode(" append slot "),
                _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(nsInput).be("group", "append"))
                }, [
                  renderSlot(_ctx.$slots, "append")
                ], 2)) : createCommentVNode("v-if", true)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createCommentVNode(" textarea "),
                createBaseVNode("textarea", mergeProps({
                  id: unref(inputId),
                  ref_key: "textarea",
                  ref: textarea,
                  class: unref(nsTextarea).e("inner")
                }, unref(attrs), {
                  tabindex: _ctx.tabindex,
                  disabled: unref(inputDisabled),
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  style: unref(textareaStyle),
                  "aria-label": _ctx.label,
                  placeholder: _ctx.placeholder,
                  form: props.form,
                  onCompositionstart: handleCompositionStart,
                  onCompositionupdate: handleCompositionUpdate,
                  onCompositionend: handleCompositionEnd,
                  onInput: handleInput,
                  onFocus: _cache[2] || (_cache[2] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                  onBlur: _cache[3] || (_cache[3] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, _hoisted_3$s),
                unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  style: normalizeStyle(countStyle.value),
                  class: normalizeClass(unref(nsInput).e("count"))
                }, toDisplayString(unref(textLength)) + " / " + toDisplayString(unref(attrs).maxlength), 7)) : createCommentVNode("v-if", true)
              ], 64))
            ], 16, _hoisted_1$M)), [
              [vShow, _ctx.type !== "hidden"]
            ]);
          };
        }
      });
      var Input = /* @__PURE__ */ _export_sfc$1(_sfc_main$11, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
      const ElInput = withInstall(Input);
      const GAP = 4;
      const BAR_MAP = {
        vertical: {
          offset: "offsetHeight",
          scroll: "scrollTop",
          scrollSize: "scrollHeight",
          size: "height",
          key: "vertical",
          axis: "Y",
          client: "clientY",
          direction: "top"
        },
        horizontal: {
          offset: "offsetWidth",
          scroll: "scrollLeft",
          scrollSize: "scrollWidth",
          size: "width",
          key: "horizontal",
          axis: "X",
          client: "clientX",
          direction: "left"
        }
      };
      const renderThumbStyle$1 = ({
        move,
        size: size2,
        bar
      }) => ({
        [bar.size]: size2,
        transform: `translate${bar.axis}(${move}%)`
      });
      const scrollbarContextKey = Symbol("scrollbarContextKey");
      const thumbProps = buildProps({
        vertical: Boolean,
        size: String,
        move: Number,
        ratio: {
          type: Number,
          required: true
        },
        always: Boolean
      });
      const COMPONENT_NAME$5 = "Thumb";
      const _sfc_main$10 = /* @__PURE__ */ defineComponent({
        __name: "thumb",
        props: thumbProps,
        setup(__props) {
          const props = __props;
          const scrollbar = inject(scrollbarContextKey);
          const ns = useNamespace("scrollbar");
          if (!scrollbar)
            throwError(COMPONENT_NAME$5, "can not inject scrollbar context");
          const instance = ref();
          const thumb = ref();
          const thumbState = ref({});
          const visible = ref(false);
          let cursorDown = false;
          let cursorLeave = false;
          let originalOnSelectStart = isClient$1 ? document.onselectstart : null;
          const bar = computed(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
          const thumbStyle = computed(() => renderThumbStyle$1({
            size: props.size,
            move: props.move,
            bar: bar.value
          }));
          const offsetRatio = computed(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
          const clickThumbHandler = (e2) => {
            var _a2;
            e2.stopPropagation();
            if (e2.ctrlKey || [1, 2].includes(e2.button))
              return;
            (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
            startDrag(e2);
            const el = e2.currentTarget;
            if (!el)
              return;
            thumbState.value[bar.value.axis] = el[bar.value.offset] - (e2[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
          };
          const clickTrackHandler = (e2) => {
            if (!thumb.value || !instance.value || !scrollbar.wrapElement)
              return;
            const offset = Math.abs(e2.target.getBoundingClientRect()[bar.value.direction] - e2[bar.value.client]);
            const thumbHalf = thumb.value[bar.value.offset] / 2;
            const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const startDrag = (e2) => {
            e2.stopImmediatePropagation();
            cursorDown = true;
            document.addEventListener("mousemove", mouseMoveDocumentHandler);
            document.addEventListener("mouseup", mouseUpDocumentHandler);
            originalOnSelectStart = document.onselectstart;
            document.onselectstart = () => false;
          };
          const mouseMoveDocumentHandler = (e2) => {
            if (!instance.value || !thumb.value)
              return;
            if (cursorDown === false)
              return;
            const prevPage = thumbState.value[bar.value.axis];
            if (!prevPage)
              return;
            const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e2[bar.value.client]) * -1;
            const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
            const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const mouseUpDocumentHandler = () => {
            cursorDown = false;
            thumbState.value[bar.value.axis] = 0;
            document.removeEventListener("mousemove", mouseMoveDocumentHandler);
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
            restoreOnselectstart();
            if (cursorLeave)
              visible.value = false;
          };
          const mouseMoveScrollbarHandler = () => {
            cursorLeave = false;
            visible.value = !!props.size;
          };
          const mouseLeaveScrollbarHandler = () => {
            cursorLeave = true;
            visible.value = cursorDown;
          };
          onBeforeUnmount(() => {
            restoreOnselectstart();
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
          });
          const restoreOnselectstart = () => {
            if (document.onselectstart !== originalOnSelectStart)
              document.onselectstart = originalOnSelectStart;
          };
          useEventListener$1(toRef$1(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
          useEventListener$1(toRef$1(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  ref_key: "instance",
                  ref: instance,
                  class: normalizeClass([unref(ns).e("bar"), unref(ns).is(unref(bar).key)]),
                  onMousedown: clickTrackHandler
                }, [
                  createBaseVNode("div", {
                    ref_key: "thumb",
                    ref: thumb,
                    class: normalizeClass(unref(ns).e("thumb")),
                    style: normalizeStyle(unref(thumbStyle)),
                    onMousedown: clickThumbHandler
                  }, null, 38)
                ], 34), [
                  [vShow, _ctx.always || visible.value]
                ])
              ]),
              _: 1
            }, 8, ["name"]);
          };
        }
      });
      var Thumb = /* @__PURE__ */ _export_sfc$1(_sfc_main$10, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
      const barProps = buildProps({
        always: {
          type: Boolean,
          default: true
        },
        width: String,
        height: String,
        ratioX: {
          type: Number,
          default: 1
        },
        ratioY: {
          type: Number,
          default: 1
        }
      });
      const _sfc_main$$ = /* @__PURE__ */ defineComponent({
        __name: "bar",
        props: barProps,
        setup(__props, { expose }) {
          const props = __props;
          const moveX = ref(0);
          const moveY = ref(0);
          const handleScroll = (wrap) => {
            if (wrap) {
              const offsetHeight = wrap.offsetHeight - GAP;
              const offsetWidth = wrap.offsetWidth - GAP;
              moveY.value = wrap.scrollTop * 100 / offsetHeight * props.ratioY;
              moveX.value = wrap.scrollLeft * 100 / offsetWidth * props.ratioX;
            }
          };
          expose({
            handleScroll
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(Thumb, {
                move: moveX.value,
                ratio: _ctx.ratioX,
                size: _ctx.width,
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"]),
              createVNode(Thumb, {
                move: moveY.value,
                ratio: _ctx.ratioY,
                size: _ctx.height,
                vertical: "",
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"])
            ], 64);
          };
        }
      });
      var Bar = /* @__PURE__ */ _export_sfc$1(_sfc_main$$, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
      const scrollbarProps = buildProps({
        height: {
          type: [String, Number],
          default: ""
        },
        maxHeight: {
          type: [String, Number],
          default: ""
        },
        native: {
          type: Boolean,
          default: false
        },
        wrapStyle: {
          type: definePropType([String, Object, Array]),
          default: ""
        },
        wrapClass: {
          type: [String, Array],
          default: ""
        },
        viewClass: {
          type: [String, Array],
          default: ""
        },
        viewStyle: {
          type: [String, Array, Object],
          default: ""
        },
        noresize: Boolean,
        tag: {
          type: String,
          default: "div"
        },
        always: Boolean,
        minSize: {
          type: Number,
          default: 20
        }
      });
      const scrollbarEmits = {
        scroll: ({
          scrollTop,
          scrollLeft
        }) => [scrollTop, scrollLeft].every(isNumber)
      };
      const COMPONENT_NAME$4 = "ElScrollbar";
      const __default__$z = defineComponent({
        name: COMPONENT_NAME$4
      });
      const _sfc_main$_ = /* @__PURE__ */ defineComponent({
        ...__default__$z,
        props: scrollbarProps,
        emits: scrollbarEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const ns = useNamespace("scrollbar");
          let stopResizeObserver = void 0;
          let stopResizeListener = void 0;
          const scrollbarRef = ref();
          const wrapRef = ref();
          const resizeRef = ref();
          const sizeWidth = ref("0");
          const sizeHeight = ref("0");
          const barRef = ref();
          const ratioY = ref(1);
          const ratioX = ref(1);
          const style = computed(() => {
            const style2 = {};
            if (props.height)
              style2.height = addUnit(props.height);
            if (props.maxHeight)
              style2.maxHeight = addUnit(props.maxHeight);
            return [props.wrapStyle, style2];
          });
          const wrapKls = computed(() => {
            return [
              props.wrapClass,
              ns.e("wrap"),
              { [ns.em("wrap", "hidden-default")]: !props.native }
            ];
          });
          const resizeKls = computed(() => {
            return [ns.e("view"), props.viewClass];
          });
          const handleScroll = () => {
            var _a2;
            if (wrapRef.value) {
              (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
              emit2("scroll", {
                scrollTop: wrapRef.value.scrollTop,
                scrollLeft: wrapRef.value.scrollLeft
              });
            }
          };
          function scrollTo(arg1, arg2) {
            if (isObject$1(arg1)) {
              wrapRef.value.scrollTo(arg1);
            } else if (isNumber(arg1) && isNumber(arg2)) {
              wrapRef.value.scrollTo(arg1, arg2);
            }
          }
          const setScrollTop = (value) => {
            if (!isNumber(value)) {
              return;
            }
            wrapRef.value.scrollTop = value;
          };
          const setScrollLeft = (value) => {
            if (!isNumber(value)) {
              return;
            }
            wrapRef.value.scrollLeft = value;
          };
          const update = () => {
            if (!wrapRef.value)
              return;
            const offsetHeight = wrapRef.value.offsetHeight - GAP;
            const offsetWidth = wrapRef.value.offsetWidth - GAP;
            const originalHeight = offsetHeight ** 2 / wrapRef.value.scrollHeight;
            const originalWidth = offsetWidth ** 2 / wrapRef.value.scrollWidth;
            const height = Math.max(originalHeight, props.minSize);
            const width = Math.max(originalWidth, props.minSize);
            ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
            ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
            sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
            sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
          };
          watch(() => props.noresize, (noresize) => {
            if (noresize) {
              stopResizeObserver == null ? void 0 : stopResizeObserver();
              stopResizeListener == null ? void 0 : stopResizeListener();
            } else {
              ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update));
              stopResizeListener = useEventListener$1("resize", update);
            }
          }, { immediate: true });
          watch(() => [props.maxHeight, props.height], () => {
            if (!props.native)
              nextTick(() => {
                var _a2;
                update();
                if (wrapRef.value) {
                  (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
                }
              });
          });
          provide(scrollbarContextKey, reactive({
            scrollbarElement: scrollbarRef,
            wrapElement: wrapRef
          }));
          onMounted(() => {
            if (!props.native)
              nextTick(() => {
                update();
              });
          });
          onUpdated(() => update());
          expose({
            wrapRef,
            update,
            scrollTo,
            setScrollTop,
            setScrollLeft,
            handleScroll
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "scrollbarRef",
              ref: scrollbarRef,
              class: normalizeClass(unref(ns).b())
            }, [
              createBaseVNode("div", {
                ref_key: "wrapRef",
                ref: wrapRef,
                class: normalizeClass(unref(wrapKls)),
                style: normalizeStyle(unref(style)),
                onScroll: handleScroll
              }, [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
                  ref_key: "resizeRef",
                  ref: resizeRef,
                  class: normalizeClass(unref(resizeKls)),
                  style: normalizeStyle(_ctx.viewStyle)
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["class", "style"]))
              ], 38),
              !_ctx.native ? (openBlock(), createBlock(Bar, {
                key: 0,
                ref_key: "barRef",
                ref: barRef,
                height: sizeHeight.value,
                width: sizeWidth.value,
                always: _ctx.always,
                "ratio-x": ratioX.value,
                "ratio-y": ratioY.value
              }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"])) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Scrollbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$_, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);
      const ElScrollbar = withInstall(Scrollbar);
      const POPPER_INJECTION_KEY = Symbol("popper");
      const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
      const roleTypes = [
        "dialog",
        "grid",
        "group",
        "listbox",
        "menu",
        "navigation",
        "tooltip",
        "tree"
      ];
      const popperProps = buildProps({
        role: {
          type: String,
          values: roleTypes,
          default: "tooltip"
        }
      });
      const __default__$y = defineComponent({
        name: "ElPopper",
        inheritAttrs: false
      });
      const _sfc_main$Z = /* @__PURE__ */ defineComponent({
        ...__default__$y,
        props: popperProps,
        setup(__props, { expose }) {
          const props = __props;
          const triggerRef2 = ref();
          const popperInstanceRef = ref();
          const contentRef = ref();
          const referenceRef = ref();
          const role = computed(() => props.role);
          const popperProvides = {
            triggerRef: triggerRef2,
            popperInstanceRef,
            contentRef,
            referenceRef,
            role
          };
          expose(popperProvides);
          provide(POPPER_INJECTION_KEY, popperProvides);
          return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
          };
        }
      });
      var Popper = /* @__PURE__ */ _export_sfc$1(_sfc_main$Z, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
      const popperArrowProps = buildProps({
        arrowOffset: {
          type: Number,
          default: 5
        }
      });
      const __default__$x = defineComponent({
        name: "ElPopperArrow",
        inheritAttrs: false
      });
      const _sfc_main$Y = /* @__PURE__ */ defineComponent({
        ...__default__$x,
        props: popperArrowProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("popper");
          const { arrowOffset, arrowRef, arrowStyle } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
          watch(() => props.arrowOffset, (val) => {
            arrowOffset.value = val;
          });
          onBeforeUnmount(() => {
            arrowRef.value = void 0;
          });
          expose({
            arrowRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              ref_key: "arrowRef",
              ref: arrowRef,
              class: normalizeClass(unref(ns).e("arrow")),
              style: normalizeStyle(unref(arrowStyle)),
              "data-popper-arrow": ""
            }, null, 6);
          };
        }
      });
      var ElPopperArrow = /* @__PURE__ */ _export_sfc$1(_sfc_main$Y, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
      const NAME = "ElOnlyChild";
      const OnlyChild = defineComponent({
        name: NAME,
        setup(_2, {
          slots,
          attrs
        }) {
          var _a2;
          const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
          const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
          return () => {
            var _a22;
            const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
            if (!defaultSlot)
              return null;
            if (defaultSlot.length > 1) {
              return null;
            }
            const firstLegitNode = findFirstLegitChild(defaultSlot);
            if (!firstLegitNode) {
              return null;
            }
            return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
          };
        }
      });
      function findFirstLegitChild(node) {
        if (!node)
          return null;
        const children = node;
        for (const child of children) {
          if (isObject$1(child)) {
            switch (child.type) {
              case Comment:
                continue;
              case Text:
              case "svg":
                return wrapTextContent(child);
              case Fragment:
                return findFirstLegitChild(child.children);
              default:
                return child;
            }
          }
          return wrapTextContent(child);
        }
        return null;
      }
      function wrapTextContent(s2) {
        const ns = useNamespace("only-child");
        return createVNode("span", {
          "class": ns.e("content")
        }, [s2]);
      }
      const popperTriggerProps = buildProps({
        virtualRef: {
          type: definePropType(Object)
        },
        virtualTriggering: Boolean,
        onMouseenter: {
          type: definePropType(Function)
        },
        onMouseleave: {
          type: definePropType(Function)
        },
        onClick: {
          type: definePropType(Function)
        },
        onKeydown: {
          type: definePropType(Function)
        },
        onFocus: {
          type: definePropType(Function)
        },
        onBlur: {
          type: definePropType(Function)
        },
        onContextmenu: {
          type: definePropType(Function)
        },
        id: String,
        open: Boolean
      });
      const __default__$w = defineComponent({
        name: "ElPopperTrigger",
        inheritAttrs: false
      });
      const _sfc_main$X = /* @__PURE__ */ defineComponent({
        ...__default__$w,
        props: popperTriggerProps,
        setup(__props, { expose }) {
          const props = __props;
          const { role, triggerRef: triggerRef2 } = inject(POPPER_INJECTION_KEY, void 0);
          useForwardRef(triggerRef2);
          const ariaControls = computed(() => {
            return ariaHaspopup.value ? props.id : void 0;
          });
          const ariaDescribedby = computed(() => {
            if (role && role.value === "tooltip") {
              return props.open && props.id ? props.id : void 0;
            }
            return void 0;
          });
          const ariaHaspopup = computed(() => {
            if (role && role.value !== "tooltip") {
              return role.value;
            }
            return void 0;
          });
          const ariaExpanded = computed(() => {
            return ariaHaspopup.value ? `${props.open}` : void 0;
          });
          let virtualTriggerAriaStopWatch = void 0;
          onMounted(() => {
            watch(() => props.virtualRef, (virtualEl) => {
              if (virtualEl) {
                triggerRef2.value = unrefElement$1(virtualEl);
              }
            }, {
              immediate: true
            });
            watch(triggerRef2, (el, prevEl) => {
              virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
              virtualTriggerAriaStopWatch = void 0;
              if (isElement(el)) {
                [
                  "onMouseenter",
                  "onMouseleave",
                  "onClick",
                  "onKeydown",
                  "onFocus",
                  "onBlur",
                  "onContextmenu"
                ].forEach((eventName) => {
                  var _a2;
                  const handler = props[eventName];
                  if (handler) {
                    el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                    (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                  }
                });
                virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                  [
                    "aria-controls",
                    "aria-describedby",
                    "aria-haspopup",
                    "aria-expanded"
                  ].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (isElement(prevEl)) {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key) => prevEl.removeAttribute(key));
              }
            }, {
              immediate: true
            });
          });
          onBeforeUnmount(() => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
          });
          expose({
            triggerRef: triggerRef2
          });
          return (_ctx, _cache) => {
            return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
              "aria-controls": unref(ariaControls),
              "aria-describedby": unref(ariaDescribedby),
              "aria-expanded": unref(ariaExpanded),
              "aria-haspopup": unref(ariaHaspopup)
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
          };
        }
      });
      var ElPopperTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$X, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
      const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
      const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
      const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
      const FOCUS_AFTER_TRAPPED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const FOCUSOUT_PREVENTED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
      const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
      const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
      const focusReason = ref();
      const lastUserFocusTimestamp = ref(0);
      const lastAutomatedFocusTimestamp = ref(0);
      let focusReasonUserCount = 0;
      const obtainAllFocusableElements = (element) => {
        const nodes = [];
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (node) => {
            const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
            if (node.disabled || node.hidden || isHiddenInput)
              return NodeFilter.FILTER_SKIP;
            return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          }
        });
        while (walker.nextNode())
          nodes.push(walker.currentNode);
        return nodes;
      };
      const getVisibleElement = (elements, container) => {
        for (const element of elements) {
          if (!isHidden(element, container))
            return element;
        }
      };
      const isHidden = (element, container) => {
        if (getComputedStyle(element).visibility === "hidden")
          return true;
        while (element) {
          if (container && element === container)
            return false;
          if (getComputedStyle(element).display === "none")
            return true;
          element = element.parentElement;
        }
        return false;
      };
      const getEdges = (container) => {
        const focusable = obtainAllFocusableElements(container);
        const first = getVisibleElement(focusable, container);
        const last = getVisibleElement(focusable.reverse(), container);
        return [first, last];
      };
      const isSelectable = (element) => {
        return element instanceof HTMLInputElement && "select" in element;
      };
      const tryFocus = (element, shouldSelect) => {
        if (element && element.focus) {
          const prevFocusedElement = document.activeElement;
          element.focus({ preventScroll: true });
          lastAutomatedFocusTimestamp.value = window.performance.now();
          if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
            element.select();
          }
        }
      };
      function removeFromStack(list, item) {
        const copy = [...list];
        const idx = list.indexOf(item);
        if (idx !== -1) {
          copy.splice(idx, 1);
        }
        return copy;
      }
      const createFocusableStack = () => {
        let stack = [];
        const push = (layer) => {
          const currentLayer = stack[0];
          if (currentLayer && layer !== currentLayer) {
            currentLayer.pause();
          }
          stack = removeFromStack(stack, layer);
          stack.unshift(layer);
        };
        const remove2 = (layer) => {
          var _a2, _b;
          stack = removeFromStack(stack, layer);
          (_b = (_a2 = stack[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
        };
        return {
          push,
          remove: remove2
        };
      };
      const focusFirstDescendant = (elements, shouldSelect = false) => {
        const prevFocusedElement = document.activeElement;
        for (const element of elements) {
          tryFocus(element, shouldSelect);
          if (document.activeElement !== prevFocusedElement)
            return;
        }
      };
      const focusableStack = createFocusableStack();
      const isFocusCausedByUserEvent = () => {
        return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
      };
      const notifyFocusReasonPointer = () => {
        focusReason.value = "pointer";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const notifyFocusReasonKeydown = () => {
        focusReason.value = "keyboard";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const useFocusReason = () => {
        onMounted(() => {
          if (focusReasonUserCount === 0) {
            document.addEventListener("mousedown", notifyFocusReasonPointer);
            document.addEventListener("touchstart", notifyFocusReasonPointer);
            document.addEventListener("keydown", notifyFocusReasonKeydown);
          }
          focusReasonUserCount++;
        });
        onBeforeUnmount(() => {
          focusReasonUserCount--;
          if (focusReasonUserCount <= 0) {
            document.removeEventListener("mousedown", notifyFocusReasonPointer);
            document.removeEventListener("touchstart", notifyFocusReasonPointer);
            document.removeEventListener("keydown", notifyFocusReasonKeydown);
          }
        });
        return {
          focusReason,
          lastUserFocusTimestamp,
          lastAutomatedFocusTimestamp
        };
      };
      const createFocusOutPreventedEvent = (detail) => {
        return new CustomEvent(FOCUSOUT_PREVENTED, {
          ...FOCUSOUT_PREVENTED_OPTS,
          detail
        });
      };
      const _sfc_main$W = defineComponent({
        name: "ElFocusTrap",
        inheritAttrs: false,
        props: {
          loop: Boolean,
          trapped: Boolean,
          focusTrapEl: Object,
          focusStartEl: {
            type: [Object, String],
            default: "first"
          }
        },
        emits: [
          ON_TRAP_FOCUS_EVT,
          ON_RELEASE_FOCUS_EVT,
          "focusin",
          "focusout",
          "focusout-prevented",
          "release-requested"
        ],
        setup(props, { emit: emit2 }) {
          const forwardRef = ref();
          let lastFocusBeforeTrapped;
          let lastFocusAfterTrapped;
          const { focusReason: focusReason2 } = useFocusReason();
          useEscapeKeydown((event) => {
            if (props.trapped && !focusLayer.paused) {
              emit2("release-requested", event);
            }
          });
          const focusLayer = {
            paused: false,
            pause() {
              this.paused = true;
            },
            resume() {
              this.paused = false;
            }
          };
          const onKeydown = (e2) => {
            if (!props.loop && !props.trapped)
              return;
            if (focusLayer.paused)
              return;
            const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e2;
            const { loop } = props;
            const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
            const currentFocusingEl = document.activeElement;
            if (isTabbing && currentFocusingEl) {
              const container = currentTarget;
              const [first, last] = getEdges(container);
              const isTabbable = first && last;
              if (!isTabbable) {
                if (currentFocusingEl === container) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e2.preventDefault();
                  }
                }
              } else {
                if (!shiftKey && currentFocusingEl === last) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e2.preventDefault();
                    if (loop)
                      tryFocus(first, true);
                  }
                } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e2.preventDefault();
                    if (loop)
                      tryFocus(last, true);
                  }
                }
              }
            }
          };
          provide(FOCUS_TRAP_INJECTION_KEY, {
            focusTrapRef: forwardRef,
            onKeydown
          });
          watch(() => props.focusTrapEl, (focusTrapEl) => {
            if (focusTrapEl) {
              forwardRef.value = focusTrapEl;
            }
          }, { immediate: true });
          watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
            if (forwardRef2) {
              forwardRef2.addEventListener("keydown", onKeydown);
              forwardRef2.addEventListener("focusin", onFocusIn);
              forwardRef2.addEventListener("focusout", onFocusOut);
            }
            if (oldForwardRef) {
              oldForwardRef.removeEventListener("keydown", onKeydown);
              oldForwardRef.removeEventListener("focusin", onFocusIn);
              oldForwardRef.removeEventListener("focusout", onFocusOut);
            }
          });
          const trapOnFocus = (e2) => {
            emit2(ON_TRAP_FOCUS_EVT, e2);
          };
          const releaseOnFocus = (e2) => emit2(ON_RELEASE_FOCUS_EVT, e2);
          const onFocusIn = (e2) => {
            const trapContainer = unref(forwardRef);
            if (!trapContainer)
              return;
            const target = e2.target;
            const relatedTarget = e2.relatedTarget;
            const isFocusedInTrap = target && trapContainer.contains(target);
            if (!props.trapped) {
              const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
              if (!isPrevFocusedInTrap) {
                lastFocusBeforeTrapped = relatedTarget;
              }
            }
            if (isFocusedInTrap)
              emit2("focusin", e2);
            if (focusLayer.paused)
              return;
            if (props.trapped) {
              if (isFocusedInTrap) {
                lastFocusAfterTrapped = target;
              } else {
                tryFocus(lastFocusAfterTrapped, true);
              }
            }
          };
          const onFocusOut = (e2) => {
            const trapContainer = unref(forwardRef);
            if (focusLayer.paused || !trapContainer)
              return;
            if (props.trapped) {
              const relatedTarget = e2.relatedTarget;
              if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
                setTimeout(() => {
                  if (!focusLayer.paused && props.trapped) {
                    const focusoutPreventedEvent = createFocusOutPreventedEvent({
                      focusReason: focusReason2.value
                    });
                    emit2("focusout-prevented", focusoutPreventedEvent);
                    if (!focusoutPreventedEvent.defaultPrevented) {
                      tryFocus(lastFocusAfterTrapped, true);
                    }
                  }
                }, 0);
              }
            } else {
              const target = e2.target;
              const isFocusedInTrap = target && trapContainer.contains(target);
              if (!isFocusedInTrap)
                emit2("focusout", e2);
            }
          };
          async function startTrap() {
            await nextTick();
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              focusableStack.push(focusLayer);
              const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
              lastFocusBeforeTrapped = prevFocusedElement;
              const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
              if (!isPrevFocusContained) {
                const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
                trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
                trapContainer.dispatchEvent(focusEvent);
                if (!focusEvent.defaultPrevented) {
                  nextTick(() => {
                    let focusStartEl = props.focusStartEl;
                    if (!isString$1(focusStartEl)) {
                      tryFocus(focusStartEl);
                      if (document.activeElement !== focusStartEl) {
                        focusStartEl = "first";
                      }
                    }
                    if (focusStartEl === "first") {
                      focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                    }
                    if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                      tryFocus(trapContainer);
                    }
                  });
                }
              }
            }
          }
          function stopTrap() {
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
              const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
                ...FOCUS_AFTER_TRAPPED_OPTS,
                detail: {
                  focusReason: focusReason2.value
                }
              });
              trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              trapContainer.dispatchEvent(releasedEvent);
              if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
                tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
              }
              trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus);
              focusableStack.remove(focusLayer);
            }
          }
          onMounted(() => {
            if (props.trapped) {
              startTrap();
            }
            watch(() => props.trapped, (trapped) => {
              if (trapped) {
                startTrap();
              } else {
                stopTrap();
              }
            });
          });
          onBeforeUnmount(() => {
            if (props.trapped) {
              stopTrap();
            }
          });
          return {
            onKeydown
          };
        }
      });
      function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
      }
      var ElFocusTrap = /* @__PURE__ */ _export_sfc$1(_sfc_main$W, [["render", _sfc_render$h], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);
      const POSITIONING_STRATEGIES = ["fixed", "absolute"];
      const popperCoreConfigProps = buildProps({
        boundariesPadding: {
          type: Number,
          default: 0
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: void 0
        },
        gpuAcceleration: {
          type: Boolean,
          default: true
        },
        offset: {
          type: Number,
          default: 12
        },
        placement: {
          type: String,
          values: Ee,
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        strategy: {
          type: String,
          values: POSITIONING_STRATEGIES,
          default: "absolute"
        }
      });
      const popperContentProps = buildProps({
        ...popperCoreConfigProps,
        id: String,
        style: {
          type: definePropType([String, Array, Object])
        },
        className: {
          type: definePropType([String, Array, Object])
        },
        effect: {
          type: String,
          default: "dark"
        },
        visible: Boolean,
        enterable: {
          type: Boolean,
          default: true
        },
        pure: Boolean,
        focusOnShow: {
          type: Boolean,
          default: false
        },
        trapping: {
          type: Boolean,
          default: false
        },
        popperClass: {
          type: definePropType([String, Array, Object])
        },
        popperStyle: {
          type: definePropType([String, Array, Object])
        },
        referenceEl: {
          type: definePropType(Object)
        },
        triggerTargetEl: {
          type: definePropType(Object)
        },
        stopPopperMouseEvent: {
          type: Boolean,
          default: true
        },
        ariaLabel: {
          type: String,
          default: void 0
        },
        virtualTriggering: Boolean,
        zIndex: Number
      });
      const popperContentEmits = {
        mouseenter: (evt) => evt instanceof MouseEvent,
        mouseleave: (evt) => evt instanceof MouseEvent,
        focus: () => true,
        blur: () => true,
        close: () => true
      };
      const buildPopperOptions = (props, modifiers = []) => {
        const { placement, strategy, popperOptions } = props;
        const options = {
          placement,
          strategy,
          ...popperOptions,
          modifiers: [...genModifiers(props), ...modifiers]
        };
        deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
        return options;
      };
      const unwrapMeasurableEl = ($el) => {
        if (!isClient$1)
          return;
        return unrefElement$1($el);
      };
      function genModifiers(options) {
        const { offset, gpuAcceleration, fallbackPlacements } = options;
        return [
          {
            name: "offset",
            options: {
              offset: [0, offset != null ? offset : 12]
            }
          },
          {
            name: "preventOverflow",
            options: {
              padding: {
                top: 2,
                bottom: 2,
                left: 5,
                right: 5
              }
            }
          },
          {
            name: "flip",
            options: {
              padding: 5,
              fallbackPlacements
            }
          },
          {
            name: "computeStyles",
            options: {
              gpuAcceleration
            }
          }
        ];
      }
      function deriveExtraModifiers(options, modifiers) {
        if (modifiers) {
          options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
        }
      }
      const DEFAULT_ARROW_OFFSET = 0;
      const usePopperContent = (props) => {
        const { popperInstanceRef, contentRef, triggerRef: triggerRef2, role } = inject(POPPER_INJECTION_KEY, void 0);
        const arrowRef = ref();
        const arrowOffset = ref();
        const eventListenerModifier = computed(() => {
          return {
            name: "eventListeners",
            enabled: !!props.visible
          };
        });
        const arrowModifier = computed(() => {
          var _a2;
          const arrowEl = unref(arrowRef);
          const offset = (_a2 = unref(arrowOffset)) != null ? _a2 : DEFAULT_ARROW_OFFSET;
          return {
            name: "arrow",
            enabled: !isUndefined$1(arrowEl),
            options: {
              element: arrowEl,
              padding: offset
            }
          };
        });
        const options = computed(() => {
          return {
            onFirstUpdate: () => {
              update();
            },
            ...buildPopperOptions(props, [
              unref(arrowModifier),
              unref(eventListenerModifier)
            ])
          };
        });
        const computedReference = computed(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef2));
        const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options);
        watch(instanceRef, (instance) => popperInstanceRef.value = instance);
        onMounted(() => {
          watch(() => {
            var _a2;
            return (_a2 = unref(computedReference)) == null ? void 0 : _a2.getBoundingClientRect();
          }, () => {
            update();
          });
        });
        return {
          attributes,
          arrowRef,
          contentRef,
          instanceRef,
          state,
          styles,
          role,
          forceUpdate,
          update
        };
      };
      const usePopperContentDOM = (props, {
        attributes,
        styles,
        role
      }) => {
        const { nextZIndex } = useZIndex();
        const ns = useNamespace("popper");
        const contentAttrs = computed(() => unref(attributes).popper);
        const contentZIndex = ref(props.zIndex || nextZIndex());
        const contentClass = computed(() => [
          ns.b(),
          ns.is("pure", props.pure),
          ns.is(props.effect),
          props.popperClass
        ]);
        const contentStyle = computed(() => {
          return [
            { zIndex: unref(contentZIndex) },
            unref(styles).popper,
            props.popperStyle || {}
          ];
        });
        const ariaModal = computed(() => role.value === "dialog" ? "false" : void 0);
        const arrowStyle = computed(() => unref(styles).arrow || {});
        const updateZIndex = () => {
          contentZIndex.value = props.zIndex || nextZIndex();
        };
        return {
          ariaModal,
          arrowStyle,
          contentAttrs,
          contentClass,
          contentStyle,
          contentZIndex,
          updateZIndex
        };
      };
      const usePopperContentFocusTrap = (props, emit2) => {
        const trapped = ref(false);
        const focusStartRef = ref();
        const onFocusAfterTrapped = () => {
          emit2("focus");
        };
        const onFocusAfterReleased = (event) => {
          var _a2;
          if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) !== "pointer") {
            focusStartRef.value = "first";
            emit2("blur");
          }
        };
        const onFocusInTrap = (event) => {
          if (props.visible && !trapped.value) {
            if (event.target) {
              focusStartRef.value = event.target;
            }
            trapped.value = true;
          }
        };
        const onFocusoutPrevented = (event) => {
          if (!props.trapping) {
            if (event.detail.focusReason === "pointer") {
              event.preventDefault();
            }
            trapped.value = false;
          }
        };
        const onReleaseRequested = () => {
          trapped.value = false;
          emit2("close");
        };
        return {
          focusStartRef,
          trapped,
          onFocusAfterReleased,
          onFocusAfterTrapped,
          onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        };
      };
      const __default__$v = defineComponent({
        name: "ElPopperContent"
      });
      const _sfc_main$V = /* @__PURE__ */ defineComponent({
        ...__default__$v,
        props: popperContentProps,
        emits: popperContentEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const {
            focusStartRef,
            trapped,
            onFocusAfterReleased,
            onFocusAfterTrapped,
            onFocusInTrap,
            onFocusoutPrevented,
            onReleaseRequested
          } = usePopperContentFocusTrap(props, emit2);
          const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props);
          const {
            ariaModal,
            arrowStyle,
            contentAttrs,
            contentClass,
            contentStyle,
            updateZIndex
          } = usePopperContentDOM(props, {
            styles,
            attributes,
            role
          });
          const formItemContext = inject(formItemContextKey, void 0);
          const arrowOffset = ref();
          provide(POPPER_CONTENT_INJECTION_KEY, {
            arrowStyle,
            arrowRef,
            arrowOffset
          });
          if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) {
            provide(formItemContextKey, {
              ...formItemContext,
              addInputId: NOOP,
              removeInputId: NOOP
            });
          }
          let triggerTargetAriaStopWatch = void 0;
          const updatePopper = (shouldUpdateZIndex = true) => {
            update();
            shouldUpdateZIndex && updateZIndex();
          };
          const togglePopperAlive = () => {
            updatePopper(false);
            if (props.visible && props.focusOnShow) {
              trapped.value = true;
            } else if (props.visible === false) {
              trapped.value = false;
            }
          };
          onMounted(() => {
            watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
              triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
              triggerTargetAriaStopWatch = void 0;
              const el = unref(triggerTargetEl || contentRef.value);
              const prevEl = unref(prevTriggerTargetEl || contentRef.value);
              if (isElement(el)) {
                triggerTargetAriaStopWatch = watch([role, () => props.ariaLabel, ariaModal, () => props.id], (watches) => {
                  ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (prevEl !== el && isElement(prevEl)) {
                ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                  prevEl.removeAttribute(key);
                });
              }
            }, { immediate: true });
            watch(() => props.visible, togglePopperAlive, { immediate: true });
          });
          onBeforeUnmount(() => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
          });
          expose({
            popperContentRef: contentRef,
            popperInstanceRef: instanceRef,
            updatePopper,
            contentStyle
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", mergeProps({
              ref_key: "contentRef",
              ref: contentRef
            }, unref(contentAttrs), {
              style: unref(contentStyle),
              class: unref(contentClass),
              tabindex: "-1",
              onMouseenter: _cache[0] || (_cache[0] = (e2) => _ctx.$emit("mouseenter", e2)),
              onMouseleave: _cache[1] || (_cache[1] = (e2) => _ctx.$emit("mouseleave", e2))
            }), [
              createVNode(unref(ElFocusTrap), {
                trapped: unref(trapped),
                "trap-on-focus-in": true,
                "focus-trap-el": unref(contentRef),
                "focus-start-el": unref(focusStartRef),
                onFocusAfterTrapped: unref(onFocusAfterTrapped),
                onFocusAfterReleased: unref(onFocusAfterReleased),
                onFocusin: unref(onFocusInTrap),
                onFocusoutPrevented: unref(onFocusoutPrevented),
                onReleaseRequested: unref(onReleaseRequested)
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
            ], 16);
          };
        }
      });
      var ElPopperContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$V, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
      const ElPopper = withInstall(Popper);
      const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
      const useTooltipContentProps = buildProps({
        ...useDelayedToggleProps,
        ...popperContentProps,
        appendTo: {
          type: definePropType([String, Object])
        },
        content: {
          type: String,
          default: ""
        },
        rawContent: {
          type: Boolean,
          default: false
        },
        persistent: Boolean,
        ariaLabel: String,
        visible: {
          type: definePropType(Boolean),
          default: null
        },
        transition: String,
        teleported: {
          type: Boolean,
          default: true
        },
        disabled: Boolean
      });
      const useTooltipTriggerProps = buildProps({
        ...popperTriggerProps,
        disabled: Boolean,
        trigger: {
          type: definePropType([String, Array]),
          default: "hover"
        },
        triggerKeys: {
          type: definePropType(Array),
          default: () => [EVENT_CODE.enter, EVENT_CODE.space]
        }
      });
      const {
        useModelToggleProps: useTooltipModelToggleProps,
        useModelToggleEmits: useTooltipModelToggleEmits,
        useModelToggle: useTooltipModelToggle
      } = createModelToggleComposable("visible");
      const useTooltipProps = buildProps({
        ...popperProps,
        ...useTooltipModelToggleProps,
        ...useTooltipContentProps,
        ...useTooltipTriggerProps,
        ...popperArrowProps,
        showArrow: {
          type: Boolean,
          default: true
        }
      });
      const tooltipEmits = [
        ...useTooltipModelToggleEmits,
        "before-show",
        "before-hide",
        "show",
        "hide",
        "open",
        "close"
      ];
      const isTriggerType = (trigger2, type2) => {
        if (isArray$2(trigger2)) {
          return trigger2.includes(type2);
        }
        return trigger2 === type2;
      };
      const whenTrigger = (trigger2, type2, handler) => {
        return (e2) => {
          isTriggerType(unref(trigger2), type2) && handler(e2);
        };
      };
      const __default__$u = defineComponent({
        name: "ElTooltipTrigger"
      });
      const _sfc_main$U = /* @__PURE__ */ defineComponent({
        ...__default__$u,
        props: useTooltipTriggerProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("tooltip");
          const { controlled, id: id2, open: open2, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const triggerRef2 = ref(null);
          const stopWhenControlledOrDisabled = () => {
            if (unref(controlled) || props.disabled) {
              return true;
            }
          };
          const trigger2 = toRef$1(props, "trigger");
          const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onOpen));
          const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onClose));
          const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "click", (e2) => {
            if (e2.button === 0) {
              onToggle(e2);
            }
          }));
          const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onOpen));
          const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onClose));
          const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "contextmenu", (e2) => {
            e2.preventDefault();
            onToggle(e2);
          }));
          const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e2) => {
            const { code } = e2;
            if (props.triggerKeys.includes(code)) {
              e2.preventDefault();
              onToggle(e2);
            }
          });
          expose({
            triggerRef: triggerRef2
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopperTrigger), {
              id: unref(id2),
              "virtual-ref": _ctx.virtualRef,
              open: unref(open2),
              "virtual-triggering": _ctx.virtualTriggering,
              class: normalizeClass(unref(ns).e("trigger")),
              onBlur: unref(onBlur),
              onClick: unref(onClick),
              onContextmenu: unref(onContextMenu),
              onFocus: unref(onFocus),
              onMouseenter: unref(onMouseenter),
              onMouseleave: unref(onMouseleave),
              onKeydown: unref(onKeydown)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
          };
        }
      });
      var ElTooltipTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$U, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
      const __default__$t = defineComponent({
        name: "ElTooltipContent",
        inheritAttrs: false
      });
      const _sfc_main$T = /* @__PURE__ */ defineComponent({
        ...__default__$t,
        props: useTooltipContentProps,
        setup(__props, { expose }) {
          const props = __props;
          const { selector } = usePopperContainerId();
          const ns = useNamespace("tooltip");
          const contentRef = ref(null);
          const destroyed = ref(false);
          const {
            controlled,
            id: id2,
            open: open2,
            trigger: trigger2,
            onClose,
            onOpen,
            onShow,
            onHide,
            onBeforeShow,
            onBeforeHide
          } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const transitionClass = computed(() => {
            return props.transition || `${ns.namespace.value}-fade-in-linear`;
          });
          const persistentRef = computed(() => {
            return props.persistent;
          });
          onBeforeUnmount(() => {
            destroyed.value = true;
          });
          const shouldRender = computed(() => {
            return unref(persistentRef) ? true : unref(open2);
          });
          const shouldShow = computed(() => {
            return props.disabled ? false : unref(open2);
          });
          const appendTo = computed(() => {
            return props.appendTo || selector.value;
          });
          const contentStyle = computed(() => {
            var _a2;
            return (_a2 = props.style) != null ? _a2 : {};
          });
          const ariaHidden = computed(() => !unref(open2));
          const onTransitionLeave = () => {
            onHide();
          };
          const stopWhenControlled = () => {
            if (unref(controlled))
              return true;
          };
          const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
            if (props.enterable && unref(trigger2) === "hover") {
              onOpen();
            }
          });
          const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
            if (unref(trigger2) === "hover") {
              onClose();
            }
          });
          const onBeforeEnter = () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            onBeforeShow == null ? void 0 : onBeforeShow();
          };
          const onBeforeLeave = () => {
            onBeforeHide == null ? void 0 : onBeforeHide();
          };
          const onAfterShow = () => {
            onShow();
            stopHandle = onClickOutside(computed(() => {
              var _a2;
              return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
            }), () => {
              if (unref(controlled))
                return;
              const $trigger = unref(trigger2);
              if ($trigger !== "hover") {
                onClose();
              }
            });
          };
          const onBlur = () => {
            if (!props.virtualTriggering) {
              onClose();
            }
          };
          let stopHandle;
          watch(() => unref(open2), (val) => {
            if (!val) {
              stopHandle == null ? void 0 : stopHandle();
            }
          }, {
            flush: "post"
          });
          watch(() => props.content, () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          });
          expose({
            contentRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              disabled: !_ctx.teleported,
              to: unref(appendTo)
            }, [
              createVNode(Transition, {
                name: unref(transitionClass),
                onAfterLeave: onTransitionLeave,
                onBeforeEnter,
                onAfterEnter: onAfterShow,
                onBeforeLeave
              }, {
                default: withCtx(() => [
                  unref(shouldRender) ? withDirectives((openBlock(), createBlock(unref(ElPopperContent), mergeProps({
                    key: 0,
                    id: unref(id2),
                    ref_key: "contentRef",
                    ref: contentRef
                  }, _ctx.$attrs, {
                    "aria-label": _ctx.ariaLabel,
                    "aria-hidden": unref(ariaHidden),
                    "boundaries-padding": _ctx.boundariesPadding,
                    "fallback-placements": _ctx.fallbackPlacements,
                    "gpu-acceleration": _ctx.gpuAcceleration,
                    offset: _ctx.offset,
                    placement: _ctx.placement,
                    "popper-options": _ctx.popperOptions,
                    strategy: _ctx.strategy,
                    effect: _ctx.effect,
                    enterable: _ctx.enterable,
                    pure: _ctx.pure,
                    "popper-class": _ctx.popperClass,
                    "popper-style": [_ctx.popperStyle, unref(contentStyle)],
                    "reference-el": _ctx.referenceEl,
                    "trigger-target-el": _ctx.triggerTargetEl,
                    visible: unref(shouldShow),
                    "z-index": _ctx.zIndex,
                    onMouseenter: unref(onContentEnter),
                    onMouseleave: unref(onContentLeave),
                    onBlur,
                    onClose: unref(onClose)
                  }), {
                    default: withCtx(() => [
                      !destroyed.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                    ]),
                    _: 3
                  }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
                    [vShow, unref(shouldShow)]
                  ]) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["name"])
            ], 8, ["disabled", "to"]);
          };
        }
      });
      var ElTooltipContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$T, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
      const _hoisted_1$L = ["innerHTML"];
      const _hoisted_2$A = { key: 1 };
      const __default__$s = defineComponent({
        name: "ElTooltip"
      });
      const _sfc_main$S = /* @__PURE__ */ defineComponent({
        ...__default__$s,
        props: useTooltipProps,
        emits: tooltipEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          usePopperContainer();
          const id2 = useId();
          const popperRef = ref();
          const contentRef = ref();
          const updatePopper = () => {
            var _a2;
            const popperComponent = unref(popperRef);
            if (popperComponent) {
              (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
            }
          };
          const open2 = ref(false);
          const toggleReason = ref();
          const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
            indicator: open2,
            toggleReason
          });
          const { onOpen, onClose } = useDelayedToggle({
            showAfter: toRef$1(props, "showAfter"),
            hideAfter: toRef$1(props, "hideAfter"),
            autoClose: toRef$1(props, "autoClose"),
            open: show,
            close: hide
          });
          const controlled = computed(() => isBoolean(props.visible) && !hasUpdateHandler.value);
          provide(TOOLTIP_INJECTION_KEY, {
            controlled,
            id: id2,
            open: readonly(open2),
            trigger: toRef$1(props, "trigger"),
            onOpen: (event) => {
              onOpen(event);
            },
            onClose: (event) => {
              onClose(event);
            },
            onToggle: (event) => {
              if (unref(open2)) {
                onClose(event);
              } else {
                onOpen(event);
              }
            },
            onShow: () => {
              emit2("show", toggleReason.value);
            },
            onHide: () => {
              emit2("hide", toggleReason.value);
            },
            onBeforeShow: () => {
              emit2("before-show", toggleReason.value);
            },
            onBeforeHide: () => {
              emit2("before-hide", toggleReason.value);
            },
            updatePopper
          });
          watch(() => props.disabled, (disabled) => {
            if (disabled && open2.value) {
              open2.value = false;
            }
          });
          const isFocusInsideContent = () => {
            var _a2, _b;
            const popperContent = (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.contentRef) == null ? void 0 : _b.popperContentRef;
            return popperContent && popperContent.contains(document.activeElement);
          };
          onDeactivated(() => open2.value && hide());
          expose({
            popperRef,
            contentRef,
            isFocusInsideContent,
            updatePopper,
            onOpen,
            onClose,
            hide
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopper), {
              ref_key: "popperRef",
              ref: popperRef,
              role: _ctx.role
            }, {
              default: withCtx(() => [
                createVNode(ElTooltipTrigger, {
                  disabled: _ctx.disabled,
                  trigger: _ctx.trigger,
                  "trigger-keys": _ctx.triggerKeys,
                  "virtual-ref": _ctx.virtualRef,
                  "virtual-triggering": _ctx.virtualTriggering
                }, {
                  default: withCtx(() => [
                    _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
                createVNode(ElTooltipContent, {
                  ref_key: "contentRef",
                  ref: contentRef,
                  "aria-label": _ctx.ariaLabel,
                  "boundaries-padding": _ctx.boundariesPadding,
                  content: _ctx.content,
                  disabled: _ctx.disabled,
                  effect: _ctx.effect,
                  enterable: _ctx.enterable,
                  "fallback-placements": _ctx.fallbackPlacements,
                  "hide-after": _ctx.hideAfter,
                  "gpu-acceleration": _ctx.gpuAcceleration,
                  offset: _ctx.offset,
                  persistent: _ctx.persistent,
                  "popper-class": _ctx.popperClass,
                  "popper-style": _ctx.popperStyle,
                  placement: _ctx.placement,
                  "popper-options": _ctx.popperOptions,
                  pure: _ctx.pure,
                  "raw-content": _ctx.rawContent,
                  "reference-el": _ctx.referenceEl,
                  "trigger-target-el": _ctx.triggerTargetEl,
                  "show-after": _ctx.showAfter,
                  strategy: _ctx.strategy,
                  teleported: _ctx.teleported,
                  transition: _ctx.transition,
                  "virtual-triggering": _ctx.virtualTriggering,
                  "z-index": _ctx.zIndex,
                  "append-to": _ctx.appendTo
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "content", {}, () => [
                      _ctx.rawContent ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        innerHTML: _ctx.content
                      }, null, 8, _hoisted_1$L)) : (openBlock(), createElementBlock("span", _hoisted_2$A, toDisplayString(_ctx.content), 1))
                    ]),
                    _ctx.showArrow ? (openBlock(), createBlock(unref(ElPopperArrow), {
                      key: 0,
                      "arrow-offset": _ctx.arrowOffset
                    }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
              ]),
              _: 3
            }, 8, ["role"]);
          };
        }
      });
      var Tooltip = /* @__PURE__ */ _export_sfc$1(_sfc_main$S, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
      const ElTooltip = withInstall(Tooltip);
      const badgeProps = buildProps({
        value: {
          type: [String, Number],
          default: ""
        },
        max: {
          type: Number,
          default: 99
        },
        isDot: Boolean,
        hidden: Boolean,
        type: {
          type: String,
          values: ["primary", "success", "warning", "info", "danger"],
          default: "danger"
        }
      });
      const _hoisted_1$K = ["textContent"];
      const __default__$r = defineComponent({
        name: "ElBadge"
      });
      const _sfc_main$R = /* @__PURE__ */ defineComponent({
        ...__default__$r,
        props: badgeProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("badge");
          const content = computed(() => {
            if (props.isDot)
              return "";
            if (isNumber(props.value) && isNumber(props.max)) {
              return props.max < props.value ? `${props.max}+` : `${props.value}`;
            }
            return `${props.value}`;
          });
          expose({
            content
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b())
            }, [
              renderSlot(_ctx.$slots, "default"),
              createVNode(Transition, {
                name: `${unref(ns).namespace.value}-zoom-in-center`,
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createBaseVNode("sup", {
                    class: normalizeClass([
                      unref(ns).e("content"),
                      unref(ns).em("content", _ctx.type),
                      unref(ns).is("fixed", !!_ctx.$slots.default),
                      unref(ns).is("dot", _ctx.isDot)
                    ]),
                    textContent: toDisplayString(unref(content))
                  }, null, 10, _hoisted_1$K), [
                    [vShow, !_ctx.hidden && (unref(content) || _ctx.isDot)]
                  ])
                ]),
                _: 1
              }, 8, ["name"])
            ], 2);
          };
        }
      });
      var Badge = /* @__PURE__ */ _export_sfc$1(_sfc_main$R, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]);
      const ElBadge = withInstall(Badge);
      const buttonGroupContextKey = Symbol("buttonGroupContextKey");
      const useButton = (props, emit2) => {
        useDeprecated({
          from: "type.text",
          replacement: "link",
          version: "3.0.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
        }, computed(() => props.type === "text"));
        const buttonGroupContext = inject(buttonGroupContextKey, void 0);
        const globalConfig2 = useGlobalConfig("button");
        const { form } = useFormItem();
        const _size = useFormSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
        const _disabled = useFormDisabled();
        const _ref = ref();
        const slots = useSlots();
        const _type = computed(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
        const autoInsertSpace = computed(() => {
          var _a2, _b, _c;
          return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
        });
        const _props = computed(() => {
          if (props.tag === "button") {
            return {
              ariaDisabled: _disabled.value || props.loading,
              disabled: _disabled.value || props.loading,
              autofocus: props.autofocus,
              type: props.nativeType
            };
          }
          return {};
        });
        const shouldAddSpace = computed(() => {
          var _a2;
          const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
          if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
            const slot = defaultSlot[0];
            if ((slot == null ? void 0 : slot.type) === Text) {
              const text = slot.children;
              return /^\p{Unified_Ideograph}{2}$/u.test(text.trim());
            }
          }
          return false;
        });
        const handleClick = (evt) => {
          if (props.nativeType === "reset") {
            form == null ? void 0 : form.resetFields();
          }
          emit2("click", evt);
        };
        return {
          _disabled,
          _size,
          _type,
          _ref,
          _props,
          shouldAddSpace,
          handleClick
        };
      };
      const buttonTypes = [
        "default",
        "primary",
        "success",
        "warning",
        "info",
        "danger",
        "text",
        ""
      ];
      const buttonNativeTypes = ["button", "submit", "reset"];
      const buttonProps = buildProps({
        size: useSizeProp,
        disabled: Boolean,
        type: {
          type: String,
          values: buttonTypes,
          default: ""
        },
        icon: {
          type: iconPropType
        },
        nativeType: {
          type: String,
          values: buttonNativeTypes,
          default: "button"
        },
        loading: Boolean,
        loadingIcon: {
          type: iconPropType,
          default: () => loading_default
        },
        plain: Boolean,
        text: Boolean,
        link: Boolean,
        bg: Boolean,
        autofocus: Boolean,
        round: Boolean,
        circle: Boolean,
        color: String,
        dark: Boolean,
        autoInsertSpace: {
          type: Boolean,
          default: void 0
        },
        tag: {
          type: definePropType([String, Object]),
          default: "button"
        }
      });
      const buttonEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      function bound01(n2, max) {
        if (isOnePointZero(n2)) {
          n2 = "100%";
        }
        var isPercent = isPercentage(n2);
        n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
        if (isPercent) {
          n2 = parseInt(String(n2 * max), 10) / 100;
        }
        if (Math.abs(n2 - max) < 1e-6) {
          return 1;
        }
        if (max === 360) {
          n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
        } else {
          n2 = n2 % max / parseFloat(String(max));
        }
        return n2;
      }
      function clamp01(val) {
        return Math.min(1, Math.max(0, val));
      }
      function isOnePointZero(n2) {
        return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
      }
      function isPercentage(n2) {
        return typeof n2 === "string" && n2.indexOf("%") !== -1;
      }
      function boundAlpha(a2) {
        a2 = parseFloat(a2);
        if (isNaN(a2) || a2 < 0 || a2 > 1) {
          a2 = 1;
        }
        return a2;
      }
      function convertToPercentage(n2) {
        if (n2 <= 1) {
          return "".concat(Number(n2) * 100, "%");
        }
        return n2;
      }
      function pad2(c2) {
        return c2.length === 1 ? "0" + c2 : String(c2);
      }
      function rgbToRgb(r2, g2, b2) {
        return {
          r: bound01(r2, 255) * 255,
          g: bound01(g2, 255) * 255,
          b: bound01(b2, 255) * 255
        };
      }
      function rgbToHsl(r2, g2, b2) {
        r2 = bound01(r2, 255);
        g2 = bound01(g2, 255);
        b2 = bound01(b2, 255);
        var max = Math.max(r2, g2, b2);
        var min = Math.min(r2, g2, b2);
        var h2 = 0;
        var s2 = 0;
        var l2 = (max + min) / 2;
        if (max === min) {
          s2 = 0;
          h2 = 0;
        } else {
          var d2 = max - min;
          s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
          switch (max) {
            case r2:
              h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
              break;
            case g2:
              h2 = (b2 - r2) / d2 + 2;
              break;
            case b2:
              h2 = (r2 - g2) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s: s2, l: l2 };
      }
      function hue2rgb(p2, q2, t2) {
        if (t2 < 0) {
          t2 += 1;
        }
        if (t2 > 1) {
          t2 -= 1;
        }
        if (t2 < 1 / 6) {
          return p2 + (q2 - p2) * (6 * t2);
        }
        if (t2 < 1 / 2) {
          return q2;
        }
        if (t2 < 2 / 3) {
          return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
        }
        return p2;
      }
      function hslToRgb(h2, s2, l2) {
        var r2;
        var g2;
        var b2;
        h2 = bound01(h2, 360);
        s2 = bound01(s2, 100);
        l2 = bound01(l2, 100);
        if (s2 === 0) {
          g2 = l2;
          b2 = l2;
          r2 = l2;
        } else {
          var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
          var p2 = 2 * l2 - q2;
          r2 = hue2rgb(p2, q2, h2 + 1 / 3);
          g2 = hue2rgb(p2, q2, h2);
          b2 = hue2rgb(p2, q2, h2 - 1 / 3);
        }
        return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
      }
      function rgbToHsv(r2, g2, b2) {
        r2 = bound01(r2, 255);
        g2 = bound01(g2, 255);
        b2 = bound01(b2, 255);
        var max = Math.max(r2, g2, b2);
        var min = Math.min(r2, g2, b2);
        var h2 = 0;
        var v2 = max;
        var d2 = max - min;
        var s2 = max === 0 ? 0 : d2 / max;
        if (max === min) {
          h2 = 0;
        } else {
          switch (max) {
            case r2:
              h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
              break;
            case g2:
              h2 = (b2 - r2) / d2 + 2;
              break;
            case b2:
              h2 = (r2 - g2) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s: s2, v: v2 };
      }
      function hsvToRgb(h2, s2, v2) {
        h2 = bound01(h2, 360) * 6;
        s2 = bound01(s2, 100);
        v2 = bound01(v2, 100);
        var i2 = Math.floor(h2);
        var f2 = h2 - i2;
        var p2 = v2 * (1 - s2);
        var q2 = v2 * (1 - f2 * s2);
        var t2 = v2 * (1 - (1 - f2) * s2);
        var mod = i2 % 6;
        var r2 = [v2, q2, p2, p2, t2, v2][mod];
        var g2 = [t2, v2, v2, q2, p2, p2][mod];
        var b2 = [p2, p2, t2, v2, v2, q2][mod];
        return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
      }
      function rgbToHex(r2, g2, b2, allow3Char) {
        var hex = [
          pad2(Math.round(r2).toString(16)),
          pad2(Math.round(g2).toString(16)),
          pad2(Math.round(b2).toString(16))
        ];
        if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToHex(r2, g2, b2, a2, allow4Char) {
        var hex = [
          pad2(Math.round(r2).toString(16)),
          pad2(Math.round(g2).toString(16)),
          pad2(Math.round(b2).toString(16)),
          pad2(convertDecimalToHex(a2))
        ];
        if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }
        return hex.join("");
      }
      function convertDecimalToHex(d2) {
        return Math.round(parseFloat(d2) * 255).toString(16);
      }
      function convertHexToDecimal(h2) {
        return parseIntFromHex(h2) / 255;
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function numberInputToObject(color) {
        return {
          r: color >> 16,
          g: (color & 65280) >> 8,
          b: color & 255
        };
      }
      var names = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        goldenrod: "#daa520",
        gold: "#ffd700",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavenderblush: "#fff0f5",
        lavender: "#e6e6fa",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
      };
      function inputToRGB(color) {
        var rgb = { r: 0, g: 0, b: 0 };
        var a2 = 1;
        var s2 = null;
        var v2 = null;
        var l2 = null;
        var ok = false;
        var format2 = false;
        if (typeof color === "string") {
          color = stringInputToObject(color);
        }
        if (typeof color === "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s2 = convertToPercentage(color.s);
            v2 = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s2, v2);
            ok = true;
            format2 = "hsv";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s2 = convertToPercentage(color.s);
            l2 = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s2, l2);
            ok = true;
            format2 = "hsl";
          }
          if (Object.prototype.hasOwnProperty.call(color, "a")) {
            a2 = color.a;
          }
        }
        a2 = boundAlpha(a2);
        return {
          ok,
          format: color.format || format2,
          r: Math.min(255, Math.max(rgb.r, 0)),
          g: Math.min(255, Math.max(rgb.g, 0)),
          b: Math.min(255, Math.max(rgb.b, 0)),
          a: a2
        };
      }
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var matchers = {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
      function stringInputToObject(color) {
        color = color.trim().toLowerCase();
        if (color.length === 0) {
          return false;
        }
        var named = false;
        if (names[color]) {
          color = names[color];
          named = true;
        } else if (color === "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match = matchers.rgb.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3] };
        }
        match = matchers.rgba.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        match = matchers.hsl.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3] };
        }
        match = matchers.hsla.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        match = matchers.hsv.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3] };
        }
        match = matchers.hsva.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        match = matchers.hex8.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex6.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
          };
        }
        match = matchers.hex4.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            a: convertHexToDecimal(match[4] + match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex3.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            format: named ? "name" : "hex"
          };
        }
        return false;
      }
      function isValidCSSUnit(color) {
        return Boolean(matchers.CSS_UNIT.exec(String(color)));
      }
      var TinyColor = (
        /** @class */
        function() {
          function TinyColor2(color, opts) {
            if (color === void 0) {
              color = "";
            }
            if (opts === void 0) {
              opts = {};
            }
            var _a2;
            if (color instanceof TinyColor2) {
              return color;
            }
            if (typeof color === "number") {
              color = numberInputToObject(color);
            }
            this.originalInput = color;
            var rgb = inputToRGB(color);
            this.originalInput = color;
            this.r = rgb.r;
            this.g = rgb.g;
            this.b = rgb.b;
            this.a = rgb.a;
            this.roundA = Math.round(100 * this.a) / 100;
            this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
            this.gradientType = opts.gradientType;
            if (this.r < 1) {
              this.r = Math.round(this.r);
            }
            if (this.g < 1) {
              this.g = Math.round(this.g);
            }
            if (this.b < 1) {
              this.b = Math.round(this.b);
            }
            this.isValid = rgb.ok;
          }
          TinyColor2.prototype.isDark = function() {
            return this.getBrightness() < 128;
          };
          TinyColor2.prototype.isLight = function() {
            return !this.isDark();
          };
          TinyColor2.prototype.getBrightness = function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
          };
          TinyColor2.prototype.getLuminance = function() {
            var rgb = this.toRgb();
            var R2;
            var G2;
            var B2;
            var RsRGB = rgb.r / 255;
            var GsRGB = rgb.g / 255;
            var BsRGB = rgb.b / 255;
            if (RsRGB <= 0.03928) {
              R2 = RsRGB / 12.92;
            } else {
              R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
            }
            if (GsRGB <= 0.03928) {
              G2 = GsRGB / 12.92;
            } else {
              G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
            }
            if (BsRGB <= 0.03928) {
              B2 = BsRGB / 12.92;
            } else {
              B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
          };
          TinyColor2.prototype.getAlpha = function() {
            return this.a;
          };
          TinyColor2.prototype.setAlpha = function(alpha) {
            this.a = boundAlpha(alpha);
            this.roundA = Math.round(100 * this.a) / 100;
            return this;
          };
          TinyColor2.prototype.isMonochrome = function() {
            var s2 = this.toHsl().s;
            return s2 === 0;
          };
          TinyColor2.prototype.toHsv = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
          };
          TinyColor2.prototype.toHsvString = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            var h2 = Math.round(hsv.h * 360);
            var s2 = Math.round(hsv.s * 100);
            var v2 = Math.round(hsv.v * 100);
            return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHsl = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
          };
          TinyColor2.prototype.toHslString = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            var h2 = Math.round(hsl.h * 360);
            var s2 = Math.round(hsl.s * 100);
            var l2 = Math.round(hsl.l * 100);
            return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHex = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return rgbToHex(this.r, this.g, this.b, allow3Char);
          };
          TinyColor2.prototype.toHexString = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return "#" + this.toHex(allow3Char);
          };
          TinyColor2.prototype.toHex8 = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
          };
          TinyColor2.prototype.toHex8String = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return "#" + this.toHex8(allow4Char);
          };
          TinyColor2.prototype.toHexShortString = function(allowShortChar) {
            if (allowShortChar === void 0) {
              allowShortChar = false;
            }
            return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
          };
          TinyColor2.prototype.toRgb = function() {
            return {
              r: Math.round(this.r),
              g: Math.round(this.g),
              b: Math.round(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toRgbString = function() {
            var r2 = Math.round(this.r);
            var g2 = Math.round(this.g);
            var b2 = Math.round(this.b);
            return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toPercentageRgb = function() {
            var fmt = function(x2) {
              return "".concat(Math.round(bound01(x2, 255) * 100), "%");
            };
            return {
              r: fmt(this.r),
              g: fmt(this.g),
              b: fmt(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toPercentageRgbString = function() {
            var rnd = function(x2) {
              return Math.round(bound01(x2, 255) * 100);
            };
            return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toName = function() {
            if (this.a === 0) {
              return "transparent";
            }
            if (this.a < 1) {
              return false;
            }
            var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
            for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
              var _b = _a2[_i], key = _b[0], value = _b[1];
              if (hex === value) {
                return key;
              }
            }
            return false;
          };
          TinyColor2.prototype.toString = function(format2) {
            var formatSet = Boolean(format2);
            format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
            var formattedString = false;
            var hasAlpha = this.a < 1 && this.a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
            if (needsAlphaFormat) {
              if (format2 === "name" && this.a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format2 === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format2 === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format2 === "hex" || format2 === "hex6") {
              formattedString = this.toHexString();
            }
            if (format2 === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format2 === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format2 === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format2 === "name") {
              formattedString = this.toName();
            }
            if (format2 === "hsl") {
              formattedString = this.toHslString();
            }
            if (format2 === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          };
          TinyColor2.prototype.toNumber = function() {
            return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
          };
          TinyColor2.prototype.clone = function() {
            return new TinyColor2(this.toString());
          };
          TinyColor2.prototype.lighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.brighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var rgb = this.toRgb();
            rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
            rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
            rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
            return new TinyColor2(rgb);
          };
          TinyColor2.prototype.darken = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.tint = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("white", amount);
          };
          TinyColor2.prototype.shade = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("black", amount);
          };
          TinyColor2.prototype.desaturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.saturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.greyscale = function() {
            return this.desaturate(100);
          };
          TinyColor2.prototype.spin = function(amount) {
            var hsl = this.toHsl();
            var hue = (hsl.h + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.mix = function(color, amount) {
            if (amount === void 0) {
              amount = 50;
            }
            var rgb1 = this.toRgb();
            var rgb2 = new TinyColor2(color).toRgb();
            var p2 = amount / 100;
            var rgba = {
              r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
              g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
              b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
              a: (rgb2.a - rgb1.a) * p2 + rgb1.a
            };
            return new TinyColor2(rgba);
          };
          TinyColor2.prototype.analogous = function(results, slices) {
            if (results === void 0) {
              results = 6;
            }
            if (slices === void 0) {
              slices = 30;
            }
            var hsl = this.toHsl();
            var part = 360 / slices;
            var ret = [this];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
              hsl.h = (hsl.h + part) % 360;
              ret.push(new TinyColor2(hsl));
            }
            return ret;
          };
          TinyColor2.prototype.complement = function() {
            var hsl = this.toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.monochromatic = function(results) {
            if (results === void 0) {
              results = 6;
            }
            var hsv = this.toHsv();
            var h2 = hsv.h;
            var s2 = hsv.s;
            var v2 = hsv.v;
            var res = [];
            var modification = 1 / results;
            while (results--) {
              res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
              v2 = (v2 + modification) % 1;
            }
            return res;
          };
          TinyColor2.prototype.splitcomplement = function() {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            return [
              this,
              new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
              new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
            ];
          };
          TinyColor2.prototype.onBackground = function(background) {
            var fg = this.toRgb();
            var bg = new TinyColor2(background).toRgb();
            var alpha = fg.a + bg.a * (1 - fg.a);
            return new TinyColor2({
              r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
              g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
              b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
              a: alpha
            });
          };
          TinyColor2.prototype.triad = function() {
            return this.polyad(3);
          };
          TinyColor2.prototype.tetrad = function() {
            return this.polyad(4);
          };
          TinyColor2.prototype.polyad = function(n2) {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            var result = [this];
            var increment = 360 / n2;
            for (var i2 = 1; i2 < n2; i2++) {
              result.push(new TinyColor2({ h: (h2 + i2 * increment) % 360, s: hsl.s, l: hsl.l }));
            }
            return result;
          };
          TinyColor2.prototype.equals = function(color) {
            return this.toRgbString() === new TinyColor2(color).toRgbString();
          };
          return TinyColor2;
        }()
      );
      function darken(color, amount = 20) {
        return color.mix("#141414", amount).toString();
      }
      function useButtonCustomStyle(props) {
        const _disabled = useFormDisabled();
        const ns = useNamespace("button");
        return computed(() => {
          let styles = {};
          const buttonColor = props.color;
          if (buttonColor) {
            const color = new TinyColor(buttonColor);
            const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
            if (props.plain) {
              styles = ns.cssVarBlock({
                "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
                "text-color": buttonColor,
                "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
                "hover-text-color": `var(${ns.cssVarName("color-white")})`,
                "hover-bg-color": buttonColor,
                "hover-border-color": buttonColor,
                "active-bg-color": activeBgColor,
                "active-text-color": `var(${ns.cssVarName("color-white")})`,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                styles[ns.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
                styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
              }
            } else {
              const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
              const textColor = color.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
              styles = ns.cssVarBlock({
                "bg-color": buttonColor,
                "text-color": textColor,
                "border-color": buttonColor,
                "hover-bg-color": hoverBgColor,
                "hover-text-color": textColor,
                "hover-border-color": hoverBgColor,
                "active-bg-color": activeBgColor,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
                styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
                styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
              }
            }
          }
          return styles;
        });
      }
      const __default__$q = defineComponent({
        name: "ElButton"
      });
      const _sfc_main$Q = /* @__PURE__ */ defineComponent({
        ...__default__$q,
        props: buttonProps,
        emits: buttonEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const buttonStyle = useButtonCustomStyle(props);
          const ns = useNamespace("button");
          const { _ref, _size, _type, _disabled, _props, shouldAddSpace, handleClick } = useButton(props, emit2);
          expose({
            ref: _ref,
            size: _size,
            type: _type,
            disabled: _disabled,
            shouldAddSpace
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({
              ref_key: "_ref",
              ref: _ref
            }, unref(_props), {
              class: [
                unref(ns).b(),
                unref(ns).m(unref(_type)),
                unref(ns).m(unref(_size)),
                unref(ns).is("disabled", unref(_disabled)),
                unref(ns).is("loading", _ctx.loading),
                unref(ns).is("plain", _ctx.plain),
                unref(ns).is("round", _ctx.round),
                unref(ns).is("circle", _ctx.circle),
                unref(ns).is("text", _ctx.text),
                unref(ns).is("link", _ctx.link),
                unref(ns).is("has-bg", _ctx.bg)
              ],
              style: unref(buttonStyle),
              onClick: unref(handleClick)
            }), {
              default: withCtx(() => [
                _ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass(unref(ns).is("loading"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"]))
                ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                  default: withCtx(() => [
                    _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
                  ]),
                  _: 3
                })) : createCommentVNode("v-if", true),
                _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                  key: 2,
                  class: normalizeClass({ [unref(ns).em("text", "expand")]: unref(shouldAddSpace) })
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["class", "style", "onClick"]);
          };
        }
      });
      var Button = /* @__PURE__ */ _export_sfc$1(_sfc_main$Q, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
      const buttonGroupProps = {
        size: buttonProps.size,
        type: buttonProps.type
      };
      const __default__$p = defineComponent({
        name: "ElButtonGroup"
      });
      const _sfc_main$P = /* @__PURE__ */ defineComponent({
        ...__default__$p,
        props: buttonGroupProps,
        setup(__props) {
          const props = __props;
          provide(buttonGroupContextKey, reactive({
            size: toRef$1(props, "size"),
            type: toRef$1(props, "type")
          }));
          const ns = useNamespace("button");
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(`${unref(ns).b("group")}`)
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var ButtonGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$P, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
      const ElButton = withInstall(Button, {
        ButtonGroup
      });
      const ElButtonGroup$1 = withNoopInstall(ButtonGroup);
      const nodeList = /* @__PURE__ */ new Map();
      let startClick;
      if (isClient$1) {
        document.addEventListener("mousedown", (e2) => startClick = e2);
        document.addEventListener("mouseup", (e2) => {
          for (const handlers of nodeList.values()) {
            for (const { documentHandler } of handlers) {
              documentHandler(e2, startClick);
            }
          }
        });
      }
      function createDocumentHandler(el, binding) {
        let excludes = [];
        if (Array.isArray(binding.arg)) {
          excludes = binding.arg;
        } else if (isElement(binding.arg)) {
          excludes.push(binding.arg);
        }
        return function(mouseup, mousedown) {
          const popperRef = binding.instance.popperRef;
          const mouseUpTarget = mouseup.target;
          const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
          const isBound = !binding || !binding.instance;
          const isTargetExists = !mouseUpTarget || !mouseDownTarget;
          const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
          const isSelf = el === mouseUpTarget;
          const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
          const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
          if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
            return;
          }
          binding.value(mouseup, mousedown);
        };
      }
      const ClickOutside = {
        beforeMount(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          nodeList.get(el).push({
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          });
        },
        updated(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          const handlers = nodeList.get(el);
          const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
          const newHandler = {
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          };
          if (oldHandlerIndex >= 0) {
            handlers.splice(oldHandlerIndex, 1, newHandler);
          } else {
            handlers.push(newHandler);
          }
        },
        unmounted(el) {
          nodeList.delete(el);
        }
      };
      const REPEAT_INTERVAL = 100;
      const REPEAT_DELAY = 600;
      const vRepeatClick = {
        beforeMount(el, binding) {
          const value = binding.value;
          const { interval = REPEAT_INTERVAL, delay = REPEAT_DELAY } = isFunction$1(value) ? {} : value;
          let intervalId;
          let delayId;
          const handler = () => isFunction$1(value) ? value() : value.handler();
          const clear2 = () => {
            if (delayId) {
              clearTimeout(delayId);
              delayId = void 0;
            }
            if (intervalId) {
              clearInterval(intervalId);
              intervalId = void 0;
            }
          };
          el.addEventListener("mousedown", (evt) => {
            if (evt.button !== 0)
              return;
            clear2();
            handler();
            document.addEventListener("mouseup", () => clear2(), {
              once: true
            });
            delayId = setTimeout(() => {
              intervalId = setInterval(() => {
                handler();
              }, interval);
            }, delay);
          });
        }
      };
      const FOCUSABLE_CHILDREN = "_trap-focus-children";
      const FOCUS_STACK = [];
      const FOCUS_HANDLER = (e2) => {
        if (FOCUS_STACK.length === 0)
          return;
        const focusableElement = FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN];
        if (focusableElement.length > 0 && e2.code === EVENT_CODE.tab) {
          if (focusableElement.length === 1) {
            e2.preventDefault();
            if (document.activeElement !== focusableElement[0]) {
              focusableElement[0].focus();
            }
            return;
          }
          const goingBackward = e2.shiftKey;
          const isFirst = e2.target === focusableElement[0];
          const isLast = e2.target === focusableElement[focusableElement.length - 1];
          if (isFirst && goingBackward) {
            e2.preventDefault();
            focusableElement[focusableElement.length - 1].focus();
          }
          if (isLast && !goingBackward) {
            e2.preventDefault();
            focusableElement[0].focus();
          }
        }
      };
      const TrapFocus = {
        beforeMount(el) {
          el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
          FOCUS_STACK.push(el);
          if (FOCUS_STACK.length <= 1) {
            document.addEventListener("keydown", FOCUS_HANDLER);
          }
        },
        updated(el) {
          nextTick(() => {
            el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
          });
        },
        unmounted() {
          FOCUS_STACK.shift();
          if (FOCUS_STACK.length === 0) {
            document.removeEventListener("keydown", FOCUS_HANDLER);
          }
        }
      };
      const checkboxProps = {
        modelValue: {
          type: [Number, String, Boolean],
          default: void 0
        },
        label: {
          type: [String, Boolean, Number, Object]
        },
        indeterminate: Boolean,
        disabled: Boolean,
        checked: Boolean,
        name: {
          type: String,
          default: void 0
        },
        trueLabel: {
          type: [String, Number],
          default: void 0
        },
        falseLabel: {
          type: [String, Number],
          default: void 0
        },
        id: {
          type: String,
          default: void 0
        },
        controls: {
          type: String,
          default: void 0
        },
        border: Boolean,
        size: useSizeProp,
        tabindex: [String, Number],
        validateEvent: {
          type: Boolean,
          default: true
        }
      };
      const checkboxEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isString$1(val) || isNumber(val) || isBoolean(val),
        change: (val) => isString$1(val) || isNumber(val) || isBoolean(val)
      };
      const checkboxGroupContextKey = Symbol("checkboxGroupContextKey");
      const useCheckboxDisabled = ({
        model,
        isChecked
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isLimitDisabled = computed(() => {
          var _a2, _b;
          const max = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value;
          const min = (_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value;
          return !isUndefined(max) && model.value.length >= max && !isChecked.value || !isUndefined(min) && model.value.length <= min && isChecked.value;
        });
        const isDisabled = useFormDisabled(computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value));
        return {
          isDisabled,
          isLimitDisabled
        };
      };
      const useCheckboxEvent = (props, {
        model,
        isLimitExceeded,
        hasOwnLabel,
        isDisabled,
        isLabeledByFormItem
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const { formItem } = useFormItem();
        const { emit: emit2 } = getCurrentInstance();
        function getLabeledValue(value) {
          var _a2, _b;
          return value === props.trueLabel || value === true ? (_a2 = props.trueLabel) != null ? _a2 : true : (_b = props.falseLabel) != null ? _b : false;
        }
        function emitChangeEvent(checked, e2) {
          emit2("change", getLabeledValue(checked), e2);
        }
        function handleChange(e2) {
          if (isLimitExceeded.value)
            return;
          const target = e2.target;
          emit2("change", getLabeledValue(target.checked), e2);
        }
        async function onClickRoot(e2) {
          if (isLimitExceeded.value)
            return;
          if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
            const eventTargets = e2.composedPath();
            const hasLabel = eventTargets.some((item) => item.tagName === "LABEL");
            if (!hasLabel) {
              model.value = getLabeledValue([false, props.falseLabel].includes(model.value));
              await nextTick();
              emitChangeEvent(model.value, e2);
            }
          }
        }
        const validateEvent = computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.validateEvent) || props.validateEvent);
        watch(() => props.modelValue, () => {
          if (validateEvent.value) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        });
        return {
          handleChange,
          onClickRoot
        };
      };
      const useCheckboxModel = (props) => {
        const selfModel = ref(false);
        const { emit: emit2 } = getCurrentInstance();
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isGroup = computed(() => isUndefined(checkboxGroup) === false);
        const isLimitExceeded = ref(false);
        const model = computed({
          get() {
            var _a2, _b;
            return isGroup.value ? (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a2.value : (_b = props.modelValue) != null ? _b : selfModel.value;
          },
          set(val) {
            var _a2, _b;
            if (isGroup.value && isArray$2(val)) {
              isLimitExceeded.value = ((_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value);
              isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));
            } else {
              emit2(UPDATE_MODEL_EVENT, val);
              selfModel.value = val;
            }
          }
        });
        return {
          model,
          isGroup,
          isLimitExceeded
        };
      };
      const useCheckboxStatus = (props, slots, { model }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isFocused = ref(false);
        const isChecked = computed(() => {
          const value = model.value;
          if (isBoolean(value)) {
            return value;
          } else if (isArray$2(value)) {
            if (isObject$1(props.label)) {
              return value.map(toRaw).some((o2) => isEqual$1(o2, props.label));
            } else {
              return value.map(toRaw).includes(props.label);
            }
          } else if (value !== null && value !== void 0) {
            return value === props.trueLabel;
          } else {
            return !!value;
          }
        });
        const checkboxButtonSize = useFormSize(computed(() => {
          var _a2;
          return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
        }), {
          prop: true
        });
        const checkboxSize = useFormSize(computed(() => {
          var _a2;
          return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
        }));
        const hasOwnLabel = computed(() => {
          return !!(slots.default || props.label);
        });
        return {
          checkboxButtonSize,
          isChecked,
          isFocused,
          checkboxSize,
          hasOwnLabel
        };
      };
      const setStoreValue = (props, { model }) => {
        function addToStore() {
          if (isArray$2(model.value) && !model.value.includes(props.label)) {
            model.value.push(props.label);
          } else {
            model.value = props.trueLabel || true;
          }
        }
        props.checked && addToStore();
      };
      const useCheckbox = (props, slots) => {
        const { formItem: elFormItem2 } = useFormItem();
        const { model, isGroup, isLimitExceeded } = useCheckboxModel(props);
        const {
          isFocused,
          isChecked,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel
        } = useCheckboxStatus(props, slots, { model });
        const { isDisabled } = useCheckboxDisabled({ model, isChecked });
        const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
          formItemContext: elFormItem2,
          disableIdGeneration: hasOwnLabel,
          disableIdManagement: isGroup
        });
        const { handleChange, onClickRoot } = useCheckboxEvent(props, {
          model,
          isLimitExceeded,
          hasOwnLabel,
          isDisabled,
          isLabeledByFormItem
        });
        setStoreValue(props, { model });
        return {
          inputId,
          isLabeledByFormItem,
          isChecked,
          isDisabled,
          isFocused,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          model,
          handleChange,
          onClickRoot
        };
      };
      const _hoisted_1$J = ["tabindex", "role", "aria-checked"];
      const _hoisted_2$z = ["id", "aria-hidden", "name", "tabindex", "disabled", "true-value", "false-value"];
      const _hoisted_3$r = ["id", "aria-hidden", "disabled", "value", "name", "tabindex"];
      const __default__$o = defineComponent({
        name: "ElCheckbox"
      });
      const _sfc_main$O = /* @__PURE__ */ defineComponent({
        ...__default__$o,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props = __props;
          const slots = useSlots();
          const {
            inputId,
            isLabeledByFormItem,
            isChecked,
            isDisabled,
            isFocused,
            checkboxSize,
            hasOwnLabel,
            model,
            handleChange,
            onClickRoot
          } = useCheckbox(props, slots);
          const ns = useNamespace("checkbox");
          const compKls = computed(() => {
            return [
              ns.b(),
              ns.m(checkboxSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("bordered", props.border),
              ns.is("checked", isChecked.value)
            ];
          });
          const spanKls = computed(() => {
            return [
              ns.e("input"),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("indeterminate", props.indeterminate),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(!unref(hasOwnLabel) && unref(isLabeledByFormItem) ? "span" : "label"), {
              class: normalizeClass(unref(compKls)),
              "aria-controls": _ctx.indeterminate ? _ctx.controls : null,
              onClick: unref(onClickRoot)
            }, {
              default: withCtx(() => [
                createBaseVNode("span", {
                  class: normalizeClass(unref(spanKls)),
                  tabindex: _ctx.indeterminate ? 0 : void 0,
                  role: _ctx.indeterminate ? "checkbox" : void 0,
                  "aria-checked": _ctx.indeterminate ? "mixed" : void 0
                }, [
                  _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                    key: 0,
                    id: unref(inputId),
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
                    class: normalizeClass(unref(ns).e("original")),
                    type: "checkbox",
                    "aria-hidden": _ctx.indeterminate ? "true" : "false",
                    name: _ctx.name,
                    tabindex: _ctx.tabindex,
                    disabled: unref(isDisabled),
                    "true-value": _ctx.trueLabel,
                    "false-value": _ctx.falseLabel,
                    onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                    onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
                    onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false)
                  }, null, 42, _hoisted_2$z)), [
                    [vModelCheckbox, unref(model)]
                  ]) : withDirectives((openBlock(), createElementBlock("input", {
                    key: 1,
                    id: unref(inputId),
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isRef(model) ? model.value = $event : null),
                    class: normalizeClass(unref(ns).e("original")),
                    type: "checkbox",
                    "aria-hidden": _ctx.indeterminate ? "true" : "false",
                    disabled: unref(isDisabled),
                    value: _ctx.label,
                    name: _ctx.name,
                    tabindex: _ctx.tabindex,
                    onChange: _cache[5] || (_cache[5] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                    onFocus: _cache[6] || (_cache[6] = ($event) => isFocused.value = true),
                    onBlur: _cache[7] || (_cache[7] = ($event) => isFocused.value = false)
                  }, null, 42, _hoisted_3$r)), [
                    [vModelCheckbox, unref(model)]
                  ]),
                  createBaseVNode("span", {
                    class: normalizeClass(unref(ns).e("inner"))
                  }, null, 2)
                ], 10, _hoisted_1$J),
                unref(hasOwnLabel) ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("label"))
                }, [
                  renderSlot(_ctx.$slots, "default"),
                  !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createTextVNode(toDisplayString(_ctx.label), 1)
                  ], 64)) : createCommentVNode("v-if", true)
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["class", "aria-controls", "onClick"]);
          };
        }
      });
      var Checkbox = /* @__PURE__ */ _export_sfc$1(_sfc_main$O, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);
      const _hoisted_1$I = ["name", "tabindex", "disabled", "true-value", "false-value"];
      const _hoisted_2$y = ["name", "tabindex", "disabled", "value"];
      const __default__$n = defineComponent({
        name: "ElCheckboxButton"
      });
      const _sfc_main$N = /* @__PURE__ */ defineComponent({
        ...__default__$n,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props = __props;
          const slots = useSlots();
          const {
            isFocused,
            isChecked,
            isDisabled,
            checkboxButtonSize,
            model,
            handleChange
          } = useCheckbox(props, slots);
          const checkboxGroup = inject(checkboxGroupContextKey, void 0);
          const ns = useNamespace("checkbox");
          const activeStyle = computed(() => {
            var _a2, _b, _c, _d;
            const fillValue = (_b = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a2.value) != null ? _b : "";
            return {
              backgroundColor: fillValue,
              borderColor: fillValue,
              color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
              boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
            };
          });
          const labelKls = computed(() => {
            return [
              ns.b("button"),
              ns.bm("button", checkboxButtonSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("label", {
              class: normalizeClass(unref(labelKls))
            }, [
              _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                key: 0,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                "true-value": _ctx.trueLabel,
                "false-value": _ctx.falseLabel,
                onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
                onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false)
              }, null, 42, _hoisted_1$I)), [
                [vModelCheckbox, unref(model)]
              ]) : withDirectives((openBlock(), createElementBlock("input", {
                key: 1,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isRef(model) ? model.value = $event : null),
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                value: _ctx.label,
                onChange: _cache[5] || (_cache[5] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                onFocus: _cache[6] || (_cache[6] = ($event) => isFocused.value = true),
                onBlur: _cache[7] || (_cache[7] = ($event) => isFocused.value = false)
              }, null, 42, _hoisted_2$y)), [
                [vModelCheckbox, unref(model)]
              ]),
              _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
                key: 2,
                class: normalizeClass(unref(ns).be("button", "inner")),
                style: normalizeStyle(unref(isChecked) ? unref(activeStyle) : void 0)
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.label), 1)
                ])
              ], 6)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var CheckboxButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$N, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);
      const checkboxGroupProps = buildProps({
        modelValue: {
          type: definePropType(Array),
          default: () => []
        },
        disabled: Boolean,
        min: Number,
        max: Number,
        size: useSizeProp,
        label: String,
        fill: String,
        textColor: String,
        tag: {
          type: String,
          default: "div"
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const checkboxGroupEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isArray$2(val),
        change: (val) => isArray$2(val)
      };
      const __default__$m = defineComponent({
        name: "ElCheckboxGroup"
      });
      const _sfc_main$M = /* @__PURE__ */ defineComponent({
        ...__default__$m,
        props: checkboxGroupProps,
        emits: checkboxGroupEmits,
        setup(__props, { emit: emit2 }) {
          const props = __props;
          const ns = useNamespace("checkbox");
          const { formItem } = useFormItem();
          const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, {
            formItemContext: formItem
          });
          const changeEvent = async (value) => {
            emit2(UPDATE_MODEL_EVENT, value);
            await nextTick();
            emit2("change", value);
          };
          const modelValue = computed({
            get() {
              return props.modelValue;
            },
            set(val) {
              changeEvent(val);
            }
          });
          provide(checkboxGroupContextKey, {
            ...pick$1(toRefs(props), [
              "size",
              "min",
              "max",
              "disabled",
              "validateEvent",
              "fill",
              "textColor"
            ]),
            modelValue,
            changeEvent
          });
          watch(() => props.modelValue, () => {
            if (props.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
          });
          return (_ctx, _cache) => {
            var _a2;
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              id: unref(groupId),
              class: normalizeClass(unref(ns).b("group")),
              role: "group",
              "aria-label": !unref(isLabeledByFormItem) ? _ctx.label || "checkbox-group" : void 0,
              "aria-labelledby": unref(isLabeledByFormItem) ? (_a2 = unref(formItem)) == null ? void 0 : _a2.labelId : void 0
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
          };
        }
      });
      var CheckboxGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$M, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);
      const ElCheckbox = withInstall(Checkbox, {
        CheckboxButton,
        CheckboxGroup
      });
      withNoopInstall(CheckboxButton);
      withNoopInstall(CheckboxGroup);
      const tagProps = buildProps({
        type: {
          type: String,
          values: ["success", "info", "warning", "danger", ""],
          default: ""
        },
        closable: Boolean,
        disableTransitions: Boolean,
        hit: Boolean,
        color: {
          type: String,
          default: ""
        },
        size: {
          type: String,
          values: componentSizes,
          default: ""
        },
        effect: {
          type: String,
          values: ["dark", "light", "plain"],
          default: "light"
        },
        round: Boolean
      });
      const tagEmits = {
        close: (evt) => evt instanceof MouseEvent,
        click: (evt) => evt instanceof MouseEvent
      };
      const __default__$l = defineComponent({
        name: "ElTag"
      });
      const _sfc_main$L = /* @__PURE__ */ defineComponent({
        ...__default__$l,
        props: tagProps,
        emits: tagEmits,
        setup(__props, { emit: emit2 }) {
          const props = __props;
          const tagSize = useFormSize();
          const ns = useNamespace("tag");
          const containerKls = computed(() => {
            const { type: type2, hit, effect, closable, round } = props;
            return [
              ns.b(),
              ns.is("closable", closable),
              ns.m(type2),
              ns.m(tagSize.value),
              ns.m(effect),
              ns.is("hit", hit),
              ns.is("round", round)
            ];
          });
          const handleClose = (event) => {
            emit2("close", event);
          };
          const handleClick = (event) => {
            emit2("click", event);
          };
          return (_ctx, _cache) => {
            return _ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(unref(containerKls)),
              style: normalizeStyle({ backgroundColor: _ctx.color }),
              onClick: handleClick
            }, [
              createBaseVNode("span", {
                class: normalizeClass(unref(ns).e("content"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2),
              _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                key: 0,
                class: normalizeClass(unref(ns).e("close")),
                onClick: withModifiers(handleClose, ["stop"])
              }, {
                default: withCtx(() => [
                  createVNode(unref(close_default))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
            ], 6)) : (openBlock(), createBlock(Transition, {
              key: 1,
              name: `${unref(ns).namespace.value}-zoom-in-center`,
              appear: ""
            }, {
              default: withCtx(() => [
                createBaseVNode("span", {
                  class: normalizeClass(unref(containerKls)),
                  style: normalizeStyle({ backgroundColor: _ctx.color }),
                  onClick: handleClick
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(ns).e("content"))
                  }, [
                    renderSlot(_ctx.$slots, "default")
                  ], 2),
                  _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).e("close")),
                    onClick: withModifiers(handleClose, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(close_default))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ], 6)
              ]),
              _: 3
            }, 8, ["name"]));
          };
        }
      });
      var Tag = /* @__PURE__ */ _export_sfc$1(_sfc_main$L, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);
      const ElTag = withInstall(Tag);
      const __default__$k = defineComponent({
        name: "ElContainer"
      });
      const _sfc_main$K = /* @__PURE__ */ defineComponent({
        ...__default__$k,
        props: {
          direction: {
            type: String
          }
        },
        setup(__props) {
          const props = __props;
          const slots = useSlots();
          const ns = useNamespace("container");
          const isVertical = computed(() => {
            if (props.direction === "vertical") {
              return true;
            } else if (props.direction === "horizontal") {
              return false;
            }
            if (slots && slots.default) {
              const vNodes = slots.default();
              return vNodes.some((vNode) => {
                const tag = vNode.type.name;
                return tag === "ElHeader" || tag === "ElFooter";
              });
            } else {
              return false;
            }
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("section", {
              class: normalizeClass([unref(ns).b(), unref(ns).is("vertical", unref(isVertical))])
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Container = /* @__PURE__ */ _export_sfc$1(_sfc_main$K, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/container.vue"]]);
      const __default__$j = defineComponent({
        name: "ElAside"
      });
      const _sfc_main$J = /* @__PURE__ */ defineComponent({
        ...__default__$j,
        props: {
          width: {
            type: String,
            default: null
          }
        },
        setup(__props) {
          const props = __props;
          const ns = useNamespace("aside");
          const style = computed(() => props.width ? ns.cssVarBlock({ width: props.width }) : {});
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("aside", {
              class: normalizeClass(unref(ns).b()),
              style: normalizeStyle(unref(style))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 6);
          };
        }
      });
      var Aside = /* @__PURE__ */ _export_sfc$1(_sfc_main$J, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/aside.vue"]]);
      const __default__$i = defineComponent({
        name: "ElFooter"
      });
      const _sfc_main$I = /* @__PURE__ */ defineComponent({
        ...__default__$i,
        props: {
          height: {
            type: String,
            default: null
          }
        },
        setup(__props) {
          const props = __props;
          const ns = useNamespace("footer");
          const style = computed(() => props.height ? ns.cssVarBlock({ height: props.height }) : {});
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("footer", {
              class: normalizeClass(unref(ns).b()),
              style: normalizeStyle(unref(style))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 6);
          };
        }
      });
      var Footer = /* @__PURE__ */ _export_sfc$1(_sfc_main$I, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/footer.vue"]]);
      const __default__$h = defineComponent({
        name: "ElHeader"
      });
      const _sfc_main$H = /* @__PURE__ */ defineComponent({
        ...__default__$h,
        props: {
          height: {
            type: String,
            default: null
          }
        },
        setup(__props) {
          const props = __props;
          const ns = useNamespace("header");
          const style = computed(() => {
            return props.height ? ns.cssVarBlock({
              height: props.height
            }) : {};
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("header", {
              class: normalizeClass(unref(ns).b()),
              style: normalizeStyle(unref(style))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 6);
          };
        }
      });
      var Header = /* @__PURE__ */ _export_sfc$1(_sfc_main$H, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/header.vue"]]);
      const __default__$g = defineComponent({
        name: "ElMain"
      });
      const _sfc_main$G = /* @__PURE__ */ defineComponent({
        ...__default__$g,
        setup(__props) {
          const ns = useNamespace("main");
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("main", {
              class: normalizeClass(unref(ns).b())
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Main = /* @__PURE__ */ _export_sfc$1(_sfc_main$G, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/main.vue"]]);
      const ElContainer = withInstall(Container, {
        Aside,
        Footer,
        Header,
        Main
      });
      const ElAside = withNoopInstall(Aside);
      withNoopInstall(Footer);
      withNoopInstall(Header);
      const ElMain = withNoopInstall(Main);
      const overlayProps = buildProps({
        mask: {
          type: Boolean,
          default: true
        },
        customMaskEvent: {
          type: Boolean,
          default: false
        },
        overlayClass: {
          type: definePropType([
            String,
            Array,
            Object
          ])
        },
        zIndex: {
          type: definePropType([String, Number])
        }
      });
      const overlayEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      const BLOCK = "overlay";
      var Overlay = defineComponent({
        name: "ElOverlay",
        props: overlayProps,
        emits: overlayEmits,
        setup(props, { slots, emit: emit2 }) {
          const ns = useNamespace(BLOCK);
          const onMaskClick = (e2) => {
            emit2("click", e2);
          };
          const { onClick, onMousedown, onMouseup } = useSameTarget(props.customMaskEvent ? void 0 : onMaskClick);
          return () => {
            return props.mask ? createVNode("div", {
              class: [ns.b(), props.overlayClass],
              style: {
                zIndex: props.zIndex
              },
              onClick,
              onMousedown,
              onMouseup
            }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h$1("div", {
              class: props.overlayClass,
              style: {
                zIndex: props.zIndex,
                position: "fixed",
                top: "0px",
                right: "0px",
                bottom: "0px",
                left: "0px"
              }
            }, [renderSlot(slots, "default")]);
          };
        }
      });
      const ElOverlay = Overlay;
      const dialogInjectionKey = Symbol("dialogInjectionKey");
      const dialogContentProps = buildProps({
        center: {
          type: Boolean,
          default: false
        },
        alignCenter: {
          type: Boolean,
          default: false
        },
        closeIcon: {
          type: iconPropType
        },
        customClass: {
          type: String,
          default: ""
        },
        draggable: {
          type: Boolean,
          default: false
        },
        fullscreen: {
          type: Boolean,
          default: false
        },
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        }
      });
      const dialogContentEmits = {
        close: () => true
      };
      const _hoisted_1$H = ["aria-label"];
      const _hoisted_2$x = ["id"];
      const __default__$f = defineComponent({ name: "ElDialogContent" });
      const _sfc_main$F = /* @__PURE__ */ defineComponent({
        ...__default__$f,
        props: dialogContentProps,
        emits: dialogContentEmits,
        setup(__props) {
          const props = __props;
          const { t: t2 } = useLocale();
          const { Close } = CloseComponents;
          const { dialogRef, headerRef, bodyId, ns, style } = inject(dialogInjectionKey);
          const { focusTrapRef } = inject(FOCUS_TRAP_INJECTION_KEY);
          const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
          const draggable = computed(() => props.draggable);
          useDraggable(dialogRef, headerRef, draggable);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref: unref(composedDialogRef),
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).is("fullscreen", _ctx.fullscreen),
                unref(ns).is("draggable", unref(draggable)),
                unref(ns).is("align-center", _ctx.alignCenter),
                { [unref(ns).m("center")]: _ctx.center },
                _ctx.customClass
              ]),
              style: normalizeStyle(unref(style)),
              tabindex: "-1"
            }, [
              createBaseVNode("header", {
                ref_key: "headerRef",
                ref: headerRef,
                class: normalizeClass(unref(ns).e("header"))
              }, [
                renderSlot(_ctx.$slots, "header", {}, () => [
                  createBaseVNode("span", {
                    role: "heading",
                    class: normalizeClass(unref(ns).e("title"))
                  }, toDisplayString(_ctx.title), 3)
                ]),
                _ctx.showClose ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  "aria-label": unref(t2)("el.dialog.close"),
                  class: normalizeClass(unref(ns).e("headerbtn")),
                  type: "button",
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
                }, [
                  createVNode(unref(ElIcon), {
                    class: normalizeClass(unref(ns).e("close"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon || unref(Close))))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ], 10, _hoisted_1$H)) : createCommentVNode("v-if", true)
              ], 2),
              createBaseVNode("div", {
                id: unref(bodyId),
                class: normalizeClass(unref(ns).e("body"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 10, _hoisted_2$x),
              _ctx.$slots.footer ? (openBlock(), createElementBlock("footer", {
                key: 0,
                class: normalizeClass(unref(ns).e("footer"))
              }, [
                renderSlot(_ctx.$slots, "footer")
              ], 2)) : createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var ElDialogContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$F, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog-content.vue"]]);
      const dialogProps = buildProps({
        ...dialogContentProps,
        appendToBody: {
          type: Boolean,
          default: false
        },
        beforeClose: {
          type: definePropType(Function)
        },
        destroyOnClose: {
          type: Boolean,
          default: false
        },
        closeOnClickModal: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        lockScroll: {
          type: Boolean,
          default: true
        },
        modal: {
          type: Boolean,
          default: true
        },
        openDelay: {
          type: Number,
          default: 0
        },
        closeDelay: {
          type: Number,
          default: 0
        },
        top: {
          type: String
        },
        modelValue: {
          type: Boolean,
          default: false
        },
        modalClass: String,
        width: {
          type: [String, Number]
        },
        zIndex: {
          type: Number
        },
        trapFocus: {
          type: Boolean,
          default: false
        }
      });
      const dialogEmits = {
        open: () => true,
        opened: () => true,
        close: () => true,
        closed: () => true,
        [UPDATE_MODEL_EVENT]: (value) => isBoolean(value),
        openAutoFocus: () => true,
        closeAutoFocus: () => true
      };
      const useDialog = (props, targetRef) => {
        const instance = getCurrentInstance();
        const emit2 = instance.emit;
        const { nextZIndex } = useZIndex();
        let lastPosition = "";
        const titleId = useId();
        const bodyId = useId();
        const visible = ref(false);
        const closed = ref(false);
        const rendered = ref(false);
        const zIndex2 = ref(props.zIndex || nextZIndex());
        let openTimer = void 0;
        let closeTimer = void 0;
        const namespace = useGlobalConfig("namespace", defaultNamespace);
        const style = computed(() => {
          const style2 = {};
          const varPrefix = `--${namespace.value}-dialog`;
          if (!props.fullscreen) {
            if (props.top) {
              style2[`${varPrefix}-margin-top`] = props.top;
            }
            if (props.width) {
              style2[`${varPrefix}-width`] = addUnit(props.width);
            }
          }
          return style2;
        });
        const overlayDialogStyle = computed(() => {
          if (props.alignCenter) {
            return { display: "flex" };
          }
          return {};
        });
        function afterEnter() {
          emit2("opened");
        }
        function afterLeave() {
          emit2("closed");
          emit2(UPDATE_MODEL_EVENT, false);
          if (props.destroyOnClose) {
            rendered.value = false;
          }
        }
        function beforeLeave() {
          emit2("close");
        }
        function open2() {
          closeTimer == null ? void 0 : closeTimer();
          openTimer == null ? void 0 : openTimer();
          if (props.openDelay && props.openDelay > 0) {
            ({ stop: openTimer } = useTimeoutFn$1(() => doOpen(), props.openDelay));
          } else {
            doOpen();
          }
        }
        function close2() {
          openTimer == null ? void 0 : openTimer();
          closeTimer == null ? void 0 : closeTimer();
          if (props.closeDelay && props.closeDelay > 0) {
            ({ stop: closeTimer } = useTimeoutFn$1(() => doClose(), props.closeDelay));
          } else {
            doClose();
          }
        }
        function handleClose() {
          function hide(shouldCancel) {
            if (shouldCancel)
              return;
            closed.value = true;
            visible.value = false;
          }
          if (props.beforeClose) {
            props.beforeClose(hide);
          } else {
            close2();
          }
        }
        function onModalClick() {
          if (props.closeOnClickModal) {
            handleClose();
          }
        }
        function doOpen() {
          if (!isClient$1)
            return;
          visible.value = true;
        }
        function doClose() {
          visible.value = false;
        }
        function onOpenAutoFocus() {
          emit2("openAutoFocus");
        }
        function onCloseAutoFocus() {
          emit2("closeAutoFocus");
        }
        function onFocusoutPrevented(event) {
          var _a2;
          if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) === "pointer") {
            event.preventDefault();
          }
        }
        if (props.lockScroll) {
          useLockscreen(visible);
        }
        function onCloseRequested() {
          if (props.closeOnPressEscape) {
            handleClose();
          }
        }
        watch(() => props.modelValue, (val) => {
          if (val) {
            closed.value = false;
            open2();
            rendered.value = true;
            zIndex2.value = props.zIndex ? zIndex2.value++ : nextZIndex();
            nextTick(() => {
              emit2("open");
              if (targetRef.value) {
                targetRef.value.scrollTop = 0;
              }
            });
          } else {
            if (visible.value) {
              close2();
            }
          }
        });
        watch(() => props.fullscreen, (val) => {
          if (!targetRef.value)
            return;
          if (val) {
            lastPosition = targetRef.value.style.transform;
            targetRef.value.style.transform = "";
          } else {
            targetRef.value.style.transform = lastPosition;
          }
        });
        onMounted(() => {
          if (props.modelValue) {
            visible.value = true;
            rendered.value = true;
            open2();
          }
        });
        return {
          afterEnter,
          afterLeave,
          beforeLeave,
          handleClose,
          onModalClick,
          close: close2,
          doClose,
          onOpenAutoFocus,
          onCloseAutoFocus,
          onCloseRequested,
          onFocusoutPrevented,
          titleId,
          bodyId,
          closed,
          style,
          overlayDialogStyle,
          rendered,
          visible,
          zIndex: zIndex2
        };
      };
      const _hoisted_1$G = ["aria-label", "aria-labelledby", "aria-describedby"];
      const __default__$e = defineComponent({
        name: "ElDialog",
        inheritAttrs: false
      });
      const _sfc_main$E = /* @__PURE__ */ defineComponent({
        ...__default__$e,
        props: dialogProps,
        emits: dialogEmits,
        setup(__props, { expose }) {
          const props = __props;
          const slots = useSlots();
          useDeprecated({
            scope: "el-dialog",
            from: "the title slot",
            replacement: "the header slot",
            version: "3.0.0",
            ref: "https://element-plus.org/en-US/component/dialog.html#slots"
          }, computed(() => !!slots.title));
          useDeprecated({
            scope: "el-dialog",
            from: "custom-class",
            replacement: "class",
            version: "2.3.0",
            ref: "https://element-plus.org/en-US/component/dialog.html#attributes",
            type: "Attribute"
          }, computed(() => !!props.customClass));
          const ns = useNamespace("dialog");
          const dialogRef = ref();
          const headerRef = ref();
          const dialogContentRef = ref();
          const {
            visible,
            titleId,
            bodyId,
            style,
            overlayDialogStyle,
            rendered,
            zIndex: zIndex2,
            afterEnter,
            afterLeave,
            beforeLeave,
            handleClose,
            onModalClick,
            onOpenAutoFocus,
            onCloseAutoFocus,
            onCloseRequested,
            onFocusoutPrevented
          } = useDialog(props, dialogRef);
          provide(dialogInjectionKey, {
            dialogRef,
            headerRef,
            bodyId,
            ns,
            rendered,
            style
          });
          const overlayEvent = useSameTarget(onModalClick);
          const draggable = computed(() => props.draggable && !props.fullscreen);
          expose({
            visible,
            dialogContentRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              to: "body",
              disabled: !_ctx.appendToBody
            }, [
              createVNode(Transition, {
                name: "dialog-fade",
                onAfterEnter: unref(afterEnter),
                onAfterLeave: unref(afterLeave),
                onBeforeLeave: unref(beforeLeave),
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createVNode(unref(ElOverlay), {
                    "custom-mask-event": "",
                    mask: _ctx.modal,
                    "overlay-class": _ctx.modalClass,
                    "z-index": unref(zIndex2)
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        role: "dialog",
                        "aria-modal": "true",
                        "aria-label": _ctx.title || void 0,
                        "aria-labelledby": !_ctx.title ? unref(titleId) : void 0,
                        "aria-describedby": unref(bodyId),
                        class: normalizeClass(`${unref(ns).namespace.value}-overlay-dialog`),
                        style: normalizeStyle(unref(overlayDialogStyle)),
                        onClick: _cache[0] || (_cache[0] = (...args) => unref(overlayEvent).onClick && unref(overlayEvent).onClick(...args)),
                        onMousedown: _cache[1] || (_cache[1] = (...args) => unref(overlayEvent).onMousedown && unref(overlayEvent).onMousedown(...args)),
                        onMouseup: _cache[2] || (_cache[2] = (...args) => unref(overlayEvent).onMouseup && unref(overlayEvent).onMouseup(...args))
                      }, [
                        createVNode(unref(ElFocusTrap), {
                          loop: "",
                          trapped: unref(visible),
                          "focus-start-el": "container",
                          onFocusAfterTrapped: unref(onOpenAutoFocus),
                          onFocusAfterReleased: unref(onCloseAutoFocus),
                          onFocusoutPrevented: unref(onFocusoutPrevented),
                          onReleaseRequested: unref(onCloseRequested)
                        }, {
                          default: withCtx(() => [
                            unref(rendered) ? (openBlock(), createBlock(ElDialogContent, mergeProps({
                              key: 0,
                              ref_key: "dialogContentRef",
                              ref: dialogContentRef
                            }, _ctx.$attrs, {
                              "custom-class": _ctx.customClass,
                              center: _ctx.center,
                              "align-center": _ctx.alignCenter,
                              "close-icon": _ctx.closeIcon,
                              draggable: unref(draggable),
                              fullscreen: _ctx.fullscreen,
                              "show-close": _ctx.showClose,
                              title: _ctx.title,
                              onClose: unref(handleClose)
                            }), createSlots({
                              header: withCtx(() => [
                                !_ctx.$slots.title ? renderSlot(_ctx.$slots, "header", {
                                  key: 0,
                                  close: unref(handleClose),
                                  titleId: unref(titleId),
                                  titleClass: unref(ns).e("title")
                                }) : renderSlot(_ctx.$slots, "title", { key: 1 })
                              ]),
                              default: withCtx(() => [
                                renderSlot(_ctx.$slots, "default")
                              ]),
                              _: 2
                            }, [
                              _ctx.$slots.footer ? {
                                name: "footer",
                                fn: withCtx(() => [
                                  renderSlot(_ctx.$slots, "footer")
                                ])
                              } : void 0
                            ]), 1040, ["custom-class", "center", "align-center", "close-icon", "draggable", "fullscreen", "show-close", "title", "onClose"])) : createCommentVNode("v-if", true)
                          ]),
                          _: 3
                        }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                      ], 46, _hoisted_1$G)
                    ]),
                    _: 3
                  }, 8, ["mask", "overlay-class", "z-index"]), [
                    [vShow, unref(visible)]
                  ])
                ]),
                _: 3
              }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
            ], 8, ["disabled"]);
          };
        }
      });
      var Dialog = /* @__PURE__ */ _export_sfc$1(_sfc_main$E, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog.vue"]]);
      const ElDialog = withInstall(Dialog);
      const _sfc_main$D = /* @__PURE__ */ defineComponent({
        inheritAttrs: false
      });
      function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default");
      }
      var Collection = /* @__PURE__ */ _export_sfc$1(_sfc_main$D, [["render", _sfc_render$g], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);
      const _sfc_main$C = /* @__PURE__ */ defineComponent({
        name: "ElCollectionItem",
        inheritAttrs: false
      });
      function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default");
      }
      var CollectionItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$C, [["render", _sfc_render$f], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);
      const COLLECTION_ITEM_SIGN = `data-el-collection-item`;
      const createCollectionWithScope = (name) => {
        const COLLECTION_NAME = `El${name}Collection`;
        const COLLECTION_ITEM_NAME = `${COLLECTION_NAME}Item`;
        const COLLECTION_INJECTION_KEY2 = Symbol(COLLECTION_NAME);
        const COLLECTION_ITEM_INJECTION_KEY2 = Symbol(COLLECTION_ITEM_NAME);
        const ElCollection2 = {
          ...Collection,
          name: COLLECTION_NAME,
          setup() {
            const collectionRef = ref(null);
            const itemMap = /* @__PURE__ */ new Map();
            const getItems = () => {
              const collectionEl = unref(collectionRef);
              if (!collectionEl)
                return [];
              const orderedNodes = Array.from(collectionEl.querySelectorAll(`[${COLLECTION_ITEM_SIGN}]`));
              const items = [...itemMap.values()];
              return items.sort((a2, b2) => orderedNodes.indexOf(a2.ref) - orderedNodes.indexOf(b2.ref));
            };
            provide(COLLECTION_INJECTION_KEY2, {
              itemMap,
              getItems,
              collectionRef
            });
          }
        };
        const ElCollectionItem2 = {
          ...CollectionItem,
          name: COLLECTION_ITEM_NAME,
          setup(_2, { attrs }) {
            const collectionItemRef = ref(null);
            const collectionInjection = inject(COLLECTION_INJECTION_KEY2, void 0);
            provide(COLLECTION_ITEM_INJECTION_KEY2, {
              collectionItemRef
            });
            onMounted(() => {
              const collectionItemEl = unref(collectionItemRef);
              if (collectionItemEl) {
                collectionInjection.itemMap.set(collectionItemEl, {
                  ref: collectionItemEl,
                  ...attrs
                });
              }
            });
            onBeforeUnmount(() => {
              const collectionItemEl = unref(collectionItemRef);
              collectionInjection.itemMap.delete(collectionItemEl);
            });
          }
        };
        return {
          COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY2,
          COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY2,
          ElCollection: ElCollection2,
          ElCollectionItem: ElCollectionItem2
        };
      };
      const rovingFocusGroupProps = buildProps({
        style: { type: definePropType([String, Array, Object]) },
        currentTabId: {
          type: definePropType(String)
        },
        defaultCurrentTabId: String,
        loop: Boolean,
        dir: {
          type: String,
          values: ["ltr", "rtl"],
          default: "ltr"
        },
        orientation: {
          type: definePropType(String)
        },
        onBlur: Function,
        onFocus: Function,
        onMousedown: Function
      });
      const {
        ElCollection: ElCollection$1,
        ElCollectionItem: ElCollectionItem$1,
        COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY$1,
        COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY$1
      } = createCollectionWithScope("RovingFocusGroup");
      const ROVING_FOCUS_GROUP_INJECTION_KEY = Symbol("elRovingFocusGroup");
      const ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY = Symbol("elRovingFocusGroupItem");
      const MAP_KEY_TO_FOCUS_INTENT = {
        ArrowLeft: "prev",
        ArrowUp: "prev",
        ArrowRight: "next",
        ArrowDown: "next",
        PageUp: "first",
        Home: "first",
        PageDown: "last",
        End: "last"
      };
      const getDirectionAwareKey = (key, dir) => {
        if (dir !== "rtl")
          return key;
        switch (key) {
          case EVENT_CODE.right:
            return EVENT_CODE.left;
          case EVENT_CODE.left:
            return EVENT_CODE.right;
          default:
            return key;
        }
      };
      const getFocusIntent = (event, orientation, dir) => {
        const key = getDirectionAwareKey(event.key, dir);
        if (orientation === "vertical" && [EVENT_CODE.left, EVENT_CODE.right].includes(key))
          return void 0;
        if (orientation === "horizontal" && [EVENT_CODE.up, EVENT_CODE.down].includes(key))
          return void 0;
        return MAP_KEY_TO_FOCUS_INTENT[key];
      };
      const reorderArray = (array2, atIdx) => {
        return array2.map((_2, idx) => array2[(idx + atIdx) % array2.length]);
      };
      const focusFirst = (elements) => {
        const { activeElement: prevActive } = document;
        for (const element of elements) {
          if (element === prevActive)
            return;
          element.focus();
          if (prevActive !== document.activeElement)
            return;
        }
      };
      const CURRENT_TAB_ID_CHANGE_EVT = "currentTabIdChange";
      const ENTRY_FOCUS_EVT = "rovingFocusGroup.entryFocus";
      const EVT_OPTS = { bubbles: false, cancelable: true };
      const _sfc_main$B = defineComponent({
        name: "ElRovingFocusGroupImpl",
        inheritAttrs: false,
        props: rovingFocusGroupProps,
        emits: [CURRENT_TAB_ID_CHANGE_EVT, "entryFocus"],
        setup(props, { emit: emit2 }) {
          var _a2;
          const currentTabbedId = ref((_a2 = props.currentTabId || props.defaultCurrentTabId) != null ? _a2 : null);
          const isBackingOut = ref(false);
          const isClickFocus = ref(false);
          const rovingFocusGroupRef = ref(null);
          const { getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
          const rovingFocusGroupRootStyle = computed(() => {
            return [
              {
                outline: "none"
              },
              props.style
            ];
          });
          const onItemFocus = (tabbedId) => {
            emit2(CURRENT_TAB_ID_CHANGE_EVT, tabbedId);
          };
          const onItemShiftTab = () => {
            isBackingOut.value = true;
          };
          const onMousedown = composeEventHandlers((e2) => {
            var _a22;
            (_a22 = props.onMousedown) == null ? void 0 : _a22.call(props, e2);
          }, () => {
            isClickFocus.value = true;
          });
          const onFocus = composeEventHandlers((e2) => {
            var _a22;
            (_a22 = props.onFocus) == null ? void 0 : _a22.call(props, e2);
          }, (e2) => {
            const isKeyboardFocus = !unref(isClickFocus);
            const { target, currentTarget } = e2;
            if (target === currentTarget && isKeyboardFocus && !unref(isBackingOut)) {
              const entryFocusEvt = new Event(ENTRY_FOCUS_EVT, EVT_OPTS);
              currentTarget == null ? void 0 : currentTarget.dispatchEvent(entryFocusEvt);
              if (!entryFocusEvt.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === unref(currentTabbedId));
                const candidates = [activeItem, currentItem, ...items].filter(Boolean);
                const candidateNodes = candidates.map((item) => item.ref);
                focusFirst(candidateNodes);
              }
            }
            isClickFocus.value = false;
          });
          const onBlur = composeEventHandlers((e2) => {
            var _a22;
            (_a22 = props.onBlur) == null ? void 0 : _a22.call(props, e2);
          }, () => {
            isBackingOut.value = false;
          });
          const handleEntryFocus = (...args) => {
            emit2("entryFocus", ...args);
          };
          provide(ROVING_FOCUS_GROUP_INJECTION_KEY, {
            currentTabbedId: readonly(currentTabbedId),
            loop: toRef$1(props, "loop"),
            tabIndex: computed(() => {
              return unref(isBackingOut) ? -1 : 0;
            }),
            rovingFocusGroupRef,
            rovingFocusGroupRootStyle,
            orientation: toRef$1(props, "orientation"),
            dir: toRef$1(props, "dir"),
            onItemFocus,
            onItemShiftTab,
            onBlur,
            onFocus,
            onMousedown
          });
          watch(() => props.currentTabId, (val) => {
            currentTabbedId.value = val != null ? val : null;
          });
          useEventListener$1(rovingFocusGroupRef, ENTRY_FOCUS_EVT, handleEntryFocus);
        }
      });
      function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default");
      }
      var ElRovingFocusGroupImpl = /* @__PURE__ */ _export_sfc$1(_sfc_main$B, [["render", _sfc_render$e], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group-impl.vue"]]);
      const _sfc_main$A = defineComponent({
        name: "ElRovingFocusGroup",
        components: {
          ElFocusGroupCollection: ElCollection$1,
          ElRovingFocusGroupImpl
        }
      });
      function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_roving_focus_group_impl = resolveComponent("el-roving-focus-group-impl");
        const _component_el_focus_group_collection = resolveComponent("el-focus-group-collection");
        return openBlock(), createBlock(_component_el_focus_group_collection, null, {
          default: withCtx(() => [
            createVNode(_component_el_roving_focus_group_impl, normalizeProps(guardReactiveProps(_ctx.$attrs)), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        });
      }
      var ElRovingFocusGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$A, [["render", _sfc_render$d], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group.vue"]]);
      const _sfc_main$z = defineComponent({
        components: {
          ElRovingFocusCollectionItem: ElCollectionItem$1
        },
        props: {
          focusable: {
            type: Boolean,
            default: true
          },
          active: {
            type: Boolean,
            default: false
          }
        },
        emits: ["mousedown", "focus", "keydown"],
        setup(props, { emit: emit2 }) {
          const { currentTabbedId, loop, onItemFocus, onItemShiftTab } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
          const { getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
          const id2 = useId();
          const rovingFocusGroupItemRef = ref(null);
          const handleMousedown = composeEventHandlers((e2) => {
            emit2("mousedown", e2);
          }, (e2) => {
            if (!props.focusable) {
              e2.preventDefault();
            } else {
              onItemFocus(unref(id2));
            }
          });
          const handleFocus = composeEventHandlers((e2) => {
            emit2("focus", e2);
          }, () => {
            onItemFocus(unref(id2));
          });
          const handleKeydown = composeEventHandlers((e2) => {
            emit2("keydown", e2);
          }, (e2) => {
            const { key, shiftKey, target, currentTarget } = e2;
            if (key === EVENT_CODE.tab && shiftKey) {
              onItemShiftTab();
              return;
            }
            if (target !== currentTarget)
              return;
            const focusIntent = getFocusIntent(e2);
            if (focusIntent) {
              e2.preventDefault();
              const items = getItems().filter((item) => item.focusable);
              let elements = items.map((item) => item.ref);
              switch (focusIntent) {
                case "last": {
                  elements.reverse();
                  break;
                }
                case "prev":
                case "next": {
                  if (focusIntent === "prev") {
                    elements.reverse();
                  }
                  const currentIdx = elements.indexOf(currentTarget);
                  elements = loop.value ? reorderArray(elements, currentIdx + 1) : elements.slice(currentIdx + 1);
                  break;
                }
              }
              nextTick(() => {
                focusFirst(elements);
              });
            }
          });
          const isCurrentTab = computed(() => currentTabbedId.value === unref(id2));
          provide(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, {
            rovingFocusGroupItemRef,
            tabIndex: computed(() => unref(isCurrentTab) ? 0 : -1),
            handleMousedown,
            handleFocus,
            handleKeydown
          });
          return {
            id: id2,
            handleKeydown,
            handleFocus,
            handleMousedown
          };
        }
      });
      function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_roving_focus_collection_item = resolveComponent("el-roving-focus-collection-item");
        return openBlock(), createBlock(_component_el_roving_focus_collection_item, {
          id: _ctx.id,
          focusable: _ctx.focusable,
          active: _ctx.active
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "focusable", "active"]);
      }
      var ElRovingFocusItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$z, [["render", _sfc_render$c], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-item.vue"]]);
      const dropdownProps = buildProps({
        trigger: useTooltipTriggerProps.trigger,
        effect: {
          ...useTooltipContentProps.effect,
          default: "light"
        },
        type: {
          type: definePropType(String)
        },
        placement: {
          type: definePropType(String),
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        id: String,
        size: {
          type: String,
          default: ""
        },
        splitButton: Boolean,
        hideOnClick: {
          type: Boolean,
          default: true
        },
        loop: {
          type: Boolean,
          default: true
        },
        showTimeout: {
          type: Number,
          default: 150
        },
        hideTimeout: {
          type: Number,
          default: 150
        },
        tabindex: {
          type: definePropType([Number, String]),
          default: 0
        },
        maxHeight: {
          type: definePropType([Number, String]),
          default: ""
        },
        popperClass: {
          type: String,
          default: ""
        },
        disabled: {
          type: Boolean,
          default: false
        },
        role: {
          type: String,
          default: "menu"
        },
        buttonProps: {
          type: definePropType(Object)
        },
        teleported: useTooltipContentProps.teleported
      });
      const dropdownItemProps = buildProps({
        command: {
          type: [Object, String, Number],
          default: () => ({})
        },
        disabled: Boolean,
        divided: Boolean,
        textValue: String,
        icon: {
          type: iconPropType
        }
      });
      const dropdownMenuProps = buildProps({
        onKeydown: { type: definePropType(Function) }
      });
      const FIRST_KEYS = [
        EVENT_CODE.down,
        EVENT_CODE.pageDown,
        EVENT_CODE.home
      ];
      const LAST_KEYS = [EVENT_CODE.up, EVENT_CODE.pageUp, EVENT_CODE.end];
      const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
      const {
        ElCollection,
        ElCollectionItem,
        COLLECTION_INJECTION_KEY,
        COLLECTION_ITEM_INJECTION_KEY
      } = createCollectionWithScope("Dropdown");
      const DROPDOWN_INJECTION_KEY = Symbol("elDropdown");
      const { ButtonGroup: ElButtonGroup } = ElButton;
      const _sfc_main$y = defineComponent({
        name: "ElDropdown",
        components: {
          ElButton,
          ElButtonGroup,
          ElScrollbar,
          ElDropdownCollection: ElCollection,
          ElTooltip,
          ElRovingFocusGroup,
          ElOnlyChild: OnlyChild,
          ElIcon,
          ArrowDown: arrow_down_default
        },
        props: dropdownProps,
        emits: ["visible-change", "click", "command"],
        setup(props, { emit: emit2 }) {
          const _instance = getCurrentInstance();
          const ns = useNamespace("dropdown");
          const { t: t2 } = useLocale();
          const triggeringElementRef = ref();
          const referenceElementRef = ref();
          const popperRef = ref(null);
          const contentRef = ref(null);
          const scrollbar = ref(null);
          const currentTabId = ref(null);
          const isUsingKeyboard = ref(false);
          const triggerKeys = [EVENT_CODE.enter, EVENT_CODE.space, EVENT_CODE.down];
          const wrapStyle = computed(() => ({
            maxHeight: addUnit(props.maxHeight)
          }));
          const dropdownTriggerKls = computed(() => [ns.m(dropdownSize.value)]);
          const defaultTriggerId = useId().value;
          const triggerId = computed(() => {
            return props.id || defaultTriggerId;
          });
          watch([triggeringElementRef, toRef$1(props, "trigger")], ([triggeringElement, trigger2], [prevTriggeringElement]) => {
            var _a2, _b, _c;
            const triggerArray = isArray$2(trigger2) ? trigger2 : [trigger2];
            if ((_a2 = prevTriggeringElement == null ? void 0 : prevTriggeringElement.$el) == null ? void 0 : _a2.removeEventListener) {
              prevTriggeringElement.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
            }
            if ((_b = triggeringElement == null ? void 0 : triggeringElement.$el) == null ? void 0 : _b.removeEventListener) {
              triggeringElement.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
            }
            if (((_c = triggeringElement == null ? void 0 : triggeringElement.$el) == null ? void 0 : _c.addEventListener) && triggerArray.includes("hover")) {
              triggeringElement.$el.addEventListener("pointerenter", onAutofocusTriggerEnter);
            }
          }, { immediate: true });
          onBeforeUnmount(() => {
            var _a2, _b;
            if ((_b = (_a2 = triggeringElementRef.value) == null ? void 0 : _a2.$el) == null ? void 0 : _b.removeEventListener) {
              triggeringElementRef.value.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
            }
          });
          function handleClick() {
            handleClose();
          }
          function handleClose() {
            var _a2;
            (_a2 = popperRef.value) == null ? void 0 : _a2.onClose();
          }
          function handleOpen() {
            var _a2;
            (_a2 = popperRef.value) == null ? void 0 : _a2.onOpen();
          }
          const dropdownSize = useFormSize();
          function commandHandler(...args) {
            emit2("command", ...args);
          }
          function onAutofocusTriggerEnter() {
            var _a2, _b;
            (_b = (_a2 = triggeringElementRef.value) == null ? void 0 : _a2.$el) == null ? void 0 : _b.focus();
          }
          function onItemEnter() {
          }
          function onItemLeave() {
            const contentEl = unref(contentRef);
            contentEl == null ? void 0 : contentEl.focus();
            currentTabId.value = null;
          }
          function handleCurrentTabIdChange(id2) {
            currentTabId.value = id2;
          }
          function handleEntryFocus(e2) {
            if (!isUsingKeyboard.value) {
              e2.preventDefault();
              e2.stopImmediatePropagation();
            }
          }
          function handleBeforeShowTooltip() {
            emit2("visible-change", true);
          }
          function handleShowTooltip(event) {
            if ((event == null ? void 0 : event.type) === "keydown") {
              contentRef.value.focus();
            }
          }
          function handleBeforeHideTooltip() {
            emit2("visible-change", false);
          }
          provide(DROPDOWN_INJECTION_KEY, {
            contentRef,
            role: computed(() => props.role),
            triggerId,
            isUsingKeyboard,
            onItemEnter,
            onItemLeave
          });
          provide("elDropdown", {
            instance: _instance,
            dropdownSize,
            handleClick,
            commandHandler,
            trigger: toRef$1(props, "trigger"),
            hideOnClick: toRef$1(props, "hideOnClick")
          });
          const onFocusAfterTrapped = (e2) => {
            var _a2, _b;
            e2.preventDefault();
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2, {
              preventScroll: true
            });
          };
          const handlerMainButtonClick = (event) => {
            emit2("click", event);
          };
          return {
            t: t2,
            ns,
            scrollbar,
            wrapStyle,
            dropdownTriggerKls,
            dropdownSize,
            triggerId,
            triggerKeys,
            currentTabId,
            handleCurrentTabIdChange,
            handlerMainButtonClick,
            handleEntryFocus,
            handleClose,
            handleOpen,
            handleBeforeShowTooltip,
            handleShowTooltip,
            handleBeforeHideTooltip,
            onFocusAfterTrapped,
            popperRef,
            contentRef,
            triggeringElementRef,
            referenceElementRef
          };
        }
      });
      function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
        var _a2;
        const _component_el_dropdown_collection = resolveComponent("el-dropdown-collection");
        const _component_el_roving_focus_group = resolveComponent("el-roving-focus-group");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_el_only_child = resolveComponent("el-only-child");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _component_el_button = resolveComponent("el-button");
        const _component_arrow_down = resolveComponent("arrow-down");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_button_group = resolveComponent("el-button-group");
        return openBlock(), createElementBlock("div", {
          class: normalizeClass([_ctx.ns.b(), _ctx.ns.is("disabled", _ctx.disabled)])
        }, [
          createVNode(_component_el_tooltip, {
            ref: "popperRef",
            role: _ctx.role,
            effect: _ctx.effect,
            "fallback-placements": ["bottom", "top"],
            "popper-options": _ctx.popperOptions,
            "gpu-acceleration": false,
            "hide-after": _ctx.trigger === "hover" ? _ctx.hideTimeout : 0,
            "manual-mode": true,
            placement: _ctx.placement,
            "popper-class": [_ctx.ns.e("popper"), _ctx.popperClass],
            "reference-element": (_a2 = _ctx.referenceElementRef) == null ? void 0 : _a2.$el,
            trigger: _ctx.trigger,
            "trigger-keys": _ctx.triggerKeys,
            "trigger-target-el": _ctx.contentRef,
            "show-after": _ctx.trigger === "hover" ? _ctx.showTimeout : 0,
            "stop-popper-mouse-event": false,
            "virtual-ref": _ctx.triggeringElementRef,
            "virtual-triggering": _ctx.splitButton,
            disabled: _ctx.disabled,
            transition: `${_ctx.ns.namespace.value}-zoom-in-top`,
            teleported: _ctx.teleported,
            pure: "",
            persistent: "",
            onBeforeShow: _ctx.handleBeforeShowTooltip,
            onShow: _ctx.handleShowTooltip,
            onBeforeHide: _ctx.handleBeforeHideTooltip
          }, createSlots({
            content: withCtx(() => [
              createVNode(_component_el_scrollbar, {
                ref: "scrollbar",
                "wrap-style": _ctx.wrapStyle,
                tag: "div",
                "view-class": _ctx.ns.e("list")
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_roving_focus_group, {
                    loop: _ctx.loop,
                    "current-tab-id": _ctx.currentTabId,
                    orientation: "horizontal",
                    onCurrentTabIdChange: _ctx.handleCurrentTabIdChange,
                    onEntryFocus: _ctx.handleEntryFocus
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_el_dropdown_collection, null, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "dropdown")
                        ]),
                        _: 3
                      })
                    ]),
                    _: 3
                  }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"])
                ]),
                _: 3
              }, 8, ["wrap-style", "view-class"])
            ]),
            _: 2
          }, [
            !_ctx.splitButton ? {
              name: "default",
              fn: withCtx(() => [
                createVNode(_component_el_only_child, {
                  id: _ctx.triggerId,
                  ref: "triggeringElementRef",
                  role: "button",
                  tabindex: _ctx.tabindex
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["id", "tabindex"])
              ])
            } : void 0
          ]), 1032, ["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "teleported", "onBeforeShow", "onShow", "onBeforeHide"]),
          _ctx.splitButton ? (openBlock(), createBlock(_component_el_button_group, { key: 0 }, {
            default: withCtx(() => [
              createVNode(_component_el_button, mergeProps({ ref: "referenceElementRef" }, _ctx.buttonProps, {
                size: _ctx.dropdownSize,
                type: _ctx.type,
                disabled: _ctx.disabled,
                tabindex: _ctx.tabindex,
                onClick: _ctx.handlerMainButtonClick
              }), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 16, ["size", "type", "disabled", "tabindex", "onClick"]),
              createVNode(_component_el_button, mergeProps({
                id: _ctx.triggerId,
                ref: "triggeringElementRef"
              }, _ctx.buttonProps, {
                role: "button",
                size: _ctx.dropdownSize,
                type: _ctx.type,
                class: _ctx.ns.e("caret-button"),
                disabled: _ctx.disabled,
                tabindex: _ctx.tabindex,
                "aria-label": _ctx.t("el.dropdown.toggleDropdown")
              }), {
                default: withCtx(() => [
                  createVNode(_component_el_icon, {
                    class: normalizeClass(_ctx.ns.e("icon"))
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_arrow_down)
                    ]),
                    _: 1
                  }, 8, ["class"])
                ]),
                _: 1
              }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])
            ]),
            _: 3
          })) : createCommentVNode("v-if", true)
        ], 2);
      }
      var Dropdown = /* @__PURE__ */ _export_sfc$1(_sfc_main$y, [["render", _sfc_render$b], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown.vue"]]);
      const _sfc_main$x = defineComponent({
        name: "DropdownItemImpl",
        components: {
          ElIcon
        },
        props: dropdownItemProps,
        emits: ["pointermove", "pointerleave", "click", "clickimpl"],
        setup(_2, { emit: emit2 }) {
          const ns = useNamespace("dropdown");
          const { role: menuRole } = inject(DROPDOWN_INJECTION_KEY, void 0);
          const { collectionItemRef: dropdownCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY, void 0);
          const { collectionItemRef: rovingFocusCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY$1, void 0);
          const {
            rovingFocusGroupItemRef,
            tabIndex,
            handleFocus,
            handleKeydown: handleItemKeydown,
            handleMousedown
          } = inject(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, void 0);
          const itemRef = composeRefs(dropdownCollectionItemRef, rovingFocusCollectionItemRef, rovingFocusGroupItemRef);
          const role = computed(() => {
            if (menuRole.value === "menu") {
              return "menuitem";
            } else if (menuRole.value === "navigation") {
              return "link";
            }
            return "button";
          });
          const handleKeydown = composeEventHandlers((e2) => {
            const { code } = e2;
            if (code === EVENT_CODE.enter || code === EVENT_CODE.space) {
              e2.preventDefault();
              e2.stopImmediatePropagation();
              emit2("clickimpl", e2);
              return true;
            }
          }, handleItemKeydown);
          return {
            ns,
            itemRef,
            dataset: {
              [COLLECTION_ITEM_SIGN]: ""
            },
            role,
            tabIndex,
            handleFocus,
            handleKeydown,
            handleMousedown
          };
        }
      });
      const _hoisted_1$F = ["aria-disabled", "tabindex", "role"];
      function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_icon = resolveComponent("el-icon");
        return openBlock(), createElementBlock(Fragment, null, [
          _ctx.divided ? (openBlock(), createElementBlock("li", mergeProps({
            key: 0,
            role: "separator",
            class: _ctx.ns.bem("menu", "item", "divided")
          }, _ctx.$attrs), null, 16)) : createCommentVNode("v-if", true),
          createBaseVNode("li", mergeProps({ ref: _ctx.itemRef }, { ..._ctx.dataset, ..._ctx.$attrs }, {
            "aria-disabled": _ctx.disabled,
            class: [_ctx.ns.be("menu", "item"), _ctx.ns.is("disabled", _ctx.disabled)],
            tabindex: _ctx.tabIndex,
            role: _ctx.role,
            onClick: _cache[0] || (_cache[0] = (e2) => _ctx.$emit("clickimpl", e2)),
            onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
            onKeydown: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args), ["self"])),
            onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.handleMousedown && _ctx.handleMousedown(...args)),
            onPointermove: _cache[4] || (_cache[4] = (e2) => _ctx.$emit("pointermove", e2)),
            onPointerleave: _cache[5] || (_cache[5] = (e2) => _ctx.$emit("pointerleave", e2))
          }), [
            _ctx.icon ? (openBlock(), createBlock(_component_el_icon, { key: 0 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
              ]),
              _: 1
            })) : createCommentVNode("v-if", true),
            renderSlot(_ctx.$slots, "default")
          ], 16, _hoisted_1$F)
        ], 64);
      }
      var ElDropdownItemImpl = /* @__PURE__ */ _export_sfc$1(_sfc_main$x, [["render", _sfc_render$a], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item-impl.vue"]]);
      const useDropdown = () => {
        const elDropdown2 = inject("elDropdown", {});
        const _elDropdownSize = computed(() => elDropdown2 == null ? void 0 : elDropdown2.dropdownSize);
        return {
          elDropdown: elDropdown2,
          _elDropdownSize
        };
      };
      const _sfc_main$w = defineComponent({
        name: "ElDropdownItem",
        components: {
          ElDropdownCollectionItem: ElCollectionItem,
          ElRovingFocusItem,
          ElDropdownItemImpl
        },
        inheritAttrs: false,
        props: dropdownItemProps,
        emits: ["pointermove", "pointerleave", "click"],
        setup(props, { emit: emit2, attrs }) {
          const { elDropdown: elDropdown2 } = useDropdown();
          const _instance = getCurrentInstance();
          const itemRef = ref(null);
          const textContent = computed(() => {
            var _a2, _b;
            return (_b = (_a2 = unref(itemRef)) == null ? void 0 : _a2.textContent) != null ? _b : "";
          });
          const { onItemEnter, onItemLeave } = inject(DROPDOWN_INJECTION_KEY, void 0);
          const handlePointerMove = composeEventHandlers((e2) => {
            emit2("pointermove", e2);
            return e2.defaultPrevented;
          }, whenMouse((e2) => {
            if (props.disabled) {
              onItemLeave(e2);
              return;
            }
            const target = e2.currentTarget;
            if (target === document.activeElement || target.contains(document.activeElement)) {
              return;
            }
            onItemEnter(e2);
            if (!e2.defaultPrevented) {
              target == null ? void 0 : target.focus();
            }
          }));
          const handlePointerLeave = composeEventHandlers((e2) => {
            emit2("pointerleave", e2);
            return e2.defaultPrevented;
          }, whenMouse((e2) => {
            onItemLeave(e2);
          }));
          const handleClick = composeEventHandlers((e2) => {
            if (props.disabled) {
              return;
            }
            emit2("click", e2);
            return e2.type !== "keydown" && e2.defaultPrevented;
          }, (e2) => {
            var _a2, _b, _c;
            if (props.disabled) {
              e2.stopImmediatePropagation();
              return;
            }
            if ((_a2 = elDropdown2 == null ? void 0 : elDropdown2.hideOnClick) == null ? void 0 : _a2.value) {
              (_b = elDropdown2.handleClick) == null ? void 0 : _b.call(elDropdown2);
            }
            (_c = elDropdown2.commandHandler) == null ? void 0 : _c.call(elDropdown2, props.command, _instance, e2);
          });
          const propsAndAttrs = computed(() => {
            return { ...props, ...attrs };
          });
          return {
            handleClick,
            handlePointerMove,
            handlePointerLeave,
            textContent,
            propsAndAttrs
          };
        }
      });
      function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
        var _a2;
        const _component_el_dropdown_item_impl = resolveComponent("el-dropdown-item-impl");
        const _component_el_roving_focus_item = resolveComponent("el-roving-focus-item");
        const _component_el_dropdown_collection_item = resolveComponent("el-dropdown-collection-item");
        return openBlock(), createBlock(_component_el_dropdown_collection_item, {
          disabled: _ctx.disabled,
          "text-value": (_a2 = _ctx.textValue) != null ? _a2 : _ctx.textContent
        }, {
          default: withCtx(() => [
            createVNode(_component_el_roving_focus_item, {
              focusable: !_ctx.disabled
            }, {
              default: withCtx(() => [
                createVNode(_component_el_dropdown_item_impl, mergeProps(_ctx.propsAndAttrs, {
                  onPointerleave: _ctx.handlePointerLeave,
                  onPointermove: _ctx.handlePointerMove,
                  onClickimpl: _ctx.handleClick
                }), {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])
              ]),
              _: 3
            }, 8, ["focusable"])
          ]),
          _: 3
        }, 8, ["disabled", "text-value"]);
      }
      var DropdownItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$w, [["render", _sfc_render$9], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item.vue"]]);
      const _sfc_main$v = defineComponent({
        name: "ElDropdownMenu",
        props: dropdownMenuProps,
        setup(props) {
          const ns = useNamespace("dropdown");
          const { _elDropdownSize } = useDropdown();
          const size2 = _elDropdownSize.value;
          const { focusTrapRef, onKeydown } = inject(FOCUS_TRAP_INJECTION_KEY, void 0);
          const { contentRef, role, triggerId } = inject(DROPDOWN_INJECTION_KEY, void 0);
          const { collectionRef: dropdownCollectionRef, getItems } = inject(COLLECTION_INJECTION_KEY, void 0);
          const {
            rovingFocusGroupRef,
            rovingFocusGroupRootStyle,
            tabIndex,
            onBlur,
            onFocus,
            onMousedown
          } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
          const { collectionRef: rovingFocusGroupCollectionRef } = inject(COLLECTION_INJECTION_KEY$1, void 0);
          const dropdownKls = computed(() => {
            return [ns.b("menu"), ns.bm("menu", size2 == null ? void 0 : size2.value)];
          });
          const dropdownListWrapperRef = composeRefs(contentRef, dropdownCollectionRef, focusTrapRef, rovingFocusGroupRef, rovingFocusGroupCollectionRef);
          const composedKeydown = composeEventHandlers((e2) => {
            var _a2;
            (_a2 = props.onKeydown) == null ? void 0 : _a2.call(props, e2);
          }, (e2) => {
            const { currentTarget, code, target } = e2;
            currentTarget.contains(target);
            if (EVENT_CODE.tab === code) {
              e2.stopImmediatePropagation();
            }
            e2.preventDefault();
            if (target !== unref(contentRef))
              return;
            if (!FIRST_LAST_KEYS.includes(code))
              return;
            const items = getItems().filter((item) => !item.disabled);
            const targets = items.map((item) => item.ref);
            if (LAST_KEYS.includes(code)) {
              targets.reverse();
            }
            focusFirst(targets);
          });
          const handleKeydown = (e2) => {
            composedKeydown(e2);
            onKeydown(e2);
          };
          return {
            size: size2,
            rovingFocusGroupRootStyle,
            tabIndex,
            dropdownKls,
            role,
            triggerId,
            dropdownListWrapperRef,
            handleKeydown,
            onBlur,
            onFocus,
            onMousedown
          };
        }
      });
      const _hoisted_1$E = ["role", "aria-labelledby"];
      function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("ul", {
          ref: _ctx.dropdownListWrapperRef,
          class: normalizeClass(_ctx.dropdownKls),
          style: normalizeStyle(_ctx.rovingFocusGroupRootStyle),
          tabindex: -1,
          role: _ctx.role,
          "aria-labelledby": _ctx.triggerId,
          onBlur: _cache[0] || (_cache[0] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
          onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
          onKeydown: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args), ["self"])),
          onMousedown: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.onMousedown && _ctx.onMousedown(...args), ["self"]))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 46, _hoisted_1$E);
      }
      var DropdownMenu = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["render", _sfc_render$8], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-menu.vue"]]);
      const ElDropdown = withInstall(Dropdown, {
        DropdownItem,
        DropdownMenu
      });
      const ElDropdownItem = withNoopInstall(DropdownItem);
      const ElDropdownMenu = withNoopInstall(DropdownMenu);
      const imageViewerProps = buildProps({
        urlList: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        zIndex: {
          type: Number
        },
        initialIndex: {
          type: Number,
          default: 0
        },
        infinite: {
          type: Boolean,
          default: true
        },
        hideOnClickModal: Boolean,
        teleported: Boolean,
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        zoomRate: {
          type: Number,
          default: 1.2
        }
      });
      const imageViewerEmits = {
        close: () => true,
        switch: (index) => isNumber(index)
      };
      const _hoisted_1$D = ["src"];
      const __default__$d = defineComponent({
        name: "ElImageViewer"
      });
      const _sfc_main$u = /* @__PURE__ */ defineComponent({
        ...__default__$d,
        props: imageViewerProps,
        emits: imageViewerEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const modes = {
            CONTAIN: {
              name: "contain",
              icon: markRaw(full_screen_default)
            },
            ORIGINAL: {
              name: "original",
              icon: markRaw(scale_to_original_default)
            }
          };
          const { t: t2 } = useLocale();
          const ns = useNamespace("image-viewer");
          const { nextZIndex } = useZIndex();
          const wrapper = ref();
          const imgRefs = ref([]);
          const scopeEventListener = effectScope();
          const loading = ref(true);
          const activeIndex = ref(props.initialIndex);
          const mode = shallowRef(modes.CONTAIN);
          const transform = ref({
            scale: 1,
            deg: 0,
            offsetX: 0,
            offsetY: 0,
            enableTransition: false
          });
          const isSingle = computed(() => {
            const { urlList } = props;
            return urlList.length <= 1;
          });
          const isFirst = computed(() => {
            return activeIndex.value === 0;
          });
          const isLast = computed(() => {
            return activeIndex.value === props.urlList.length - 1;
          });
          const currentImg = computed(() => {
            return props.urlList[activeIndex.value];
          });
          const arrowPrevKls = computed(() => [
            ns.e("btn"),
            ns.e("prev"),
            ns.is("disabled", !props.infinite && isFirst.value)
          ]);
          const arrowNextKls = computed(() => [
            ns.e("btn"),
            ns.e("next"),
            ns.is("disabled", !props.infinite && isLast.value)
          ]);
          const imgStyle = computed(() => {
            const { scale, deg, offsetX, offsetY, enableTransition } = transform.value;
            let translateX = offsetX / scale;
            let translateY = offsetY / scale;
            switch (deg % 360) {
              case 90:
              case -270:
                [translateX, translateY] = [translateY, -translateX];
                break;
              case 180:
              case -180:
                [translateX, translateY] = [-translateX, -translateY];
                break;
              case 270:
              case -90:
                [translateX, translateY] = [-translateY, translateX];
                break;
            }
            const style = {
              transform: `scale(${scale}) rotate(${deg}deg) translate(${translateX}px, ${translateY}px)`,
              transition: enableTransition ? "transform .3s" : ""
            };
            if (mode.value.name === modes.CONTAIN.name) {
              style.maxWidth = style.maxHeight = "100%";
            }
            return style;
          });
          const computedZIndex = computed(() => {
            return isNumber(props.zIndex) ? props.zIndex : nextZIndex();
          });
          function hide() {
            unregisterEventListener();
            emit2("close");
          }
          function registerEventListener() {
            const keydownHandler = throttle((e2) => {
              switch (e2.code) {
                case EVENT_CODE.esc:
                  props.closeOnPressEscape && hide();
                  break;
                case EVENT_CODE.space:
                  toggleMode();
                  break;
                case EVENT_CODE.left:
                  prev();
                  break;
                case EVENT_CODE.up:
                  handleActions("zoomIn");
                  break;
                case EVENT_CODE.right:
                  next();
                  break;
                case EVENT_CODE.down:
                  handleActions("zoomOut");
                  break;
              }
            });
            const mousewheelHandler = throttle((e2) => {
              const delta = e2.deltaY || e2.deltaX;
              handleActions(delta < 0 ? "zoomIn" : "zoomOut", {
                zoomRate: props.zoomRate,
                enableTransition: false
              });
            });
            scopeEventListener.run(() => {
              useEventListener$1(document, "keydown", keydownHandler);
              useEventListener$1(document, "wheel", mousewheelHandler);
            });
          }
          function unregisterEventListener() {
            scopeEventListener.stop();
          }
          function handleImgLoad() {
            loading.value = false;
          }
          function handleImgError(e2) {
            loading.value = false;
            e2.target.alt = t2("el.image.error");
          }
          function handleMouseDown(e2) {
            if (loading.value || e2.button !== 0 || !wrapper.value)
              return;
            transform.value.enableTransition = false;
            const { offsetX, offsetY } = transform.value;
            const startX = e2.pageX;
            const startY = e2.pageY;
            const dragHandler = throttle((ev) => {
              transform.value = {
                ...transform.value,
                offsetX: offsetX + ev.pageX - startX,
                offsetY: offsetY + ev.pageY - startY
              };
            });
            const removeMousemove = useEventListener$1(document, "mousemove", dragHandler);
            useEventListener$1(document, "mouseup", () => {
              removeMousemove();
            });
            e2.preventDefault();
          }
          function reset() {
            transform.value = {
              scale: 1,
              deg: 0,
              offsetX: 0,
              offsetY: 0,
              enableTransition: false
            };
          }
          function toggleMode() {
            if (loading.value)
              return;
            const modeNames = keysOf(modes);
            const modeValues = Object.values(modes);
            const currentMode = mode.value.name;
            const index = modeValues.findIndex((i2) => i2.name === currentMode);
            const nextIndex = (index + 1) % modeNames.length;
            mode.value = modes[modeNames[nextIndex]];
            reset();
          }
          function setActiveItem(index) {
            const len = props.urlList.length;
            activeIndex.value = (index + len) % len;
          }
          function prev() {
            if (isFirst.value && !props.infinite)
              return;
            setActiveItem(activeIndex.value - 1);
          }
          function next() {
            if (isLast.value && !props.infinite)
              return;
            setActiveItem(activeIndex.value + 1);
          }
          function handleActions(action, options = {}) {
            if (loading.value)
              return;
            const { zoomRate, rotateDeg, enableTransition } = {
              zoomRate: props.zoomRate,
              rotateDeg: 90,
              enableTransition: true,
              ...options
            };
            switch (action) {
              case "zoomOut":
                if (transform.value.scale > 0.2) {
                  transform.value.scale = Number.parseFloat((transform.value.scale / zoomRate).toFixed(3));
                }
                break;
              case "zoomIn":
                if (transform.value.scale < 7) {
                  transform.value.scale = Number.parseFloat((transform.value.scale * zoomRate).toFixed(3));
                }
                break;
              case "clockwise":
                transform.value.deg += rotateDeg;
                break;
              case "anticlockwise":
                transform.value.deg -= rotateDeg;
                break;
            }
            transform.value.enableTransition = enableTransition;
          }
          watch(currentImg, () => {
            nextTick(() => {
              const $img = imgRefs.value[0];
              if (!($img == null ? void 0 : $img.complete)) {
                loading.value = true;
              }
            });
          });
          watch(activeIndex, (val) => {
            reset();
            emit2("switch", val);
          });
          onMounted(() => {
            var _a2, _b;
            registerEventListener();
            (_b = (_a2 = wrapper.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          });
          expose({
            setActiveItem
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              to: "body",
              disabled: !_ctx.teleported
            }, [
              createVNode(Transition, {
                name: "viewer-fade",
                appear: ""
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", {
                    ref_key: "wrapper",
                    ref: wrapper,
                    tabindex: -1,
                    class: normalizeClass(unref(ns).e("wrapper")),
                    style: normalizeStyle({ zIndex: unref(computedZIndex) })
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(unref(ns).e("mask")),
                      onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.hideOnClickModal && hide(), ["self"]))
                    }, null, 2),
                    createCommentVNode(" CLOSE "),
                    createBaseVNode("span", {
                      class: normalizeClass([unref(ns).e("btn"), unref(ns).e("close")]),
                      onClick: hide
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(close_default))
                        ]),
                        _: 1
                      })
                    ], 2),
                    createCommentVNode(" ARROW "),
                    !unref(isSingle) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createBaseVNode("span", {
                        class: normalizeClass(unref(arrowPrevKls)),
                        onClick: prev
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(arrow_left_default))
                          ]),
                          _: 1
                        })
                      ], 2),
                      createBaseVNode("span", {
                        class: normalizeClass(unref(arrowNextKls)),
                        onClick: next
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(arrow_right_default))
                          ]),
                          _: 1
                        })
                      ], 2)
                    ], 64)) : createCommentVNode("v-if", true),
                    createCommentVNode(" ACTIONS "),
                    createBaseVNode("div", {
                      class: normalizeClass([unref(ns).e("btn"), unref(ns).e("actions")])
                    }, [
                      createBaseVNode("div", {
                        class: normalizeClass(unref(ns).e("actions__inner"))
                      }, [
                        createVNode(unref(ElIcon), {
                          onClick: _cache[1] || (_cache[1] = ($event) => handleActions("zoomOut"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(zoom_out_default))
                          ]),
                          _: 1
                        }),
                        createVNode(unref(ElIcon), {
                          onClick: _cache[2] || (_cache[2] = ($event) => handleActions("zoomIn"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(zoom_in_default))
                          ]),
                          _: 1
                        }),
                        createBaseVNode("i", {
                          class: normalizeClass(unref(ns).e("actions__divider"))
                        }, null, 2),
                        createVNode(unref(ElIcon), { onClick: toggleMode }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(unref(mode).icon)))
                          ]),
                          _: 1
                        }),
                        createBaseVNode("i", {
                          class: normalizeClass(unref(ns).e("actions__divider"))
                        }, null, 2),
                        createVNode(unref(ElIcon), {
                          onClick: _cache[3] || (_cache[3] = ($event) => handleActions("anticlockwise"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(refresh_left_default))
                          ]),
                          _: 1
                        }),
                        createVNode(unref(ElIcon), {
                          onClick: _cache[4] || (_cache[4] = ($event) => handleActions("clockwise"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(refresh_right_default))
                          ]),
                          _: 1
                        })
                      ], 2)
                    ], 2),
                    createCommentVNode(" CANVAS "),
                    createBaseVNode("div", {
                      class: normalizeClass(unref(ns).e("canvas"))
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.urlList, (url, i2) => {
                        return withDirectives((openBlock(), createElementBlock("img", {
                          ref_for: true,
                          ref: (el) => imgRefs.value[i2] = el,
                          key: url,
                          src: url,
                          style: normalizeStyle(unref(imgStyle)),
                          class: normalizeClass(unref(ns).e("img")),
                          onLoad: handleImgLoad,
                          onError: handleImgError,
                          onMousedown: handleMouseDown
                        }, null, 46, _hoisted_1$D)), [
                          [vShow, i2 === activeIndex.value]
                        ]);
                      }), 128))
                    ], 2),
                    renderSlot(_ctx.$slots, "default")
                  ], 6)
                ]),
                _: 3
              })
            ], 8, ["disabled"]);
          };
        }
      });
      var ImageViewer = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image-viewer/src/image-viewer.vue"]]);
      const ElImageViewer = withInstall(ImageViewer);
      const imageProps = buildProps({
        hideOnClickModal: Boolean,
        src: {
          type: String,
          default: ""
        },
        fit: {
          type: String,
          values: ["", "contain", "cover", "fill", "none", "scale-down"],
          default: ""
        },
        loading: {
          type: String,
          values: ["eager", "lazy"]
        },
        lazy: Boolean,
        scrollContainer: {
          type: definePropType([String, Object])
        },
        previewSrcList: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        previewTeleported: Boolean,
        zIndex: {
          type: Number
        },
        initialIndex: {
          type: Number,
          default: 0
        },
        infinite: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        zoomRate: {
          type: Number,
          default: 1.2
        }
      });
      const imageEmits = {
        load: (evt) => evt instanceof Event,
        error: (evt) => evt instanceof Event,
        switch: (val) => isNumber(val),
        close: () => true,
        show: () => true
      };
      const _hoisted_1$C = ["src", "loading"];
      const _hoisted_2$w = { key: 0 };
      const __default__$c = defineComponent({
        name: "ElImage",
        inheritAttrs: false
      });
      const _sfc_main$t = /* @__PURE__ */ defineComponent({
        ...__default__$c,
        props: imageProps,
        emits: imageEmits,
        setup(__props, { emit: emit2 }) {
          const props = __props;
          let prevOverflow = "";
          const { t: t2 } = useLocale();
          const ns = useNamespace("image");
          const rawAttrs = useAttrs$1();
          const attrs = useAttrs();
          const imageSrc = ref();
          const hasLoadError = ref(false);
          const isLoading = ref(true);
          const showViewer = ref(false);
          const container = ref();
          const _scrollContainer = ref();
          const supportLoading = isClient$1 && "loading" in HTMLImageElement.prototype;
          let stopScrollListener;
          let stopWheelListener;
          const imageKls = computed(() => [
            ns.e("inner"),
            preview.value && ns.e("preview"),
            isLoading.value && ns.is("loading")
          ]);
          const containerStyle = computed(() => rawAttrs.style);
          const imageStyle = computed(() => {
            const { fit } = props;
            if (isClient$1 && fit) {
              return { objectFit: fit };
            }
            return {};
          });
          const preview = computed(() => {
            const { previewSrcList } = props;
            return Array.isArray(previewSrcList) && previewSrcList.length > 0;
          });
          const imageIndex = computed(() => {
            const { previewSrcList, initialIndex } = props;
            let previewIndex = initialIndex;
            if (initialIndex > previewSrcList.length - 1) {
              previewIndex = 0;
            }
            return previewIndex;
          });
          const isManual = computed(() => {
            if (props.loading === "eager")
              return false;
            return !supportLoading && props.loading === "lazy" || props.lazy;
          });
          const loadImage = () => {
            if (!isClient$1)
              return;
            isLoading.value = true;
            hasLoadError.value = false;
            imageSrc.value = props.src;
          };
          function handleLoad(event) {
            isLoading.value = false;
            hasLoadError.value = false;
            emit2("load", event);
          }
          function handleError2(event) {
            isLoading.value = false;
            hasLoadError.value = true;
            emit2("error", event);
          }
          function handleLazyLoad() {
            if (isInContainer(container.value, _scrollContainer.value)) {
              loadImage();
              removeLazyLoadListener();
            }
          }
          const lazyLoadHandler = useThrottleFn(handleLazyLoad, 200, true);
          async function addLazyLoadListener() {
            var _a2;
            if (!isClient$1)
              return;
            await nextTick();
            const { scrollContainer } = props;
            if (isElement(scrollContainer)) {
              _scrollContainer.value = scrollContainer;
            } else if (isString$1(scrollContainer) && scrollContainer !== "") {
              _scrollContainer.value = (_a2 = document.querySelector(scrollContainer)) != null ? _a2 : void 0;
            } else if (container.value) {
              _scrollContainer.value = getScrollContainer(container.value);
            }
            if (_scrollContainer.value) {
              stopScrollListener = useEventListener$1(_scrollContainer, "scroll", lazyLoadHandler);
              setTimeout(() => handleLazyLoad(), 100);
            }
          }
          function removeLazyLoadListener() {
            if (!isClient$1 || !_scrollContainer.value || !lazyLoadHandler)
              return;
            stopScrollListener == null ? void 0 : stopScrollListener();
            _scrollContainer.value = void 0;
          }
          function wheelHandler(e2) {
            if (!e2.ctrlKey)
              return;
            if (e2.deltaY < 0) {
              e2.preventDefault();
              return false;
            } else if (e2.deltaY > 0) {
              e2.preventDefault();
              return false;
            }
          }
          function clickHandler() {
            if (!preview.value)
              return;
            stopWheelListener = useEventListener$1("wheel", wheelHandler, {
              passive: false
            });
            prevOverflow = document.body.style.overflow;
            document.body.style.overflow = "hidden";
            showViewer.value = true;
            emit2("show");
          }
          function closeViewer() {
            stopWheelListener == null ? void 0 : stopWheelListener();
            document.body.style.overflow = prevOverflow;
            showViewer.value = false;
            emit2("close");
          }
          function switchViewer(val) {
            emit2("switch", val);
          }
          watch(() => props.src, () => {
            if (isManual.value) {
              isLoading.value = true;
              hasLoadError.value = false;
              removeLazyLoadListener();
              addLazyLoadListener();
            } else {
              loadImage();
            }
          });
          onMounted(() => {
            if (isManual.value) {
              addLazyLoadListener();
            } else {
              loadImage();
            }
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "container",
              ref: container,
              class: normalizeClass([unref(ns).b(), _ctx.$attrs.class]),
              style: normalizeStyle(unref(containerStyle))
            }, [
              hasLoadError.value ? renderSlot(_ctx.$slots, "error", { key: 0 }, () => [
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).e("error"))
                }, toDisplayString(unref(t2)("el.image.error")), 3)
              ]) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                imageSrc.value !== void 0 ? (openBlock(), createElementBlock("img", mergeProps({ key: 0 }, unref(attrs), {
                  src: imageSrc.value,
                  loading: _ctx.loading,
                  style: unref(imageStyle),
                  class: unref(imageKls),
                  onClick: clickHandler,
                  onLoad: handleLoad,
                  onError: handleError2
                }), null, 16, _hoisted_1$C)) : createCommentVNode("v-if", true),
                isLoading.value ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(ns).e("wrapper"))
                }, [
                  renderSlot(_ctx.$slots, "placeholder", {}, () => [
                    createBaseVNode("div", {
                      class: normalizeClass(unref(ns).e("placeholder"))
                    }, null, 2)
                  ])
                ], 2)) : createCommentVNode("v-if", true)
              ], 64)),
              unref(preview) ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                showViewer.value ? (openBlock(), createBlock(unref(ElImageViewer), {
                  key: 0,
                  "z-index": _ctx.zIndex,
                  "initial-index": unref(imageIndex),
                  infinite: _ctx.infinite,
                  "zoom-rate": _ctx.zoomRate,
                  "url-list": _ctx.previewSrcList,
                  "hide-on-click-modal": _ctx.hideOnClickModal,
                  teleported: _ctx.previewTeleported,
                  "close-on-press-escape": _ctx.closeOnPressEscape,
                  onClose: closeViewer,
                  onSwitch: switchViewer
                }, {
                  default: withCtx(() => [
                    _ctx.$slots.viewer ? (openBlock(), createElementBlock("div", _hoisted_2$w, [
                      renderSlot(_ctx.$slots, "viewer")
                    ])) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["z-index", "initial-index", "infinite", "zoom-rate", "url-list", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : createCommentVNode("v-if", true)
              ], 64)) : createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var Image$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image/src/image.vue"]]);
      const ElImage = withInstall(Image$1);
      const inputNumberProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        step: {
          type: Number,
          default: 1
        },
        stepStrictly: Boolean,
        max: {
          type: Number,
          default: Number.POSITIVE_INFINITY
        },
        min: {
          type: Number,
          default: Number.NEGATIVE_INFINITY
        },
        modelValue: Number,
        readonly: Boolean,
        disabled: Boolean,
        size: useSizeProp,
        controls: {
          type: Boolean,
          default: true
        },
        controlsPosition: {
          type: String,
          default: "",
          values: ["", "right"]
        },
        valueOnClear: {
          type: [String, Number, null],
          validator: (val) => val === null || isNumber(val) || ["min", "max"].includes(val),
          default: null
        },
        name: String,
        label: String,
        placeholder: String,
        precision: {
          type: Number,
          validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const inputNumberEmits = {
        [CHANGE_EVENT]: (cur, prev) => prev !== cur,
        blur: (e2) => e2 instanceof FocusEvent,
        focus: (e2) => e2 instanceof FocusEvent,
        [INPUT_EVENT]: (val) => isNumber(val) || isNil(val),
        [UPDATE_MODEL_EVENT]: (val) => isNumber(val) || isNil(val)
      };
      const _hoisted_1$B = ["aria-label", "onKeydown"];
      const _hoisted_2$v = ["aria-label", "onKeydown"];
      const __default__$b = defineComponent({
        name: "ElInputNumber"
      });
      const _sfc_main$s = /* @__PURE__ */ defineComponent({
        ...__default__$b,
        props: inputNumberProps,
        emits: inputNumberEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const { t: t2 } = useLocale();
          const ns = useNamespace("input-number");
          const input = ref();
          const data = reactive({
            currentValue: props.modelValue,
            userInput: null
          });
          const { formItem } = useFormItem();
          const minDisabled = computed(() => isNumber(props.modelValue) && props.modelValue <= props.min);
          const maxDisabled = computed(() => isNumber(props.modelValue) && props.modelValue >= props.max);
          const numPrecision = computed(() => {
            const stepPrecision = getPrecision(props.step);
            if (!isUndefined(props.precision)) {
              if (stepPrecision > props.precision)
                ;
              return props.precision;
            } else {
              return Math.max(getPrecision(props.modelValue), stepPrecision);
            }
          });
          const controlsAtRight = computed(() => {
            return props.controls && props.controlsPosition === "right";
          });
          const inputNumberSize = useFormSize();
          const inputNumberDisabled = useFormDisabled();
          const displayValue = computed(() => {
            if (data.userInput !== null) {
              return data.userInput;
            }
            let currentValue = data.currentValue;
            if (isNil(currentValue))
              return "";
            if (isNumber(currentValue)) {
              if (Number.isNaN(currentValue))
                return "";
              if (!isUndefined(props.precision)) {
                currentValue = currentValue.toFixed(props.precision);
              }
            }
            return currentValue;
          });
          const toPrecision = (num, pre) => {
            if (isUndefined(pre))
              pre = numPrecision.value;
            if (pre === 0)
              return Math.round(num);
            let snum = String(num);
            const pointPos = snum.indexOf(".");
            if (pointPos === -1)
              return num;
            const nums = snum.replace(".", "").split("");
            const datum = nums[pointPos + pre];
            if (!datum)
              return num;
            const length = snum.length;
            if (snum.charAt(length - 1) === "5") {
              snum = `${snum.slice(0, Math.max(0, length - 1))}6`;
            }
            return Number.parseFloat(Number(snum).toFixed(pre));
          };
          const getPrecision = (value) => {
            if (isNil(value))
              return 0;
            const valueString = value.toString();
            const dotPosition = valueString.indexOf(".");
            let precision = 0;
            if (dotPosition !== -1) {
              precision = valueString.length - dotPosition - 1;
            }
            return precision;
          };
          const ensurePrecision = (val, coefficient = 1) => {
            if (!isNumber(val))
              return data.currentValue;
            return toPrecision(val + props.step * coefficient);
          };
          const increase = () => {
            if (props.readonly || inputNumberDisabled.value || maxDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value);
            setCurrentValue(newVal);
            emit2(INPUT_EVENT, data.currentValue);
          };
          const decrease = () => {
            if (props.readonly || inputNumberDisabled.value || minDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value, -1);
            setCurrentValue(newVal);
            emit2(INPUT_EVENT, data.currentValue);
          };
          const verifyValue = (value, update) => {
            const { max, min, step, precision, stepStrictly, valueOnClear } = props;
            if (max < min) {
              throwError("InputNumber", "min should not be greater than max.");
            }
            let newVal = Number(value);
            if (isNil(value) || Number.isNaN(newVal)) {
              return null;
            }
            if (value === "") {
              if (valueOnClear === null) {
                return null;
              }
              newVal = isString$1(valueOnClear) ? { min, max }[valueOnClear] : valueOnClear;
            }
            if (stepStrictly) {
              newVal = toPrecision(Math.round(newVal / step) * step, precision);
            }
            if (!isUndefined(precision)) {
              newVal = toPrecision(newVal, precision);
            }
            if (newVal > max || newVal < min) {
              newVal = newVal > max ? max : min;
              update && emit2(UPDATE_MODEL_EVENT, newVal);
            }
            return newVal;
          };
          const setCurrentValue = (value, emitChange = true) => {
            var _a2;
            const oldVal = data.currentValue;
            const newVal = verifyValue(value);
            if (!emitChange) {
              emit2(UPDATE_MODEL_EVENT, newVal);
              return;
            }
            if (oldVal === newVal)
              return;
            data.userInput = null;
            emit2(UPDATE_MODEL_EVENT, newVal);
            emit2(CHANGE_EVENT, newVal, oldVal);
            if (props.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
            }
            data.currentValue = newVal;
          };
          const handleInput = (value) => {
            data.userInput = value;
            const newVal = value === "" ? null : Number(value);
            emit2(INPUT_EVENT, newVal);
            setCurrentValue(newVal, false);
          };
          const handleInputChange = (value) => {
            const newVal = value !== "" ? Number(value) : "";
            if (isNumber(newVal) && !Number.isNaN(newVal) || value === "") {
              setCurrentValue(newVal);
            }
            data.userInput = null;
          };
          const focus = () => {
            var _a2, _b;
            (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          };
          const blur = () => {
            var _a2, _b;
            (_b = (_a2 = input.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
          };
          const handleFocus = (event) => {
            emit2("focus", event);
          };
          const handleBlur = (event) => {
            var _a2;
            emit2("blur", event);
            if (props.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn());
            }
          };
          watch(() => props.modelValue, (value) => {
            const userInput = verifyValue(data.userInput);
            const newValue = verifyValue(value, true);
            if (!isNumber(userInput) && (!userInput || userInput !== newValue)) {
              data.currentValue = newValue;
              data.userInput = null;
            }
          }, { immediate: true });
          onMounted(() => {
            var _a2;
            const { min, max, modelValue } = props;
            const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
            innerInput.setAttribute("role", "spinbutton");
            if (Number.isFinite(max)) {
              innerInput.setAttribute("aria-valuemax", String(max));
            } else {
              innerInput.removeAttribute("aria-valuemax");
            }
            if (Number.isFinite(min)) {
              innerInput.setAttribute("aria-valuemin", String(min));
            } else {
              innerInput.removeAttribute("aria-valuemin");
            }
            innerInput.setAttribute("aria-valuenow", String(data.currentValue));
            innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
            if (!isNumber(modelValue) && modelValue != null) {
              let val = Number(modelValue);
              if (Number.isNaN(val)) {
                val = null;
              }
              emit2(UPDATE_MODEL_EVENT, val);
            }
          });
          onUpdated(() => {
            var _a2;
            const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
            innerInput == null ? void 0 : innerInput.setAttribute("aria-valuenow", `${data.currentValue}`);
          });
          expose({
            focus,
            blur
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).m(unref(inputNumberSize)),
                unref(ns).is("disabled", unref(inputNumberDisabled)),
                unref(ns).is("without-controls", !_ctx.controls),
                unref(ns).is("controls-right", unref(controlsAtRight))
              ]),
              onDragstart: _cache[1] || (_cache[1] = withModifiers(() => {
              }, ["prevent"]))
            }, [
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 0,
                role: "button",
                "aria-label": unref(t2)("el.inputNumber.decrease"),
                class: normalizeClass([unref(ns).e("decrease"), unref(ns).is("disabled", unref(minDisabled))]),
                onKeydown: withKeys(decrease, ["enter"])
              }, [
                createVNode(unref(ElIcon), null, {
                  default: withCtx(() => [
                    unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_down_default), { key: 0 })) : (openBlock(), createBlock(unref(minus_default), { key: 1 }))
                  ]),
                  _: 1
                })
              ], 42, _hoisted_1$B)), [
                [unref(vRepeatClick), decrease]
              ]) : createCommentVNode("v-if", true),
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 1,
                role: "button",
                "aria-label": unref(t2)("el.inputNumber.increase"),
                class: normalizeClass([unref(ns).e("increase"), unref(ns).is("disabled", unref(maxDisabled))]),
                onKeydown: withKeys(increase, ["enter"])
              }, [
                createVNode(unref(ElIcon), null, {
                  default: withCtx(() => [
                    unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_up_default), { key: 0 })) : (openBlock(), createBlock(unref(plus_default), { key: 1 }))
                  ]),
                  _: 1
                })
              ], 42, _hoisted_2$v)), [
                [unref(vRepeatClick), increase]
              ]) : createCommentVNode("v-if", true),
              createVNode(unref(ElInput), {
                id: _ctx.id,
                ref_key: "input",
                ref: input,
                type: "number",
                step: _ctx.step,
                "model-value": unref(displayValue),
                placeholder: _ctx.placeholder,
                readonly: _ctx.readonly,
                disabled: unref(inputNumberDisabled),
                size: unref(inputNumberSize),
                max: _ctx.max,
                min: _ctx.min,
                name: _ctx.name,
                label: _ctx.label,
                "validate-event": false,
                onWheel: _cache[0] || (_cache[0] = withModifiers(() => {
                }, ["prevent"])),
                onKeydown: [
                  withKeys(withModifiers(increase, ["prevent"]), ["up"]),
                  withKeys(withModifiers(decrease, ["prevent"]), ["down"])
                ],
                onBlur: handleBlur,
                onFocus: handleFocus,
                onInput: handleInput,
                onChange: handleInputChange
              }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])
            ], 34);
          };
        }
      });
      var InputNumber = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input-number/src/input-number.vue"]]);
      const ElInputNumber = withInstall(InputNumber);
      const selectGroupKey = Symbol("ElSelectGroup");
      const selectKey = Symbol("ElSelect");
      function useOption$1(props, states) {
        const select = inject(selectKey);
        const selectGroup = inject(selectGroupKey, { disabled: false });
        const isObject2 = computed(() => {
          return Object.prototype.toString.call(props.value).toLowerCase() === "[object object]";
        });
        const itemSelected = computed(() => {
          if (!select.props.multiple) {
            return isEqual2(props.value, select.props.modelValue);
          } else {
            return contains(select.props.modelValue, props.value);
          }
        });
        const limitReached = computed(() => {
          if (select.props.multiple) {
            const modelValue = select.props.modelValue || [];
            return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
          } else {
            return false;
          }
        });
        const currentLabel = computed(() => {
          return props.label || (isObject2.value ? "" : props.value);
        });
        const currentValue = computed(() => {
          return props.value || props.label || "";
        });
        const isDisabled = computed(() => {
          return props.disabled || states.groupDisabled || limitReached.value;
        });
        const instance = getCurrentInstance();
        const contains = (arr = [], target) => {
          if (!isObject2.value) {
            return arr && arr.includes(target);
          } else {
            const valueKey = select.props.valueKey;
            return arr && arr.some((item) => {
              return toRaw(get(item, valueKey)) === get(target, valueKey);
            });
          }
        };
        const isEqual2 = (a2, b2) => {
          if (!isObject2.value) {
            return a2 === b2;
          } else {
            const { valueKey } = select.props;
            return get(a2, valueKey) === get(b2, valueKey);
          }
        };
        const hoverItem = () => {
          if (!props.disabled && !selectGroup.disabled) {
            select.hoverIndex = select.optionsArray.indexOf(instance.proxy);
          }
        };
        watch(() => currentLabel.value, () => {
          if (!props.created && !select.props.remote)
            select.setSelected();
        });
        watch(() => props.value, (val, oldVal) => {
          const { remote, valueKey } = select.props;
          if (!Object.is(val, oldVal)) {
            select.onOptionDestroy(oldVal, instance.proxy);
            select.onOptionCreate(instance.proxy);
          }
          if (!props.created && !remote) {
            if (valueKey && typeof val === "object" && typeof oldVal === "object" && val[valueKey] === oldVal[valueKey]) {
              return;
            }
            select.setSelected();
          }
        });
        watch(() => selectGroup.disabled, () => {
          states.groupDisabled = selectGroup.disabled;
        }, { immediate: true });
        const { queryChange } = toRaw(select);
        watch(queryChange, (changes) => {
          const { query } = unref(changes);
          const regexp2 = new RegExp(escapeStringRegexp(query), "i");
          states.visible = regexp2.test(currentLabel.value) || props.created;
          if (!states.visible) {
            select.filteredOptionsCount--;
          }
        }, { immediate: true });
        return {
          select,
          currentLabel,
          currentValue,
          itemSelected,
          isDisabled,
          hoverItem
        };
      }
      const _sfc_main$r = defineComponent({
        name: "ElOption",
        componentName: "ElOption",
        props: {
          value: {
            required: true,
            type: [String, Number, Boolean, Object]
          },
          label: [String, Number],
          created: Boolean,
          disabled: {
            type: Boolean,
            default: false
          }
        },
        setup(props) {
          const ns = useNamespace("select");
          const containerKls = computed(() => [
            ns.be("dropdown", "item"),
            ns.is("disabled", unref(isDisabled)),
            {
              selected: unref(itemSelected),
              hover: unref(hover)
            }
          ]);
          const states = reactive({
            index: -1,
            groupDisabled: false,
            visible: true,
            hitState: false,
            hover: false
          });
          const { currentLabel, itemSelected, isDisabled, select, hoverItem } = useOption$1(props, states);
          const { visible, hover } = toRefs(states);
          const vm = getCurrentInstance().proxy;
          select.onOptionCreate(vm);
          onBeforeUnmount(() => {
            const key = vm.value;
            const { selected } = select;
            const selectedOptions = select.props.multiple ? selected : [selected];
            const doesSelected = selectedOptions.some((item) => {
              return item.value === vm.value;
            });
            nextTick(() => {
              if (select.cachedOptions.get(key) === vm && !doesSelected) {
                select.cachedOptions.delete(key);
              }
            });
            select.onOptionDestroy(key, vm);
          });
          function selectOptionClick() {
            if (props.disabled !== true && states.groupDisabled !== true) {
              select.handleOptionSelect(vm);
            }
          }
          return {
            ns,
            containerKls,
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            visible,
            hover,
            selectOptionClick,
            states
          };
        }
      });
      function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
        return withDirectives((openBlock(), createElementBlock("li", {
          class: normalizeClass(_ctx.containerKls),
          onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createBaseVNode("span", null, toDisplayString(_ctx.currentLabel), 1)
          ])
        ], 34)), [
          [vShow, _ctx.visible]
        ]);
      }
      var Option = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["render", _sfc_render$7], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);
      const _sfc_main$q = defineComponent({
        name: "ElSelectDropdown",
        componentName: "ElSelectDropdown",
        setup() {
          const select = inject(selectKey);
          const ns = useNamespace("select");
          const popperClass = computed(() => select.props.popperClass);
          const isMultiple = computed(() => select.props.multiple);
          const isFitInputWidth = computed(() => select.props.fitInputWidth);
          const minWidth = ref("");
          function updateMinWidth() {
            var _a2;
            minWidth.value = `${(_a2 = select.selectWrapper) == null ? void 0 : _a2.offsetWidth}px`;
          }
          onMounted(() => {
            updateMinWidth();
            useResizeObserver(select.selectWrapper, updateMinWidth);
          });
          return {
            ns,
            minWidth,
            popperClass,
            isMultiple,
            isFitInputWidth
          };
        }
      });
      function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
          style: normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 6);
      }
      var ElSelectMenu$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["render", _sfc_render$6], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);
      function useSelectStates(props) {
        const { t: t2 } = useLocale();
        return reactive({
          options: /* @__PURE__ */ new Map(),
          cachedOptions: /* @__PURE__ */ new Map(),
          createdLabel: null,
          createdSelected: false,
          selected: props.multiple ? [] : {},
          inputLength: 20,
          inputWidth: 0,
          optionsCount: 0,
          filteredOptionsCount: 0,
          visible: false,
          selectedLabel: "",
          hoverIndex: -1,
          query: "",
          previousQuery: null,
          inputHovering: false,
          cachedPlaceHolder: "",
          currentPlaceholder: t2("el.select.placeholder"),
          menuVisibleOnFocus: false,
          isOnComposition: false,
          prefixWidth: 11,
          mouseEnter: false
        });
      }
      let ignoreFocusEvent = false;
      const useSelect$1 = (props, states, ctx) => {
        const { t: t2 } = useLocale();
        const ns = useNamespace("select");
        useDeprecated({
          from: "suffixTransition",
          replacement: "override style scheme",
          version: "2.3.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
        }, computed(() => props.suffixTransition === false));
        const reference = ref(null);
        const input = ref(null);
        const iOSInput = ref(null);
        const tooltipRef = ref(null);
        const tagTooltipRef = ref(null);
        const tags = ref(null);
        const selectWrapper = ref(null);
        const scrollbar = ref(null);
        const hoverOption = ref(-1);
        const queryChange = shallowRef({ query: "" });
        const groupQueryChange = shallowRef("");
        const optionList = ref([]);
        let originClientHeight = 0;
        const { form, formItem } = useFormItem();
        const readonly2 = computed(() => !props.filterable || props.multiple || !states.visible);
        const selectDisabled = computed(() => props.disabled || (form == null ? void 0 : form.disabled));
        const showClose = computed(() => {
          const hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== "";
          const criteria = props.clearable && !selectDisabled.value && states.inputHovering && hasValue;
          return criteria;
        });
        const iconComponent = computed(() => props.remote && props.filterable && !props.remoteShowSuffix ? "" : props.suffixIcon);
        const iconReverse = computed(() => ns.is("reverse", iconComponent.value && states.visible && props.suffixTransition));
        const debounce$1 = computed(() => props.remote ? 300 : 0);
        const emptyText = computed(() => {
          if (props.loading) {
            return props.loadingText || t2("el.select.loading");
          } else {
            if (props.remote && states.query === "" && states.options.size === 0)
              return false;
            if (props.filterable && states.query && states.options.size > 0 && states.filteredOptionsCount === 0) {
              return props.noMatchText || t2("el.select.noMatch");
            }
            if (states.options.size === 0) {
              return props.noDataText || t2("el.select.noData");
            }
          }
          return null;
        });
        const optionsArray = computed(() => {
          const list = Array.from(states.options.values());
          const newList = [];
          optionList.value.forEach((item) => {
            const index = list.findIndex((i2) => i2.currentLabel === item);
            if (index > -1) {
              newList.push(list[index]);
            }
          });
          return newList.length ? newList : list;
        });
        const cachedOptionsArray = computed(() => Array.from(states.cachedOptions.values()));
        const showNewOption = computed(() => {
          const hasExistingOption = optionsArray.value.filter((option) => {
            return !option.created;
          }).some((option) => {
            return option.currentLabel === states.query;
          });
          return props.filterable && props.allowCreate && states.query !== "" && !hasExistingOption;
        });
        const selectSize = useFormSize();
        const collapseTagSize = computed(() => ["small"].includes(selectSize.value) ? "small" : "default");
        const dropMenuVisible = computed({
          get() {
            return states.visible && emptyText.value !== false;
          },
          set(val) {
            states.visible = val;
          }
        });
        watch([() => selectDisabled.value, () => selectSize.value, () => form == null ? void 0 : form.size], () => {
          nextTick(() => {
            resetInputHeight();
          });
        });
        watch(() => props.placeholder, (val) => {
          states.cachedPlaceHolder = states.currentPlaceholder = val;
          const hasValue = props.multiple && Array.isArray(props.modelValue) && props.modelValue.length > 0;
          if (hasValue) {
            states.currentPlaceholder = "";
          }
        });
        watch(() => props.modelValue, (val, oldVal) => {
          if (props.multiple) {
            resetInputHeight();
            if (val && val.length > 0 || input.value && states.query !== "") {
              states.currentPlaceholder = "";
            } else {
              states.currentPlaceholder = states.cachedPlaceHolder;
            }
            if (props.filterable && !props.reserveKeyword) {
              states.query = "";
              handleQueryChange(states.query);
            }
          }
          setSelected();
          if (props.filterable && !props.multiple) {
            states.inputLength = 20;
          }
          if (!isEqual$1(val, oldVal) && props.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        }, {
          flush: "post",
          deep: true
        });
        watch(() => states.visible, (val) => {
          var _a2, _b, _c, _d, _e;
          if (!val) {
            if (props.filterable) {
              if (isFunction$1(props.filterMethod)) {
                props.filterMethod("");
              }
              if (isFunction$1(props.remoteMethod)) {
                props.remoteMethod("");
              }
            }
            input.value && input.value.blur();
            states.query = "";
            states.previousQuery = null;
            states.selectedLabel = "";
            states.inputLength = 20;
            states.menuVisibleOnFocus = false;
            resetHoverIndex();
            nextTick(() => {
              if (input.value && input.value.value === "" && states.selected.length === 0) {
                states.currentPlaceholder = states.cachedPlaceHolder;
              }
            });
            if (!props.multiple) {
              if (states.selected) {
                if (props.filterable && props.allowCreate && states.createdSelected && states.createdLabel) {
                  states.selectedLabel = states.createdLabel;
                } else {
                  states.selectedLabel = states.selected.currentLabel;
                }
                if (props.filterable)
                  states.query = states.selectedLabel;
              }
              if (props.filterable) {
                states.currentPlaceholder = states.cachedPlaceHolder;
              }
            }
          } else {
            (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            if (props.filterable) {
              states.filteredOptionsCount = states.optionsCount;
              states.query = props.remote ? "" : states.selectedLabel;
              (_d = (_c = iOSInput.value) == null ? void 0 : _c.focus) == null ? void 0 : _d.call(_c);
              if (props.multiple) {
                (_e = input.value) == null ? void 0 : _e.focus();
              } else {
                if (states.selectedLabel) {
                  states.currentPlaceholder = `${states.selectedLabel}`;
                  states.selectedLabel = "";
                }
              }
              handleQueryChange(states.query);
              if (!props.multiple && !props.remote) {
                queryChange.value.query = "";
                triggerRef(queryChange);
                triggerRef(groupQueryChange);
              }
            }
          }
          ctx.emit("visible-change", val);
        });
        watch(() => states.options.entries(), () => {
          var _a2, _b, _c;
          if (!isClient$1)
            return;
          (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          if (props.multiple) {
            resetInputHeight();
          }
          const inputs = ((_c = selectWrapper.value) == null ? void 0 : _c.querySelectorAll("input")) || [];
          if (!Array.from(inputs).includes(document.activeElement)) {
            setSelected();
          }
          if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {
            checkDefaultFirstOption();
          }
        }, {
          flush: "post"
        });
        watch(() => states.hoverIndex, (val) => {
          if (isNumber(val) && val > -1) {
            hoverOption.value = optionsArray.value[val] || {};
          } else {
            hoverOption.value = {};
          }
          optionsArray.value.forEach((option) => {
            option.hover = hoverOption.value === option;
          });
        });
        const resetInputHeight = () => {
          nextTick(() => {
            var _a2, _b;
            if (!reference.value)
              return;
            const input2 = reference.value.$el.querySelector("input");
            originClientHeight = originClientHeight || (input2.clientHeight > 0 ? input2.clientHeight + 2 : 0);
            const _tags = tags.value;
            const gotSize = getComponentSize(selectSize.value || (form == null ? void 0 : form.size));
            const sizeInMap = selectSize.value || gotSize === originClientHeight || originClientHeight <= 0 ? gotSize : originClientHeight;
            const isElHidden = input2.offsetParent === null;
            !isElHidden && (input2.style.height = `${(states.selected.length === 0 ? sizeInMap : Math.max(_tags ? _tags.clientHeight + (_tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap)) - 2}px`);
            if (states.visible && emptyText.value !== false) {
              (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            }
          });
        };
        const handleQueryChange = async (val) => {
          if (states.previousQuery === val || states.isOnComposition)
            return;
          if (states.previousQuery === null && (isFunction$1(props.filterMethod) || isFunction$1(props.remoteMethod))) {
            states.previousQuery = val;
            return;
          }
          states.previousQuery = val;
          nextTick(() => {
            var _a2, _b;
            if (states.visible)
              (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          });
          states.hoverIndex = -1;
          if (props.multiple && props.filterable) {
            nextTick(() => {
              const length = input.value.value.length * 15 + 20;
              states.inputLength = props.collapseTags ? Math.min(50, length) : length;
              managePlaceholder();
              resetInputHeight();
            });
          }
          if (props.remote && isFunction$1(props.remoteMethod)) {
            states.hoverIndex = -1;
            props.remoteMethod(val);
          } else if (isFunction$1(props.filterMethod)) {
            props.filterMethod(val);
            triggerRef(groupQueryChange);
          } else {
            states.filteredOptionsCount = states.optionsCount;
            queryChange.value.query = val;
            triggerRef(queryChange);
            triggerRef(groupQueryChange);
          }
          if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {
            await nextTick();
            checkDefaultFirstOption();
          }
        };
        const managePlaceholder = () => {
          if (states.currentPlaceholder !== "") {
            states.currentPlaceholder = input.value.value ? "" : states.cachedPlaceHolder;
          }
        };
        const checkDefaultFirstOption = () => {
          const optionsInDropdown = optionsArray.value.filter((n2) => n2.visible && !n2.disabled && !n2.states.groupDisabled);
          const userCreatedOption = optionsInDropdown.find((n2) => n2.created);
          const firstOriginOption = optionsInDropdown[0];
          states.hoverIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
        };
        const setSelected = () => {
          var _a2;
          if (!props.multiple) {
            const option = getOption(props.modelValue);
            if ((_a2 = option.props) == null ? void 0 : _a2.created) {
              states.createdLabel = option.props.value;
              states.createdSelected = true;
            } else {
              states.createdSelected = false;
            }
            states.selectedLabel = option.currentLabel;
            states.selected = option;
            if (props.filterable)
              states.query = states.selectedLabel;
            return;
          } else {
            states.selectedLabel = "";
          }
          const result = [];
          if (Array.isArray(props.modelValue)) {
            props.modelValue.forEach((value) => {
              result.push(getOption(value));
            });
          }
          states.selected = result;
          nextTick(() => {
            resetInputHeight();
          });
        };
        const getOption = (value) => {
          let option;
          const isObjectValue = toRawType(value).toLowerCase() === "object";
          const isNull = toRawType(value).toLowerCase() === "null";
          const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
          for (let i2 = states.cachedOptions.size - 1; i2 >= 0; i2--) {
            const cachedOption = cachedOptionsArray.value[i2];
            const isEqualValue = isObjectValue ? get(cachedOption.value, props.valueKey) === get(value, props.valueKey) : cachedOption.value === value;
            if (isEqualValue) {
              option = {
                value,
                currentLabel: cachedOption.currentLabel,
                isDisabled: cachedOption.isDisabled
              };
              break;
            }
          }
          if (option)
            return option;
          const label = isObjectValue ? value.label : !isNull && !isUndefined2 ? value : "";
          const newOption = {
            value,
            currentLabel: label
          };
          if (props.multiple) {
            newOption.hitState = false;
          }
          return newOption;
        };
        const resetHoverIndex = () => {
          setTimeout(() => {
            const valueKey = props.valueKey;
            if (!props.multiple) {
              states.hoverIndex = optionsArray.value.findIndex((item) => {
                return getValueKey(item) === getValueKey(states.selected);
              });
            } else {
              if (states.selected.length > 0) {
                states.hoverIndex = Math.min.apply(null, states.selected.map((selected) => {
                  return optionsArray.value.findIndex((item) => {
                    return get(item, valueKey) === get(selected, valueKey);
                  });
                }));
              } else {
                states.hoverIndex = -1;
              }
            }
          }, 300);
        };
        const handleResize = () => {
          var _a2, _b;
          resetInputWidth();
          (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          props.multiple && resetInputHeight();
        };
        const resetInputWidth = () => {
          var _a2;
          states.inputWidth = (_a2 = reference.value) == null ? void 0 : _a2.$el.offsetWidth;
        };
        const onInputChange = () => {
          if (props.filterable && states.query !== states.selectedLabel) {
            states.query = states.selectedLabel;
            handleQueryChange(states.query);
          }
        };
        const debouncedOnInputChange = debounce(() => {
          onInputChange();
        }, debounce$1.value);
        const debouncedQueryChange = debounce((e2) => {
          handleQueryChange(e2.target.value);
        }, debounce$1.value);
        const emitChange = (val) => {
          if (!isEqual$1(props.modelValue, val)) {
            ctx.emit(CHANGE_EVENT, val);
          }
        };
        const deletePrevTag = (e2) => {
          if (e2.code === EVENT_CODE.delete)
            return;
          if (e2.target.value.length <= 0 && !toggleLastOptionHitState()) {
            const value = props.modelValue.slice();
            value.pop();
            ctx.emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
          }
          if (e2.target.value.length === 1 && props.modelValue.length === 0) {
            states.currentPlaceholder = states.cachedPlaceHolder;
          }
        };
        const deleteTag = (event, tag) => {
          const index = states.selected.indexOf(tag);
          if (index > -1 && !selectDisabled.value) {
            const value = props.modelValue.slice();
            value.splice(index, 1);
            ctx.emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            ctx.emit("remove-tag", tag.value);
          }
          event.stopPropagation();
        };
        const deleteSelected = (event) => {
          event.stopPropagation();
          const value = props.multiple ? [] : "";
          if (!isString$1(value)) {
            for (const item of states.selected) {
              if (item.isDisabled)
                value.push(item.value);
            }
          }
          ctx.emit(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          states.hoverIndex = -1;
          states.visible = false;
          ctx.emit("clear");
        };
        const handleOptionSelect = (option) => {
          var _a2;
          if (props.multiple) {
            const value = (props.modelValue || []).slice();
            const optionIndex = getValueIndex(value, option.value);
            if (optionIndex > -1) {
              value.splice(optionIndex, 1);
            } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
              value.push(option.value);
            }
            ctx.emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            if (option.created) {
              states.query = "";
              handleQueryChange("");
              states.inputLength = 20;
            }
            if (props.filterable)
              (_a2 = input.value) == null ? void 0 : _a2.focus();
          } else {
            ctx.emit(UPDATE_MODEL_EVENT, option.value);
            emitChange(option.value);
            states.visible = false;
          }
          setSoftFocus();
          if (states.visible)
            return;
          nextTick(() => {
            scrollToOption(option);
          });
        };
        const getValueIndex = (arr = [], value) => {
          if (!isObject$1(value))
            return arr.indexOf(value);
          const valueKey = props.valueKey;
          let index = -1;
          arr.some((item, i2) => {
            if (toRaw(get(item, valueKey)) === get(value, valueKey)) {
              index = i2;
              return true;
            }
            return false;
          });
          return index;
        };
        const setSoftFocus = () => {
          const _input = input.value || reference.value;
          if (_input) {
            _input == null ? void 0 : _input.focus();
          }
        };
        const scrollToOption = (option) => {
          var _a2, _b, _c, _d, _e;
          const targetOption = Array.isArray(option) ? option[0] : option;
          let target = null;
          if (targetOption == null ? void 0 : targetOption.value) {
            const options = optionsArray.value.filter((item) => item.value === targetOption.value);
            if (options.length > 0) {
              target = options[0].$el;
            }
          }
          if (tooltipRef.value && target) {
            const menu = (_d = (_c = (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${ns.be("dropdown", "wrap")}`);
            if (menu) {
              scrollIntoView(menu, target);
            }
          }
          (_e = scrollbar.value) == null ? void 0 : _e.handleScroll();
        };
        const onOptionCreate = (vm) => {
          states.optionsCount++;
          states.filteredOptionsCount++;
          states.options.set(vm.value, vm);
          states.cachedOptions.set(vm.value, vm);
        };
        const onOptionDestroy = (key, vm) => {
          if (states.options.get(key) === vm) {
            states.optionsCount--;
            states.filteredOptionsCount--;
            states.options.delete(key);
          }
        };
        const resetInputState = (e2) => {
          if (e2.code !== EVENT_CODE.backspace)
            toggleLastOptionHitState(false);
          states.inputLength = input.value.value.length * 15 + 20;
          resetInputHeight();
        };
        const toggleLastOptionHitState = (hit) => {
          if (!Array.isArray(states.selected))
            return;
          const option = states.selected[states.selected.length - 1];
          if (!option)
            return;
          if (hit === true || hit === false) {
            option.hitState = hit;
            return hit;
          }
          option.hitState = !option.hitState;
          return option.hitState;
        };
        const handleComposition = (event) => {
          const text = event.target.value;
          if (event.type === "compositionend") {
            states.isOnComposition = false;
            nextTick(() => handleQueryChange(text));
          } else {
            const lastCharacter = text[text.length - 1] || "";
            states.isOnComposition = !isKorean(lastCharacter);
          }
        };
        const handleMenuEnter = () => {
          nextTick(() => scrollToOption(states.selected));
        };
        const handleFocus = (event) => {
          if (!ignoreFocusEvent) {
            if (props.automaticDropdown || props.filterable) {
              if (props.filterable && !states.visible) {
                states.menuVisibleOnFocus = true;
              }
              states.visible = true;
            }
            ctx.emit("focus", event);
          } else {
            ignoreFocusEvent = false;
          }
        };
        const blur = () => {
          var _a2, _b, _c;
          states.visible = false;
          (_a2 = reference.value) == null ? void 0 : _a2.blur();
          (_c = (_b = iOSInput.value) == null ? void 0 : _b.blur) == null ? void 0 : _c.call(_b);
        };
        const handleBlur = (event) => {
          setTimeout(() => {
            var _a2;
            if ((_a2 = tooltipRef.value) == null ? void 0 : _a2.isFocusInsideContent()) {
              ignoreFocusEvent = true;
              return;
            }
            states.visible && handleClose();
            ctx.emit("blur", event);
          });
        };
        const handleClearClick = (event) => {
          deleteSelected(event);
        };
        const handleClose = () => {
          states.visible = false;
        };
        const handleKeydownEscape = (event) => {
          if (states.visible) {
            event.preventDefault();
            event.stopPropagation();
            states.visible = false;
          }
        };
        const toggleMenu = (e2) => {
          var _a2;
          if (e2 && !states.mouseEnter) {
            return;
          }
          if (!selectDisabled.value) {
            if (states.menuVisibleOnFocus) {
              states.menuVisibleOnFocus = false;
            } else {
              if (!tooltipRef.value || !tooltipRef.value.isFocusInsideContent()) {
                states.visible = !states.visible;
              }
            }
            if (states.visible) {
              (_a2 = input.value || reference.value) == null ? void 0 : _a2.focus();
            }
          }
        };
        const selectOption = () => {
          if (!states.visible) {
            toggleMenu();
          } else {
            if (optionsArray.value[states.hoverIndex]) {
              handleOptionSelect(optionsArray.value[states.hoverIndex]);
            }
          }
        };
        const getValueKey = (item) => {
          return isObject$1(item.value) ? get(item.value, props.valueKey) : item.value;
        };
        const optionsAllDisabled = computed(() => optionsArray.value.filter((option) => option.visible).every((option) => option.disabled));
        const showTagList = computed(() => states.selected.slice(0, props.maxCollapseTags));
        const collapseTagList = computed(() => states.selected.slice(props.maxCollapseTags));
        const navigateOptions = (direction2) => {
          if (!states.visible) {
            states.visible = true;
            return;
          }
          if (states.options.size === 0 || states.filteredOptionsCount === 0)
            return;
          if (states.isOnComposition)
            return;
          if (!optionsAllDisabled.value) {
            if (direction2 === "next") {
              states.hoverIndex++;
              if (states.hoverIndex === states.options.size) {
                states.hoverIndex = 0;
              }
            } else if (direction2 === "prev") {
              states.hoverIndex--;
              if (states.hoverIndex < 0) {
                states.hoverIndex = states.options.size - 1;
              }
            }
            const option = optionsArray.value[states.hoverIndex];
            if (option.disabled === true || option.states.groupDisabled === true || !option.visible) {
              navigateOptions(direction2);
            }
            nextTick(() => scrollToOption(hoverOption.value));
          }
        };
        const handleMouseEnter = () => {
          states.mouseEnter = true;
        };
        const handleMouseLeave = () => {
          states.mouseEnter = false;
        };
        const handleDeleteTooltipTag = (event, tag) => {
          var _a2, _b;
          deleteTag(event, tag);
          (_b = (_a2 = tagTooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        };
        return {
          optionList,
          optionsArray,
          selectSize,
          handleResize,
          debouncedOnInputChange,
          debouncedQueryChange,
          deletePrevTag,
          deleteTag,
          deleteSelected,
          handleOptionSelect,
          scrollToOption,
          readonly: readonly2,
          resetInputHeight,
          showClose,
          iconComponent,
          iconReverse,
          showNewOption,
          collapseTagSize,
          setSelected,
          managePlaceholder,
          selectDisabled,
          emptyText,
          toggleLastOptionHitState,
          resetInputState,
          handleComposition,
          onOptionCreate,
          onOptionDestroy,
          handleMenuEnter,
          handleFocus,
          blur,
          handleBlur,
          handleClearClick,
          handleClose,
          handleKeydownEscape,
          toggleMenu,
          selectOption,
          getValueKey,
          navigateOptions,
          handleDeleteTooltipTag,
          dropMenuVisible,
          queryChange,
          groupQueryChange,
          showTagList,
          collapseTagList,
          reference,
          input,
          iOSInput,
          tooltipRef,
          tagTooltipRef,
          tags,
          selectWrapper,
          scrollbar,
          handleMouseEnter,
          handleMouseLeave
        };
      };
      var ElOptions = defineComponent({
        name: "ElOptions",
        emits: ["update-options"],
        setup(_2, { slots, emit: emit2 }) {
          let cachedOptions = [];
          function isSameOptions(a2, b2) {
            if (a2.length !== b2.length)
              return false;
            for (const [index] of a2.entries()) {
              if (a2[index] != b2[index]) {
                return false;
              }
            }
            return true;
          }
          return () => {
            var _a2, _b;
            const children = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
            const filteredOptions = [];
            function filterOptions(children2) {
              if (!Array.isArray(children2))
                return;
              children2.forEach((item) => {
                var _a22, _b2, _c, _d;
                const name = (_a22 = (item == null ? void 0 : item.type) || {}) == null ? void 0 : _a22.name;
                if (name === "ElOptionGroup") {
                  filterOptions(!isString$1(item.children) && !Array.isArray(item.children) && isFunction$1((_b2 = item.children) == null ? void 0 : _b2.default) ? (_c = item.children) == null ? void 0 : _c.default() : item.children);
                } else if (name === "ElOption") {
                  filteredOptions.push((_d = item.props) == null ? void 0 : _d.label);
                } else if (Array.isArray(item.children)) {
                  filterOptions(item.children);
                }
              });
            }
            if (children.length) {
              filterOptions((_b = children[0]) == null ? void 0 : _b.children);
            }
            if (!isSameOptions(filteredOptions, cachedOptions)) {
              cachedOptions = filteredOptions;
              emit2("update-options", filteredOptions);
            }
            return children;
          };
        }
      });
      const COMPONENT_NAME$3 = "ElSelect";
      const _sfc_main$p = defineComponent({
        name: COMPONENT_NAME$3,
        componentName: COMPONENT_NAME$3,
        components: {
          ElInput,
          ElSelectMenu: ElSelectMenu$1,
          ElOption: Option,
          ElOptions,
          ElTag,
          ElScrollbar,
          ElTooltip,
          ElIcon
        },
        directives: { ClickOutside },
        props: {
          name: String,
          id: String,
          modelValue: {
            type: [Array, String, Number, Boolean, Object],
            default: void 0
          },
          autocomplete: {
            type: String,
            default: "off"
          },
          automaticDropdown: Boolean,
          size: {
            type: String,
            validator: isValidComponentSize
          },
          effect: {
            type: String,
            default: "light"
          },
          disabled: Boolean,
          clearable: Boolean,
          filterable: Boolean,
          allowCreate: Boolean,
          loading: Boolean,
          popperClass: {
            type: String,
            default: ""
          },
          popperOptions: {
            type: Object,
            default: () => ({})
          },
          remote: Boolean,
          loadingText: String,
          noMatchText: String,
          noDataText: String,
          remoteMethod: Function,
          filterMethod: Function,
          multiple: Boolean,
          multipleLimit: {
            type: Number,
            default: 0
          },
          placeholder: {
            type: String
          },
          defaultFirstOption: Boolean,
          reserveKeyword: {
            type: Boolean,
            default: true
          },
          valueKey: {
            type: String,
            default: "value"
          },
          collapseTags: Boolean,
          collapseTagsTooltip: {
            type: Boolean,
            default: false
          },
          maxCollapseTags: {
            type: Number,
            default: 1
          },
          teleported: useTooltipContentProps.teleported,
          persistent: {
            type: Boolean,
            default: true
          },
          clearIcon: {
            type: iconPropType,
            default: circle_close_default
          },
          fitInputWidth: {
            type: Boolean,
            default: false
          },
          suffixIcon: {
            type: iconPropType,
            default: arrow_down_default
          },
          tagType: { ...tagProps.type, default: "info" },
          validateEvent: {
            type: Boolean,
            default: true
          },
          remoteShowSuffix: {
            type: Boolean,
            default: false
          },
          suffixTransition: {
            type: Boolean,
            default: true
          },
          placement: {
            type: String,
            values: Ee,
            default: "bottom-start"
          }
        },
        emits: [
          UPDATE_MODEL_EVENT,
          CHANGE_EVENT,
          "remove-tag",
          "clear",
          "visible-change",
          "focus",
          "blur"
        ],
        setup(props, ctx) {
          const nsSelect = useNamespace("select");
          const nsInput = useNamespace("input");
          const { t: t2 } = useLocale();
          const states = useSelectStates(props);
          const {
            optionList,
            optionsArray,
            selectSize,
            readonly: readonly2,
            handleResize,
            collapseTagSize,
            debouncedOnInputChange,
            debouncedQueryChange,
            deletePrevTag,
            deleteTag,
            deleteSelected,
            handleOptionSelect,
            scrollToOption,
            setSelected,
            resetInputHeight,
            managePlaceholder,
            showClose,
            selectDisabled,
            iconComponent,
            iconReverse,
            showNewOption,
            emptyText,
            toggleLastOptionHitState,
            resetInputState,
            handleComposition,
            onOptionCreate,
            onOptionDestroy,
            handleMenuEnter,
            handleFocus,
            blur,
            handleBlur,
            handleClearClick,
            handleClose,
            handleKeydownEscape,
            toggleMenu,
            selectOption,
            getValueKey,
            navigateOptions,
            handleDeleteTooltipTag,
            dropMenuVisible,
            reference,
            input,
            iOSInput,
            tooltipRef,
            tagTooltipRef,
            tags,
            selectWrapper,
            scrollbar,
            queryChange,
            groupQueryChange,
            handleMouseEnter,
            handleMouseLeave,
            showTagList,
            collapseTagList
          } = useSelect$1(props, states, ctx);
          const { focus } = useFocus(reference);
          const {
            inputWidth,
            selected,
            inputLength,
            filteredOptionsCount,
            visible,
            selectedLabel,
            hoverIndex,
            query,
            inputHovering,
            currentPlaceholder,
            menuVisibleOnFocus,
            isOnComposition,
            options,
            cachedOptions,
            optionsCount,
            prefixWidth
          } = toRefs(states);
          const wrapperKls = computed(() => {
            const classList = [nsSelect.b()];
            const _selectSize = unref(selectSize);
            if (_selectSize) {
              classList.push(nsSelect.m(_selectSize));
            }
            if (props.disabled) {
              classList.push(nsSelect.m("disabled"));
            }
            return classList;
          });
          const tagsKls = computed(() => [
            nsSelect.e("tags"),
            nsSelect.is("disabled", unref(selectDisabled))
          ]);
          const tagWrapperKls = computed(() => [
            nsSelect.b("tags-wrapper"),
            { "has-prefix": unref(prefixWidth) && unref(selected).length }
          ]);
          const inputKls = computed(() => [
            nsSelect.e("input"),
            nsSelect.is(unref(selectSize)),
            nsSelect.is("disabled", unref(selectDisabled))
          ]);
          const iOSInputKls = computed(() => [
            nsSelect.e("input"),
            nsSelect.is(unref(selectSize)),
            nsSelect.em("input", "iOS")
          ]);
          const scrollbarKls = computed(() => [
            nsSelect.is("empty", !props.allowCreate && Boolean(unref(query)) && unref(filteredOptionsCount) === 0)
          ]);
          const selectTagsStyle = computed(() => ({
            maxWidth: `${unref(inputWidth) - 32}px`,
            width: "100%"
          }));
          const tagTextStyle = computed(() => {
            const maxWidth = unref(inputWidth) > 123 ? unref(inputWidth) - 123 : unref(inputWidth) - 75;
            return { maxWidth: `${maxWidth}px` };
          });
          const inputStyle = computed(() => ({
            marginLeft: `${unref(prefixWidth)}px`,
            flexGrow: 1,
            width: `${unref(inputLength) / (unref(inputWidth) - 32)}%`,
            maxWidth: `${unref(inputWidth) - 42}px`
          }));
          provide(selectKey, reactive({
            props,
            options,
            optionsArray,
            cachedOptions,
            optionsCount,
            filteredOptionsCount,
            hoverIndex,
            handleOptionSelect,
            onOptionCreate,
            onOptionDestroy,
            selectWrapper,
            selected,
            setSelected,
            queryChange,
            groupQueryChange
          }));
          onMounted(() => {
            states.cachedPlaceHolder = currentPlaceholder.value = props.placeholder || (() => t2("el.select.placeholder"));
            if (props.multiple && Array.isArray(props.modelValue) && props.modelValue.length > 0) {
              currentPlaceholder.value = "";
            }
            useResizeObserver(selectWrapper, handleResize);
            if (props.remote && props.multiple) {
              resetInputHeight();
            }
            nextTick(() => {
              const refEl = reference.value && reference.value.$el;
              if (!refEl)
                return;
              inputWidth.value = refEl.getBoundingClientRect().width;
              if (ctx.slots.prefix) {
                const prefix = refEl.querySelector(`.${nsInput.e("prefix")}`);
                prefixWidth.value = Math.max(prefix.getBoundingClientRect().width + 11, 30);
              }
            });
            setSelected();
          });
          if (props.multiple && !Array.isArray(props.modelValue)) {
            ctx.emit(UPDATE_MODEL_EVENT, []);
          }
          if (!props.multiple && Array.isArray(props.modelValue)) {
            ctx.emit(UPDATE_MODEL_EVENT, "");
          }
          const popperPaneRef = computed(() => {
            var _a2, _b;
            return (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
          });
          const onOptionsRendered = (v2) => {
            optionList.value = v2;
          };
          return {
            isIOS,
            onOptionsRendered,
            prefixWidth,
            selectSize,
            readonly: readonly2,
            handleResize,
            collapseTagSize,
            debouncedOnInputChange,
            debouncedQueryChange,
            deletePrevTag,
            deleteTag,
            handleDeleteTooltipTag,
            deleteSelected,
            handleOptionSelect,
            scrollToOption,
            inputWidth,
            selected,
            inputLength,
            filteredOptionsCount,
            visible,
            selectedLabel,
            hoverIndex,
            query,
            inputHovering,
            currentPlaceholder,
            menuVisibleOnFocus,
            isOnComposition,
            options,
            resetInputHeight,
            managePlaceholder,
            showClose,
            selectDisabled,
            iconComponent,
            iconReverse,
            showNewOption,
            emptyText,
            toggleLastOptionHitState,
            resetInputState,
            handleComposition,
            handleMenuEnter,
            handleFocus,
            blur,
            handleBlur,
            handleClearClick,
            handleClose,
            handleKeydownEscape,
            toggleMenu,
            selectOption,
            getValueKey,
            navigateOptions,
            dropMenuVisible,
            focus,
            reference,
            input,
            iOSInput,
            tooltipRef,
            popperPaneRef,
            tags,
            selectWrapper,
            scrollbar,
            wrapperKls,
            tagsKls,
            tagWrapperKls,
            inputKls,
            iOSInputKls,
            scrollbarKls,
            selectTagsStyle,
            nsSelect,
            tagTextStyle,
            inputStyle,
            handleMouseEnter,
            handleMouseLeave,
            showTagList,
            collapseTagList,
            tagTooltipRef
          };
        }
      });
      const _hoisted_1$A = ["disabled", "autocomplete"];
      const _hoisted_2$u = ["disabled"];
      const _hoisted_3$q = { style: { "height": "100%", "display": "flex", "justify-content": "center", "align-items": "center" } };
      function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_tag = resolveComponent("el-tag");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_input = resolveComponent("el-input");
        const _component_el_option = resolveComponent("el-option");
        const _component_el_options = resolveComponent("el-options");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_el_select_menu = resolveComponent("el-select-menu");
        const _directive_click_outside = resolveDirective("click-outside");
        return withDirectives((openBlock(), createElementBlock("div", {
          ref: "selectWrapper",
          class: normalizeClass(_ctx.wrapperKls),
          onMouseenter: _cache[21] || (_cache[21] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
          onMouseleave: _cache[22] || (_cache[22] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
          onClick: _cache[23] || (_cache[23] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
        }, [
          createVNode(_component_el_tooltip, {
            ref: "tooltipRef",
            visible: _ctx.dropMenuVisible,
            placement: _ctx.placement,
            teleported: _ctx.teleported,
            "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
            "popper-options": _ctx.popperOptions,
            "fallback-placements": ["bottom-start", "top-start", "right", "left"],
            effect: _ctx.effect,
            pure: "",
            trigger: "click",
            transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
            "stop-popper-mouse-event": false,
            "gpu-acceleration": false,
            persistent: _ctx.persistent,
            onShow: _ctx.handleMenuEnter
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                class: "select-trigger",
                onMouseenter: _cache[19] || (_cache[19] = ($event) => _ctx.inputHovering = true),
                onMouseleave: _cache[20] || (_cache[20] = ($event) => _ctx.inputHovering = false)
              }, [
                _ctx.multiple ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref: "tags",
                  class: normalizeClass(_ctx.tagsKls),
                  style: normalizeStyle(_ctx.selectTagsStyle)
                }, [
                  _ctx.collapseTags && _ctx.selected.length ? (openBlock(), createBlock(Transition, {
                    key: 0,
                    onAfterLeave: _ctx.resetInputHeight
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("span", {
                        class: normalizeClass(_ctx.tagWrapperKls)
                      }, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showTagList, (item) => {
                          return openBlock(), createBlock(_component_el_tag, {
                            key: _ctx.getValueKey(item),
                            closable: !_ctx.selectDisabled && !item.isDisabled,
                            size: _ctx.collapseTagSize,
                            hit: item.hitState,
                            type: _ctx.tagType,
                            "disable-transitions": "",
                            onClose: ($event) => _ctx.deleteTag($event, item)
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", {
                                class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                                style: normalizeStyle(_ctx.tagTextStyle)
                              }, toDisplayString(item.currentLabel), 7)
                            ]),
                            _: 2
                          }, 1032, ["closable", "size", "hit", "type", "onClose"]);
                        }), 128)),
                        _ctx.selected.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tag, {
                          key: 0,
                          closable: false,
                          size: _ctx.collapseTagSize,
                          type: _ctx.tagType,
                          "disable-transitions": ""
                        }, {
                          default: withCtx(() => [
                            _ctx.collapseTagsTooltip ? (openBlock(), createBlock(_component_el_tooltip, {
                              key: 0,
                              ref: "tagTooltipRef",
                              disabled: _ctx.dropMenuVisible,
                              "fallback-placements": ["bottom", "top", "right", "left"],
                              effect: _ctx.effect,
                              placement: "bottom",
                              teleported: _ctx.teleported
                            }, {
                              default: withCtx(() => [
                                createBaseVNode("span", {
                                  class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                }, "+ " + toDisplayString(_ctx.selected.length - _ctx.maxCollapseTags), 3)
                              ]),
                              content: withCtx(() => [
                                createBaseVNode("div", {
                                  class: normalizeClass(_ctx.nsSelect.e("collapse-tags"))
                                }, [
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapseTagList, (item) => {
                                    return openBlock(), createElementBlock("div", {
                                      key: _ctx.getValueKey(item),
                                      class: normalizeClass(_ctx.nsSelect.e("collapse-tag"))
                                    }, [
                                      createVNode(_component_el_tag, {
                                        class: "in-tooltip",
                                        closable: !_ctx.selectDisabled && !item.isDisabled,
                                        size: _ctx.collapseTagSize,
                                        hit: item.hitState,
                                        type: _ctx.tagType,
                                        "disable-transitions": "",
                                        style: { margin: "2px" },
                                        onClose: ($event) => _ctx.handleDeleteTooltipTag($event, item)
                                      }, {
                                        default: withCtx(() => [
                                          createBaseVNode("span", {
                                            class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                                            style: normalizeStyle({
                                              maxWidth: _ctx.inputWidth - 75 + "px"
                                            })
                                          }, toDisplayString(item.currentLabel), 7)
                                        ]),
                                        _: 2
                                      }, 1032, ["closable", "size", "hit", "type", "onClose"])
                                    ], 2);
                                  }), 128))
                                ], 2)
                              ]),
                              _: 1
                            }, 8, ["disabled", "effect", "teleported"])) : (openBlock(), createElementBlock("span", {
                              key: 1,
                              class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                            }, "+ " + toDisplayString(_ctx.selected.length - _ctx.maxCollapseTags), 3))
                          ]),
                          _: 1
                        }, 8, ["size", "type"])) : createCommentVNode("v-if", true)
                      ], 2)
                    ]),
                    _: 1
                  }, 8, ["onAfterLeave"])) : createCommentVNode("v-if", true),
                  !_ctx.collapseTags ? (openBlock(), createBlock(Transition, {
                    key: 1,
                    onAfterLeave: _ctx.resetInputHeight
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("span", {
                        class: normalizeClass(_ctx.tagWrapperKls),
                        style: normalizeStyle(_ctx.prefixWidth && _ctx.selected.length ? { marginLeft: `${_ctx.prefixWidth}px` } : "")
                      }, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.selected, (item) => {
                          return openBlock(), createBlock(_component_el_tag, {
                            key: _ctx.getValueKey(item),
                            closable: !_ctx.selectDisabled && !item.isDisabled,
                            size: _ctx.collapseTagSize,
                            hit: item.hitState,
                            type: _ctx.tagType,
                            "disable-transitions": "",
                            onClose: ($event) => _ctx.deleteTag($event, item)
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", {
                                class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                                style: normalizeStyle({ maxWidth: _ctx.inputWidth - 75 + "px" })
                              }, toDisplayString(item.currentLabel), 7)
                            ]),
                            _: 2
                          }, 1032, ["closable", "size", "hit", "type", "onClose"]);
                        }), 128))
                      ], 6)
                    ]),
                    _: 1
                  }, 8, ["onAfterLeave"])) : createCommentVNode("v-if", true),
                  _ctx.filterable && !_ctx.selectDisabled ? withDirectives((openBlock(), createElementBlock("input", {
                    key: 2,
                    ref: "input",
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.query = $event),
                    type: "text",
                    class: normalizeClass(_ctx.inputKls),
                    disabled: _ctx.selectDisabled,
                    autocomplete: _ctx.autocomplete,
                    style: normalizeStyle(_ctx.inputStyle),
                    onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                    onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                    onKeyup: _cache[3] || (_cache[3] = (...args) => _ctx.managePlaceholder && _ctx.managePlaceholder(...args)),
                    onKeydown: [
                      _cache[4] || (_cache[4] = (...args) => _ctx.resetInputState && _ctx.resetInputState(...args)),
                      _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["prevent"]), ["down"])),
                      _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["prevent"]), ["up"])),
                      _cache[7] || (_cache[7] = withKeys((...args) => _ctx.handleKeydownEscape && _ctx.handleKeydownEscape(...args), ["esc"])),
                      _cache[8] || (_cache[8] = withKeys(withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                      _cache[9] || (_cache[9] = withKeys((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["delete"])),
                      _cache[10] || (_cache[10] = withKeys(($event) => _ctx.visible = false, ["tab"]))
                    ],
                    onCompositionstart: _cache[11] || (_cache[11] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                    onCompositionupdate: _cache[12] || (_cache[12] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                    onCompositionend: _cache[13] || (_cache[13] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                    onInput: _cache[14] || (_cache[14] = (...args) => _ctx.debouncedQueryChange && _ctx.debouncedQueryChange(...args))
                  }, null, 46, _hoisted_1$A)), [
                    [vModelText, _ctx.query]
                  ]) : createCommentVNode("v-if", true)
                ], 6)) : createCommentVNode("v-if", true),
                createCommentVNode(" fix: https://github.com/element-plus/element-plus/issues/11415 "),
                _ctx.isIOS && !_ctx.multiple && _ctx.filterable && _ctx.readonly ? (openBlock(), createElementBlock("input", {
                  key: 1,
                  ref: "iOSInput",
                  class: normalizeClass(_ctx.iOSInputKls),
                  disabled: _ctx.selectDisabled,
                  type: "text"
                }, null, 10, _hoisted_2$u)) : createCommentVNode("v-if", true),
                createVNode(_component_el_input, {
                  id: _ctx.id,
                  ref: "reference",
                  modelValue: _ctx.selectedLabel,
                  "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => _ctx.selectedLabel = $event),
                  type: "text",
                  placeholder: typeof _ctx.currentPlaceholder === "function" ? _ctx.currentPlaceholder() : _ctx.currentPlaceholder,
                  name: _ctx.name,
                  autocomplete: _ctx.autocomplete,
                  size: _ctx.selectSize,
                  disabled: _ctx.selectDisabled,
                  readonly: _ctx.readonly,
                  "validate-event": false,
                  class: normalizeClass([_ctx.nsSelect.is("focus", _ctx.visible)]),
                  tabindex: _ctx.multiple && _ctx.filterable ? -1 : void 0,
                  onFocus: _ctx.handleFocus,
                  onBlur: _ctx.handleBlur,
                  onInput: _ctx.debouncedOnInputChange,
                  onPaste: _ctx.debouncedOnInputChange,
                  onCompositionstart: _ctx.handleComposition,
                  onCompositionupdate: _ctx.handleComposition,
                  onCompositionend: _ctx.handleComposition,
                  onKeydown: [
                    _cache[16] || (_cache[16] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                    _cache[17] || (_cache[17] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                    withKeys(withModifiers(_ctx.selectOption, ["stop", "prevent"]), ["enter"]),
                    withKeys(_ctx.handleKeydownEscape, ["esc"]),
                    _cache[18] || (_cache[18] = withKeys(($event) => _ctx.visible = false, ["tab"]))
                  ]
                }, createSlots({
                  suffix: withCtx(() => [
                    _ctx.iconComponent && !_ctx.showClose ? (openBlock(), createBlock(_component_el_icon, {
                      key: 0,
                      class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true),
                    _ctx.showClose && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                      key: 1,
                      class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
                      onClick: _ctx.handleClearClick
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 2
                }, [
                  _ctx.$slots.prefix ? {
                    name: "prefix",
                    fn: withCtx(() => [
                      createBaseVNode("div", _hoisted_3$q, [
                        renderSlot(_ctx.$slots, "prefix")
                      ])
                    ])
                  } : void 0
                ]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])
              ], 32)
            ]),
            content: withCtx(() => [
              createVNode(_component_el_select_menu, null, {
                default: withCtx(() => [
                  withDirectives(createVNode(_component_el_scrollbar, {
                    ref: "scrollbar",
                    tag: "ul",
                    "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
                    "view-class": _ctx.nsSelect.be("dropdown", "list"),
                    class: normalizeClass(_ctx.scrollbarKls)
                  }, {
                    default: withCtx(() => [
                      _ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
                        key: 0,
                        value: _ctx.query,
                        created: true
                      }, null, 8, ["value"])) : createCommentVNode("v-if", true),
                      createVNode(_component_el_options, { onUpdateOptions: _ctx.onOptionsRendered }, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "default")
                        ]),
                        _: 3
                      }, 8, ["onUpdateOptions"])
                    ]),
                    _: 3
                  }, 8, ["wrap-class", "view-class", "class"]), [
                    [vShow, _ctx.options.size > 0 && !_ctx.loading]
                  ]),
                  _ctx.emptyText && (!_ctx.allowCreate || _ctx.loading || _ctx.allowCreate && _ctx.options.size === 0) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    _ctx.$slots.empty ? renderSlot(_ctx.$slots, "empty", { key: 0 }) : (openBlock(), createElementBlock("p", {
                      key: 1,
                      class: normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                    }, toDisplayString(_ctx.emptyText), 3))
                  ], 64)) : createCommentVNode("v-if", true)
                ]),
                _: 3
              })
            ]),
            _: 3
          }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onShow"])
        ], 34)), [
          [_directive_click_outside, _ctx.handleClose, _ctx.popperPaneRef]
        ]);
      }
      var Select$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["render", _sfc_render$5], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);
      const _sfc_main$o = defineComponent({
        name: "ElOptionGroup",
        componentName: "ElOptionGroup",
        props: {
          label: String,
          disabled: {
            type: Boolean,
            default: false
          }
        },
        setup(props) {
          const ns = useNamespace("select");
          const visible = ref(true);
          const instance = getCurrentInstance();
          const children = ref([]);
          provide(selectGroupKey, reactive({
            ...toRefs(props)
          }));
          const select = inject(selectKey);
          onMounted(() => {
            children.value = flattedChildren2(instance.subTree);
          });
          const flattedChildren2 = (node) => {
            const children2 = [];
            if (Array.isArray(node.children)) {
              node.children.forEach((child) => {
                var _a2;
                if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
                  children2.push(child.component.proxy);
                } else if ((_a2 = child.children) == null ? void 0 : _a2.length) {
                  children2.push(...flattedChildren2(child));
                }
              });
            }
            return children2;
          };
          const { groupQueryChange } = toRaw(select);
          watch(groupQueryChange, () => {
            visible.value = children.value.some((option) => option.visible === true);
          }, { flush: "post" });
          return {
            visible,
            ns
          };
        }
      });
      function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
        return withDirectives((openBlock(), createElementBlock("ul", {
          class: normalizeClass(_ctx.ns.be("group", "wrap"))
        }, [
          createBaseVNode("li", {
            class: normalizeClass(_ctx.ns.be("group", "title"))
          }, toDisplayString(_ctx.label), 3),
          createBaseVNode("li", null, [
            createBaseVNode("ul", {
              class: normalizeClass(_ctx.ns.b("group"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)
          ])
        ], 2)), [
          [vShow, _ctx.visible]
        ]);
      }
      var OptionGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["render", _sfc_render$4], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);
      const ElSelect = withInstall(Select$1, {
        Option,
        OptionGroup
      });
      const ElOption = withNoopInstall(Option);
      withNoopInstall(OptionGroup);
      const popoverProps = buildProps({
        trigger: useTooltipTriggerProps.trigger,
        placement: dropdownProps.placement,
        disabled: useTooltipTriggerProps.disabled,
        visible: useTooltipContentProps.visible,
        transition: useTooltipContentProps.transition,
        popperOptions: dropdownProps.popperOptions,
        tabindex: dropdownProps.tabindex,
        content: useTooltipContentProps.content,
        popperStyle: useTooltipContentProps.popperStyle,
        popperClass: useTooltipContentProps.popperClass,
        enterable: {
          ...useTooltipContentProps.enterable,
          default: true
        },
        effect: {
          ...useTooltipContentProps.effect,
          default: "light"
        },
        teleported: useTooltipContentProps.teleported,
        title: String,
        width: {
          type: [String, Number],
          default: 150
        },
        offset: {
          type: Number,
          default: void 0
        },
        showAfter: {
          type: Number,
          default: 0
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        autoClose: {
          type: Number,
          default: 0
        },
        showArrow: {
          type: Boolean,
          default: true
        },
        persistent: {
          type: Boolean,
          default: true
        },
        "onUpdate:visible": {
          type: Function
        }
      });
      const popoverEmits = {
        "update:visible": (value) => isBoolean(value),
        "before-enter": () => true,
        "before-leave": () => true,
        "after-enter": () => true,
        "after-leave": () => true
      };
      const updateEventKeyRaw = `onUpdate:visible`;
      const __default__$a = defineComponent({
        name: "ElPopover"
      });
      const _sfc_main$n = /* @__PURE__ */ defineComponent({
        ...__default__$a,
        props: popoverProps,
        emits: popoverEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const onUpdateVisible = computed(() => {
            return props[updateEventKeyRaw];
          });
          const ns = useNamespace("popover");
          const tooltipRef = ref();
          const popperRef = computed(() => {
            var _a2;
            return (_a2 = unref(tooltipRef)) == null ? void 0 : _a2.popperRef;
          });
          const style = computed(() => {
            return [
              {
                width: addUnit(props.width)
              },
              props.popperStyle
            ];
          });
          const kls = computed(() => {
            return [ns.b(), props.popperClass, { [ns.m("plain")]: !!props.content }];
          });
          const gpuAcceleration = computed(() => {
            return props.transition === `${ns.namespace.value}-fade-in-linear`;
          });
          const hide = () => {
            var _a2;
            (_a2 = tooltipRef.value) == null ? void 0 : _a2.hide();
          };
          const beforeEnter = () => {
            emit2("before-enter");
          };
          const beforeLeave = () => {
            emit2("before-leave");
          };
          const afterEnter = () => {
            emit2("after-enter");
          };
          const afterLeave = () => {
            emit2("update:visible", false);
            emit2("after-leave");
          };
          expose({
            popperRef,
            hide
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTooltip), mergeProps({
              ref_key: "tooltipRef",
              ref: tooltipRef
            }, _ctx.$attrs, {
              trigger: _ctx.trigger,
              placement: _ctx.placement,
              disabled: _ctx.disabled,
              visible: _ctx.visible,
              transition: _ctx.transition,
              "popper-options": _ctx.popperOptions,
              tabindex: _ctx.tabindex,
              content: _ctx.content,
              offset: _ctx.offset,
              "show-after": _ctx.showAfter,
              "hide-after": _ctx.hideAfter,
              "auto-close": _ctx.autoClose,
              "show-arrow": _ctx.showArrow,
              "aria-label": _ctx.title,
              effect: _ctx.effect,
              enterable: _ctx.enterable,
              "popper-class": unref(kls),
              "popper-style": unref(style),
              teleported: _ctx.teleported,
              persistent: _ctx.persistent,
              "gpu-acceleration": unref(gpuAcceleration),
              "onUpdate:visible": unref(onUpdateVisible),
              onBeforeShow: beforeEnter,
              onBeforeHide: beforeLeave,
              onShow: afterEnter,
              onHide: afterLeave
            }), {
              content: withCtx(() => [
                _ctx.title ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("title")),
                  role: "title"
                }, toDisplayString(_ctx.title), 3)) : createCommentVNode("v-if", true),
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.content), 1)
                ])
              ]),
              default: withCtx(() => [
                _ctx.$slots.reference ? renderSlot(_ctx.$slots, "reference", { key: 0 }) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onUpdate:visible"]);
          };
        }
      });
      var Popover = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/popover.vue"]]);
      const attachEvents = (el, binding) => {
        const popperComponent = binding.arg || binding.value;
        const popover = popperComponent == null ? void 0 : popperComponent.popperRef;
        if (popover) {
          popover.triggerRef = el;
        }
      };
      var PopoverDirective = {
        mounted(el, binding) {
          attachEvents(el, binding);
        },
        updated(el, binding) {
          attachEvents(el, binding);
        }
      };
      const VPopover = "popover";
      const ElPopoverDirective = withInstallDirective(PopoverDirective, VPopover);
      const ElPopover = withInstall(Popover, {
        directive: ElPopoverDirective
      });
      const progressProps = buildProps({
        type: {
          type: String,
          default: "line",
          values: ["line", "circle", "dashboard"]
        },
        percentage: {
          type: Number,
          default: 0,
          validator: (val) => val >= 0 && val <= 100
        },
        status: {
          type: String,
          default: "",
          values: ["", "success", "exception", "warning"]
        },
        indeterminate: {
          type: Boolean,
          default: false
        },
        duration: {
          type: Number,
          default: 3
        },
        strokeWidth: {
          type: Number,
          default: 6
        },
        strokeLinecap: {
          type: definePropType(String),
          default: "round"
        },
        textInside: {
          type: Boolean,
          default: false
        },
        width: {
          type: Number,
          default: 126
        },
        showText: {
          type: Boolean,
          default: true
        },
        color: {
          type: definePropType([
            String,
            Array,
            Function
          ]),
          default: ""
        },
        striped: Boolean,
        stripedFlow: Boolean,
        format: {
          type: definePropType(Function),
          default: (percentage) => `${percentage}%`
        }
      });
      const _hoisted_1$z = ["aria-valuenow"];
      const _hoisted_2$t = { viewBox: "0 0 100 100" };
      const _hoisted_3$p = ["d", "stroke", "stroke-linecap", "stroke-width"];
      const _hoisted_4$9 = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"];
      const _hoisted_5$5 = { key: 0 };
      const __default__$9 = defineComponent({
        name: "ElProgress"
      });
      const _sfc_main$m = /* @__PURE__ */ defineComponent({
        ...__default__$9,
        props: progressProps,
        setup(__props) {
          const props = __props;
          const STATUS_COLOR_MAP = {
            success: "#13ce66",
            exception: "#ff4949",
            warning: "#e6a23c",
            default: "#20a0ff"
          };
          const ns = useNamespace("progress");
          const barStyle = computed(() => ({
            width: `${props.percentage}%`,
            animationDuration: `${props.duration}s`,
            backgroundColor: getCurrentColor(props.percentage)
          }));
          const relativeStrokeWidth = computed(() => (props.strokeWidth / props.width * 100).toFixed(1));
          const radius = computed(() => {
            if (["circle", "dashboard"].includes(props.type)) {
              return Number.parseInt(`${50 - Number.parseFloat(relativeStrokeWidth.value) / 2}`, 10);
            }
            return 0;
          });
          const trackPath = computed(() => {
            const r2 = radius.value;
            const isDashboard = props.type === "dashboard";
            return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r2}
          a ${r2} ${r2} 0 1 1 0 ${isDashboard ? "-" : ""}${r2 * 2}
          a ${r2} ${r2} 0 1 1 0 ${isDashboard ? "" : "-"}${r2 * 2}
          `;
          });
          const perimeter = computed(() => 2 * Math.PI * radius.value);
          const rate = computed(() => props.type === "dashboard" ? 0.75 : 1);
          const strokeDashoffset = computed(() => {
            const offset = -1 * perimeter.value * (1 - rate.value) / 2;
            return `${offset}px`;
          });
          const trailPathStyle = computed(() => ({
            strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
            strokeDashoffset: strokeDashoffset.value
          }));
          const circlePathStyle = computed(() => ({
            strokeDasharray: `${perimeter.value * rate.value * (props.percentage / 100)}px, ${perimeter.value}px`,
            strokeDashoffset: strokeDashoffset.value,
            transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
          }));
          const stroke = computed(() => {
            let ret;
            if (props.color) {
              ret = getCurrentColor(props.percentage);
            } else {
              ret = STATUS_COLOR_MAP[props.status] || STATUS_COLOR_MAP.default;
            }
            return ret;
          });
          const statusIcon = computed(() => {
            if (props.status === "warning") {
              return warning_filled_default;
            }
            if (props.type === "line") {
              return props.status === "success" ? circle_check_default : circle_close_default;
            } else {
              return props.status === "success" ? check_default : close_default;
            }
          });
          const progressTextSize = computed(() => {
            return props.type === "line" ? 12 + props.strokeWidth * 0.4 : props.width * 0.111111 + 2;
          });
          const content = computed(() => props.format(props.percentage));
          function getColors(color) {
            const span = 100 / color.length;
            const seriesColors = color.map((seriesColor, index) => {
              if (isString$1(seriesColor)) {
                return {
                  color: seriesColor,
                  percentage: (index + 1) * span
                };
              }
              return seriesColor;
            });
            return seriesColors.sort((a2, b2) => a2.percentage - b2.percentage);
          }
          const getCurrentColor = (percentage) => {
            var _a2;
            const { color } = props;
            if (isFunction$1(color)) {
              return color(percentage);
            } else if (isString$1(color)) {
              return color;
            } else {
              const colors = getColors(color);
              for (const color2 of colors) {
                if (color2.percentage > percentage)
                  return color2.color;
              }
              return (_a2 = colors[colors.length - 1]) == null ? void 0 : _a2.color;
            }
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).m(_ctx.type),
                unref(ns).is(_ctx.status),
                {
                  [unref(ns).m("without-text")]: !_ctx.showText,
                  [unref(ns).m("text-inside")]: _ctx.textInside
                }
              ]),
              role: "progressbar",
              "aria-valuenow": _ctx.percentage,
              "aria-valuemin": "0",
              "aria-valuemax": "100"
            }, [
              _ctx.type === "line" ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).b("bar"))
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).be("bar", "outer")),
                  style: normalizeStyle({ height: `${_ctx.strokeWidth}px` })
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass([
                      unref(ns).be("bar", "inner"),
                      { [unref(ns).bem("bar", "inner", "indeterminate")]: _ctx.indeterminate },
                      { [unref(ns).bem("bar", "inner", "striped")]: _ctx.striped },
                      { [unref(ns).bem("bar", "inner", "striped-flow")]: _ctx.stripedFlow }
                    ]),
                    style: normalizeStyle(unref(barStyle))
                  }, [
                    (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass(unref(ns).be("bar", "innerText"))
                    }, [
                      renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                        createBaseVNode("span", null, toDisplayString(unref(content)), 1)
                      ])
                    ], 2)) : createCommentVNode("v-if", true)
                  ], 6)
                ], 6)
              ], 2)) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).b("circle")),
                style: normalizeStyle({ height: `${_ctx.width}px`, width: `${_ctx.width}px` })
              }, [
                (openBlock(), createElementBlock("svg", _hoisted_2$t, [
                  createBaseVNode("path", {
                    class: normalizeClass(unref(ns).be("circle", "track")),
                    d: unref(trackPath),
                    stroke: `var(${unref(ns).cssVarName("fill-color-light")}, #e5e9f2)`,
                    "stroke-linecap": _ctx.strokeLinecap,
                    "stroke-width": unref(relativeStrokeWidth),
                    fill: "none",
                    style: normalizeStyle(unref(trailPathStyle))
                  }, null, 14, _hoisted_3$p),
                  createBaseVNode("path", {
                    class: normalizeClass(unref(ns).be("circle", "path")),
                    d: unref(trackPath),
                    stroke: unref(stroke),
                    fill: "none",
                    opacity: _ctx.percentage ? 1 : 0,
                    "stroke-linecap": _ctx.strokeLinecap,
                    "stroke-width": unref(relativeStrokeWidth),
                    style: normalizeStyle(unref(circlePathStyle))
                  }, null, 14, _hoisted_4$9)
                ]))
              ], 6)),
              (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? (openBlock(), createElementBlock("div", {
                key: 2,
                class: normalizeClass(unref(ns).e("text")),
                style: normalizeStyle({ fontSize: `${unref(progressTextSize)}px` })
              }, [
                renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                  !_ctx.status ? (openBlock(), createElementBlock("span", _hoisted_5$5, toDisplayString(unref(content)), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(statusIcon))))
                    ]),
                    _: 1
                  }))
                ])
              ], 6)) : createCommentVNode("v-if", true)
            ], 10, _hoisted_1$z);
          };
        }
      });
      var Progress = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]);
      const ElProgress = withInstall(Progress);
      var safeIsNaN = Number.isNaN || function ponyfill(value) {
        return typeof value === "number" && value !== value;
      };
      function isEqual(first, second) {
        if (first === second) {
          return true;
        }
        if (safeIsNaN(first) && safeIsNaN(second)) {
          return true;
        }
        return false;
      }
      function areInputsEqual(newInputs, lastInputs) {
        if (newInputs.length !== lastInputs.length) {
          return false;
        }
        for (var i2 = 0; i2 < newInputs.length; i2++) {
          if (!isEqual(newInputs[i2], lastInputs[i2])) {
            return false;
          }
        }
        return true;
      }
      function memoizeOne(resultFn, isEqual2) {
        if (isEqual2 === void 0) {
          isEqual2 = areInputsEqual;
        }
        var cache2 = null;
        function memoized() {
          var newArgs = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
          }
          if (cache2 && cache2.lastThis === this && isEqual2(newArgs, cache2.lastArgs)) {
            return cache2.lastResult;
          }
          var lastResult = resultFn.apply(this, newArgs);
          cache2 = {
            lastResult,
            lastArgs: newArgs,
            lastThis: this
          };
          return lastResult;
        }
        memoized.clear = function clear2() {
          cache2 = null;
        };
        return memoized;
      }
      const useCache = () => {
        const vm = getCurrentInstance();
        const props = vm.proxy.$props;
        return computed(() => {
          const _getItemStyleCache = (_2, __, ___) => ({});
          return props.perfMode ? memoize(_getItemStyleCache) : memoizeOne(_getItemStyleCache);
        });
      };
      const DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;
      const ITEM_RENDER_EVT = "itemRendered";
      const SCROLL_EVT = "scroll";
      const FORWARD = "forward";
      const BACKWARD = "backward";
      const AUTO_ALIGNMENT = "auto";
      const SMART_ALIGNMENT = "smart";
      const START_ALIGNMENT = "start";
      const CENTERED_ALIGNMENT = "center";
      const END_ALIGNMENT = "end";
      const HORIZONTAL = "horizontal";
      const VERTICAL = "vertical";
      const LTR = "ltr";
      const RTL = "rtl";
      const RTL_OFFSET_NAG = "negative";
      const RTL_OFFSET_POS_ASC = "positive-ascending";
      const RTL_OFFSET_POS_DESC = "positive-descending";
      const ScrollbarDirKey = {
        [HORIZONTAL]: "left",
        [VERTICAL]: "top"
      };
      const SCROLLBAR_MIN_SIZE = 20;
      const LayoutKeys = {
        [HORIZONTAL]: "deltaX",
        [VERTICAL]: "deltaY"
      };
      const useWheel = ({ atEndEdge, atStartEdge, layout: layout2 }, onWheelDelta) => {
        let frameHandle;
        let offset = 0;
        const hasReachedEdge = (offset2) => {
          const edgeReached = offset2 < 0 && atStartEdge.value || offset2 > 0 && atEndEdge.value;
          return edgeReached;
        };
        const onWheel = (e2) => {
          cAF(frameHandle);
          const newOffset = e2[LayoutKeys[layout2.value]];
          if (hasReachedEdge(offset) && hasReachedEdge(offset + newOffset))
            return;
          offset += newOffset;
          if (!isFirefox()) {
            e2.preventDefault();
          }
          frameHandle = rAF(() => {
            onWheelDelta(offset);
            offset = 0;
          });
        };
        return {
          hasReachedEdge,
          onWheel
        };
      };
      const itemSize$1 = buildProp({
        type: definePropType([Number, Function]),
        required: true
      });
      const estimatedItemSize = buildProp({
        type: Number
      });
      const cache = buildProp({
        type: Number,
        default: 2
      });
      const direction = buildProp({
        type: String,
        values: ["ltr", "rtl"],
        default: "ltr"
      });
      const initScrollOffset = buildProp({
        type: Number,
        default: 0
      });
      const total = buildProp({
        type: Number,
        required: true
      });
      const layout = buildProp({
        type: String,
        values: ["horizontal", "vertical"],
        default: VERTICAL
      });
      const virtualizedProps = buildProps({
        className: {
          type: String,
          default: ""
        },
        containerElement: {
          type: definePropType([String, Object]),
          default: "div"
        },
        data: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        direction,
        height: {
          type: [String, Number],
          required: true
        },
        innerElement: {
          type: [String, Object],
          default: "div"
        },
        style: {
          type: definePropType([Object, String, Array])
        },
        useIsScrolling: {
          type: Boolean,
          default: false
        },
        width: {
          type: [Number, String],
          required: false
        },
        perfMode: {
          type: Boolean,
          default: true
        },
        scrollbarAlwaysOn: {
          type: Boolean,
          default: false
        }
      });
      const virtualizedListProps = buildProps({
        cache,
        estimatedItemSize,
        layout,
        initScrollOffset,
        total,
        itemSize: itemSize$1,
        ...virtualizedProps
      });
      const scrollbarSize = {
        type: Number,
        default: 6
      };
      const startGap = { type: Number, default: 0 };
      const endGap = { type: Number, default: 2 };
      buildProps({
        columnCache: cache,
        columnWidth: itemSize$1,
        estimatedColumnWidth: estimatedItemSize,
        estimatedRowHeight: estimatedItemSize,
        initScrollLeft: initScrollOffset,
        initScrollTop: initScrollOffset,
        itemKey: {
          type: definePropType(Function),
          default: ({
            columnIndex,
            rowIndex
          }) => `${rowIndex}:${columnIndex}`
        },
        rowCache: cache,
        rowHeight: itemSize$1,
        totalColumn: total,
        totalRow: total,
        hScrollbarSize: scrollbarSize,
        vScrollbarSize: scrollbarSize,
        scrollbarStartGap: startGap,
        scrollbarEndGap: endGap,
        role: String,
        ...virtualizedProps
      });
      const virtualizedScrollbarProps = buildProps({
        alwaysOn: Boolean,
        class: String,
        layout,
        total,
        ratio: {
          type: Number,
          required: true
        },
        clientSize: {
          type: Number,
          required: true
        },
        scrollFrom: {
          type: Number,
          required: true
        },
        scrollbarSize,
        startGap,
        endGap,
        visible: Boolean
      });
      const getScrollDir = (prev, cur) => prev < cur ? FORWARD : BACKWARD;
      const isHorizontal = (dir) => dir === LTR || dir === RTL || dir === HORIZONTAL;
      let cachedRTLResult = null;
      function getRTLOffsetType(recalculate = false) {
        if (cachedRTLResult === null || recalculate) {
          const outerDiv = document.createElement("div");
          const outerStyle = outerDiv.style;
          outerStyle.width = "50px";
          outerStyle.height = "50px";
          outerStyle.overflow = "scroll";
          outerStyle.direction = "rtl";
          const innerDiv = document.createElement("div");
          const innerStyle = innerDiv.style;
          innerStyle.width = "100px";
          innerStyle.height = "100px";
          outerDiv.appendChild(innerDiv);
          document.body.appendChild(outerDiv);
          if (outerDiv.scrollLeft > 0) {
            cachedRTLResult = RTL_OFFSET_POS_DESC;
          } else {
            outerDiv.scrollLeft = 1;
            if (outerDiv.scrollLeft === 0) {
              cachedRTLResult = RTL_OFFSET_NAG;
            } else {
              cachedRTLResult = RTL_OFFSET_POS_ASC;
            }
          }
          document.body.removeChild(outerDiv);
          return cachedRTLResult;
        }
        return cachedRTLResult;
      }
      function renderThumbStyle({ move, size: size2, bar }, layout2) {
        const style = {};
        const translate2 = `translate${bar.axis}(${move}px)`;
        style[bar.size] = size2;
        style.transform = translate2;
        style.msTransform = translate2;
        style.webkitTransform = translate2;
        if (layout2 === "horizontal") {
          style.height = "100%";
        } else {
          style.width = "100%";
        }
        return style;
      }
      const ScrollBar = defineComponent({
        name: "ElVirtualScrollBar",
        props: virtualizedScrollbarProps,
        emits: ["scroll", "start-move", "stop-move"],
        setup(props, { emit: emit2 }) {
          const GAP2 = computed(() => props.startGap + props.endGap);
          const nsVirtualScrollbar = useNamespace("virtual-scrollbar");
          const nsScrollbar = useNamespace("scrollbar");
          const trackRef = ref();
          const thumbRef = ref();
          let frameHandle = null;
          let onselectstartStore = null;
          const state = reactive({
            isDragging: false,
            traveled: 0
          });
          const bar = computed(() => BAR_MAP[props.layout]);
          const trackSize = computed(() => props.clientSize - unref(GAP2));
          const trackStyle = computed(() => ({
            position: "absolute",
            width: `${HORIZONTAL === props.layout ? trackSize.value : props.scrollbarSize}px`,
            height: `${HORIZONTAL === props.layout ? props.scrollbarSize : trackSize.value}px`,
            [ScrollbarDirKey[props.layout]]: "2px",
            right: "2px",
            bottom: "2px",
            borderRadius: "4px"
          }));
          const thumbSize = computed(() => {
            const ratio = props.ratio;
            const clientSize = props.clientSize;
            if (ratio >= 100) {
              return Number.POSITIVE_INFINITY;
            }
            if (ratio >= 50) {
              return ratio * clientSize / 100;
            }
            const SCROLLBAR_MAX_SIZE = clientSize / 3;
            return Math.floor(Math.min(Math.max(ratio * clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));
          });
          const thumbStyle = computed(() => {
            if (!Number.isFinite(thumbSize.value)) {
              return {
                display: "none"
              };
            }
            const thumb = `${thumbSize.value}px`;
            const style = renderThumbStyle({
              bar: bar.value,
              size: thumb,
              move: state.traveled
            }, props.layout);
            return style;
          });
          const totalSteps = computed(() => Math.floor(props.clientSize - thumbSize.value - unref(GAP2)));
          const attachEvents2 = () => {
            window.addEventListener("mousemove", onMouseMove);
            window.addEventListener("mouseup", onMouseUp);
            const thumbEl = unref(thumbRef);
            if (!thumbEl)
              return;
            onselectstartStore = document.onselectstart;
            document.onselectstart = () => false;
            thumbEl.addEventListener("touchmove", onMouseMove);
            thumbEl.addEventListener("touchend", onMouseUp);
          };
          const detachEvents = () => {
            window.removeEventListener("mousemove", onMouseMove);
            window.removeEventListener("mouseup", onMouseUp);
            document.onselectstart = onselectstartStore;
            onselectstartStore = null;
            const thumbEl = unref(thumbRef);
            if (!thumbEl)
              return;
            thumbEl.removeEventListener("touchmove", onMouseMove);
            thumbEl.removeEventListener("touchend", onMouseUp);
          };
          const onThumbMouseDown = (e2) => {
            e2.stopImmediatePropagation();
            if (e2.ctrlKey || [1, 2].includes(e2.button)) {
              return;
            }
            state.isDragging = true;
            state[bar.value.axis] = e2.currentTarget[bar.value.offset] - (e2[bar.value.client] - e2.currentTarget.getBoundingClientRect()[bar.value.direction]);
            emit2("start-move");
            attachEvents2();
          };
          const onMouseUp = () => {
            state.isDragging = false;
            state[bar.value.axis] = 0;
            emit2("stop-move");
            detachEvents();
          };
          const onMouseMove = (e2) => {
            const { isDragging } = state;
            if (!isDragging)
              return;
            if (!thumbRef.value || !trackRef.value)
              return;
            const prevPage = state[bar.value.axis];
            if (!prevPage)
              return;
            cAF(frameHandle);
            const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e2[bar.value.client]) * -1;
            const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;
            const distance = offset - thumbClickPosition;
            frameHandle = rAF(() => {
              state.traveled = Math.max(props.startGap, Math.min(distance, totalSteps.value));
              emit2("scroll", distance, totalSteps.value);
            });
          };
          const clickTrackHandler = (e2) => {
            const offset = Math.abs(e2.target.getBoundingClientRect()[bar.value.direction] - e2[bar.value.client]);
            const thumbHalf = thumbRef.value[bar.value.offset] / 2;
            const distance = offset - thumbHalf;
            state.traveled = Math.max(0, Math.min(distance, totalSteps.value));
            emit2("scroll", distance, totalSteps.value);
          };
          watch(() => props.scrollFrom, (v2) => {
            if (state.isDragging)
              return;
            state.traveled = Math.ceil(v2 * totalSteps.value);
          });
          onBeforeUnmount(() => {
            detachEvents();
          });
          return () => {
            return h$1("div", {
              role: "presentation",
              ref: trackRef,
              class: [
                nsVirtualScrollbar.b(),
                props.class,
                (props.alwaysOn || state.isDragging) && "always-on"
              ],
              style: trackStyle.value,
              onMousedown: withModifiers(clickTrackHandler, ["stop", "prevent"]),
              onTouchstartPrevent: onThumbMouseDown
            }, h$1("div", {
              ref: thumbRef,
              class: nsScrollbar.e("thumb"),
              style: thumbStyle.value,
              onMousedown: onThumbMouseDown
            }, []));
          };
        }
      });
      const createList = ({
        name,
        getOffset,
        getItemSize,
        getItemOffset,
        getEstimatedTotalSize: getEstimatedTotalSize2,
        getStartIndexForOffset,
        getStopIndexForStartIndex,
        initCache,
        clearCache,
        validateProps
      }) => {
        return defineComponent({
          name: name != null ? name : "ElVirtualList",
          props: virtualizedListProps,
          emits: [ITEM_RENDER_EVT, SCROLL_EVT],
          setup(props, { emit: emit2, expose }) {
            validateProps(props);
            const instance = getCurrentInstance();
            const ns = useNamespace("vl");
            const dynamicSizeCache = ref(initCache(props, instance));
            const getItemStyleCache = useCache();
            const windowRef = ref();
            const innerRef = ref();
            const scrollbarRef = ref();
            const states = ref({
              isScrolling: false,
              scrollDir: "forward",
              scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,
              updateRequested: false,
              isScrollbarDragging: false,
              scrollbarAlwaysOn: props.scrollbarAlwaysOn
            });
            const itemsToRender = computed(() => {
              const { total: total2, cache: cache2 } = props;
              const { isScrolling, scrollDir, scrollOffset } = unref(states);
              if (total2 === 0) {
                return [0, 0, 0, 0];
              }
              const startIndex = getStartIndexForOffset(props, scrollOffset, unref(dynamicSizeCache));
              const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, unref(dynamicSizeCache));
              const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache2) : 1;
              const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache2) : 1;
              return [
                Math.max(0, startIndex - cacheBackward),
                Math.max(0, Math.min(total2 - 1, stopIndex + cacheForward)),
                startIndex,
                stopIndex
              ];
            });
            const estimatedTotalSize = computed(() => getEstimatedTotalSize2(props, unref(dynamicSizeCache)));
            const _isHorizontal = computed(() => isHorizontal(props.layout));
            const windowStyle = computed(() => [
              {
                position: "relative",
                [`overflow-${_isHorizontal.value ? "x" : "y"}`]: "scroll",
                WebkitOverflowScrolling: "touch",
                willChange: "transform"
              },
              {
                direction: props.direction,
                height: isNumber(props.height) ? `${props.height}px` : props.height,
                width: isNumber(props.width) ? `${props.width}px` : props.width
              },
              props.style
            ]);
            const innerStyle = computed(() => {
              const size2 = unref(estimatedTotalSize);
              const horizontal = unref(_isHorizontal);
              return {
                height: horizontal ? "100%" : `${size2}px`,
                pointerEvents: unref(states).isScrolling ? "none" : void 0,
                width: horizontal ? `${size2}px` : "100%"
              };
            });
            const clientSize = computed(() => _isHorizontal.value ? props.width : props.height);
            const { onWheel } = useWheel({
              atStartEdge: computed(() => states.value.scrollOffset <= 0),
              atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),
              layout: computed(() => props.layout)
            }, (offset) => {
              var _a2, _b;
              (_b = (_a2 = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a2);
              scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));
            });
            const emitEvents = () => {
              const { total: total2 } = props;
              if (total2 > 0) {
                const [cacheStart, cacheEnd, visibleStart, visibleEnd] = unref(itemsToRender);
                emit2(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);
              }
              const { scrollDir, scrollOffset, updateRequested } = unref(states);
              emit2(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);
            };
            const scrollVertically = (e2) => {
              const { clientHeight, scrollHeight, scrollTop } = e2.currentTarget;
              const _states = unref(states);
              if (_states.scrollOffset === scrollTop) {
                return;
              }
              const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
              states.value = {
                ..._states,
                isScrolling: true,
                scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),
                scrollOffset,
                updateRequested: false
              };
              nextTick(resetIsScrolling);
            };
            const scrollHorizontally = (e2) => {
              const { clientWidth, scrollLeft, scrollWidth } = e2.currentTarget;
              const _states = unref(states);
              if (_states.scrollOffset === scrollLeft) {
                return;
              }
              const { direction: direction2 } = props;
              let scrollOffset = scrollLeft;
              if (direction2 === RTL) {
                switch (getRTLOffsetType()) {
                  case RTL_OFFSET_NAG: {
                    scrollOffset = -scrollLeft;
                    break;
                  }
                  case RTL_OFFSET_POS_DESC: {
                    scrollOffset = scrollWidth - clientWidth - scrollLeft;
                    break;
                  }
                }
              }
              scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
              states.value = {
                ..._states,
                isScrolling: true,
                scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),
                scrollOffset,
                updateRequested: false
              };
              nextTick(resetIsScrolling);
            };
            const onScroll = (e2) => {
              unref(_isHorizontal) ? scrollHorizontally(e2) : scrollVertically(e2);
              emitEvents();
            };
            const onScrollbarScroll = (distanceToGo, totalSteps) => {
              const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;
              scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));
            };
            const scrollTo = (offset) => {
              offset = Math.max(offset, 0);
              if (offset === unref(states).scrollOffset) {
                return;
              }
              states.value = {
                ...unref(states),
                scrollOffset: offset,
                scrollDir: getScrollDir(unref(states).scrollOffset, offset),
                updateRequested: true
              };
              nextTick(resetIsScrolling);
            };
            const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {
              const { scrollOffset } = unref(states);
              idx = Math.max(0, Math.min(idx, props.total - 1));
              scrollTo(getOffset(props, idx, alignment, scrollOffset, unref(dynamicSizeCache)));
            };
            const getItemStyle = (idx) => {
              const { direction: direction2, itemSize: itemSize2, layout: layout2 } = props;
              const itemStyleCache = getItemStyleCache.value(clearCache && itemSize2, clearCache && layout2, clearCache && direction2);
              let style;
              if (hasOwn(itemStyleCache, String(idx))) {
                style = itemStyleCache[idx];
              } else {
                const offset = getItemOffset(props, idx, unref(dynamicSizeCache));
                const size2 = getItemSize(props, idx, unref(dynamicSizeCache));
                const horizontal = unref(_isHorizontal);
                const isRtl = direction2 === RTL;
                const offsetHorizontal = horizontal ? offset : 0;
                itemStyleCache[idx] = style = {
                  position: "absolute",
                  left: isRtl ? void 0 : `${offsetHorizontal}px`,
                  right: isRtl ? `${offsetHorizontal}px` : void 0,
                  top: !horizontal ? `${offset}px` : 0,
                  height: !horizontal ? `${size2}px` : "100%",
                  width: horizontal ? `${size2}px` : "100%"
                };
              }
              return style;
            };
            const resetIsScrolling = () => {
              states.value.isScrolling = false;
              nextTick(() => {
                getItemStyleCache.value(-1, null, null);
              });
            };
            const resetScrollTop = () => {
              const window2 = windowRef.value;
              if (window2) {
                window2.scrollTop = 0;
              }
            };
            onMounted(() => {
              if (!isClient$1)
                return;
              const { initScrollOffset: initScrollOffset2 } = props;
              const windowElement = unref(windowRef);
              if (isNumber(initScrollOffset2) && windowElement) {
                if (unref(_isHorizontal)) {
                  windowElement.scrollLeft = initScrollOffset2;
                } else {
                  windowElement.scrollTop = initScrollOffset2;
                }
              }
              emitEvents();
            });
            onUpdated(() => {
              const { direction: direction2, layout: layout2 } = props;
              const { scrollOffset, updateRequested } = unref(states);
              const windowElement = unref(windowRef);
              if (updateRequested && windowElement) {
                if (layout2 === HORIZONTAL) {
                  if (direction2 === RTL) {
                    switch (getRTLOffsetType()) {
                      case RTL_OFFSET_NAG: {
                        windowElement.scrollLeft = -scrollOffset;
                        break;
                      }
                      case RTL_OFFSET_POS_ASC: {
                        windowElement.scrollLeft = scrollOffset;
                        break;
                      }
                      default: {
                        const { clientWidth, scrollWidth } = windowElement;
                        windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                        break;
                      }
                    }
                  } else {
                    windowElement.scrollLeft = scrollOffset;
                  }
                } else {
                  windowElement.scrollTop = scrollOffset;
                }
              }
            });
            const api = {
              ns,
              clientSize,
              estimatedTotalSize,
              windowStyle,
              windowRef,
              innerRef,
              innerStyle,
              itemsToRender,
              scrollbarRef,
              states,
              getItemStyle,
              onScroll,
              onScrollbarScroll,
              onWheel,
              scrollTo,
              scrollToItem,
              resetScrollTop
            };
            expose({
              windowRef,
              innerRef,
              getItemStyleCache,
              scrollTo,
              scrollToItem,
              resetScrollTop,
              states
            });
            return api;
          },
          render(ctx) {
            var _a2;
            const {
              $slots,
              className,
              clientSize,
              containerElement,
              data,
              getItemStyle,
              innerElement,
              itemsToRender,
              innerStyle,
              layout: layout2,
              total: total2,
              onScroll,
              onScrollbarScroll,
              onWheel,
              states,
              useIsScrolling,
              windowStyle,
              ns
            } = ctx;
            const [start, end2] = itemsToRender;
            const Container2 = resolveDynamicComponent(containerElement);
            const Inner = resolveDynamicComponent(innerElement);
            const children = [];
            if (total2 > 0) {
              for (let i2 = start; i2 <= end2; i2++) {
                children.push((_a2 = $slots.default) == null ? void 0 : _a2.call($slots, {
                  data,
                  key: i2,
                  index: i2,
                  isScrolling: useIsScrolling ? states.isScrolling : void 0,
                  style: getItemStyle(i2)
                }));
              }
            }
            const InnerNode = [
              h$1(Inner, {
                style: innerStyle,
                ref: "innerRef"
              }, !isString$1(Inner) ? {
                default: () => children
              } : children)
            ];
            const scrollbar = h$1(ScrollBar, {
              ref: "scrollbarRef",
              clientSize,
              layout: layout2,
              onScroll: onScrollbarScroll,
              ratio: clientSize * 100 / this.estimatedTotalSize,
              scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),
              total: total2
            });
            const listContainer = h$1(Container2, {
              class: [ns.e("window"), className],
              style: windowStyle,
              onScroll,
              onWheel,
              ref: "windowRef",
              key: 0
            }, !isString$1(Container2) ? { default: () => [InnerNode] } : [InnerNode]);
            return h$1("div", {
              key: 0,
              class: [ns.e("wrapper"), states.scrollbarAlwaysOn ? "always-on" : ""]
            }, [listContainer, scrollbar]);
          }
        });
      };
      const FixedSizeList = createList({
        name: "ElFixedSizeList",
        getItemOffset: ({ itemSize: itemSize2 }, index) => index * itemSize2,
        getItemSize: ({ itemSize: itemSize2 }) => itemSize2,
        getEstimatedTotalSize: ({ total: total2, itemSize: itemSize2 }) => itemSize2 * total2,
        getOffset: ({ height, total: total2, itemSize: itemSize2, layout: layout2, width }, index, alignment, scrollOffset) => {
          const size2 = isHorizontal(layout2) ? width : height;
          const lastItemOffset = Math.max(0, total2 * itemSize2 - size2);
          const maxOffset = Math.min(lastItemOffset, index * itemSize2);
          const minOffset = Math.max(0, (index + 1) * itemSize2 - size2);
          if (alignment === SMART_ALIGNMENT) {
            if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
              alignment = AUTO_ALIGNMENT;
            } else {
              alignment = CENTERED_ALIGNMENT;
            }
          }
          switch (alignment) {
            case START_ALIGNMENT: {
              return maxOffset;
            }
            case END_ALIGNMENT: {
              return minOffset;
            }
            case CENTERED_ALIGNMENT: {
              const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
              if (middleOffset < Math.ceil(size2 / 2)) {
                return 0;
              } else if (middleOffset > lastItemOffset + Math.floor(size2 / 2)) {
                return lastItemOffset;
              } else {
                return middleOffset;
              }
            }
            case AUTO_ALIGNMENT:
            default: {
              if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
                return scrollOffset;
              } else if (scrollOffset < minOffset) {
                return minOffset;
              } else {
                return maxOffset;
              }
            }
          }
        },
        getStartIndexForOffset: ({ total: total2, itemSize: itemSize2 }, offset) => Math.max(0, Math.min(total2 - 1, Math.floor(offset / itemSize2))),
        getStopIndexForStartIndex: ({ height, total: total2, itemSize: itemSize2, layout: layout2, width }, startIndex, scrollOffset) => {
          const offset = startIndex * itemSize2;
          const size2 = isHorizontal(layout2) ? width : height;
          const numVisibleItems = Math.ceil((size2 + scrollOffset - offset) / itemSize2);
          return Math.max(0, Math.min(total2 - 1, startIndex + numVisibleItems - 1));
        },
        initCache() {
          return void 0;
        },
        clearCache: true,
        validateProps() {
        }
      });
      const getItemFromCache = (props, index, listCache) => {
        const { itemSize: itemSize2 } = props;
        const { items, lastVisitedIndex } = listCache;
        if (index > lastVisitedIndex) {
          let offset = 0;
          if (lastVisitedIndex >= 0) {
            const item = items[lastVisitedIndex];
            offset = item.offset + item.size;
          }
          for (let i2 = lastVisitedIndex + 1; i2 <= index; i2++) {
            const size2 = itemSize2(i2);
            items[i2] = {
              offset,
              size: size2
            };
            offset += size2;
          }
          listCache.lastVisitedIndex = index;
        }
        return items[index];
      };
      const findItem = (props, listCache, offset) => {
        const { items, lastVisitedIndex } = listCache;
        const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;
        if (lastVisitedOffset >= offset) {
          return bs(props, listCache, 0, lastVisitedIndex, offset);
        }
        return es(props, listCache, Math.max(0, lastVisitedIndex), offset);
      };
      const bs = (props, listCache, low, high, offset) => {
        while (low <= high) {
          const mid = low + Math.floor((high - low) / 2);
          const currentOffset = getItemFromCache(props, mid, listCache).offset;
          if (currentOffset === offset) {
            return mid;
          } else if (currentOffset < offset) {
            low = mid + 1;
          } else if (currentOffset > offset) {
            high = mid - 1;
          }
        }
        return Math.max(0, low - 1);
      };
      const es = (props, listCache, index, offset) => {
        const { total: total2 } = props;
        let exponent = 1;
        while (index < total2 && getItemFromCache(props, index, listCache).offset < offset) {
          index += exponent;
          exponent *= 2;
        }
        return bs(props, listCache, Math.floor(index / 2), Math.min(index, total2 - 1), offset);
      };
      const getEstimatedTotalSize = ({ total: total2 }, { items, estimatedItemSize: estimatedItemSize2, lastVisitedIndex }) => {
        let totalSizeOfMeasuredItems = 0;
        if (lastVisitedIndex >= total2) {
          lastVisitedIndex = total2 - 1;
        }
        if (lastVisitedIndex >= 0) {
          const item = items[lastVisitedIndex];
          totalSizeOfMeasuredItems = item.offset + item.size;
        }
        const numUnmeasuredItems = total2 - lastVisitedIndex - 1;
        const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize2;
        return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
      };
      const DynamicSizeList = createList({
        name: "ElDynamicSizeList",
        getItemOffset: (props, index, listCache) => getItemFromCache(props, index, listCache).offset,
        getItemSize: (_2, index, { items }) => items[index].size,
        getEstimatedTotalSize,
        getOffset: (props, index, alignment, scrollOffset, listCache) => {
          const { height, layout: layout2, width } = props;
          const size2 = isHorizontal(layout2) ? width : height;
          const item = getItemFromCache(props, index, listCache);
          const estimatedTotalSize = getEstimatedTotalSize(props, listCache);
          const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size2, item.offset));
          const minOffset = Math.max(0, item.offset - size2 + item.size);
          if (alignment === SMART_ALIGNMENT) {
            if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
              alignment = AUTO_ALIGNMENT;
            } else {
              alignment = CENTERED_ALIGNMENT;
            }
          }
          switch (alignment) {
            case START_ALIGNMENT: {
              return maxOffset;
            }
            case END_ALIGNMENT: {
              return minOffset;
            }
            case CENTERED_ALIGNMENT: {
              return Math.round(minOffset + (maxOffset - minOffset) / 2);
            }
            case AUTO_ALIGNMENT:
            default: {
              if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
                return scrollOffset;
              } else if (scrollOffset < minOffset) {
                return minOffset;
              } else {
                return maxOffset;
              }
            }
          }
        },
        getStartIndexForOffset: (props, offset, listCache) => findItem(props, listCache, offset),
        getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {
          const { height, total: total2, layout: layout2, width } = props;
          const size2 = isHorizontal(layout2) ? width : height;
          const item = getItemFromCache(props, startIndex, listCache);
          const maxOffset = scrollOffset + size2;
          let offset = item.offset + item.size;
          let stopIndex = startIndex;
          while (stopIndex < total2 - 1 && offset < maxOffset) {
            stopIndex++;
            offset += getItemFromCache(props, stopIndex, listCache).size;
          }
          return stopIndex;
        },
        initCache({ estimatedItemSize: estimatedItemSize2 = DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {
          const cache2 = {
            items: {},
            estimatedItemSize: estimatedItemSize2,
            lastVisitedIndex: -1
          };
          cache2.clearCacheAfterIndex = (index, forceUpdate = true) => {
            var _a2, _b;
            cache2.lastVisitedIndex = Math.min(cache2.lastVisitedIndex, index - 1);
            (_a2 = instance.exposed) == null ? void 0 : _a2.getItemStyleCache(-1);
            if (forceUpdate) {
              (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();
            }
          };
          return cache2;
        },
        clearCache: false,
        validateProps: ({ itemSize: itemSize2 }) => {
        }
      });
      const _sfc_main$l = defineComponent({
        props: {
          item: {
            type: Object,
            required: true
          },
          style: Object,
          height: Number
        },
        setup() {
          const ns = useNamespace("select");
          return {
            ns
          };
        }
      });
      function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
        return _ctx.item.isTitle ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.ns.be("group", "title")),
          style: normalizeStyle([_ctx.style, { lineHeight: `${_ctx.height}px` }])
        }, toDisplayString(_ctx.item.label), 7)) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.ns.be("group", "split")),
          style: normalizeStyle(_ctx.style)
        }, [
          createBaseVNode("span", {
            class: normalizeClass(_ctx.ns.be("group", "split-dash")),
            style: normalizeStyle({ top: `${_ctx.height / 2}px` })
          }, null, 6)
        ], 6));
      }
      var GroupItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["render", _sfc_render$3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/group-item.vue"]]);
      function useOption(props, { emit: emit2 }) {
        return {
          hoverItem: () => {
            if (!props.disabled) {
              emit2("hover", props.index);
            }
          },
          selectOptionClick: () => {
            if (!props.disabled) {
              emit2("select", props.item, props.index);
            }
          }
        };
      }
      const SelectProps = {
        allowCreate: Boolean,
        autocomplete: {
          type: String,
          default: "none"
        },
        automaticDropdown: Boolean,
        clearable: Boolean,
        clearIcon: {
          type: [String, Object],
          default: circle_close_default
        },
        effect: {
          type: String,
          default: "light"
        },
        collapseTags: Boolean,
        collapseTagsTooltip: {
          type: Boolean,
          default: false
        },
        maxCollapseTags: {
          type: Number,
          default: 1
        },
        defaultFirstOption: Boolean,
        disabled: Boolean,
        estimatedOptionHeight: {
          type: Number,
          default: void 0
        },
        filterable: Boolean,
        filterMethod: Function,
        height: {
          type: Number,
          default: 170
        },
        itemHeight: {
          type: Number,
          default: 34
        },
        id: String,
        loading: Boolean,
        loadingText: String,
        label: String,
        modelValue: [Array, String, Number, Boolean, Object],
        multiple: Boolean,
        multipleLimit: {
          type: Number,
          default: 0
        },
        name: String,
        noDataText: String,
        noMatchText: String,
        remoteMethod: Function,
        reserveKeyword: {
          type: Boolean,
          default: true
        },
        options: {
          type: Array,
          required: true
        },
        placeholder: {
          type: String
        },
        teleported: useTooltipContentProps.teleported,
        persistent: {
          type: Boolean,
          default: true
        },
        popperClass: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: Object,
          default: () => ({})
        },
        remote: Boolean,
        size: {
          type: String,
          validator: isValidComponentSize
        },
        valueKey: {
          type: String,
          default: "value"
        },
        scrollbarAlwaysOn: {
          type: Boolean,
          default: false
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        placement: {
          type: definePropType(String),
          values: Ee,
          default: "bottom-start"
        }
      };
      const OptionProps = {
        data: Array,
        disabled: Boolean,
        hovering: Boolean,
        item: Object,
        index: Number,
        style: Object,
        selected: Boolean,
        created: Boolean
      };
      const _sfc_main$k = defineComponent({
        props: OptionProps,
        emits: ["select", "hover"],
        setup(props, { emit: emit2 }) {
          const ns = useNamespace("select");
          const { hoverItem, selectOptionClick } = useOption(props, { emit: emit2 });
          return {
            ns,
            hoverItem,
            selectOptionClick
          };
        }
      });
      const _hoisted_1$y = ["aria-selected"];
      function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("li", {
          "aria-selected": _ctx.selected,
          style: normalizeStyle(_ctx.style),
          class: normalizeClass([
            _ctx.ns.be("dropdown", "option-item"),
            _ctx.ns.is("selected", _ctx.selected),
            _ctx.ns.is("disabled", _ctx.disabled),
            _ctx.ns.is("created", _ctx.created),
            { hover: _ctx.hovering }
          ]),
          onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "default", {
            item: _ctx.item,
            index: _ctx.index,
            disabled: _ctx.disabled
          }, () => [
            createBaseVNode("span", null, toDisplayString(_ctx.item.label), 1)
          ])
        ], 46, _hoisted_1$y);
      }
      var OptionItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["render", _sfc_render$2], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/option-item.vue"]]);
      const selectV2InjectionKey = Symbol("ElSelectV2Injection");
      var ElSelectMenu = defineComponent({
        name: "ElSelectDropdown",
        props: {
          data: {
            type: Array,
            required: true
          },
          hoveringIndex: Number,
          width: Number
        },
        setup(props, {
          slots,
          expose
        }) {
          const select = inject(selectV2InjectionKey);
          const ns = useNamespace("select");
          const cachedHeights = ref([]);
          const listRef = ref();
          const size2 = computed(() => props.data.length);
          watch(() => size2.value, () => {
            var _a2, _b;
            (_b = (_a2 = select.popper.value).updatePopper) == null ? void 0 : _b.call(_a2);
          });
          const isSized = computed(() => isUndefined(select.props.estimatedOptionHeight));
          const listProps = computed(() => {
            if (isSized.value) {
              return {
                itemSize: select.props.itemHeight
              };
            }
            return {
              estimatedSize: select.props.estimatedOptionHeight,
              itemSize: (idx) => cachedHeights.value[idx]
            };
          });
          const contains = (arr = [], target) => {
            const {
              props: {
                valueKey
              }
            } = select;
            if (!isObject$1(target)) {
              return arr.includes(target);
            }
            return arr && arr.some((item) => {
              return get(item, valueKey) === get(target, valueKey);
            });
          };
          const isEqual2 = (selected, target) => {
            if (!isObject$1(target)) {
              return selected === target;
            } else {
              const {
                valueKey
              } = select.props;
              return get(selected, valueKey) === get(target, valueKey);
            }
          };
          const isItemSelected = (modelValue, target) => {
            const {
              valueKey
            } = select.props;
            if (select.props.multiple) {
              return contains(modelValue, get(target, valueKey));
            }
            return isEqual2(modelValue, get(target, valueKey));
          };
          const isItemDisabled = (modelValue, selected) => {
            const {
              disabled,
              multiple,
              multipleLimit
            } = select.props;
            return disabled || !selected && (multiple ? multipleLimit > 0 && modelValue.length >= multipleLimit : false);
          };
          const isItemHovering = (target) => props.hoveringIndex === target;
          const scrollToItem = (index) => {
            const list = listRef.value;
            if (list) {
              list.scrollToItem(index);
            }
          };
          const resetScrollTop = () => {
            const list = listRef.value;
            if (list) {
              list.resetScrollTop();
            }
          };
          expose({
            listRef,
            isSized,
            isItemDisabled,
            isItemHovering,
            isItemSelected,
            scrollToItem,
            resetScrollTop
          });
          const Item = (itemProps) => {
            const {
              index,
              data,
              style
            } = itemProps;
            const sized = unref(isSized);
            const {
              itemSize: itemSize2,
              estimatedSize
            } = unref(listProps);
            const {
              modelValue
            } = select.props;
            const {
              onSelect,
              onHover
            } = select;
            const item = data[index];
            if (item.type === "Group") {
              return createVNode(GroupItem, {
                "item": item,
                "style": style,
                "height": sized ? itemSize2 : estimatedSize
              }, null);
            }
            const isSelected = isItemSelected(modelValue, item);
            const isDisabled = isItemDisabled(modelValue, isSelected);
            const isHovering = isItemHovering(index);
            return createVNode(OptionItem, mergeProps(itemProps, {
              "selected": isSelected,
              "disabled": item.disabled || isDisabled,
              "created": !!item.created,
              "hovering": isHovering,
              "item": item,
              "onSelect": onSelect,
              "onHover": onHover
            }), {
              default: (props2) => {
                var _a2;
                return ((_a2 = slots.default) == null ? void 0 : _a2.call(slots, props2)) || createVNode("span", null, [item.label]);
              }
            });
          };
          const {
            onKeyboardNavigate,
            onKeyboardSelect
          } = select;
          const onForward = () => {
            onKeyboardNavigate("forward");
          };
          const onBackward = () => {
            onKeyboardNavigate("backward");
          };
          const onEscOrTab = () => {
            select.expanded = false;
          };
          const onKeydown = (e2) => {
            const {
              code
            } = e2;
            const {
              tab,
              esc,
              down: down2,
              up: up2,
              enter
            } = EVENT_CODE;
            if (code !== tab) {
              e2.preventDefault();
              e2.stopPropagation();
            }
            switch (code) {
              case tab:
              case esc: {
                onEscOrTab();
                break;
              }
              case down2: {
                onForward();
                break;
              }
              case up2: {
                onBackward();
                break;
              }
              case enter: {
                onKeyboardSelect();
                break;
              }
            }
          };
          return () => {
            var _a2;
            const {
              data,
              width
            } = props;
            const {
              height,
              multiple,
              scrollbarAlwaysOn
            } = select.props;
            if (data.length === 0) {
              return createVNode("div", {
                "class": ns.b("dropdown"),
                "style": {
                  width: `${width}px`
                }
              }, [(_a2 = slots.empty) == null ? void 0 : _a2.call(slots)]);
            }
            const List = unref(isSized) ? FixedSizeList : DynamicSizeList;
            return createVNode("div", {
              "class": [ns.b("dropdown"), ns.is("multiple", multiple)]
            }, [createVNode(List, mergeProps({
              "ref": listRef
            }, unref(listProps), {
              "className": ns.be("dropdown", "list"),
              "scrollbarAlwaysOn": scrollbarAlwaysOn,
              "data": data,
              "height": height,
              "width": width,
              "total": data.length,
              "onKeydown": onKeydown
            }), {
              default: (props2) => createVNode(Item, props2, null)
            })]);
          };
        }
      });
      function useAllowCreate(props, states) {
        const createOptionCount = ref(0);
        const cachedSelectedOption = ref(null);
        const enableAllowCreateMode = computed(() => {
          return props.allowCreate && props.filterable;
        });
        function hasExistingOption(query) {
          const hasValue = (option) => option.value === query;
          return props.options && props.options.some(hasValue) || states.createdOptions.some(hasValue);
        }
        function selectNewOption(option) {
          if (!enableAllowCreateMode.value) {
            return;
          }
          if (props.multiple && option.created) {
            createOptionCount.value++;
          } else {
            cachedSelectedOption.value = option;
          }
        }
        function createNewOption(query) {
          if (enableAllowCreateMode.value) {
            if (query && query.length > 0 && !hasExistingOption(query)) {
              const newOption = {
                value: query,
                label: query,
                created: true,
                disabled: false
              };
              if (states.createdOptions.length >= createOptionCount.value) {
                states.createdOptions[createOptionCount.value] = newOption;
              } else {
                states.createdOptions.push(newOption);
              }
            } else {
              if (props.multiple) {
                states.createdOptions.length = createOptionCount.value;
              } else {
                const selectedOption = cachedSelectedOption.value;
                states.createdOptions.length = 0;
                if (selectedOption && selectedOption.created) {
                  states.createdOptions.push(selectedOption);
                }
              }
            }
          }
        }
        function removeNewOption(option) {
          if (!enableAllowCreateMode.value || !option || !option.created || option.created && props.reserveKeyword && states.inputValue === option.label) {
            return;
          }
          const idx = states.createdOptions.findIndex((it2) => it2.value === option.value);
          if (~idx) {
            states.createdOptions.splice(idx, 1);
            createOptionCount.value--;
          }
        }
        function clearAllNewOption() {
          if (enableAllowCreateMode.value) {
            states.createdOptions.length = 0;
            createOptionCount.value = 0;
          }
        }
        return {
          createNewOption,
          removeNewOption,
          selectNewOption,
          clearAllNewOption
        };
      }
      const flattenOptions = (options) => {
        const flattened = [];
        options.forEach((option) => {
          if (isArray$2(option.options)) {
            flattened.push({
              label: option.label,
              isTitle: true,
              type: "Group"
            });
            option.options.forEach((o2) => {
              flattened.push(o2);
            });
            flattened.push({
              type: "Group"
            });
          } else {
            flattened.push(option);
          }
        });
        return flattened;
      };
      function useInput(handleInput) {
        const isComposing = ref(false);
        const handleCompositionStart = () => {
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          const text = event.target.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          if (isComposing.value) {
            isComposing.value = false;
            if (isFunction$1(handleInput)) {
              handleInput(event);
            }
          }
        };
        return {
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        };
      }
      const DEFAULT_INPUT_PLACEHOLDER = "";
      const MINIMUM_INPUT_WIDTH = 11;
      const TAG_BASE_WIDTH = {
        larget: 51,
        default: 42,
        small: 33
      };
      const useSelect = (props, emit2) => {
        const { t: t2 } = useLocale();
        const nsSelectV2 = useNamespace("select-v2");
        const nsInput = useNamespace("input");
        const { form: elForm2, formItem: elFormItem2 } = useFormItem();
        const states = reactive({
          inputValue: DEFAULT_INPUT_PLACEHOLDER,
          displayInputValue: DEFAULT_INPUT_PLACEHOLDER,
          calculatedWidth: 0,
          cachedPlaceholder: "",
          cachedOptions: [],
          createdOptions: [],
          createdLabel: "",
          createdSelected: false,
          currentPlaceholder: "",
          hoveringIndex: -1,
          comboBoxHovering: false,
          isOnComposition: false,
          isSilentBlur: false,
          isComposing: false,
          inputLength: 20,
          selectWidth: 200,
          initialInputHeight: 0,
          previousQuery: null,
          previousValue: void 0,
          query: "",
          selectedLabel: "",
          softFocus: false,
          tagInMultiLine: false
        });
        const selectedIndex = ref(-1);
        const popperSize = ref(-1);
        const controlRef = ref(null);
        const inputRef = ref(null);
        const menuRef = ref(null);
        const popper = ref(null);
        const selectRef = ref(null);
        const selectionRef = ref(null);
        const calculatorRef = ref(null);
        const expanded = ref(false);
        const selectDisabled = computed(() => props.disabled || (elForm2 == null ? void 0 : elForm2.disabled));
        const popupHeight = computed(() => {
          const totalHeight = filteredOptions.value.length * 34;
          return totalHeight > props.height ? props.height : totalHeight;
        });
        const hasModelValue = computed(() => {
          return !isNil(props.modelValue);
        });
        const showClearBtn = computed(() => {
          const hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : hasModelValue.value;
          const criteria = props.clearable && !selectDisabled.value && states.comboBoxHovering && hasValue;
          return criteria;
        });
        const iconComponent = computed(() => props.remote && props.filterable ? "" : arrow_up_default);
        const iconReverse = computed(() => iconComponent.value && nsSelectV2.is("reverse", expanded.value));
        const validateState = computed(() => (elFormItem2 == null ? void 0 : elFormItem2.validateState) || "");
        const validateIcon = computed(() => ValidateComponentsMap[validateState.value]);
        const debounce$1 = computed(() => props.remote ? 300 : 0);
        const emptyText = computed(() => {
          const options = filteredOptions.value;
          if (props.loading) {
            return props.loadingText || t2("el.select.loading");
          } else {
            if (props.remote && states.inputValue === "" && options.length === 0)
              return false;
            if (props.filterable && states.inputValue && options.length > 0) {
              return props.noMatchText || t2("el.select.noMatch");
            }
            if (options.length === 0) {
              return props.noDataText || t2("el.select.noData");
            }
          }
          return null;
        });
        const filteredOptions = computed(() => {
          const isValidOption = (o2) => {
            const query = states.inputValue;
            const regexp2 = new RegExp(escapeStringRegexp(query), "i");
            const containsQueryString = query ? regexp2.test(o2.label || "") : true;
            return containsQueryString;
          };
          if (props.loading) {
            return [];
          }
          return flattenOptions(props.options.concat(states.createdOptions).map((v2) => {
            if (isArray$2(v2.options)) {
              const filtered = v2.options.filter(isValidOption);
              if (filtered.length > 0) {
                return {
                  ...v2,
                  options: filtered
                };
              }
            } else {
              if (props.remote || isValidOption(v2)) {
                return v2;
              }
            }
            return null;
          }).filter((v2) => v2 !== null));
        });
        const filteredOptionsValueMap = computed(() => {
          const valueMap = /* @__PURE__ */ new Map();
          filteredOptions.value.forEach((option, index) => {
            valueMap.set(getValueKey(option), { option, index });
          });
          return valueMap;
        });
        const optionsAllDisabled = computed(() => filteredOptions.value.every((option) => option.disabled));
        const selectSize = useFormSize();
        const collapseTagSize = computed(() => selectSize.value === "small" ? "small" : "default");
        const tagMaxWidth = computed(() => {
          const select = selectionRef.value;
          const size2 = collapseTagSize.value || "default";
          const paddingLeft = select ? Number.parseInt(getComputedStyle(select).paddingLeft) : 0;
          const paddingRight = select ? Number.parseInt(getComputedStyle(select).paddingRight) : 0;
          return states.selectWidth - paddingRight - paddingLeft - TAG_BASE_WIDTH[size2];
        });
        const calculatePopperSize = () => {
          var _a2;
          popperSize.value = ((_a2 = selectRef.value) == null ? void 0 : _a2.offsetWidth) || 200;
        };
        const inputWrapperStyle = computed(() => {
          return {
            width: `${states.calculatedWidth === 0 ? MINIMUM_INPUT_WIDTH : Math.ceil(states.calculatedWidth) + MINIMUM_INPUT_WIDTH}px`
          };
        });
        const shouldShowPlaceholder = computed(() => {
          if (isArray$2(props.modelValue)) {
            return props.modelValue.length === 0 && !states.displayInputValue;
          }
          return props.filterable ? states.displayInputValue.length === 0 : true;
        });
        const currentPlaceholder = computed(() => {
          const _placeholder = props.placeholder || t2("el.select.placeholder");
          return props.multiple || isNil(props.modelValue) ? _placeholder : states.selectedLabel;
        });
        const popperRef = computed(() => {
          var _a2, _b;
          return (_b = (_a2 = popper.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
        });
        const indexRef = computed(() => {
          if (props.multiple) {
            const len = props.modelValue.length;
            if (props.modelValue.length > 0 && filteredOptionsValueMap.value.has(props.modelValue[len - 1])) {
              const { index } = filteredOptionsValueMap.value.get(props.modelValue[len - 1]);
              return index;
            }
          } else {
            if (props.modelValue && filteredOptionsValueMap.value.has(props.modelValue)) {
              const { index } = filteredOptionsValueMap.value.get(props.modelValue);
              return index;
            }
          }
          return -1;
        });
        const dropdownMenuVisible = computed({
          get() {
            return expanded.value && emptyText.value !== false;
          },
          set(val) {
            expanded.value = val;
          }
        });
        const showTagList = computed(() => states.cachedOptions.slice(0, props.maxCollapseTags));
        const collapseTagList = computed(() => states.cachedOptions.slice(props.maxCollapseTags));
        const {
          createNewOption,
          removeNewOption,
          selectNewOption,
          clearAllNewOption
        } = useAllowCreate(props, states);
        const {
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        } = useInput((e2) => onInput(e2));
        const focusAndUpdatePopup = () => {
          var _a2, _b, _c;
          (_b = (_a2 = inputRef.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          (_c = popper.value) == null ? void 0 : _c.updatePopper();
        };
        const toggleMenu = () => {
          if (props.automaticDropdown)
            return;
          if (!selectDisabled.value) {
            if (states.isComposing)
              states.softFocus = true;
            return nextTick(() => {
              var _a2, _b;
              expanded.value = !expanded.value;
              (_b = (_a2 = inputRef.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
            });
          }
        };
        const onInputChange = () => {
          if (props.filterable && states.inputValue !== states.selectedLabel) {
            states.query = states.selectedLabel;
          }
          handleQueryChange(states.inputValue);
          return nextTick(() => {
            createNewOption(states.inputValue);
          });
        };
        const debouncedOnInputChange = debounce(onInputChange, debounce$1.value);
        const handleQueryChange = (val) => {
          if (states.previousQuery === val) {
            return;
          }
          states.previousQuery = val;
          if (props.filterable && isFunction$1(props.filterMethod)) {
            props.filterMethod(val);
          } else if (props.filterable && props.remote && isFunction$1(props.remoteMethod)) {
            props.remoteMethod(val);
          }
        };
        const emitChange = (val) => {
          if (!isEqual$1(props.modelValue, val)) {
            emit2(CHANGE_EVENT, val);
          }
        };
        const update = (val) => {
          emit2(UPDATE_MODEL_EVENT, val);
          emitChange(val);
          states.previousValue = val == null ? void 0 : val.toString();
        };
        const getValueIndex = (arr = [], value) => {
          if (!isObject$1(value)) {
            return arr.indexOf(value);
          }
          const valueKey = props.valueKey;
          let index = -1;
          arr.some((item, i2) => {
            if (get(item, valueKey) === get(value, valueKey)) {
              index = i2;
              return true;
            }
            return false;
          });
          return index;
        };
        const getValueKey = (item) => {
          return isObject$1(item) ? get(item, props.valueKey) : item;
        };
        const getLabel = (item) => {
          return isObject$1(item) ? item.label : item;
        };
        const resetInputHeight = () => {
          return nextTick(() => {
            var _a2, _b;
            if (!inputRef.value)
              return;
            const selection = selectionRef.value;
            selectRef.value.height = selection.offsetHeight;
            if (expanded.value && emptyText.value !== false) {
              (_b = (_a2 = popper.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            }
          });
        };
        const handleResize = () => {
          var _a2, _b;
          resetInputWidth();
          calculatePopperSize();
          (_b = (_a2 = popper.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          if (props.multiple) {
            return resetInputHeight();
          }
        };
        const resetInputWidth = () => {
          const select = selectionRef.value;
          if (select) {
            states.selectWidth = select.getBoundingClientRect().width;
          }
        };
        const onSelect = (option, idx, byClick = true) => {
          var _a2, _b;
          if (props.multiple) {
            let selectedOptions = props.modelValue.slice();
            const index = getValueIndex(selectedOptions, getValueKey(option));
            if (index > -1) {
              selectedOptions = [
                ...selectedOptions.slice(0, index),
                ...selectedOptions.slice(index + 1)
              ];
              states.cachedOptions.splice(index, 1);
              removeNewOption(option);
            } else if (props.multipleLimit <= 0 || selectedOptions.length < props.multipleLimit) {
              selectedOptions = [...selectedOptions, getValueKey(option)];
              states.cachedOptions.push(option);
              selectNewOption(option);
              updateHoveringIndex(idx);
            }
            update(selectedOptions);
            if (option.created) {
              states.query = "";
              handleQueryChange("");
              states.inputLength = 20;
            }
            if (props.filterable && !props.reserveKeyword) {
              (_b = (_a2 = inputRef.value).focus) == null ? void 0 : _b.call(_a2);
              onUpdateInputValue("");
            }
            if (props.filterable) {
              states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
            }
            resetInputHeight();
            setSoftFocus();
          } else {
            selectedIndex.value = idx;
            states.selectedLabel = option.label;
            update(getValueKey(option));
            expanded.value = false;
            states.isComposing = false;
            states.isSilentBlur = byClick;
            selectNewOption(option);
            if (!option.created) {
              clearAllNewOption();
            }
            updateHoveringIndex(idx);
          }
        };
        const deleteTag = (event, tag) => {
          const { valueKey } = props;
          const index = props.modelValue.indexOf(get(tag, valueKey));
          if (index > -1 && !selectDisabled.value) {
            const value = [
              ...props.modelValue.slice(0, index),
              ...props.modelValue.slice(index + 1)
            ];
            states.cachedOptions.splice(index, 1);
            update(value);
            emit2("remove-tag", get(tag, valueKey));
            states.softFocus = true;
            removeNewOption(tag);
            return nextTick(focusAndUpdatePopup);
          }
          event.stopPropagation();
        };
        const handleFocus = (event) => {
          const focused = states.isComposing;
          states.isComposing = true;
          if (!states.softFocus) {
            if (!focused)
              emit2("focus", event);
          } else {
            states.softFocus = false;
          }
        };
        const handleBlur = (event) => {
          states.softFocus = false;
          return nextTick(() => {
            var _a2, _b;
            (_b = (_a2 = inputRef.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
            if (calculatorRef.value) {
              states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
            }
            if (states.isSilentBlur) {
              states.isSilentBlur = false;
            } else {
              if (states.isComposing) {
                emit2("blur", event);
              }
            }
            states.isComposing = false;
          });
        };
        const handleEsc = () => {
          if (states.displayInputValue.length > 0) {
            onUpdateInputValue("");
          } else {
            expanded.value = false;
          }
        };
        const handleDel = (e2) => {
          if (states.displayInputValue.length === 0) {
            e2.preventDefault();
            const selected = props.modelValue.slice();
            selected.pop();
            removeNewOption(states.cachedOptions.pop());
            update(selected);
          }
        };
        const handleClear = () => {
          let emptyValue;
          if (isArray$2(props.modelValue)) {
            emptyValue = [];
          } else {
            emptyValue = void 0;
          }
          states.softFocus = true;
          if (props.multiple) {
            states.cachedOptions = [];
          } else {
            states.selectedLabel = "";
          }
          expanded.value = false;
          update(emptyValue);
          emit2("clear");
          clearAllNewOption();
          return nextTick(focusAndUpdatePopup);
        };
        const onUpdateInputValue = (val) => {
          states.displayInputValue = val;
          states.inputValue = val;
        };
        const onKeyboardNavigate = (direction2, hoveringIndex = void 0) => {
          const options = filteredOptions.value;
          if (!["forward", "backward"].includes(direction2) || selectDisabled.value || options.length <= 0 || optionsAllDisabled.value) {
            return;
          }
          if (!expanded.value) {
            return toggleMenu();
          }
          if (hoveringIndex === void 0) {
            hoveringIndex = states.hoveringIndex;
          }
          let newIndex = -1;
          if (direction2 === "forward") {
            newIndex = hoveringIndex + 1;
            if (newIndex >= options.length) {
              newIndex = 0;
            }
          } else if (direction2 === "backward") {
            newIndex = hoveringIndex - 1;
            if (newIndex < 0 || newIndex >= options.length) {
              newIndex = options.length - 1;
            }
          }
          const option = options[newIndex];
          if (option.disabled || option.type === "Group") {
            return onKeyboardNavigate(direction2, newIndex);
          } else {
            updateHoveringIndex(newIndex);
            scrollToItem(newIndex);
          }
        };
        const onKeyboardSelect = () => {
          if (!expanded.value) {
            return toggleMenu();
          } else if (~states.hoveringIndex && filteredOptions.value[states.hoveringIndex]) {
            onSelect(filteredOptions.value[states.hoveringIndex], states.hoveringIndex, false);
          }
        };
        const updateHoveringIndex = (idx) => {
          states.hoveringIndex = idx;
        };
        const resetHoveringIndex = () => {
          states.hoveringIndex = -1;
        };
        const setSoftFocus = () => {
          var _a2;
          const _input = inputRef.value;
          if (_input) {
            (_a2 = _input.focus) == null ? void 0 : _a2.call(_input);
          }
        };
        const onInput = (event) => {
          const value = event.target.value;
          onUpdateInputValue(value);
          if (states.displayInputValue.length > 0 && !expanded.value) {
            expanded.value = true;
          }
          states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
          if (props.multiple) {
            resetInputHeight();
          }
          if (props.remote) {
            debouncedOnInputChange();
          } else {
            return onInputChange();
          }
        };
        const handleClickOutside = () => {
          expanded.value = false;
          return handleBlur();
        };
        const handleMenuEnter = () => {
          states.inputValue = states.displayInputValue;
          return nextTick(() => {
            if (~indexRef.value) {
              updateHoveringIndex(indexRef.value);
              scrollToItem(states.hoveringIndex);
            }
          });
        };
        const scrollToItem = (index) => {
          menuRef.value.scrollToItem(index);
        };
        const initStates = () => {
          resetHoveringIndex();
          if (props.multiple) {
            if (props.modelValue.length > 0) {
              let initHovering = false;
              states.cachedOptions.length = 0;
              states.previousValue = props.modelValue.toString();
              for (const value of props.modelValue) {
                if (filteredOptionsValueMap.value.has(value)) {
                  const { index, option } = filteredOptionsValueMap.value.get(value);
                  states.cachedOptions.push(option);
                  if (!initHovering) {
                    updateHoveringIndex(index);
                  }
                  initHovering = true;
                }
              }
            } else {
              states.cachedOptions = [];
              states.previousValue = void 0;
            }
          } else {
            if (hasModelValue.value) {
              states.previousValue = props.modelValue;
              const options = filteredOptions.value;
              const selectedItemIndex = options.findIndex((option) => getValueKey(option) === getValueKey(props.modelValue));
              if (~selectedItemIndex) {
                states.selectedLabel = options[selectedItemIndex].label;
                updateHoveringIndex(selectedItemIndex);
              } else {
                states.selectedLabel = `${props.modelValue}`;
              }
            } else {
              states.selectedLabel = "";
              states.previousValue = void 0;
            }
          }
          clearAllNewOption();
          calculatePopperSize();
        };
        watch(expanded, (val) => {
          var _a2, _b;
          emit2("visible-change", val);
          if (val) {
            (_b = (_a2 = popper.value).update) == null ? void 0 : _b.call(_a2);
          } else {
            states.displayInputValue = "";
            states.previousQuery = null;
            createNewOption("");
          }
        });
        watch(() => props.modelValue, (val, oldVal) => {
          var _a2;
          if (!val || val.toString() !== states.previousValue) {
            initStates();
          }
          if (!isEqual$1(val, oldVal) && props.validateEvent) {
            (_a2 = elFormItem2 == null ? void 0 : elFormItem2.validate) == null ? void 0 : _a2.call(elFormItem2, "change").catch((err) => debugWarn());
          }
        }, {
          deep: true
        });
        watch(() => props.options, () => {
          const input = inputRef.value;
          if (!input || input && document.activeElement !== input) {
            initStates();
          }
        }, {
          deep: true
        });
        watch(filteredOptions, () => {
          return nextTick(menuRef.value.resetScrollTop);
        });
        watch(() => dropdownMenuVisible.value, (val) => {
          if (!val) {
            resetHoveringIndex();
          }
        });
        onMounted(() => {
          initStates();
        });
        useResizeObserver(selectRef, handleResize);
        return {
          collapseTagSize,
          currentPlaceholder,
          expanded,
          emptyText,
          popupHeight,
          debounce: debounce$1,
          filteredOptions,
          iconComponent,
          iconReverse,
          inputWrapperStyle,
          popperSize,
          dropdownMenuVisible,
          hasModelValue,
          shouldShowPlaceholder,
          selectDisabled,
          selectSize,
          showClearBtn,
          states,
          tagMaxWidth,
          nsSelectV2,
          nsInput,
          calculatorRef,
          controlRef,
          inputRef,
          menuRef,
          popper,
          selectRef,
          selectionRef,
          popperRef,
          validateState,
          validateIcon,
          showTagList,
          collapseTagList,
          debouncedOnInputChange,
          deleteTag,
          getLabel,
          getValueKey,
          handleBlur,
          handleClear,
          handleClickOutside,
          handleDel,
          handleEsc,
          handleFocus,
          handleMenuEnter,
          handleResize,
          toggleMenu,
          scrollTo: scrollToItem,
          onInput,
          onKeyboardNavigate,
          onKeyboardSelect,
          onSelect,
          onHover: updateHoveringIndex,
          onUpdateInputValue,
          handleCompositionStart,
          handleCompositionEnd,
          handleCompositionUpdate
        };
      };
      const _sfc_main$j = defineComponent({
        name: "ElSelectV2",
        components: {
          ElSelectMenu,
          ElTag,
          ElTooltip,
          ElIcon
        },
        directives: { ClickOutside, ModelText: vModelText },
        props: SelectProps,
        emits: [
          UPDATE_MODEL_EVENT,
          CHANGE_EVENT,
          "remove-tag",
          "clear",
          "visible-change",
          "focus",
          "blur"
        ],
        setup(props, { emit: emit2 }) {
          const modelValue = computed(() => {
            const { modelValue: rawModelValue, multiple } = props;
            const fallback = multiple ? [] : void 0;
            if (isArray$2(rawModelValue)) {
              return multiple ? rawModelValue : fallback;
            }
            return multiple ? fallback : rawModelValue;
          });
          const API = useSelect(reactive({
            ...toRefs(props),
            modelValue
          }), emit2);
          provide(selectV2InjectionKey, {
            props: reactive({
              ...toRefs(props),
              height: API.popupHeight,
              modelValue
            }),
            popper: API.popper,
            onSelect: API.onSelect,
            onHover: API.onHover,
            onKeyboardNavigate: API.onKeyboardNavigate,
            onKeyboardSelect: API.onKeyboardSelect
          });
          return {
            ...API,
            modelValue
          };
        }
      });
      const _hoisted_1$x = { key: 0 };
      const _hoisted_2$s = ["id", "autocomplete", "aria-expanded", "aria-labelledby", "disabled", "readonly", "name", "unselectable"];
      const _hoisted_3$o = ["textContent"];
      const _hoisted_4$8 = ["id", "aria-labelledby", "aria-expanded", "autocomplete", "disabled", "name", "readonly", "unselectable"];
      const _hoisted_5$4 = ["textContent"];
      function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_tag = resolveComponent("el-tag");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_select_menu = resolveComponent("el-select-menu");
        const _directive_model_text = resolveDirective("model-text");
        const _directive_click_outside = resolveDirective("click-outside");
        return withDirectives((openBlock(), createElementBlock("div", {
          ref: "selectRef",
          class: normalizeClass([_ctx.nsSelectV2.b(), _ctx.nsSelectV2.m(_ctx.selectSize)]),
          onClick: _cache[24] || (_cache[24] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"])),
          onMouseenter: _cache[25] || (_cache[25] = ($event) => _ctx.states.comboBoxHovering = true),
          onMouseleave: _cache[26] || (_cache[26] = ($event) => _ctx.states.comboBoxHovering = false)
        }, [
          createVNode(_component_el_tooltip, {
            ref: "popper",
            visible: _ctx.dropdownMenuVisible,
            teleported: _ctx.teleported,
            "popper-class": [_ctx.nsSelectV2.e("popper"), _ctx.popperClass],
            "gpu-acceleration": false,
            "stop-popper-mouse-event": false,
            "popper-options": _ctx.popperOptions,
            "fallback-placements": ["bottom-start", "top-start", "right", "left"],
            effect: _ctx.effect,
            placement: _ctx.placement,
            pure: "",
            transition: `${_ctx.nsSelectV2.namespace.value}-zoom-in-top`,
            trigger: "click",
            persistent: _ctx.persistent,
            onBeforeShow: _ctx.handleMenuEnter,
            onHide: _cache[23] || (_cache[23] = ($event) => _ctx.states.inputValue = _ctx.states.displayInputValue)
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                ref: "selectionRef",
                class: normalizeClass([
                  _ctx.nsSelectV2.e("wrapper"),
                  _ctx.nsSelectV2.is("focused", _ctx.states.isComposing || _ctx.expanded),
                  _ctx.nsSelectV2.is("hovering", _ctx.states.comboBoxHovering),
                  _ctx.nsSelectV2.is("filterable", _ctx.filterable),
                  _ctx.nsSelectV2.is("disabled", _ctx.selectDisabled)
                ])
              }, [
                _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", _hoisted_1$x, [
                  renderSlot(_ctx.$slots, "prefix")
                ])) : createCommentVNode("v-if", true),
                _ctx.multiple ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(_ctx.nsSelectV2.e("selection"))
                }, [
                  _ctx.collapseTags && _ctx.modelValue.length > 0 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showTagList, (item) => {
                      return openBlock(), createElementBlock("div", {
                        key: _ctx.getValueKey(item),
                        class: normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                      }, [
                        createVNode(_component_el_tag, {
                          closable: !_ctx.selectDisabled && !(item == null ? void 0 : item.disable),
                          size: _ctx.collapseTagSize,
                          type: "info",
                          "disable-transitions": "",
                          onClose: ($event) => _ctx.deleteTag($event, item)
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("span", {
                              class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                              style: normalizeStyle({
                                maxWidth: `${_ctx.tagMaxWidth}px`
                              })
                            }, toDisplayString(item == null ? void 0 : item.label), 7)
                          ]),
                          _: 2
                        }, 1032, ["closable", "size", "onClose"])
                      ], 2);
                    }), 128)),
                    createBaseVNode("div", {
                      class: normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                    }, [
                      _ctx.modelValue.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tag, {
                        key: 0,
                        closable: false,
                        size: _ctx.collapseTagSize,
                        type: "info",
                        "disable-transitions": ""
                      }, {
                        default: withCtx(() => [
                          _ctx.collapseTagsTooltip ? (openBlock(), createBlock(_component_el_tooltip, {
                            key: 0,
                            disabled: _ctx.dropdownMenuVisible,
                            "fallback-placements": ["bottom", "top", "right", "left"],
                            effect: _ctx.effect,
                            placement: "bottom",
                            teleported: false
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", {
                                class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                                style: normalizeStyle({
                                  maxWidth: `${_ctx.tagMaxWidth}px`
                                })
                              }, "+ " + toDisplayString(_ctx.modelValue.length - _ctx.maxCollapseTags), 7)
                            ]),
                            content: withCtx(() => [
                              createBaseVNode("div", {
                                class: normalizeClass(_ctx.nsSelectV2.e("selection"))
                              }, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapseTagList, (selected) => {
                                  return openBlock(), createElementBlock("div", {
                                    key: _ctx.getValueKey(selected),
                                    class: normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                                  }, [
                                    createVNode(_component_el_tag, {
                                      closable: !_ctx.selectDisabled && !selected.disabled,
                                      size: _ctx.collapseTagSize,
                                      class: "in-tooltip",
                                      type: "info",
                                      "disable-transitions": "",
                                      onClose: ($event) => _ctx.deleteTag($event, selected)
                                    }, {
                                      default: withCtx(() => [
                                        createBaseVNode("span", {
                                          class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                                          style: normalizeStyle({
                                            maxWidth: `${_ctx.tagMaxWidth}px`
                                          })
                                        }, toDisplayString(_ctx.getLabel(selected)), 7)
                                      ]),
                                      _: 2
                                    }, 1032, ["closable", "size", "onClose"])
                                  ], 2);
                                }), 128))
                              ], 2)
                            ]),
                            _: 1
                          }, 8, ["disabled", "effect"])) : (openBlock(), createElementBlock("span", {
                            key: 1,
                            class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                            style: normalizeStyle({
                              maxWidth: `${_ctx.tagMaxWidth}px`
                            })
                          }, "+ " + toDisplayString(_ctx.modelValue.length - _ctx.maxCollapseTags), 7))
                        ]),
                        _: 1
                      }, 8, ["size"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 64)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.states.cachedOptions, (selected) => {
                    return openBlock(), createElementBlock("div", {
                      key: _ctx.getValueKey(selected),
                      class: normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                    }, [
                      createVNode(_component_el_tag, {
                        closable: !_ctx.selectDisabled && !selected.disabled,
                        size: _ctx.collapseTagSize,
                        type: "info",
                        "disable-transitions": "",
                        onClose: ($event) => _ctx.deleteTag($event, selected)
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("span", {
                            class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                            style: normalizeStyle({
                              maxWidth: `${_ctx.tagMaxWidth}px`
                            })
                          }, toDisplayString(_ctx.getLabel(selected)), 7)
                        ]),
                        _: 2
                      }, 1032, ["closable", "size", "onClose"])
                    ], 2);
                  }), 128)),
                  createBaseVNode("div", {
                    class: normalizeClass([
                      _ctx.nsSelectV2.e("selected-item"),
                      _ctx.nsSelectV2.e("input-wrapper")
                    ]),
                    style: normalizeStyle(_ctx.inputWrapperStyle)
                  }, [
                    withDirectives(createBaseVNode("input", {
                      id: _ctx.id,
                      ref: "inputRef",
                      autocomplete: _ctx.autocomplete,
                      "aria-autocomplete": "list",
                      "aria-haspopup": "listbox",
                      autocapitalize: "off",
                      "aria-expanded": _ctx.expanded,
                      "aria-labelledby": _ctx.label,
                      class: normalizeClass([
                        _ctx.nsSelectV2.is(_ctx.selectSize),
                        _ctx.nsSelectV2.e("combobox-input")
                      ]),
                      disabled: _ctx.disabled,
                      role: "combobox",
                      readonly: !_ctx.filterable,
                      spellcheck: "false",
                      type: "text",
                      name: _ctx.name,
                      unselectable: _ctx.expanded ? "on" : void 0,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = (...args) => _ctx.onUpdateInputValue && _ctx.onUpdateInputValue(...args)),
                      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                      onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                      onInput: _cache[3] || (_cache[3] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                      onCompositionstart: _cache[4] || (_cache[4] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                      onCompositionupdate: _cache[5] || (_cache[5] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                      onCompositionend: _cache[6] || (_cache[6] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                      onKeydown: [
                        _cache[7] || (_cache[7] = withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                        _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                        _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => _ctx.onKeyboardSelect && _ctx.onKeyboardSelect(...args), ["stop", "prevent"]), ["enter"])),
                        _cache[10] || (_cache[10] = withKeys(withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"])),
                        _cache[11] || (_cache[11] = withKeys(withModifiers((...args) => _ctx.handleDel && _ctx.handleDel(...args), ["stop"]), ["delete"]))
                      ]
                    }, null, 42, _hoisted_2$s), [
                      [_directive_model_text, _ctx.states.displayInputValue]
                    ]),
                    _ctx.filterable ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      ref: "calculatorRef",
                      "aria-hidden": "true",
                      class: normalizeClass(_ctx.nsSelectV2.e("input-calculator")),
                      textContent: toDisplayString(_ctx.states.displayInputValue)
                    }, null, 10, _hoisted_3$o)) : createCommentVNode("v-if", true)
                  ], 6)
                ], 2)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                  createBaseVNode("div", {
                    class: normalizeClass([
                      _ctx.nsSelectV2.e("selected-item"),
                      _ctx.nsSelectV2.e("input-wrapper")
                    ])
                  }, [
                    withDirectives(createBaseVNode("input", {
                      id: _ctx.id,
                      ref: "inputRef",
                      "aria-autocomplete": "list",
                      "aria-haspopup": "listbox",
                      "aria-labelledby": _ctx.label,
                      "aria-expanded": _ctx.expanded,
                      autocapitalize: "off",
                      autocomplete: _ctx.autocomplete,
                      class: normalizeClass(_ctx.nsSelectV2.e("combobox-input")),
                      disabled: _ctx.disabled,
                      name: _ctx.name,
                      role: "combobox",
                      readonly: !_ctx.filterable,
                      spellcheck: "false",
                      type: "text",
                      unselectable: _ctx.expanded ? "on" : void 0,
                      onCompositionstart: _cache[12] || (_cache[12] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                      onCompositionupdate: _cache[13] || (_cache[13] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                      onCompositionend: _cache[14] || (_cache[14] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                      onFocus: _cache[15] || (_cache[15] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                      onBlur: _cache[16] || (_cache[16] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                      onInput: _cache[17] || (_cache[17] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                      onKeydown: [
                        _cache[18] || (_cache[18] = withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                        _cache[19] || (_cache[19] = withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                        _cache[20] || (_cache[20] = withKeys(withModifiers((...args) => _ctx.onKeyboardSelect && _ctx.onKeyboardSelect(...args), ["stop", "prevent"]), ["enter"])),
                        _cache[21] || (_cache[21] = withKeys(withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"]))
                      ],
                      "onUpdate:modelValue": _cache[22] || (_cache[22] = (...args) => _ctx.onUpdateInputValue && _ctx.onUpdateInputValue(...args))
                    }, null, 42, _hoisted_4$8), [
                      [_directive_model_text, _ctx.states.displayInputValue]
                    ])
                  ], 2),
                  _ctx.filterable ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    ref: "calculatorRef",
                    "aria-hidden": "true",
                    class: normalizeClass([
                      _ctx.nsSelectV2.e("selected-item"),
                      _ctx.nsSelectV2.e("input-calculator")
                    ]),
                    textContent: toDisplayString(_ctx.states.displayInputValue)
                  }, null, 10, _hoisted_5$4)) : createCommentVNode("v-if", true)
                ], 64)),
                _ctx.shouldShowPlaceholder ? (openBlock(), createElementBlock("span", {
                  key: 3,
                  class: normalizeClass([
                    _ctx.nsSelectV2.e("placeholder"),
                    _ctx.nsSelectV2.is("transparent", _ctx.multiple ? _ctx.modelValue.length === 0 : !_ctx.hasModelValue)
                  ])
                }, toDisplayString(_ctx.currentPlaceholder), 3)) : createCommentVNode("v-if", true),
                createBaseVNode("span", {
                  class: normalizeClass(_ctx.nsSelectV2.e("suffix"))
                }, [
                  _ctx.iconComponent ? withDirectives((openBlock(), createBlock(_component_el_icon, {
                    key: 0,
                    class: normalizeClass([_ctx.nsSelectV2.e("caret"), _ctx.nsInput.e("icon"), _ctx.iconReverse])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                    ]),
                    _: 1
                  }, 8, ["class"])), [
                    [vShow, !_ctx.showClearBtn]
                  ]) : createCommentVNode("v-if", true),
                  _ctx.showClearBtn && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 1,
                    class: normalizeClass([_ctx.nsSelectV2.e("caret"), _ctx.nsInput.e("icon")]),
                    onClick: withModifiers(_ctx.handleClear, ["prevent", "stop"])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                  _ctx.validateState && _ctx.validateIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 2,
                    class: normalizeClass([_ctx.nsInput.e("icon"), _ctx.nsInput.e("validateIcon")])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.validateIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 2)
              ], 2)
            ]),
            content: withCtx(() => [
              createVNode(_component_el_select_menu, {
                ref: "menuRef",
                data: _ctx.filteredOptions,
                width: _ctx.popperSize,
                "hovering-index": _ctx.states.hoveringIndex,
                "scrollbar-always-on": _ctx.scrollbarAlwaysOn
              }, {
                default: withCtx((scope) => [
                  renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(scope)))
                ]),
                empty: withCtx(() => [
                  renderSlot(_ctx.$slots, "empty", {}, () => [
                    createBaseVNode("p", {
                      class: normalizeClass(_ctx.nsSelectV2.e("empty"))
                    }, toDisplayString(_ctx.emptyText ? _ctx.emptyText : ""), 3)
                  ])
                ]),
                _: 3
              }, 8, ["data", "width", "hovering-index", "scrollbar-always-on"])
            ]),
            _: 3
          }, 8, ["visible", "teleported", "popper-class", "popper-options", "effect", "placement", "transition", "persistent", "onBeforeShow"])
        ], 34)), [
          [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
        ]);
      }
      var Select = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["render", _sfc_render$1], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/select.vue"]]);
      Select.install = (app2) => {
        app2.component(Select.name, Select);
      };
      const _Select = Select;
      const ElSelectV2 = _Select;
      const sliderContextKey = Symbol("sliderContextKey");
      const sliderProps = buildProps({
        modelValue: {
          type: definePropType([Number, Array]),
          default: 0
        },
        id: {
          type: String,
          default: void 0
        },
        min: {
          type: Number,
          default: 0
        },
        max: {
          type: Number,
          default: 100
        },
        step: {
          type: Number,
          default: 1
        },
        showInput: Boolean,
        showInputControls: {
          type: Boolean,
          default: true
        },
        size: useSizeProp,
        inputSize: useSizeProp,
        showStops: Boolean,
        showTooltip: {
          type: Boolean,
          default: true
        },
        formatTooltip: {
          type: definePropType(Function),
          default: void 0
        },
        disabled: Boolean,
        range: Boolean,
        vertical: Boolean,
        height: String,
        debounce: {
          type: Number,
          default: 300
        },
        label: {
          type: String,
          default: void 0
        },
        rangeStartLabel: {
          type: String,
          default: void 0
        },
        rangeEndLabel: {
          type: String,
          default: void 0
        },
        formatValueText: {
          type: definePropType(Function),
          default: void 0
        },
        tooltipClass: {
          type: String,
          default: void 0
        },
        placement: {
          type: String,
          values: Ee,
          default: "top"
        },
        marks: {
          type: definePropType(Object)
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const isValidValue = (value) => isNumber(value) || isArray$2(value) && value.every(isNumber);
      const sliderEmits = {
        [UPDATE_MODEL_EVENT]: isValidValue,
        [INPUT_EVENT]: isValidValue,
        [CHANGE_EVENT]: isValidValue
      };
      const useLifecycle = (props, initData, resetSize) => {
        const sliderWrapper = ref();
        onMounted(async () => {
          if (props.range) {
            if (Array.isArray(props.modelValue)) {
              initData.firstValue = Math.max(props.min, props.modelValue[0]);
              initData.secondValue = Math.min(props.max, props.modelValue[1]);
            } else {
              initData.firstValue = props.min;
              initData.secondValue = props.max;
            }
            initData.oldValue = [initData.firstValue, initData.secondValue];
          } else {
            if (typeof props.modelValue !== "number" || Number.isNaN(props.modelValue)) {
              initData.firstValue = props.min;
            } else {
              initData.firstValue = Math.min(props.max, Math.max(props.min, props.modelValue));
            }
            initData.oldValue = initData.firstValue;
          }
          useEventListener$1(window, "resize", resetSize);
          await nextTick();
          resetSize();
        });
        return {
          sliderWrapper
        };
      };
      const useMarks = (props) => {
        return computed(() => {
          if (!props.marks) {
            return [];
          }
          const marksKeys = Object.keys(props.marks);
          return marksKeys.map(Number.parseFloat).sort((a2, b2) => a2 - b2).filter((point) => point <= props.max && point >= props.min).map((point) => ({
            point,
            position: (point - props.min) * 100 / (props.max - props.min),
            mark: props.marks[point]
          }));
        });
      };
      const useSlide = (props, initData, emit2) => {
        const { form: elForm2, formItem: elFormItem2 } = useFormItem();
        const slider = shallowRef();
        const firstButton = ref();
        const secondButton = ref();
        const buttonRefs = {
          firstButton,
          secondButton
        };
        const sliderDisabled = computed(() => {
          return props.disabled || (elForm2 == null ? void 0 : elForm2.disabled) || false;
        });
        const minValue = computed(() => {
          return Math.min(initData.firstValue, initData.secondValue);
        });
        const maxValue = computed(() => {
          return Math.max(initData.firstValue, initData.secondValue);
        });
        const barSize = computed(() => {
          return props.range ? `${100 * (maxValue.value - minValue.value) / (props.max - props.min)}%` : `${100 * (initData.firstValue - props.min) / (props.max - props.min)}%`;
        });
        const barStart = computed(() => {
          return props.range ? `${100 * (minValue.value - props.min) / (props.max - props.min)}%` : "0%";
        });
        const runwayStyle = computed(() => {
          return props.vertical ? { height: props.height } : {};
        });
        const barStyle = computed(() => {
          return props.vertical ? {
            height: barSize.value,
            bottom: barStart.value
          } : {
            width: barSize.value,
            left: barStart.value
          };
        });
        const resetSize = () => {
          if (slider.value) {
            initData.sliderSize = slider.value[`client${props.vertical ? "Height" : "Width"}`];
          }
        };
        const getButtonRefByPercent = (percent) => {
          const targetValue = props.min + percent * (props.max - props.min) / 100;
          if (!props.range) {
            return firstButton;
          }
          let buttonRefName;
          if (Math.abs(minValue.value - targetValue) < Math.abs(maxValue.value - targetValue)) {
            buttonRefName = initData.firstValue < initData.secondValue ? "firstButton" : "secondButton";
          } else {
            buttonRefName = initData.firstValue > initData.secondValue ? "firstButton" : "secondButton";
          }
          return buttonRefs[buttonRefName];
        };
        const setPosition = (percent) => {
          const buttonRef = getButtonRefByPercent(percent);
          buttonRef.value.setPosition(percent);
          return buttonRef;
        };
        const setFirstValue = (firstValue) => {
          initData.firstValue = firstValue;
          _emit(props.range ? [minValue.value, maxValue.value] : firstValue);
        };
        const setSecondValue = (secondValue) => {
          initData.secondValue = secondValue;
          if (props.range) {
            _emit([minValue.value, maxValue.value]);
          }
        };
        const _emit = (val) => {
          emit2(UPDATE_MODEL_EVENT, val);
          emit2(INPUT_EVENT, val);
        };
        const emitChange = async () => {
          await nextTick();
          emit2(CHANGE_EVENT, props.range ? [minValue.value, maxValue.value] : props.modelValue);
        };
        const handleSliderPointerEvent = (event) => {
          var _a2, _b, _c, _d, _e, _f;
          if (sliderDisabled.value || initData.dragging)
            return;
          resetSize();
          let newPercent = 0;
          if (props.vertical) {
            const clientY = (_c = (_b = (_a2 = event.touches) == null ? void 0 : _a2.item(0)) == null ? void 0 : _b.clientY) != null ? _c : event.clientY;
            const sliderOffsetBottom = slider.value.getBoundingClientRect().bottom;
            newPercent = (sliderOffsetBottom - clientY) / initData.sliderSize * 100;
          } else {
            const clientX = (_f = (_e = (_d = event.touches) == null ? void 0 : _d.item(0)) == null ? void 0 : _e.clientX) != null ? _f : event.clientX;
            const sliderOffsetLeft = slider.value.getBoundingClientRect().left;
            newPercent = (clientX - sliderOffsetLeft) / initData.sliderSize * 100;
          }
          if (newPercent < 0 || newPercent > 100)
            return;
          return setPosition(newPercent);
        };
        const onSliderWrapperPrevent = (event) => {
          var _a2, _b;
          if (((_a2 = buttonRefs["firstButton"].value) == null ? void 0 : _a2.dragging) || ((_b = buttonRefs["secondButton"].value) == null ? void 0 : _b.dragging)) {
            event.preventDefault();
          }
        };
        const onSliderDown = async (event) => {
          const buttonRef = handleSliderPointerEvent(event);
          if (buttonRef) {
            await nextTick();
            buttonRef.value.onButtonDown(event);
          }
        };
        const onSliderClick = (event) => {
          const buttonRef = handleSliderPointerEvent(event);
          if (buttonRef) {
            emitChange();
          }
        };
        return {
          elFormItem: elFormItem2,
          slider,
          firstButton,
          secondButton,
          sliderDisabled,
          minValue,
          maxValue,
          runwayStyle,
          barStyle,
          resetSize,
          setPosition,
          emitChange,
          onSliderWrapperPrevent,
          onSliderClick,
          onSliderDown,
          setFirstValue,
          setSecondValue
        };
      };
      const { left, down, right, up, home, end, pageUp, pageDown } = EVENT_CODE;
      const useTooltip = (props, formatTooltip, showTooltip) => {
        const tooltip = ref();
        const tooltipVisible = ref(false);
        const enableFormat = computed(() => {
          return formatTooltip.value instanceof Function;
        });
        const formatValue = computed(() => {
          return enableFormat.value && formatTooltip.value(props.modelValue) || props.modelValue;
        });
        const displayTooltip = debounce(() => {
          showTooltip.value && (tooltipVisible.value = true);
        }, 50);
        const hideTooltip = debounce(() => {
          showTooltip.value && (tooltipVisible.value = false);
        }, 50);
        return {
          tooltip,
          tooltipVisible,
          formatValue,
          displayTooltip,
          hideTooltip
        };
      };
      const useSliderButton = (props, initData, emit2) => {
        const {
          disabled,
          min,
          max,
          step,
          showTooltip,
          precision,
          sliderSize,
          formatTooltip,
          emitChange,
          resetSize,
          updateDragging
        } = inject(sliderContextKey);
        const { tooltip, tooltipVisible, formatValue, displayTooltip, hideTooltip } = useTooltip(props, formatTooltip, showTooltip);
        const button = ref();
        const currentPosition = computed(() => {
          return `${(props.modelValue - min.value) / (max.value - min.value) * 100}%`;
        });
        const wrapperStyle = computed(() => {
          return props.vertical ? { bottom: currentPosition.value } : { left: currentPosition.value };
        });
        const handleMouseEnter = () => {
          initData.hovering = true;
          displayTooltip();
        };
        const handleMouseLeave = () => {
          initData.hovering = false;
          if (!initData.dragging) {
            hideTooltip();
          }
        };
        const onButtonDown = (event) => {
          if (disabled.value)
            return;
          event.preventDefault();
          onDragStart(event);
          window.addEventListener("mousemove", onDragging);
          window.addEventListener("touchmove", onDragging);
          window.addEventListener("mouseup", onDragEnd);
          window.addEventListener("touchend", onDragEnd);
          window.addEventListener("contextmenu", onDragEnd);
          button.value.focus();
        };
        const incrementPosition = (amount) => {
          if (disabled.value)
            return;
          initData.newPosition = Number.parseFloat(currentPosition.value) + amount / (max.value - min.value) * 100;
          setPosition(initData.newPosition);
          emitChange();
        };
        const onLeftKeyDown = () => {
          incrementPosition(-step.value);
        };
        const onRightKeyDown = () => {
          incrementPosition(step.value);
        };
        const onPageDownKeyDown = () => {
          incrementPosition(-step.value * 4);
        };
        const onPageUpKeyDown = () => {
          incrementPosition(step.value * 4);
        };
        const onHomeKeyDown = () => {
          if (disabled.value)
            return;
          setPosition(0);
          emitChange();
        };
        const onEndKeyDown = () => {
          if (disabled.value)
            return;
          setPosition(100);
          emitChange();
        };
        const onKeyDown = (event) => {
          let isPreventDefault = true;
          if ([left, down].includes(event.key)) {
            onLeftKeyDown();
          } else if ([right, up].includes(event.key)) {
            onRightKeyDown();
          } else if (event.key === home) {
            onHomeKeyDown();
          } else if (event.key === end) {
            onEndKeyDown();
          } else if (event.key === pageDown) {
            onPageDownKeyDown();
          } else if (event.key === pageUp) {
            onPageUpKeyDown();
          } else {
            isPreventDefault = false;
          }
          isPreventDefault && event.preventDefault();
        };
        const getClientXY = (event) => {
          let clientX;
          let clientY;
          if (event.type.startsWith("touch")) {
            clientY = event.touches[0].clientY;
            clientX = event.touches[0].clientX;
          } else {
            clientY = event.clientY;
            clientX = event.clientX;
          }
          return {
            clientX,
            clientY
          };
        };
        const onDragStart = (event) => {
          initData.dragging = true;
          initData.isClick = true;
          const { clientX, clientY } = getClientXY(event);
          if (props.vertical) {
            initData.startY = clientY;
          } else {
            initData.startX = clientX;
          }
          initData.startPosition = Number.parseFloat(currentPosition.value);
          initData.newPosition = initData.startPosition;
        };
        const onDragging = (event) => {
          if (initData.dragging) {
            initData.isClick = false;
            displayTooltip();
            resetSize();
            let diff;
            const { clientX, clientY } = getClientXY(event);
            if (props.vertical) {
              initData.currentY = clientY;
              diff = (initData.startY - initData.currentY) / sliderSize.value * 100;
            } else {
              initData.currentX = clientX;
              diff = (initData.currentX - initData.startX) / sliderSize.value * 100;
            }
            initData.newPosition = initData.startPosition + diff;
            setPosition(initData.newPosition);
          }
        };
        const onDragEnd = () => {
          if (initData.dragging) {
            setTimeout(() => {
              initData.dragging = false;
              if (!initData.hovering) {
                hideTooltip();
              }
              if (!initData.isClick) {
                setPosition(initData.newPosition);
              }
              emitChange();
            }, 0);
            window.removeEventListener("mousemove", onDragging);
            window.removeEventListener("touchmove", onDragging);
            window.removeEventListener("mouseup", onDragEnd);
            window.removeEventListener("touchend", onDragEnd);
            window.removeEventListener("contextmenu", onDragEnd);
          }
        };
        const setPosition = async (newPosition) => {
          if (newPosition === null || Number.isNaN(+newPosition))
            return;
          if (newPosition < 0) {
            newPosition = 0;
          } else if (newPosition > 100) {
            newPosition = 100;
          }
          const lengthPerStep = 100 / ((max.value - min.value) / step.value);
          const steps = Math.round(newPosition / lengthPerStep);
          let value = steps * lengthPerStep * (max.value - min.value) * 0.01 + min.value;
          value = Number.parseFloat(value.toFixed(precision.value));
          if (value !== props.modelValue) {
            emit2(UPDATE_MODEL_EVENT, value);
          }
          if (!initData.dragging && props.modelValue !== initData.oldValue) {
            initData.oldValue = props.modelValue;
          }
          await nextTick();
          initData.dragging && displayTooltip();
          tooltip.value.updatePopper();
        };
        watch(() => initData.dragging, (val) => {
          updateDragging(val);
        });
        return {
          disabled,
          button,
          tooltip,
          tooltipVisible,
          showTooltip,
          wrapperStyle,
          formatValue,
          handleMouseEnter,
          handleMouseLeave,
          onButtonDown,
          onKeyDown,
          setPosition
        };
      };
      const useStops = (props, initData, minValue, maxValue) => {
        const stops = computed(() => {
          if (!props.showStops || props.min > props.max)
            return [];
          if (props.step === 0) {
            return [];
          }
          const stopCount = (props.max - props.min) / props.step;
          const stepWidth = 100 * props.step / (props.max - props.min);
          const result = Array.from({ length: stopCount - 1 }).map((_2, index) => (index + 1) * stepWidth);
          if (props.range) {
            return result.filter((step) => {
              return step < 100 * (minValue.value - props.min) / (props.max - props.min) || step > 100 * (maxValue.value - props.min) / (props.max - props.min);
            });
          } else {
            return result.filter((step) => step > 100 * (initData.firstValue - props.min) / (props.max - props.min));
          }
        });
        const getStopStyle = (position) => {
          return props.vertical ? { bottom: `${position}%` } : { left: `${position}%` };
        };
        return {
          stops,
          getStopStyle
        };
      };
      const useWatch = (props, initData, minValue, maxValue, emit2, elFormItem2) => {
        const _emit = (val) => {
          emit2(UPDATE_MODEL_EVENT, val);
          emit2(INPUT_EVENT, val);
        };
        const valueChanged = () => {
          if (props.range) {
            return ![minValue.value, maxValue.value].every((item, index) => item === initData.oldValue[index]);
          } else {
            return props.modelValue !== initData.oldValue;
          }
        };
        const setValues = () => {
          var _a2, _b;
          if (props.min > props.max) {
            throwError("Slider", "min should not be greater than max.");
          }
          const val = props.modelValue;
          if (props.range && Array.isArray(val)) {
            if (val[1] < props.min) {
              _emit([props.min, props.min]);
            } else if (val[0] > props.max) {
              _emit([props.max, props.max]);
            } else if (val[0] < props.min) {
              _emit([props.min, val[1]]);
            } else if (val[1] > props.max) {
              _emit([val[0], props.max]);
            } else {
              initData.firstValue = val[0];
              initData.secondValue = val[1];
              if (valueChanged()) {
                if (props.validateEvent) {
                  (_a2 = elFormItem2 == null ? void 0 : elFormItem2.validate) == null ? void 0 : _a2.call(elFormItem2, "change").catch((err) => debugWarn());
                }
                initData.oldValue = val.slice();
              }
            }
          } else if (!props.range && typeof val === "number" && !Number.isNaN(val)) {
            if (val < props.min) {
              _emit(props.min);
            } else if (val > props.max) {
              _emit(props.max);
            } else {
              initData.firstValue = val;
              if (valueChanged()) {
                if (props.validateEvent) {
                  (_b = elFormItem2 == null ? void 0 : elFormItem2.validate) == null ? void 0 : _b.call(elFormItem2, "change").catch((err) => debugWarn());
                }
                initData.oldValue = val;
              }
            }
          }
        };
        setValues();
        watch(() => initData.dragging, (val) => {
          if (!val) {
            setValues();
          }
        });
        watch(() => props.modelValue, (val, oldVal) => {
          if (initData.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every((item, index) => item === oldVal[index]) && initData.firstValue === val[0] && initData.secondValue === val[1]) {
            return;
          }
          setValues();
        }, {
          deep: true
        });
        watch(() => [props.min, props.max], () => {
          setValues();
        });
      };
      const sliderButtonProps = buildProps({
        modelValue: {
          type: Number,
          default: 0
        },
        vertical: Boolean,
        tooltipClass: String,
        placement: {
          type: String,
          values: Ee,
          default: "top"
        }
      });
      const sliderButtonEmits = {
        [UPDATE_MODEL_EVENT]: (value) => isNumber(value)
      };
      const _hoisted_1$w = ["tabindex"];
      const __default__$8 = defineComponent({
        name: "ElSliderButton"
      });
      const _sfc_main$i = /* @__PURE__ */ defineComponent({
        ...__default__$8,
        props: sliderButtonProps,
        emits: sliderButtonEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const ns = useNamespace("slider");
          const initData = reactive({
            hovering: false,
            dragging: false,
            isClick: false,
            startX: 0,
            currentX: 0,
            startY: 0,
            currentY: 0,
            startPosition: 0,
            newPosition: 0,
            oldValue: props.modelValue
          });
          const {
            disabled,
            button,
            tooltip,
            showTooltip,
            tooltipVisible,
            wrapperStyle,
            formatValue,
            handleMouseEnter,
            handleMouseLeave,
            onButtonDown,
            onKeyDown,
            setPosition
          } = useSliderButton(props, initData, emit2);
          const { hovering, dragging } = toRefs(initData);
          expose({
            onButtonDown,
            onKeyDown,
            setPosition,
            hovering,
            dragging
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "button",
              ref: button,
              class: normalizeClass([unref(ns).e("button-wrapper"), { hover: unref(hovering), dragging: unref(dragging) }]),
              style: normalizeStyle(unref(wrapperStyle)),
              tabindex: unref(disabled) ? -1 : 0,
              onMouseenter: _cache[0] || (_cache[0] = (...args) => unref(handleMouseEnter) && unref(handleMouseEnter)(...args)),
              onMouseleave: _cache[1] || (_cache[1] = (...args) => unref(handleMouseLeave) && unref(handleMouseLeave)(...args)),
              onMousedown: _cache[2] || (_cache[2] = (...args) => unref(onButtonDown) && unref(onButtonDown)(...args)),
              onTouchstart: _cache[3] || (_cache[3] = (...args) => unref(onButtonDown) && unref(onButtonDown)(...args)),
              onFocus: _cache[4] || (_cache[4] = (...args) => unref(handleMouseEnter) && unref(handleMouseEnter)(...args)),
              onBlur: _cache[5] || (_cache[5] = (...args) => unref(handleMouseLeave) && unref(handleMouseLeave)(...args)),
              onKeydown: _cache[6] || (_cache[6] = (...args) => unref(onKeyDown) && unref(onKeyDown)(...args))
            }, [
              createVNode(unref(ElTooltip), {
                ref_key: "tooltip",
                ref: tooltip,
                visible: unref(tooltipVisible),
                placement: _ctx.placement,
                "fallback-placements": ["top", "bottom", "right", "left"],
                "stop-popper-mouse-event": false,
                "popper-class": _ctx.tooltipClass,
                disabled: !unref(showTooltip),
                persistent: ""
              }, {
                content: withCtx(() => [
                  createBaseVNode("span", null, toDisplayString(unref(formatValue)), 1)
                ]),
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: normalizeClass([unref(ns).e("button"), { hover: unref(hovering), dragging: unref(dragging) }])
                  }, null, 2)
                ]),
                _: 1
              }, 8, ["visible", "placement", "popper-class", "disabled"])
            ], 46, _hoisted_1$w);
          };
        }
      });
      var SliderButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/button.vue"]]);
      const sliderMarkerProps = buildProps({
        mark: {
          type: definePropType([String, Object]),
          default: void 0
        }
      });
      var SliderMarker = defineComponent({
        name: "ElSliderMarker",
        props: sliderMarkerProps,
        setup(props) {
          const ns = useNamespace("slider");
          const label = computed(() => {
            return isString$1(props.mark) ? props.mark : props.mark.label;
          });
          const style = computed(() => isString$1(props.mark) ? void 0 : props.mark.style);
          return () => h$1("div", {
            class: ns.e("marks-text"),
            style: style.value
          }, label.value);
        }
      });
      const _hoisted_1$v = ["id", "role", "aria-label", "aria-labelledby"];
      const _hoisted_2$r = { key: 1 };
      const __default__$7 = defineComponent({
        name: "ElSlider"
      });
      const _sfc_main$h = /* @__PURE__ */ defineComponent({
        ...__default__$7,
        props: sliderProps,
        emits: sliderEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const ns = useNamespace("slider");
          const { t: t2 } = useLocale();
          const initData = reactive({
            firstValue: 0,
            secondValue: 0,
            oldValue: 0,
            dragging: false,
            sliderSize: 1
          });
          const {
            elFormItem: elFormItem2,
            slider,
            firstButton,
            secondButton,
            sliderDisabled,
            minValue,
            maxValue,
            runwayStyle,
            barStyle,
            resetSize,
            emitChange,
            onSliderWrapperPrevent,
            onSliderClick,
            onSliderDown,
            setFirstValue,
            setSecondValue
          } = useSlide(props, initData, emit2);
          const { stops, getStopStyle } = useStops(props, initData, minValue, maxValue);
          const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
            formItemContext: elFormItem2
          });
          const sliderWrapperSize = useFormSize();
          const sliderInputSize = computed(() => props.inputSize || sliderWrapperSize.value);
          const groupLabel = computed(() => {
            return props.label || t2("el.slider.defaultLabel", {
              min: props.min,
              max: props.max
            });
          });
          const firstButtonLabel = computed(() => {
            if (props.range) {
              return props.rangeStartLabel || t2("el.slider.defaultRangeStartLabel");
            } else {
              return groupLabel.value;
            }
          });
          const firstValueText = computed(() => {
            return props.formatValueText ? props.formatValueText(firstValue.value) : `${firstValue.value}`;
          });
          const secondButtonLabel = computed(() => {
            return props.rangeEndLabel || t2("el.slider.defaultRangeEndLabel");
          });
          const secondValueText = computed(() => {
            return props.formatValueText ? props.formatValueText(secondValue.value) : `${secondValue.value}`;
          });
          const sliderKls = computed(() => [
            ns.b(),
            ns.m(sliderWrapperSize.value),
            ns.is("vertical", props.vertical),
            { [ns.m("with-input")]: props.showInput }
          ]);
          const markList = useMarks(props);
          useWatch(props, initData, minValue, maxValue, emit2, elFormItem2);
          const precision = computed(() => {
            const precisions = [props.min, props.max, props.step].map((item) => {
              const decimal = `${item}`.split(".")[1];
              return decimal ? decimal.length : 0;
            });
            return Math.max.apply(null, precisions);
          });
          const { sliderWrapper } = useLifecycle(props, initData, resetSize);
          const { firstValue, secondValue, sliderSize } = toRefs(initData);
          const updateDragging = (val) => {
            initData.dragging = val;
          };
          provide(sliderContextKey, {
            ...toRefs(props),
            sliderSize,
            disabled: sliderDisabled,
            precision,
            emitChange,
            resetSize,
            updateDragging
          });
          expose({
            onSliderClick
          });
          return (_ctx, _cache) => {
            var _a2, _b;
            return openBlock(), createElementBlock("div", {
              id: _ctx.range ? unref(inputId) : void 0,
              ref_key: "sliderWrapper",
              ref: sliderWrapper,
              class: normalizeClass(unref(sliderKls)),
              role: _ctx.range ? "group" : void 0,
              "aria-label": _ctx.range && !unref(isLabeledByFormItem) ? unref(groupLabel) : void 0,
              "aria-labelledby": _ctx.range && unref(isLabeledByFormItem) ? (_a2 = unref(elFormItem2)) == null ? void 0 : _a2.labelId : void 0,
              onTouchstart: _cache[2] || (_cache[2] = (...args) => unref(onSliderWrapperPrevent) && unref(onSliderWrapperPrevent)(...args)),
              onTouchmove: _cache[3] || (_cache[3] = (...args) => unref(onSliderWrapperPrevent) && unref(onSliderWrapperPrevent)(...args))
            }, [
              createBaseVNode("div", {
                ref_key: "slider",
                ref: slider,
                class: normalizeClass([
                  unref(ns).e("runway"),
                  { "show-input": _ctx.showInput && !_ctx.range },
                  unref(ns).is("disabled", unref(sliderDisabled))
                ]),
                style: normalizeStyle(unref(runwayStyle)),
                onMousedown: _cache[0] || (_cache[0] = (...args) => unref(onSliderDown) && unref(onSliderDown)(...args)),
                onTouchstart: _cache[1] || (_cache[1] = (...args) => unref(onSliderDown) && unref(onSliderDown)(...args))
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).e("bar")),
                  style: normalizeStyle(unref(barStyle))
                }, null, 6),
                createVNode(SliderButton, {
                  id: !_ctx.range ? unref(inputId) : void 0,
                  ref_key: "firstButton",
                  ref: firstButton,
                  "model-value": unref(firstValue),
                  vertical: _ctx.vertical,
                  "tooltip-class": _ctx.tooltipClass,
                  placement: _ctx.placement,
                  role: "slider",
                  "aria-label": _ctx.range || !unref(isLabeledByFormItem) ? unref(firstButtonLabel) : void 0,
                  "aria-labelledby": !_ctx.range && unref(isLabeledByFormItem) ? (_b = unref(elFormItem2)) == null ? void 0 : _b.labelId : void 0,
                  "aria-valuemin": _ctx.min,
                  "aria-valuemax": _ctx.range ? unref(secondValue) : _ctx.max,
                  "aria-valuenow": unref(firstValue),
                  "aria-valuetext": unref(firstValueText),
                  "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                  "aria-disabled": unref(sliderDisabled),
                  "onUpdate:modelValue": unref(setFirstValue)
                }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
                _ctx.range ? (openBlock(), createBlock(SliderButton, {
                  key: 0,
                  ref_key: "secondButton",
                  ref: secondButton,
                  "model-value": unref(secondValue),
                  vertical: _ctx.vertical,
                  "tooltip-class": _ctx.tooltipClass,
                  placement: _ctx.placement,
                  role: "slider",
                  "aria-label": unref(secondButtonLabel),
                  "aria-valuemin": unref(firstValue),
                  "aria-valuemax": _ctx.max,
                  "aria-valuenow": unref(secondValue),
                  "aria-valuetext": unref(secondValueText),
                  "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                  "aria-disabled": unref(sliderDisabled),
                  "onUpdate:modelValue": unref(setSecondValue)
                }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : createCommentVNode("v-if", true),
                _ctx.showStops ? (openBlock(), createElementBlock("div", _hoisted_2$r, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(stops), (item, key) => {
                    return openBlock(), createElementBlock("div", {
                      key,
                      class: normalizeClass(unref(ns).e("stop")),
                      style: normalizeStyle(unref(getStopStyle)(item))
                    }, null, 6);
                  }), 128))
                ])) : createCommentVNode("v-if", true),
                unref(markList).length > 0 ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                  createBaseVNode("div", null, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(markList), (item, key) => {
                      return openBlock(), createElementBlock("div", {
                        key,
                        style: normalizeStyle(unref(getStopStyle)(item.position)),
                        class: normalizeClass([unref(ns).e("stop"), unref(ns).e("marks-stop")])
                      }, null, 6);
                    }), 128))
                  ]),
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ns).e("marks"))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(markList), (item, key) => {
                      return openBlock(), createBlock(unref(SliderMarker), {
                        key,
                        mark: item.mark,
                        style: normalizeStyle(unref(getStopStyle)(item.position))
                      }, null, 8, ["mark", "style"]);
                    }), 128))
                  ], 2)
                ], 64)) : createCommentVNode("v-if", true)
              ], 38),
              _ctx.showInput && !_ctx.range ? (openBlock(), createBlock(unref(ElInputNumber), {
                key: 0,
                ref: "input",
                "model-value": unref(firstValue),
                class: normalizeClass(unref(ns).e("input")),
                step: _ctx.step,
                disabled: unref(sliderDisabled),
                controls: _ctx.showInputControls,
                min: _ctx.min,
                max: _ctx.max,
                debounce: _ctx.debounce,
                size: unref(sliderInputSize),
                "onUpdate:modelValue": unref(setFirstValue),
                onChange: unref(emitChange)
              }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : createCommentVNode("v-if", true)
            ], 42, _hoisted_1$v);
          };
        }
      });
      var Slider = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/slider.vue"]]);
      const ElSlider = withInstall(Slider);
      const statisticProps = buildProps({
        decimalSeparator: {
          type: String,
          default: "."
        },
        groupSeparator: {
          type: String,
          default: ","
        },
        precision: {
          type: Number,
          default: 0
        },
        formatter: Function,
        value: {
          type: definePropType([Number, Object]),
          default: 0
        },
        prefix: String,
        suffix: String,
        title: String,
        valueStyle: {
          type: definePropType([String, Object, Array])
        }
      });
      const __default__$6 = defineComponent({
        name: "ElStatistic"
      });
      const _sfc_main$g = /* @__PURE__ */ defineComponent({
        ...__default__$6,
        props: statisticProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("statistic");
          const displayValue = computed(() => {
            const { value, formatter, precision, decimalSeparator, groupSeparator } = props;
            if (isFunction$1(formatter))
              return formatter(value);
            if (!isNumber(value))
              return value;
            let [integer2, decimal = ""] = String(value).split(".");
            decimal = decimal.padEnd(precision, "0").slice(0, precision > 0 ? precision : 0);
            integer2 = integer2.replace(/\B(?=(\d{3})+(?!\d))/g, groupSeparator);
            return [integer2, decimal].join(decimal ? decimalSeparator : "");
          });
          expose({
            displayValue
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b())
            }, [
              _ctx.$slots.title || _ctx.title ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("head"))
              }, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString(_ctx.title), 1)
                ])
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).e("content"))
              }, [
                _ctx.$slots.prefix || _ctx.prefix ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("prefix"))
                }, [
                  renderSlot(_ctx.$slots, "prefix", {}, () => [
                    createBaseVNode("span", null, toDisplayString(_ctx.prefix), 1)
                  ])
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("span", {
                  class: normalizeClass(unref(ns).e("number")),
                  style: normalizeStyle(_ctx.valueStyle)
                }, toDisplayString(unref(displayValue)), 7),
                _ctx.$slots.suffix || _ctx.suffix ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(ns).e("suffix"))
                }, [
                  renderSlot(_ctx.$slots, "suffix", {}, () => [
                    createBaseVNode("span", null, toDisplayString(_ctx.suffix), 1)
                  ])
                ], 2)) : createCommentVNode("v-if", true)
              ], 2)
            ], 2);
          };
        }
      });
      var Statistic = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/statistic/src/statistic.vue"]]);
      const ElStatistic = withInstall(Statistic);
      const tabsRootContextKey = Symbol("tabsRootContextKey");
      const tabBarProps = buildProps({
        tabs: {
          type: definePropType(Array),
          default: () => mutable([])
        }
      });
      const COMPONENT_NAME$2 = "ElTabBar";
      const __default__$5 = defineComponent({
        name: COMPONENT_NAME$2
      });
      const _sfc_main$f = /* @__PURE__ */ defineComponent({
        ...__default__$5,
        props: tabBarProps,
        setup(__props, { expose }) {
          const props = __props;
          const instance = getCurrentInstance();
          const rootTabs = inject(tabsRootContextKey);
          if (!rootTabs)
            throwError(COMPONENT_NAME$2, "<el-tabs><el-tab-bar /></el-tabs>");
          const ns = useNamespace("tabs");
          const barRef = ref();
          const barStyle = ref();
          const getBarStyle = () => {
            let offset = 0;
            let tabSize = 0;
            const sizeName = ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height";
            const sizeDir = sizeName === "width" ? "x" : "y";
            const position = sizeDir === "x" ? "left" : "top";
            props.tabs.every((tab) => {
              var _a2, _b;
              const $el = (_b = (_a2 = instance.parent) == null ? void 0 : _a2.refs) == null ? void 0 : _b[`tab-${tab.uid}`];
              if (!$el)
                return false;
              if (!tab.active) {
                return true;
              }
              offset = $el[`offset${capitalize(position)}`];
              tabSize = $el[`client${capitalize(sizeName)}`];
              const tabStyles = window.getComputedStyle($el);
              if (sizeName === "width") {
                if (props.tabs.length > 1) {
                  tabSize -= Number.parseFloat(tabStyles.paddingLeft) + Number.parseFloat(tabStyles.paddingRight);
                }
                offset += Number.parseFloat(tabStyles.paddingLeft);
              }
              return false;
            });
            return {
              [sizeName]: `${tabSize}px`,
              transform: `translate${capitalize(sizeDir)}(${offset}px)`
            };
          };
          const update = () => barStyle.value = getBarStyle();
          watch(() => props.tabs, async () => {
            await nextTick();
            update();
          }, { immediate: true });
          useResizeObserver(barRef, () => update());
          expose({
            ref: barRef,
            update
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "barRef",
              ref: barRef,
              class: normalizeClass([unref(ns).e("active-bar"), unref(ns).is(unref(rootTabs).props.tabPosition)]),
              style: normalizeStyle(barStyle.value)
            }, null, 6);
          };
        }
      });
      var TabBar = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-bar.vue"]]);
      const tabNavProps = buildProps({
        panes: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        currentName: {
          type: [String, Number],
          default: ""
        },
        editable: Boolean,
        type: {
          type: String,
          values: ["card", "border-card", ""],
          default: ""
        },
        stretch: Boolean
      });
      const tabNavEmits = {
        tabClick: (tab, tabName, ev) => ev instanceof Event,
        tabRemove: (tab, ev) => ev instanceof Event
      };
      const COMPONENT_NAME$1 = "ElTabNav";
      const TabNav = defineComponent({
        name: COMPONENT_NAME$1,
        props: tabNavProps,
        emits: tabNavEmits,
        setup(props, {
          expose,
          emit: emit2
        }) {
          const vm = getCurrentInstance();
          const rootTabs = inject(tabsRootContextKey);
          if (!rootTabs)
            throwError(COMPONENT_NAME$1, `<el-tabs><tab-nav /></el-tabs>`);
          const ns = useNamespace("tabs");
          const visibility = useDocumentVisibility();
          const focused = useWindowFocus();
          const navScroll$ = ref();
          const nav$ = ref();
          const el$ = ref();
          const tabBarRef = ref();
          const scrollable = ref(false);
          const navOffset = ref(0);
          const isFocus = ref(false);
          const focusable = ref(true);
          const sizeName = computed(() => ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height");
          const navStyle = computed(() => {
            const dir = sizeName.value === "width" ? "X" : "Y";
            return {
              transform: `translate${dir}(-${navOffset.value}px)`
            };
          });
          const scrollPrev = () => {
            if (!navScroll$.value)
              return;
            const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (!currentOffset)
              return;
            const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;
            navOffset.value = newOffset;
          };
          const scrollNext = () => {
            if (!navScroll$.value || !nav$.value)
              return;
            const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
            const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (navSize - currentOffset <= containerSize)
              return;
            const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;
            navOffset.value = newOffset;
          };
          const scrollToActiveTab = async () => {
            const nav = nav$.value;
            if (!scrollable.value || !el$.value || !navScroll$.value || !nav)
              return;
            await nextTick();
            const activeTab = el$.value.querySelector(".is-active");
            if (!activeTab)
              return;
            const navScroll = navScroll$.value;
            const isHorizontal2 = ["top", "bottom"].includes(rootTabs.props.tabPosition);
            const activeTabBounding = activeTab.getBoundingClientRect();
            const navScrollBounding = navScroll.getBoundingClientRect();
            const maxOffset = isHorizontal2 ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;
            const currentOffset = navOffset.value;
            let newOffset = currentOffset;
            if (isHorizontal2) {
              if (activeTabBounding.left < navScrollBounding.left) {
                newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
              }
              if (activeTabBounding.right > navScrollBounding.right) {
                newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
              }
            } else {
              if (activeTabBounding.top < navScrollBounding.top) {
                newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);
              }
              if (activeTabBounding.bottom > navScrollBounding.bottom) {
                newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);
              }
            }
            newOffset = Math.max(newOffset, 0);
            navOffset.value = Math.min(newOffset, maxOffset);
          };
          const update = () => {
            var _a2;
            if (!nav$.value || !navScroll$.value)
              return;
            props.stretch && ((_a2 = tabBarRef.value) == null ? void 0 : _a2.update());
            const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
            const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (containerSize < navSize) {
              scrollable.value = scrollable.value || {};
              scrollable.value.prev = currentOffset;
              scrollable.value.next = currentOffset + containerSize < navSize;
              if (navSize - currentOffset < containerSize) {
                navOffset.value = navSize - containerSize;
              }
            } else {
              scrollable.value = false;
              if (currentOffset > 0) {
                navOffset.value = 0;
              }
            }
          };
          const changeTab = (e2) => {
            const code = e2.code;
            const {
              up: up2,
              down: down2,
              left: left2,
              right: right2
            } = EVENT_CODE;
            if (![up2, down2, left2, right2].includes(code))
              return;
            const tabList = Array.from(e2.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)"));
            const currentIndex = tabList.indexOf(e2.target);
            let nextIndex;
            if (code === left2 || code === up2) {
              if (currentIndex === 0) {
                nextIndex = tabList.length - 1;
              } else {
                nextIndex = currentIndex - 1;
              }
            } else {
              if (currentIndex < tabList.length - 1) {
                nextIndex = currentIndex + 1;
              } else {
                nextIndex = 0;
              }
            }
            tabList[nextIndex].focus({
              preventScroll: true
            });
            tabList[nextIndex].click();
            setFocus();
          };
          const setFocus = () => {
            if (focusable.value)
              isFocus.value = true;
          };
          const removeFocus = () => isFocus.value = false;
          watch(visibility, (visibility2) => {
            if (visibility2 === "hidden") {
              focusable.value = false;
            } else if (visibility2 === "visible") {
              setTimeout(() => focusable.value = true, 50);
            }
          });
          watch(focused, (focused2) => {
            if (focused2) {
              setTimeout(() => focusable.value = true, 50);
            } else {
              focusable.value = false;
            }
          });
          useResizeObserver(el$, update);
          onMounted(() => setTimeout(() => scrollToActiveTab(), 0));
          onUpdated(() => update());
          expose({
            scrollToActiveTab,
            removeFocus
          });
          watch(() => props.panes, () => vm.update(), {
            flush: "post",
            deep: true
          });
          return () => {
            const scrollBtn = scrollable.value ? [createVNode("span", {
              "class": [ns.e("nav-prev"), ns.is("disabled", !scrollable.value.prev)],
              "onClick": scrollPrev
            }, [createVNode(ElIcon, null, {
              default: () => [createVNode(arrow_left_default, null, null)]
            })]), createVNode("span", {
              "class": [ns.e("nav-next"), ns.is("disabled", !scrollable.value.next)],
              "onClick": scrollNext
            }, [createVNode(ElIcon, null, {
              default: () => [createVNode(arrow_right_default, null, null)]
            })])] : null;
            const tabs = props.panes.map((pane, index) => {
              var _a2, _b, _c, _d;
              const uid2 = pane.uid;
              const disabled = pane.props.disabled;
              const tabName = (_b = (_a2 = pane.props.name) != null ? _a2 : pane.index) != null ? _b : `${index}`;
              const closable = !disabled && (pane.isClosable || props.editable);
              pane.index = `${index}`;
              const btnClose = closable ? createVNode(ElIcon, {
                "class": "is-icon-close",
                "onClick": (ev) => emit2("tabRemove", pane, ev)
              }, {
                default: () => [createVNode(close_default, null, null)]
              }) : null;
              const tabLabelContent = ((_d = (_c = pane.slots).label) == null ? void 0 : _d.call(_c)) || pane.props.label;
              const tabindex = !disabled && pane.active ? 0 : -1;
              return createVNode("div", {
                "ref": `tab-${uid2}`,
                "class": [ns.e("item"), ns.is(rootTabs.props.tabPosition), ns.is("active", pane.active), ns.is("disabled", disabled), ns.is("closable", closable), ns.is("focus", isFocus.value)],
                "id": `tab-${tabName}`,
                "key": `tab-${uid2}`,
                "aria-controls": `pane-${tabName}`,
                "role": "tab",
                "aria-selected": pane.active,
                "tabindex": tabindex,
                "onFocus": () => setFocus(),
                "onBlur": () => removeFocus(),
                "onClick": (ev) => {
                  removeFocus();
                  emit2("tabClick", pane, tabName, ev);
                },
                "onKeydown": (ev) => {
                  if (closable && (ev.code === EVENT_CODE.delete || ev.code === EVENT_CODE.backspace)) {
                    emit2("tabRemove", pane, ev);
                  }
                }
              }, [...[tabLabelContent, btnClose]]);
            });
            return createVNode("div", {
              "ref": el$,
              "class": [ns.e("nav-wrap"), ns.is("scrollable", !!scrollable.value), ns.is(rootTabs.props.tabPosition)]
            }, [scrollBtn, createVNode("div", {
              "class": ns.e("nav-scroll"),
              "ref": navScroll$
            }, [createVNode("div", {
              "class": [ns.e("nav"), ns.is(rootTabs.props.tabPosition), ns.is("stretch", props.stretch && ["top", "bottom"].includes(rootTabs.props.tabPosition))],
              "ref": nav$,
              "style": navStyle.value,
              "role": "tablist",
              "onKeydown": changeTab
            }, [...[!props.type ? createVNode(TabBar, {
              "ref": tabBarRef,
              "tabs": [...props.panes]
            }, null) : null, tabs]])])]);
          };
        }
      });
      const tabsProps = buildProps({
        type: {
          type: String,
          values: ["card", "border-card", ""],
          default: ""
        },
        activeName: {
          type: [String, Number]
        },
        closable: Boolean,
        addable: Boolean,
        modelValue: {
          type: [String, Number]
        },
        editable: Boolean,
        tabPosition: {
          type: String,
          values: ["top", "right", "bottom", "left"],
          default: "top"
        },
        beforeLeave: {
          type: definePropType(Function),
          default: () => true
        },
        stretch: Boolean
      });
      const isPaneName = (value) => isString$1(value) || isNumber(value);
      const tabsEmits = {
        [UPDATE_MODEL_EVENT]: (name) => isPaneName(name),
        tabClick: (pane, ev) => ev instanceof Event,
        tabChange: (name) => isPaneName(name),
        edit: (paneName, action) => ["remove", "add"].includes(action),
        tabRemove: (name) => isPaneName(name),
        tabAdd: () => true
      };
      var Tabs = defineComponent({
        name: "ElTabs",
        props: tabsProps,
        emits: tabsEmits,
        setup(props, {
          emit: emit2,
          slots,
          expose
        }) {
          var _a2, _b;
          const ns = useNamespace("tabs");
          const {
            children: panes,
            addChild: registerPane,
            removeChild: unregisterPane
          } = useOrderedChildren(getCurrentInstance(), "ElTabPane");
          const nav$ = ref();
          const currentName = ref((_b = (_a2 = props.modelValue) != null ? _a2 : props.activeName) != null ? _b : "0");
          const changeCurrentName = (value) => {
            currentName.value = value;
            emit2(UPDATE_MODEL_EVENT, value);
            emit2("tabChange", value);
          };
          const setCurrentName = async (value) => {
            var _a22, _b2, _c;
            if (currentName.value === value || isUndefined(value))
              return;
            try {
              const canLeave = await ((_a22 = props.beforeLeave) == null ? void 0 : _a22.call(props, value, currentName.value));
              if (canLeave !== false) {
                changeCurrentName(value);
                (_c = (_b2 = nav$.value) == null ? void 0 : _b2.removeFocus) == null ? void 0 : _c.call(_b2);
              }
            } catch (e2) {
            }
          };
          const handleTabClick = (tab, tabName, event) => {
            if (tab.props.disabled)
              return;
            setCurrentName(tabName);
            emit2("tabClick", tab, event);
          };
          const handleTabRemove = (pane, ev) => {
            if (pane.props.disabled || isUndefined(pane.props.name))
              return;
            ev.stopPropagation();
            emit2("edit", pane.props.name, "remove");
            emit2("tabRemove", pane.props.name);
          };
          const handleTabAdd = () => {
            emit2("edit", void 0, "add");
            emit2("tabAdd");
          };
          useDeprecated({
            from: '"activeName"',
            replacement: '"model-value" or "v-model"',
            scope: "ElTabs",
            version: "2.3.0",
            ref: "https://element-plus.org/en-US/component/tabs.html#attributes",
            type: "Attribute"
          }, computed(() => !!props.activeName));
          watch(() => props.activeName, (modelValue) => setCurrentName(modelValue));
          watch(() => props.modelValue, (modelValue) => setCurrentName(modelValue));
          watch(currentName, async () => {
            var _a22;
            await nextTick();
            (_a22 = nav$.value) == null ? void 0 : _a22.scrollToActiveTab();
          });
          provide(tabsRootContextKey, {
            props,
            currentName,
            registerPane,
            unregisterPane
          });
          expose({
            currentName
          });
          return () => {
            const newButton = props.editable || props.addable ? createVNode("span", {
              "class": ns.e("new-tab"),
              "tabindex": "0",
              "onClick": handleTabAdd,
              "onKeydown": (ev) => {
                if (ev.code === EVENT_CODE.enter)
                  handleTabAdd();
              }
            }, [createVNode(ElIcon, {
              "class": ns.is("icon-plus")
            }, {
              default: () => [createVNode(plus_default, null, null)]
            })]) : null;
            const header = createVNode("div", {
              "class": [ns.e("header"), ns.is(props.tabPosition)]
            }, [newButton, createVNode(TabNav, {
              "ref": nav$,
              "currentName": currentName.value,
              "editable": props.editable,
              "type": props.type,
              "panes": panes.value,
              "stretch": props.stretch,
              "onTabClick": handleTabClick,
              "onTabRemove": handleTabRemove
            }, null)]);
            const panels = createVNode("div", {
              "class": ns.e("content")
            }, [renderSlot(slots, "default")]);
            return createVNode("div", {
              "class": [ns.b(), ns.m(props.tabPosition), {
                [ns.m("card")]: props.type === "card",
                [ns.m("border-card")]: props.type === "border-card"
              }]
            }, [...props.tabPosition !== "bottom" ? [header, panels] : [panels, header]]);
          };
        }
      });
      const tabPaneProps = buildProps({
        label: {
          type: String,
          default: ""
        },
        name: {
          type: [String, Number]
        },
        closable: Boolean,
        disabled: Boolean,
        lazy: Boolean
      });
      const _hoisted_1$u = ["id", "aria-hidden", "aria-labelledby"];
      const COMPONENT_NAME = "ElTabPane";
      const __default__$4 = defineComponent({
        name: COMPONENT_NAME
      });
      const _sfc_main$e = /* @__PURE__ */ defineComponent({
        ...__default__$4,
        props: tabPaneProps,
        setup(__props) {
          const props = __props;
          const instance = getCurrentInstance();
          const slots = useSlots();
          const tabsRoot = inject(tabsRootContextKey);
          if (!tabsRoot)
            throwError(COMPONENT_NAME, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
          const ns = useNamespace("tab-pane");
          const index = ref();
          const isClosable = computed(() => props.closable || tabsRoot.props.closable);
          const active = computedEager(() => {
            var _a2;
            return tabsRoot.currentName.value === ((_a2 = props.name) != null ? _a2 : index.value);
          });
          const loaded = ref(active.value);
          const paneName = computed(() => {
            var _a2;
            return (_a2 = props.name) != null ? _a2 : index.value;
          });
          const shouldBeRender = computedEager(() => !props.lazy || loaded.value || active.value);
          watch(active, (val) => {
            if (val)
              loaded.value = true;
          });
          const pane = reactive({
            uid: instance.uid,
            slots,
            props,
            paneName,
            active,
            index,
            isClosable
          });
          onMounted(() => {
            tabsRoot.registerPane(pane);
          });
          onUnmounted(() => {
            tabsRoot.unregisterPane(pane.uid);
          });
          return (_ctx, _cache) => {
            return unref(shouldBeRender) ? withDirectives((openBlock(), createElementBlock("div", {
              key: 0,
              id: `pane-${unref(paneName)}`,
              class: normalizeClass(unref(ns).b()),
              role: "tabpanel",
              "aria-hidden": !unref(active),
              "aria-labelledby": `tab-${unref(paneName)}`
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 10, _hoisted_1$u)), [
              [vShow, unref(active)]
            ]) : createCommentVNode("v-if", true);
          };
        }
      });
      var TabPane = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-pane.vue"]]);
      const ElTabs = withInstall(Tabs, {
        TabPane
      });
      const ElTabPane = withNoopInstall(TabPane);
      const ROOT_TREE_INJECTION_KEY = Symbol();
      const EMPTY_NODE = {
        key: -1,
        level: -1,
        data: {}
      };
      var TreeOptionsEnum = /* @__PURE__ */ ((TreeOptionsEnum2) => {
        TreeOptionsEnum2["KEY"] = "id";
        TreeOptionsEnum2["LABEL"] = "label";
        TreeOptionsEnum2["CHILDREN"] = "children";
        TreeOptionsEnum2["DISABLED"] = "disabled";
        return TreeOptionsEnum2;
      })(TreeOptionsEnum || {});
      var SetOperationEnum = /* @__PURE__ */ ((SetOperationEnum2) => {
        SetOperationEnum2["ADD"] = "add";
        SetOperationEnum2["DELETE"] = "delete";
        return SetOperationEnum2;
      })(SetOperationEnum || {});
      const itemSize = {
        type: Number,
        default: 26
      };
      const treeProps = buildProps({
        data: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        emptyText: {
          type: String
        },
        height: {
          type: Number,
          default: 200
        },
        props: {
          type: definePropType(Object),
          default: () => mutable({
            children: "children",
            label: "label",
            disabled: "disabled",
            value: "id"
            /* KEY */
          })
        },
        highlightCurrent: {
          type: Boolean,
          default: false
        },
        showCheckbox: {
          type: Boolean,
          default: false
        },
        defaultCheckedKeys: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        checkStrictly: {
          type: Boolean,
          default: false
        },
        defaultExpandedKeys: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        indent: {
          type: Number,
          default: 16
        },
        itemSize,
        icon: {
          type: iconPropType
        },
        expandOnClickNode: {
          type: Boolean,
          default: true
        },
        checkOnClickNode: {
          type: Boolean,
          default: false
        },
        currentNodeKey: {
          type: definePropType([String, Number])
        },
        accordion: {
          type: Boolean,
          default: false
        },
        filterMethod: {
          type: definePropType(Function)
        },
        perfMode: {
          type: Boolean,
          default: true
        }
      });
      const treeNodeProps = buildProps({
        node: {
          type: definePropType(Object),
          default: () => mutable(EMPTY_NODE)
        },
        expanded: {
          type: Boolean,
          default: false
        },
        checked: {
          type: Boolean,
          default: false
        },
        indeterminate: {
          type: Boolean,
          default: false
        },
        showCheckbox: {
          type: Boolean,
          default: false
        },
        disabled: {
          type: Boolean,
          default: false
        },
        current: {
          type: Boolean,
          default: false
        },
        hiddenExpandIcon: {
          type: Boolean,
          default: false
        },
        itemSize
      });
      const treeNodeContentProps = buildProps({
        node: {
          type: definePropType(Object),
          required: true
        }
      });
      const NODE_CLICK = "node-click";
      const NODE_EXPAND = "node-expand";
      const NODE_COLLAPSE = "node-collapse";
      const CURRENT_CHANGE = "current-change";
      const NODE_CHECK = "check";
      const NODE_CHECK_CHANGE = "check-change";
      const NODE_CONTEXTMENU = "node-contextmenu";
      const treeEmits = {
        [NODE_CLICK]: (data, node, e2) => data && node && e2,
        [NODE_EXPAND]: (data, node) => data && node,
        [NODE_COLLAPSE]: (data, node) => data && node,
        [CURRENT_CHANGE]: (data, node) => data && node,
        [NODE_CHECK]: (data, checkedInfo) => data && checkedInfo,
        [NODE_CHECK_CHANGE]: (data, checked) => data && typeof checked === "boolean",
        [NODE_CONTEXTMENU]: (event, data, node) => event && data && node
      };
      const treeNodeEmits = {
        click: (node, e2) => !!(node && e2),
        toggle: (node) => !!node,
        check: (node, checked) => node && typeof checked === "boolean"
      };
      function useCheck(props, tree) {
        const checkedKeys = ref(/* @__PURE__ */ new Set());
        const indeterminateKeys = ref(/* @__PURE__ */ new Set());
        const { emit: emit2 } = getCurrentInstance();
        watch([() => tree.value, () => props.defaultCheckedKeys], () => {
          return nextTick(() => {
            _setCheckedKeys(props.defaultCheckedKeys);
          });
        }, {
          immediate: true
        });
        const updateCheckedKeys = () => {
          if (!tree.value || !props.showCheckbox || props.checkStrictly) {
            return;
          }
          const { levelTreeNodeMap, maxLevel } = tree.value;
          const checkedKeySet = checkedKeys.value;
          const indeterminateKeySet = /* @__PURE__ */ new Set();
          for (let level = maxLevel - 1; level >= 1; --level) {
            const nodes = levelTreeNodeMap.get(level);
            if (!nodes)
              continue;
            nodes.forEach((node) => {
              const children = node.children;
              if (children) {
                let allChecked = true;
                let hasChecked = false;
                for (const childNode of children) {
                  const key = childNode.key;
                  if (checkedKeySet.has(key)) {
                    hasChecked = true;
                  } else if (indeterminateKeySet.has(key)) {
                    allChecked = false;
                    hasChecked = true;
                    break;
                  } else {
                    allChecked = false;
                  }
                }
                if (allChecked) {
                  checkedKeySet.add(node.key);
                } else if (hasChecked) {
                  indeterminateKeySet.add(node.key);
                  checkedKeySet.delete(node.key);
                } else {
                  checkedKeySet.delete(node.key);
                  indeterminateKeySet.delete(node.key);
                }
              }
            });
          }
          indeterminateKeys.value = indeterminateKeySet;
        };
        const isChecked = (node) => checkedKeys.value.has(node.key);
        const isIndeterminate = (node) => indeterminateKeys.value.has(node.key);
        const toggleCheckbox = (node, isChecked2, nodeClick = true) => {
          const checkedKeySet = checkedKeys.value;
          const toggle = (node2, checked) => {
            checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](node2.key);
            const children = node2.children;
            if (!props.checkStrictly && children) {
              children.forEach((childNode) => {
                if (!childNode.disabled) {
                  toggle(childNode, checked);
                }
              });
            }
          };
          toggle(node, isChecked2);
          updateCheckedKeys();
          if (nodeClick) {
            afterNodeCheck(node, isChecked2);
          }
        };
        const afterNodeCheck = (node, checked) => {
          const { checkedNodes, checkedKeys: checkedKeys2 } = getChecked();
          const { halfCheckedNodes, halfCheckedKeys } = getHalfChecked();
          emit2(NODE_CHECK, node.data, {
            checkedKeys: checkedKeys2,
            checkedNodes,
            halfCheckedKeys,
            halfCheckedNodes
          });
          emit2(NODE_CHECK_CHANGE, node.data, checked);
        };
        function getCheckedKeys(leafOnly = false) {
          return getChecked(leafOnly).checkedKeys;
        }
        function getCheckedNodes(leafOnly = false) {
          return getChecked(leafOnly).checkedNodes;
        }
        function getHalfCheckedKeys() {
          return getHalfChecked().halfCheckedKeys;
        }
        function getHalfCheckedNodes() {
          return getHalfChecked().halfCheckedNodes;
        }
        function getChecked(leafOnly = false) {
          const checkedNodes = [];
          const keys2 = [];
          if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {
            const { treeNodeMap } = tree.value;
            checkedKeys.value.forEach((key) => {
              const node = treeNodeMap.get(key);
              if (node && (!leafOnly || leafOnly && node.isLeaf)) {
                keys2.push(key);
                checkedNodes.push(node.data);
              }
            });
          }
          return {
            checkedKeys: keys2,
            checkedNodes
          };
        }
        function getHalfChecked() {
          const halfCheckedNodes = [];
          const halfCheckedKeys = [];
          if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {
            const { treeNodeMap } = tree.value;
            indeterminateKeys.value.forEach((key) => {
              const node = treeNodeMap.get(key);
              if (node) {
                halfCheckedKeys.push(key);
                halfCheckedNodes.push(node.data);
              }
            });
          }
          return {
            halfCheckedNodes,
            halfCheckedKeys
          };
        }
        function setCheckedKeys(keys2) {
          checkedKeys.value.clear();
          indeterminateKeys.value.clear();
          _setCheckedKeys(keys2);
        }
        function setChecked2(key, isChecked2) {
          if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {
            const node = tree.value.treeNodeMap.get(key);
            if (node) {
              toggleCheckbox(node, isChecked2, false);
            }
          }
        }
        function _setCheckedKeys(keys2) {
          if (tree == null ? void 0 : tree.value) {
            const { treeNodeMap } = tree.value;
            if (props.showCheckbox && treeNodeMap && keys2) {
              for (const key of keys2) {
                const node = treeNodeMap.get(key);
                if (node && !isChecked(node)) {
                  toggleCheckbox(node, true, false);
                }
              }
            }
          }
        }
        return {
          updateCheckedKeys,
          toggleCheckbox,
          isChecked,
          isIndeterminate,
          getCheckedKeys,
          getCheckedNodes,
          getHalfCheckedKeys,
          getHalfCheckedNodes,
          setChecked: setChecked2,
          setCheckedKeys
        };
      }
      function useFilter(props, tree) {
        const hiddenNodeKeySet = ref(/* @__PURE__ */ new Set([]));
        const hiddenExpandIconKeySet = ref(/* @__PURE__ */ new Set([]));
        const filterable = computed(() => {
          return isFunction$1(props.filterMethod);
        });
        function doFilter(query) {
          var _a2;
          if (!filterable.value) {
            return;
          }
          const expandKeySet = /* @__PURE__ */ new Set();
          const hiddenExpandIconKeys = hiddenExpandIconKeySet.value;
          const hiddenKeys = hiddenNodeKeySet.value;
          const family = [];
          const nodes = ((_a2 = tree.value) == null ? void 0 : _a2.treeNodes) || [];
          const filter = props.filterMethod;
          hiddenKeys.clear();
          function traverse2(nodes2) {
            nodes2.forEach((node) => {
              family.push(node);
              if (filter == null ? void 0 : filter(query, node.data)) {
                family.forEach((member) => {
                  expandKeySet.add(member.key);
                });
              } else if (node.isLeaf) {
                hiddenKeys.add(node.key);
              }
              const children = node.children;
              if (children) {
                traverse2(children);
              }
              if (!node.isLeaf) {
                if (!expandKeySet.has(node.key)) {
                  hiddenKeys.add(node.key);
                } else if (children) {
                  let allHidden = true;
                  for (const childNode of children) {
                    if (!hiddenKeys.has(childNode.key)) {
                      allHidden = false;
                      break;
                    }
                  }
                  if (allHidden) {
                    hiddenExpandIconKeys.add(node.key);
                  } else {
                    hiddenExpandIconKeys.delete(node.key);
                  }
                }
              }
              family.pop();
            });
          }
          traverse2(nodes);
          return expandKeySet;
        }
        function isForceHiddenExpandIcon(node) {
          return hiddenExpandIconKeySet.value.has(node.key);
        }
        return {
          hiddenExpandIconKeySet,
          hiddenNodeKeySet,
          doFilter,
          isForceHiddenExpandIcon
        };
      }
      function useTree(props, emit2) {
        const expandedKeySet = ref(new Set(props.defaultExpandedKeys));
        const currentKey = ref();
        const tree = shallowRef();
        watch(() => props.currentNodeKey, (key) => {
          currentKey.value = key;
        }, {
          immediate: true
        });
        watch(() => props.data, (data) => {
          setData(data);
        }, {
          immediate: true
        });
        const {
          isIndeterminate,
          isChecked,
          toggleCheckbox,
          getCheckedKeys,
          getCheckedNodes,
          getHalfCheckedKeys,
          getHalfCheckedNodes,
          setChecked: setChecked2,
          setCheckedKeys
        } = useCheck(props, tree);
        const { doFilter, hiddenNodeKeySet, isForceHiddenExpandIcon } = useFilter(props, tree);
        const valueKey = computed(() => {
          var _a2;
          return ((_a2 = props.props) == null ? void 0 : _a2.value) || TreeOptionsEnum.KEY;
        });
        const childrenKey = computed(() => {
          var _a2;
          return ((_a2 = props.props) == null ? void 0 : _a2.children) || TreeOptionsEnum.CHILDREN;
        });
        const disabledKey = computed(() => {
          var _a2;
          return ((_a2 = props.props) == null ? void 0 : _a2.disabled) || TreeOptionsEnum.DISABLED;
        });
        const labelKey = computed(() => {
          var _a2;
          return ((_a2 = props.props) == null ? void 0 : _a2.label) || TreeOptionsEnum.LABEL;
        });
        const flattenTree = computed(() => {
          const expandedKeys = expandedKeySet.value;
          const hiddenKeys = hiddenNodeKeySet.value;
          const flattenNodes = [];
          const nodes = tree.value && tree.value.treeNodes || [];
          function traverse2() {
            const stack = [];
            for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
              stack.push(nodes[i2]);
            }
            while (stack.length) {
              const node = stack.pop();
              if (!node)
                continue;
              if (!hiddenKeys.has(node.key)) {
                flattenNodes.push(node);
              }
              if (expandedKeys.has(node.key)) {
                const children = node.children;
                if (children) {
                  const length = children.length;
                  for (let i2 = length - 1; i2 >= 0; --i2) {
                    stack.push(children[i2]);
                  }
                }
              }
            }
          }
          traverse2();
          return flattenNodes;
        });
        const isNotEmpty = computed(() => {
          return flattenTree.value.length > 0;
        });
        function createTree(data) {
          const treeNodeMap = /* @__PURE__ */ new Map();
          const levelTreeNodeMap = /* @__PURE__ */ new Map();
          let maxLevel = 1;
          function traverse2(nodes, level = 1, parent = void 0) {
            var _a2;
            const siblings = [];
            for (const rawNode of nodes) {
              const value = getKey(rawNode);
              const node = {
                level,
                key: value,
                data: rawNode
              };
              node.label = getLabel(rawNode);
              node.parent = parent;
              const children = getChildren(rawNode);
              node.disabled = getDisabled(rawNode);
              node.isLeaf = !children || children.length === 0;
              if (children && children.length) {
                node.children = traverse2(children, level + 1, node);
              }
              siblings.push(node);
              treeNodeMap.set(value, node);
              if (!levelTreeNodeMap.has(level)) {
                levelTreeNodeMap.set(level, []);
              }
              (_a2 = levelTreeNodeMap.get(level)) == null ? void 0 : _a2.push(node);
            }
            if (level > maxLevel) {
              maxLevel = level;
            }
            return siblings;
          }
          const treeNodes = traverse2(data);
          return {
            treeNodeMap,
            levelTreeNodeMap,
            maxLevel,
            treeNodes
          };
        }
        function filter(query) {
          const keys2 = doFilter(query);
          if (keys2) {
            expandedKeySet.value = keys2;
          }
        }
        function getChildren(node) {
          return node[childrenKey.value];
        }
        function getKey(node) {
          if (!node) {
            return "";
          }
          return node[valueKey.value];
        }
        function getDisabled(node) {
          return node[disabledKey.value];
        }
        function getLabel(node) {
          return node[labelKey.value];
        }
        function toggleExpand(node) {
          const expandedKeys = expandedKeySet.value;
          if (expandedKeys.has(node.key)) {
            collapseNode(node);
          } else {
            expandNode(node);
          }
        }
        function setExpandedKeys(keys2) {
          expandedKeySet.value = new Set(keys2);
        }
        function handleNodeClick(node, e2) {
          emit2(NODE_CLICK, node.data, node, e2);
          handleCurrentChange(node);
          if (props.expandOnClickNode) {
            toggleExpand(node);
          }
          if (props.showCheckbox && props.checkOnClickNode && !node.disabled) {
            toggleCheckbox(node, !isChecked(node), true);
          }
        }
        function handleCurrentChange(node) {
          if (!isCurrent(node)) {
            currentKey.value = node.key;
            emit2(CURRENT_CHANGE, node.data, node);
          }
        }
        function handleNodeCheck(node, checked) {
          toggleCheckbox(node, checked);
        }
        function expandNode(node) {
          const keySet = expandedKeySet.value;
          if (tree.value && props.accordion) {
            const { treeNodeMap } = tree.value;
            keySet.forEach((key) => {
              const treeNode = treeNodeMap.get(key);
              if (node && node.level === (treeNode == null ? void 0 : treeNode.level)) {
                keySet.delete(key);
              }
            });
          }
          keySet.add(node.key);
          emit2(NODE_EXPAND, node.data, node);
        }
        function collapseNode(node) {
          expandedKeySet.value.delete(node.key);
          emit2(NODE_COLLAPSE, node.data, node);
        }
        function isExpanded(node) {
          return expandedKeySet.value.has(node.key);
        }
        function isDisabled(node) {
          return !!node.disabled;
        }
        function isCurrent(node) {
          const current = currentKey.value;
          return !!current && current === node.key;
        }
        function getCurrentNode() {
          var _a2, _b;
          if (!currentKey.value)
            return void 0;
          return (_b = (_a2 = tree.value) == null ? void 0 : _a2.treeNodeMap.get(currentKey.value)) == null ? void 0 : _b.data;
        }
        function getCurrentKey() {
          return currentKey.value;
        }
        function setCurrentKey(key) {
          currentKey.value = key;
        }
        function setData(data) {
          nextTick(() => tree.value = createTree(data));
        }
        function getNode(data) {
          var _a2;
          const key = isObject$1(data) ? getKey(data) : data;
          return (_a2 = tree.value) == null ? void 0 : _a2.treeNodeMap.get(key);
        }
        return {
          tree,
          flattenTree,
          isNotEmpty,
          getKey,
          getChildren,
          toggleExpand,
          toggleCheckbox,
          isExpanded,
          isChecked,
          isIndeterminate,
          isDisabled,
          isCurrent,
          isForceHiddenExpandIcon,
          handleNodeClick,
          handleNodeCheck,
          getCurrentNode,
          getCurrentKey,
          setCurrentKey,
          getCheckedKeys,
          getCheckedNodes,
          getHalfCheckedKeys,
          getHalfCheckedNodes,
          setChecked: setChecked2,
          setCheckedKeys,
          filter,
          setData,
          getNode,
          expandNode,
          collapseNode,
          setExpandedKeys
        };
      }
      var ElNodeContent = defineComponent({
        name: "ElTreeNodeContent",
        props: treeNodeContentProps,
        setup(props) {
          const tree = inject(ROOT_TREE_INJECTION_KEY);
          const ns = useNamespace("tree");
          return () => {
            const node = props.node;
            const { data } = node;
            return (tree == null ? void 0 : tree.ctx.slots.default) ? tree.ctx.slots.default({ node, data }) : h$1("span", { class: ns.be("node", "label") }, [node == null ? void 0 : node.label]);
          };
        }
      });
      const _hoisted_1$t = ["aria-expanded", "aria-disabled", "aria-checked", "data-key", "onClick"];
      const __default__$3 = defineComponent({
        name: "ElTreeNode"
      });
      const _sfc_main$d = /* @__PURE__ */ defineComponent({
        ...__default__$3,
        props: treeNodeProps,
        emits: treeNodeEmits,
        setup(__props, { emit: emit2 }) {
          const props = __props;
          const tree = inject(ROOT_TREE_INJECTION_KEY);
          const ns = useNamespace("tree");
          const indent = computed(() => {
            var _a2;
            return (_a2 = tree == null ? void 0 : tree.props.indent) != null ? _a2 : 16;
          });
          const icon = computed(() => {
            var _a2;
            return (_a2 = tree == null ? void 0 : tree.props.icon) != null ? _a2 : caret_right_default;
          });
          const handleClick = (e2) => {
            emit2("click", props.node, e2);
          };
          const handleExpandIconClick = () => {
            emit2("toggle", props.node);
          };
          const handleCheckChange = (value) => {
            emit2("check", props.node, value);
          };
          const handleContextMenu = (event) => {
            var _a2, _b, _c, _d;
            if ((_c = (_b = (_a2 = tree == null ? void 0 : tree.instance) == null ? void 0 : _a2.vnode) == null ? void 0 : _b.props) == null ? void 0 : _c["onNodeContextmenu"]) {
              event.stopPropagation();
              event.preventDefault();
            }
            tree == null ? void 0 : tree.ctx.emit(NODE_CONTEXTMENU, event, (_d = props.node) == null ? void 0 : _d.data, props.node);
          };
          return (_ctx, _cache) => {
            var _a2, _b, _c;
            return openBlock(), createElementBlock("div", {
              ref: "node$",
              class: normalizeClass([
                unref(ns).b("node"),
                unref(ns).is("expanded", _ctx.expanded),
                unref(ns).is("current", _ctx.current),
                unref(ns).is("focusable", !_ctx.disabled),
                unref(ns).is("checked", !_ctx.disabled && _ctx.checked)
              ]),
              role: "treeitem",
              tabindex: "-1",
              "aria-expanded": _ctx.expanded,
              "aria-disabled": _ctx.disabled,
              "aria-checked": _ctx.checked,
              "data-key": (_a2 = _ctx.node) == null ? void 0 : _a2.key,
              onClick: withModifiers(handleClick, ["stop"]),
              onContextmenu: handleContextMenu
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).be("node", "content")),
                style: normalizeStyle({
                  paddingLeft: `${(_ctx.node.level - 1) * unref(indent)}px`,
                  height: _ctx.itemSize + "px"
                })
              }, [
                unref(icon) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass([
                    unref(ns).is("leaf", !!((_b = _ctx.node) == null ? void 0 : _b.isLeaf)),
                    unref(ns).is("hidden", _ctx.hiddenExpandIcon),
                    {
                      expanded: !((_c = _ctx.node) == null ? void 0 : _c.isLeaf) && _ctx.expanded
                    },
                    unref(ns).be("node", "expand-icon")
                  ]),
                  onClick: withModifiers(handleExpandIconClick, ["stop"])
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(icon))))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                _ctx.showCheckbox ? (openBlock(), createBlock(unref(ElCheckbox), {
                  key: 1,
                  "model-value": _ctx.checked,
                  indeterminate: _ctx.indeterminate,
                  disabled: _ctx.disabled,
                  onChange: handleCheckChange,
                  onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                  }, ["stop"]))
                }, null, 8, ["model-value", "indeterminate", "disabled"])) : createCommentVNode("v-if", true),
                createVNode(unref(ElNodeContent), { node: _ctx.node }, null, 8, ["node"])
              ], 6)
            ], 42, _hoisted_1$t);
          };
        }
      });
      var ElTreeNode = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree-node.vue"]]);
      const __default__$2 = defineComponent({
        name: "ElTreeV2"
      });
      const _sfc_main$c = /* @__PURE__ */ defineComponent({
        ...__default__$2,
        props: treeProps,
        emits: treeEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const slots = useSlots();
          const treeNodeSize = computed(() => props.itemSize);
          provide(ROOT_TREE_INJECTION_KEY, {
            ctx: {
              emit: emit2,
              slots
            },
            props,
            instance: getCurrentInstance()
          });
          provide(formItemContextKey, void 0);
          const { t: t2 } = useLocale();
          const ns = useNamespace("tree");
          const {
            flattenTree,
            isNotEmpty,
            toggleExpand,
            isExpanded,
            isIndeterminate,
            isChecked,
            isDisabled,
            isCurrent,
            isForceHiddenExpandIcon,
            handleNodeClick,
            handleNodeCheck,
            toggleCheckbox,
            getCurrentNode,
            getCurrentKey,
            setCurrentKey,
            getCheckedKeys,
            getCheckedNodes,
            getHalfCheckedKeys,
            getHalfCheckedNodes,
            setChecked: setChecked2,
            setCheckedKeys,
            filter,
            setData,
            getNode,
            expandNode,
            collapseNode,
            setExpandedKeys
          } = useTree(props, emit2);
          expose({
            toggleCheckbox,
            getCurrentNode,
            getCurrentKey,
            setCurrentKey,
            getCheckedKeys,
            getCheckedNodes,
            getHalfCheckedKeys,
            getHalfCheckedNodes,
            setChecked: setChecked2,
            setCheckedKeys,
            filter,
            setData,
            getNode,
            expandNode,
            collapseNode,
            setExpandedKeys
          });
          return (_ctx, _cache) => {
            var _a2;
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b(), { [unref(ns).m("highlight-current")]: _ctx.highlightCurrent }]),
              role: "tree"
            }, [
              unref(isNotEmpty) ? (openBlock(), createBlock(unref(FixedSizeList), {
                key: 0,
                "class-name": unref(ns).b("virtual-list"),
                data: unref(flattenTree),
                total: unref(flattenTree).length,
                height: _ctx.height,
                "item-size": unref(treeNodeSize),
                "perf-mode": _ctx.perfMode
              }, {
                default: withCtx(({ data, index, style }) => [
                  (openBlock(), createBlock(ElTreeNode, {
                    key: data[index].key,
                    style: normalizeStyle(style),
                    node: data[index],
                    expanded: unref(isExpanded)(data[index]),
                    "show-checkbox": _ctx.showCheckbox,
                    checked: unref(isChecked)(data[index]),
                    indeterminate: unref(isIndeterminate)(data[index]),
                    "item-size": unref(treeNodeSize),
                    disabled: unref(isDisabled)(data[index]),
                    current: unref(isCurrent)(data[index]),
                    "hidden-expand-icon": unref(isForceHiddenExpandIcon)(data[index]),
                    onClick: unref(handleNodeClick),
                    onToggle: unref(toggleExpand),
                    onCheck: unref(handleNodeCheck)
                  }, null, 8, ["style", "node", "expanded", "show-checkbox", "checked", "indeterminate", "item-size", "disabled", "current", "hidden-expand-icon", "onClick", "onToggle", "onCheck"]))
                ]),
                _: 1
              }, 8, ["class-name", "data", "total", "height", "item-size", "perf-mode"])) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).e("empty-block"))
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(unref(ns).e("empty-text"))
                }, toDisplayString((_a2 = _ctx.emptyText) != null ? _a2 : unref(t2)("el.tree.emptyText")), 3)
              ], 2))
            ], 2);
          };
        }
      });
      var TreeV2 = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree.vue"]]);
      const ElTreeV2 = withInstall(TreeV2);
      const messageTypes = ["success", "info", "warning", "error"];
      const messageDefaults = mutable({
        customClass: "",
        center: false,
        dangerouslyUseHTMLString: false,
        duration: 3e3,
        icon: void 0,
        id: "",
        message: "",
        onClose: void 0,
        showClose: false,
        type: "info",
        offset: 16,
        zIndex: 0,
        grouping: false,
        repeatNum: 1,
        appendTo: isClient$1 ? document.body : void 0
      });
      const messageProps = buildProps({
        customClass: {
          type: String,
          default: messageDefaults.customClass
        },
        center: {
          type: Boolean,
          default: messageDefaults.center
        },
        dangerouslyUseHTMLString: {
          type: Boolean,
          default: messageDefaults.dangerouslyUseHTMLString
        },
        duration: {
          type: Number,
          default: messageDefaults.duration
        },
        icon: {
          type: iconPropType,
          default: messageDefaults.icon
        },
        id: {
          type: String,
          default: messageDefaults.id
        },
        message: {
          type: definePropType([
            String,
            Object,
            Function
          ]),
          default: messageDefaults.message
        },
        onClose: {
          type: definePropType(Function),
          required: false
        },
        showClose: {
          type: Boolean,
          default: messageDefaults.showClose
        },
        type: {
          type: String,
          values: messageTypes,
          default: messageDefaults.type
        },
        offset: {
          type: Number,
          default: messageDefaults.offset
        },
        zIndex: {
          type: Number,
          default: messageDefaults.zIndex
        },
        grouping: {
          type: Boolean,
          default: messageDefaults.grouping
        },
        repeatNum: {
          type: Number,
          default: messageDefaults.repeatNum
        }
      });
      const messageEmits = {
        destroy: () => true
      };
      const instances = shallowReactive([]);
      const getInstance = (id2) => {
        const idx = instances.findIndex((instance) => instance.id === id2);
        const current = instances[idx];
        let prev;
        if (idx > 0) {
          prev = instances[idx - 1];
        }
        return { current, prev };
      };
      const getLastOffset = (id2) => {
        const { prev } = getInstance(id2);
        if (!prev)
          return 0;
        return prev.vm.exposed.bottom.value;
      };
      const getOffsetOrSpace = (id2, offset) => {
        const idx = instances.findIndex((instance) => instance.id === id2);
        return idx > 0 ? 20 : offset;
      };
      const _hoisted_1$s = ["id"];
      const _hoisted_2$q = ["innerHTML"];
      const __default__$1 = defineComponent({
        name: "ElMessage"
      });
      const _sfc_main$b = /* @__PURE__ */ defineComponent({
        ...__default__$1,
        props: messageProps,
        emits: messageEmits,
        setup(__props, { expose }) {
          const props = __props;
          const { Close } = TypeComponents;
          const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("message");
          const { currentZIndex, nextZIndex } = zIndex2;
          const messageRef = ref();
          const visible = ref(false);
          const height = ref(0);
          let stopTimer = void 0;
          const badgeType = computed(() => props.type ? props.type === "error" ? "danger" : props.type : "info");
          const typeClass = computed(() => {
            const type2 = props.type;
            return { [ns.bm("icon", type2)]: type2 && TypeComponentsMap[type2] };
          });
          const iconComponent = computed(() => props.icon || TypeComponentsMap[props.type] || "");
          const lastOffset = computed(() => getLastOffset(props.id));
          const offset = computed(() => getOffsetOrSpace(props.id, props.offset) + lastOffset.value);
          const bottom = computed(() => height.value + offset.value);
          const customStyle = computed(() => ({
            top: `${offset.value}px`,
            zIndex: currentZIndex.value
          }));
          function startTimer() {
            if (props.duration === 0)
              return;
            ({ stop: stopTimer } = useTimeoutFn$1(() => {
              close2();
            }, props.duration));
          }
          function clearTimer() {
            stopTimer == null ? void 0 : stopTimer();
          }
          function close2() {
            visible.value = false;
          }
          function keydown({ code }) {
            if (code === EVENT_CODE.esc) {
              close2();
            }
          }
          onMounted(() => {
            startTimer();
            nextZIndex();
            visible.value = true;
          });
          watch(() => props.repeatNum, () => {
            clearTimer();
            startTimer();
          });
          useEventListener$1(document, "keydown", keydown);
          useResizeObserver(messageRef, () => {
            height.value = messageRef.value.getBoundingClientRect().height;
          });
          expose({
            visible,
            bottom,
            close: close2
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              onBeforeLeave: _ctx.onClose,
              onAfterLeave: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("destroy")),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  id: _ctx.id,
                  ref_key: "messageRef",
                  ref: messageRef,
                  class: normalizeClass([
                    unref(ns).b(),
                    { [unref(ns).m(_ctx.type)]: _ctx.type && !_ctx.icon },
                    unref(ns).is("center", _ctx.center),
                    unref(ns).is("closable", _ctx.showClose),
                    _ctx.customClass
                  ]),
                  style: normalizeStyle(unref(customStyle)),
                  role: "alert",
                  onMouseenter: clearTimer,
                  onMouseleave: startTimer
                }, [
                  _ctx.repeatNum > 1 ? (openBlock(), createBlock(unref(ElBadge), {
                    key: 0,
                    value: _ctx.repeatNum,
                    type: unref(badgeType),
                    class: normalizeClass(unref(ns).e("badge"))
                  }, null, 8, ["value", "type", "class"])) : createCommentVNode("v-if", true),
                  unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass([unref(ns).e("icon"), unref(typeClass)])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  renderSlot(_ctx.$slots, "default", {}, () => [
                    !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", {
                      key: 0,
                      class: normalizeClass(unref(ns).e("content"))
                    }, toDisplayString(_ctx.message), 3)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                      createBaseVNode("p", {
                        class: normalizeClass(unref(ns).e("content")),
                        innerHTML: _ctx.message
                      }, null, 10, _hoisted_2$q)
                    ], 2112))
                  ]),
                  _ctx.showClose ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 2,
                    class: normalizeClass(unref(ns).e("closeBtn")),
                    onClick: withModifiers(close2, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(Close))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ], 46, _hoisted_1$s), [
                  [vShow, visible.value]
                ])
              ]),
              _: 3
            }, 8, ["name", "onBeforeLeave"]);
          };
        }
      });
      var MessageConstructor = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]]);
      let seed$1 = 1;
      const normalizeOptions = (params) => {
        const options = !params || isString$1(params) || isVNode(params) || isFunction$1(params) ? { message: params } : params;
        const normalized = {
          ...messageDefaults,
          ...options
        };
        if (!normalized.appendTo) {
          normalized.appendTo = document.body;
        } else if (isString$1(normalized.appendTo)) {
          let appendTo = document.querySelector(normalized.appendTo);
          if (!isElement(appendTo)) {
            appendTo = document.body;
          }
          normalized.appendTo = appendTo;
        }
        return normalized;
      };
      const closeMessage = (instance) => {
        const idx = instances.indexOf(instance);
        if (idx === -1)
          return;
        instances.splice(idx, 1);
        const { handler } = instance;
        handler.close();
      };
      const createMessage = ({ appendTo, ...options }, context) => {
        const id2 = `message_${seed$1++}`;
        const userOnClose = options.onClose;
        const container = document.createElement("div");
        const props = {
          ...options,
          id: id2,
          onClose: () => {
            userOnClose == null ? void 0 : userOnClose();
            closeMessage(instance);
          },
          onDestroy: () => {
            render$i(null, container);
          }
        };
        const vnode = createVNode(MessageConstructor, props, isFunction$1(props.message) || isVNode(props.message) ? {
          default: isFunction$1(props.message) ? props.message : () => props.message
        } : null);
        vnode.appContext = context || message._context;
        render$i(vnode, container);
        appendTo.appendChild(container.firstElementChild);
        const vm = vnode.component;
        const handler = {
          close: () => {
            vm.exposed.visible.value = false;
          }
        };
        const instance = {
          id: id2,
          vnode,
          vm,
          handler,
          props: vnode.component.props
        };
        return instance;
      };
      const message = (options = {}, context) => {
        if (!isClient$1)
          return { close: () => void 0 };
        if (isNumber(messageConfig.max) && instances.length >= messageConfig.max) {
          return { close: () => void 0 };
        }
        const normalized = normalizeOptions(options);
        if (normalized.grouping && instances.length) {
          const instance2 = instances.find(({ vnode: vm }) => {
            var _a2;
            return ((_a2 = vm.props) == null ? void 0 : _a2.message) === normalized.message;
          });
          if (instance2) {
            instance2.props.repeatNum += 1;
            instance2.props.type = normalized.type;
            return instance2.handler;
          }
        }
        const instance = createMessage(normalized, context);
        instances.push(instance);
        return instance.handler;
      };
      messageTypes.forEach((type2) => {
        message[type2] = (options = {}, appContext) => {
          const normalized = normalizeOptions(options);
          return message({ ...normalized, type: type2 }, appContext);
        };
      });
      function closeAll$1(type2) {
        for (const instance of instances) {
          if (!type2 || type2 === instance.props.type) {
            instance.handler.close();
          }
        }
      }
      message.closeAll = closeAll$1;
      message._context = null;
      const ElMessage = withInstallFunction(message, "$message");
      const _sfc_main$a = defineComponent({
        name: "ElMessageBox",
        directives: {
          TrapFocus
        },
        components: {
          ElButton,
          ElFocusTrap,
          ElInput,
          ElOverlay,
          ElIcon,
          ...TypeComponents
        },
        inheritAttrs: false,
        props: {
          buttonSize: {
            type: String,
            validator: isValidComponentSize
          },
          modal: {
            type: Boolean,
            default: true
          },
          lockScroll: {
            type: Boolean,
            default: true
          },
          showClose: {
            type: Boolean,
            default: true
          },
          closeOnClickModal: {
            type: Boolean,
            default: true
          },
          closeOnPressEscape: {
            type: Boolean,
            default: true
          },
          closeOnHashChange: {
            type: Boolean,
            default: true
          },
          center: Boolean,
          draggable: Boolean,
          roundButton: {
            default: false,
            type: Boolean
          },
          container: {
            type: String,
            default: "body"
          },
          boxType: {
            type: String,
            default: ""
          }
        },
        emits: ["vanish", "action"],
        setup(props, { emit: emit2 }) {
          const {
            locale,
            zIndex: zIndex2,
            ns,
            size: btnSize
          } = useGlobalComponentSettings("message-box", computed(() => props.buttonSize));
          const { t: t2 } = locale;
          const { nextZIndex } = zIndex2;
          const visible = ref(false);
          const state = reactive({
            autofocus: true,
            beforeClose: null,
            callback: null,
            cancelButtonText: "",
            cancelButtonClass: "",
            confirmButtonText: "",
            confirmButtonClass: "",
            customClass: "",
            customStyle: {},
            dangerouslyUseHTMLString: false,
            distinguishCancelAndClose: false,
            icon: "",
            inputPattern: null,
            inputPlaceholder: "",
            inputType: "text",
            inputValue: null,
            inputValidator: null,
            inputErrorMessage: "",
            message: null,
            modalFade: true,
            modalClass: "",
            showCancelButton: false,
            showConfirmButton: true,
            type: "",
            title: void 0,
            showInput: false,
            action: "",
            confirmButtonLoading: false,
            cancelButtonLoading: false,
            confirmButtonDisabled: false,
            editorErrorMessage: "",
            validateError: false,
            zIndex: nextZIndex()
          });
          const typeClass = computed(() => {
            const type2 = state.type;
            return { [ns.bm("icon", type2)]: type2 && TypeComponentsMap[type2] };
          });
          const contentId = useId();
          const inputId = useId();
          const iconComponent = computed(() => state.icon || TypeComponentsMap[state.type] || "");
          const hasMessage = computed(() => !!state.message);
          const rootRef = ref();
          const headerRef = ref();
          const focusStartRef = ref();
          const inputRef = ref();
          const confirmRef = ref();
          const confirmButtonClasses = computed(() => state.confirmButtonClass);
          watch(() => state.inputValue, async (val) => {
            await nextTick();
            if (props.boxType === "prompt" && val !== null) {
              validate();
            }
          }, { immediate: true });
          watch(() => visible.value, (val) => {
            var _a2, _b;
            if (val) {
              if (props.boxType !== "prompt") {
                if (state.autofocus) {
                  focusStartRef.value = (_b = (_a2 = confirmRef.value) == null ? void 0 : _a2.$el) != null ? _b : rootRef.value;
                } else {
                  focusStartRef.value = rootRef.value;
                }
              }
              state.zIndex = nextZIndex();
            }
            if (props.boxType !== "prompt")
              return;
            if (val) {
              nextTick().then(() => {
                var _a22;
                if (inputRef.value && inputRef.value.$el) {
                  if (state.autofocus) {
                    focusStartRef.value = (_a22 = getInputElement()) != null ? _a22 : rootRef.value;
                  } else {
                    focusStartRef.value = rootRef.value;
                  }
                }
              });
            } else {
              state.editorErrorMessage = "";
              state.validateError = false;
            }
          });
          const draggable = computed(() => props.draggable);
          useDraggable(rootRef, headerRef, draggable);
          onMounted(async () => {
            await nextTick();
            if (props.closeOnHashChange) {
              window.addEventListener("hashchange", doClose);
            }
          });
          onBeforeUnmount(() => {
            if (props.closeOnHashChange) {
              window.removeEventListener("hashchange", doClose);
            }
          });
          function doClose() {
            if (!visible.value)
              return;
            visible.value = false;
            nextTick(() => {
              if (state.action)
                emit2("action", state.action);
            });
          }
          const handleWrapperClick = () => {
            if (props.closeOnClickModal) {
              handleAction(state.distinguishCancelAndClose ? "close" : "cancel");
            }
          };
          const overlayEvent = useSameTarget(handleWrapperClick);
          const handleInputEnter = (e2) => {
            if (state.inputType !== "textarea") {
              e2.preventDefault();
              return handleAction("confirm");
            }
          };
          const handleAction = (action) => {
            var _a2;
            if (props.boxType === "prompt" && action === "confirm" && !validate()) {
              return;
            }
            state.action = action;
            if (state.beforeClose) {
              (_a2 = state.beforeClose) == null ? void 0 : _a2.call(state, action, state, doClose);
            } else {
              doClose();
            }
          };
          const validate = () => {
            if (props.boxType === "prompt") {
              const inputPattern = state.inputPattern;
              if (inputPattern && !inputPattern.test(state.inputValue || "")) {
                state.editorErrorMessage = state.inputErrorMessage || t2("el.messagebox.error");
                state.validateError = true;
                return false;
              }
              const inputValidator = state.inputValidator;
              if (typeof inputValidator === "function") {
                const validateResult = inputValidator(state.inputValue);
                if (validateResult === false) {
                  state.editorErrorMessage = state.inputErrorMessage || t2("el.messagebox.error");
                  state.validateError = true;
                  return false;
                }
                if (typeof validateResult === "string") {
                  state.editorErrorMessage = validateResult;
                  state.validateError = true;
                  return false;
                }
              }
            }
            state.editorErrorMessage = "";
            state.validateError = false;
            return true;
          };
          const getInputElement = () => {
            const inputRefs = inputRef.value.$refs;
            return inputRefs.input || inputRefs.textarea;
          };
          const handleClose = () => {
            handleAction("close");
          };
          const onCloseRequested = () => {
            if (props.closeOnPressEscape) {
              handleClose();
            }
          };
          if (props.lockScroll) {
            useLockscreen(visible);
          }
          return {
            ...toRefs(state),
            ns,
            overlayEvent,
            visible,
            hasMessage,
            typeClass,
            contentId,
            inputId,
            btnSize,
            iconComponent,
            confirmButtonClasses,
            rootRef,
            focusStartRef,
            headerRef,
            inputRef,
            confirmRef,
            doClose,
            handleClose,
            onCloseRequested,
            handleWrapperClick,
            handleInputEnter,
            handleAction,
            t: t2
          };
        }
      });
      const _hoisted_1$r = ["aria-label", "aria-describedby"];
      const _hoisted_2$p = ["aria-label"];
      const _hoisted_3$n = ["id"];
      function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_icon = resolveComponent("el-icon");
        const _component_close = resolveComponent("close");
        const _component_el_input = resolveComponent("el-input");
        const _component_el_button = resolveComponent("el-button");
        const _component_el_focus_trap = resolveComponent("el-focus-trap");
        const _component_el_overlay = resolveComponent("el-overlay");
        return openBlock(), createBlock(Transition, {
          name: "fade-in-linear",
          onAfterLeave: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("vanish")),
          persisted: ""
        }, {
          default: withCtx(() => [
            withDirectives(createVNode(_component_el_overlay, {
              "z-index": _ctx.zIndex,
              "overlay-class": [_ctx.ns.is("message-box"), _ctx.modalClass],
              mask: _ctx.modal
            }, {
              default: withCtx(() => [
                createBaseVNode("div", {
                  role: "dialog",
                  "aria-label": _ctx.title,
                  "aria-modal": "true",
                  "aria-describedby": !_ctx.showInput ? _ctx.contentId : void 0,
                  class: normalizeClass(`${_ctx.ns.namespace.value}-overlay-message-box`),
                  onClick: _cache[8] || (_cache[8] = (...args) => _ctx.overlayEvent.onClick && _ctx.overlayEvent.onClick(...args)),
                  onMousedown: _cache[9] || (_cache[9] = (...args) => _ctx.overlayEvent.onMousedown && _ctx.overlayEvent.onMousedown(...args)),
                  onMouseup: _cache[10] || (_cache[10] = (...args) => _ctx.overlayEvent.onMouseup && _ctx.overlayEvent.onMouseup(...args))
                }, [
                  createVNode(_component_el_focus_trap, {
                    loop: "",
                    trapped: _ctx.visible,
                    "focus-trap-el": _ctx.rootRef,
                    "focus-start-el": _ctx.focusStartRef,
                    onReleaseRequested: _ctx.onCloseRequested
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        ref: "rootRef",
                        class: normalizeClass([
                          _ctx.ns.b(),
                          _ctx.customClass,
                          _ctx.ns.is("draggable", _ctx.draggable),
                          { [_ctx.ns.m("center")]: _ctx.center }
                        ]),
                        style: normalizeStyle(_ctx.customStyle),
                        tabindex: "-1",
                        onClick: _cache[7] || (_cache[7] = withModifiers(() => {
                        }, ["stop"]))
                      }, [
                        _ctx.title !== null && _ctx.title !== void 0 ? (openBlock(), createElementBlock("div", {
                          key: 0,
                          ref: "headerRef",
                          class: normalizeClass(_ctx.ns.e("header"))
                        }, [
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.ns.e("title"))
                          }, [
                            _ctx.iconComponent && _ctx.center ? (openBlock(), createBlock(_component_el_icon, {
                              key: 0,
                              class: normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                            }, {
                              default: withCtx(() => [
                                (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                              ]),
                              _: 1
                            }, 8, ["class"])) : createCommentVNode("v-if", true),
                            createBaseVNode("span", null, toDisplayString(_ctx.title), 1)
                          ], 2),
                          _ctx.showClose ? (openBlock(), createElementBlock("button", {
                            key: 0,
                            type: "button",
                            class: normalizeClass(_ctx.ns.e("headerbtn")),
                            "aria-label": _ctx.t("el.messagebox.close"),
                            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel")),
                            onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
                          }, [
                            createVNode(_component_el_icon, {
                              class: normalizeClass(_ctx.ns.e("close"))
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_close)
                              ]),
                              _: 1
                            }, 8, ["class"])
                          ], 42, _hoisted_2$p)) : createCommentVNode("v-if", true)
                        ], 2)) : createCommentVNode("v-if", true),
                        createBaseVNode("div", {
                          id: _ctx.contentId,
                          class: normalizeClass(_ctx.ns.e("content"))
                        }, [
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.ns.e("container"))
                          }, [
                            _ctx.iconComponent && !_ctx.center && _ctx.hasMessage ? (openBlock(), createBlock(_component_el_icon, {
                              key: 0,
                              class: normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                            }, {
                              default: withCtx(() => [
                                (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                              ]),
                              _: 1
                            }, 8, ["class"])) : createCommentVNode("v-if", true),
                            _ctx.hasMessage ? (openBlock(), createElementBlock("div", {
                              key: 1,
                              class: normalizeClass(_ctx.ns.e("message"))
                            }, [
                              renderSlot(_ctx.$slots, "default", {}, () => [
                                !_ctx.dangerouslyUseHTMLString ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                                  key: 0,
                                  for: _ctx.showInput ? _ctx.inputId : void 0
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString(!_ctx.dangerouslyUseHTMLString ? _ctx.message : ""), 1)
                                  ]),
                                  _: 1
                                }, 8, ["for"])) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                                  key: 1,
                                  for: _ctx.showInput ? _ctx.inputId : void 0,
                                  innerHTML: _ctx.message
                                }, null, 8, ["for", "innerHTML"]))
                              ])
                            ], 2)) : createCommentVNode("v-if", true)
                          ], 2),
                          withDirectives(createBaseVNode("div", {
                            class: normalizeClass(_ctx.ns.e("input"))
                          }, [
                            createVNode(_component_el_input, {
                              id: _ctx.inputId,
                              ref: "inputRef",
                              modelValue: _ctx.inputValue,
                              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.inputValue = $event),
                              type: _ctx.inputType,
                              placeholder: _ctx.inputPlaceholder,
                              "aria-invalid": _ctx.validateError,
                              class: normalizeClass({ invalid: _ctx.validateError }),
                              onKeydown: withKeys(_ctx.handleInputEnter, ["enter"])
                            }, null, 8, ["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                            createBaseVNode("div", {
                              class: normalizeClass(_ctx.ns.e("errormsg")),
                              style: normalizeStyle({
                                visibility: !!_ctx.editorErrorMessage ? "visible" : "hidden"
                              })
                            }, toDisplayString(_ctx.editorErrorMessage), 7)
                          ], 2), [
                            [vShow, _ctx.showInput]
                          ])
                        ], 10, _hoisted_3$n),
                        createBaseVNode("div", {
                          class: normalizeClass(_ctx.ns.e("btns"))
                        }, [
                          _ctx.showCancelButton ? (openBlock(), createBlock(_component_el_button, {
                            key: 0,
                            loading: _ctx.cancelButtonLoading,
                            class: normalizeClass([_ctx.cancelButtonClass]),
                            round: _ctx.roundButton,
                            size: _ctx.btnSize,
                            onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleAction("cancel")),
                            onKeydown: _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.handleAction("cancel"), ["prevent"]), ["enter"]))
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(_ctx.cancelButtonText || _ctx.t("el.messagebox.cancel")), 1)
                            ]),
                            _: 1
                          }, 8, ["loading", "class", "round", "size"])) : createCommentVNode("v-if", true),
                          withDirectives(createVNode(_component_el_button, {
                            ref: "confirmRef",
                            type: "primary",
                            loading: _ctx.confirmButtonLoading,
                            class: normalizeClass([_ctx.confirmButtonClasses]),
                            round: _ctx.roundButton,
                            disabled: _ctx.confirmButtonDisabled,
                            size: _ctx.btnSize,
                            onClick: _cache[5] || (_cache[5] = ($event) => _ctx.handleAction("confirm")),
                            onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.handleAction("confirm"), ["prevent"]), ["enter"]))
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(_ctx.confirmButtonText || _ctx.t("el.messagebox.confirm")), 1)
                            ]),
                            _: 1
                          }, 8, ["loading", "class", "round", "disabled", "size"]), [
                            [vShow, _ctx.showConfirmButton]
                          ])
                        ], 2)
                      ], 6)
                    ]),
                    _: 3
                  }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
                ], 42, _hoisted_1$r)
              ]),
              _: 3
            }, 8, ["z-index", "overlay-class", "mask"]), [
              [vShow, _ctx.visible]
            ])
          ]),
          _: 3
        });
      }
      var MessageBoxConstructor = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["render", _sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/message-box/src/index.vue"]]);
      const messageInstance = /* @__PURE__ */ new Map();
      const getAppendToElement = (props) => {
        let appendTo = document.body;
        if (props.appendTo) {
          if (isString$1(props.appendTo)) {
            appendTo = document.querySelector(props.appendTo);
          }
          if (isElement(props.appendTo)) {
            appendTo = props.appendTo;
          }
          if (!isElement(appendTo)) {
            appendTo = document.body;
          }
        }
        return appendTo;
      };
      const initInstance = (props, container, appContext = null) => {
        const vnode = createVNode(MessageBoxConstructor, props, isFunction$1(props.message) || isVNode(props.message) ? {
          default: isFunction$1(props.message) ? props.message : () => props.message
        } : null);
        vnode.appContext = appContext;
        render$i(vnode, container);
        getAppendToElement(props).appendChild(container.firstElementChild);
        return vnode.component;
      };
      const genContainer = () => {
        return document.createElement("div");
      };
      const showMessage = (options, appContext) => {
        const container = genContainer();
        options.onVanish = () => {
          render$i(null, container);
          messageInstance.delete(vm);
        };
        options.onAction = (action) => {
          const currentMsg = messageInstance.get(vm);
          let resolve2;
          if (options.showInput) {
            resolve2 = { value: vm.inputValue, action };
          } else {
            resolve2 = action;
          }
          if (options.callback) {
            options.callback(resolve2, instance.proxy);
          } else {
            if (action === "cancel" || action === "close") {
              if (options.distinguishCancelAndClose && action !== "cancel") {
                currentMsg.reject("close");
              } else {
                currentMsg.reject("cancel");
              }
            } else {
              currentMsg.resolve(resolve2);
            }
          }
        };
        const instance = initInstance(options, container, appContext);
        const vm = instance.proxy;
        for (const prop in options) {
          if (hasOwn(options, prop) && !hasOwn(vm.$props, prop)) {
            vm[prop] = options[prop];
          }
        }
        vm.visible = true;
        return vm;
      };
      function MessageBox(options, appContext = null) {
        if (!isClient$1)
          return Promise.reject();
        let callback;
        if (isString$1(options) || isVNode(options)) {
          options = {
            message: options
          };
        } else {
          callback = options.callback;
        }
        return new Promise((resolve2, reject) => {
          const vm = showMessage(options, appContext != null ? appContext : MessageBox._context);
          messageInstance.set(vm, {
            options,
            callback,
            resolve: resolve2,
            reject
          });
        });
      }
      const MESSAGE_BOX_VARIANTS = ["alert", "confirm", "prompt"];
      const MESSAGE_BOX_DEFAULT_OPTS = {
        alert: { closeOnPressEscape: false, closeOnClickModal: false },
        confirm: { showCancelButton: true },
        prompt: { showCancelButton: true, showInput: true }
      };
      MESSAGE_BOX_VARIANTS.forEach((boxType) => {
        MessageBox[boxType] = messageBoxFactory(boxType);
      });
      function messageBoxFactory(boxType) {
        return (message2, title, options, appContext) => {
          let titleOrOpts = "";
          if (isObject$1(title)) {
            options = title;
            titleOrOpts = "";
          } else if (isUndefined(title)) {
            titleOrOpts = "";
          } else {
            titleOrOpts = title;
          }
          return MessageBox(Object.assign({
            title: titleOrOpts,
            message: message2,
            type: "",
            ...MESSAGE_BOX_DEFAULT_OPTS[boxType]
          }, options, {
            boxType
          }), appContext);
        };
      }
      MessageBox.close = () => {
        messageInstance.forEach((_2, vm) => {
          vm.doClose();
        });
        messageInstance.clear();
      };
      MessageBox._context = null;
      const _MessageBox = MessageBox;
      _MessageBox.install = (app2) => {
        _MessageBox._context = app2._context;
        app2.config.globalProperties.$msgbox = _MessageBox;
        app2.config.globalProperties.$messageBox = _MessageBox;
        app2.config.globalProperties.$alert = _MessageBox.alert;
        app2.config.globalProperties.$confirm = _MessageBox.confirm;
        app2.config.globalProperties.$prompt = _MessageBox.prompt;
      };
      const ElMessageBox = _MessageBox;
      const notificationTypes = [
        "success",
        "info",
        "warning",
        "error"
      ];
      const notificationProps = buildProps({
        customClass: {
          type: String,
          default: ""
        },
        dangerouslyUseHTMLString: {
          type: Boolean,
          default: false
        },
        duration: {
          type: Number,
          default: 4500
        },
        icon: {
          type: iconPropType
        },
        id: {
          type: String,
          default: ""
        },
        message: {
          type: definePropType([String, Object]),
          default: ""
        },
        offset: {
          type: Number,
          default: 0
        },
        onClick: {
          type: definePropType(Function),
          default: () => void 0
        },
        onClose: {
          type: definePropType(Function),
          required: true
        },
        position: {
          type: String,
          values: ["top-right", "top-left", "bottom-right", "bottom-left"],
          default: "top-right"
        },
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        },
        type: {
          type: String,
          values: [...notificationTypes, ""],
          default: ""
        },
        zIndex: Number
      });
      const notificationEmits = {
        destroy: () => true
      };
      const _hoisted_1$q = ["id"];
      const _hoisted_2$o = ["textContent"];
      const _hoisted_3$m = { key: 0 };
      const _hoisted_4$7 = ["innerHTML"];
      const __default__ = defineComponent({
        name: "ElNotification"
      });
      const _sfc_main$9 = /* @__PURE__ */ defineComponent({
        ...__default__,
        props: notificationProps,
        emits: notificationEmits,
        setup(__props, { expose }) {
          const props = __props;
          const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("notification");
          const { nextZIndex, currentZIndex } = zIndex2;
          const { Close } = CloseComponents;
          const visible = ref(false);
          let timer = void 0;
          const typeClass = computed(() => {
            const type2 = props.type;
            return type2 && TypeComponentsMap[props.type] ? ns.m(type2) : "";
          });
          const iconComponent = computed(() => {
            if (!props.type)
              return props.icon;
            return TypeComponentsMap[props.type] || props.icon;
          });
          const horizontalClass = computed(() => props.position.endsWith("right") ? "right" : "left");
          const verticalProperty = computed(() => props.position.startsWith("top") ? "top" : "bottom");
          const positionStyle = computed(() => {
            var _a2;
            return {
              [verticalProperty.value]: `${props.offset}px`,
              zIndex: (_a2 = props.zIndex) != null ? _a2 : currentZIndex.value
            };
          });
          function startTimer() {
            if (props.duration > 0) {
              ({ stop: timer } = useTimeoutFn$1(() => {
                if (visible.value)
                  close2();
              }, props.duration));
            }
          }
          function clearTimer() {
            timer == null ? void 0 : timer();
          }
          function close2() {
            visible.value = false;
          }
          function onKeydown({ code }) {
            if (code === EVENT_CODE.delete || code === EVENT_CODE.backspace) {
              clearTimer();
            } else if (code === EVENT_CODE.esc) {
              if (visible.value) {
                close2();
              }
            } else {
              startTimer();
            }
          }
          onMounted(() => {
            startTimer();
            nextZIndex();
            visible.value = true;
          });
          useEventListener$1(document, "keydown", onKeydown);
          expose({
            visible,
            close: close2
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              onBeforeLeave: _ctx.onClose,
              onAfterLeave: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("destroy")),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  id: _ctx.id,
                  class: normalizeClass([unref(ns).b(), _ctx.customClass, unref(horizontalClass)]),
                  style: normalizeStyle(unref(positionStyle)),
                  role: "alert",
                  onMouseenter: clearTimer,
                  onMouseleave: startTimer,
                  onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
                }, [
                  unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass([unref(ns).e("icon"), unref(typeClass)])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ns).e("group"))
                  }, [
                    createBaseVNode("h2", {
                      class: normalizeClass(unref(ns).e("title")),
                      textContent: toDisplayString(_ctx.title)
                    }, null, 10, _hoisted_2$o),
                    withDirectives(createBaseVNode("div", {
                      class: normalizeClass(unref(ns).e("content")),
                      style: normalizeStyle(!!_ctx.title ? void 0 : { margin: 0 })
                    }, [
                      renderSlot(_ctx.$slots, "default", {}, () => [
                        !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", _hoisted_3$m, toDisplayString(_ctx.message), 1)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                          createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                          createBaseVNode("p", { innerHTML: _ctx.message }, null, 8, _hoisted_4$7)
                        ], 2112))
                      ])
                    ], 6), [
                      [vShow, _ctx.message]
                    ]),
                    _ctx.showClose ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(ns).e("closeBtn")),
                      onClick: withModifiers(close2, ["stop"])
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(Close))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 46, _hoisted_1$q), [
                  [vShow, visible.value]
                ])
              ]),
              _: 3
            }, 8, ["name", "onBeforeLeave"]);
          };
        }
      });
      var NotificationConstructor = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/notification/src/notification.vue"]]);
      const notifications = {
        "top-left": [],
        "top-right": [],
        "bottom-left": [],
        "bottom-right": []
      };
      const GAP_SIZE = 16;
      let seed = 1;
      const notify = function(options = {}, context = null) {
        if (!isClient$1)
          return { close: () => void 0 };
        if (typeof options === "string" || isVNode(options)) {
          options = { message: options };
        }
        const position = options.position || "top-right";
        let verticalOffset = options.offset || 0;
        notifications[position].forEach(({ vm: vm2 }) => {
          var _a2;
          verticalOffset += (((_a2 = vm2.el) == null ? void 0 : _a2.offsetHeight) || 0) + GAP_SIZE;
        });
        verticalOffset += GAP_SIZE;
        const id2 = `notification_${seed++}`;
        const userOnClose = options.onClose;
        const props = {
          ...options,
          offset: verticalOffset,
          id: id2,
          onClose: () => {
            close(id2, position, userOnClose);
          }
        };
        let appendTo = document.body;
        if (isElement(options.appendTo)) {
          appendTo = options.appendTo;
        } else if (isString$1(options.appendTo)) {
          appendTo = document.querySelector(options.appendTo);
        }
        if (!isElement(appendTo)) {
          appendTo = document.body;
        }
        const container = document.createElement("div");
        const vm = createVNode(NotificationConstructor, props, isVNode(props.message) ? {
          default: () => props.message
        } : null);
        vm.appContext = context != null ? context : notify._context;
        vm.props.onDestroy = () => {
          render$i(null, container);
        };
        render$i(vm, container);
        notifications[position].push({ vm });
        appendTo.appendChild(container.firstElementChild);
        return {
          close: () => {
            vm.component.exposed.visible.value = false;
          }
        };
      };
      notificationTypes.forEach((type2) => {
        notify[type2] = (options = {}) => {
          if (typeof options === "string" || isVNode(options)) {
            options = {
              message: options
            };
          }
          return notify({
            ...options,
            type: type2
          });
        };
      });
      function close(id2, position, userOnClose) {
        const orientedNotifications = notifications[position];
        const idx = orientedNotifications.findIndex(({ vm: vm2 }) => {
          var _a2;
          return ((_a2 = vm2.component) == null ? void 0 : _a2.props.id) === id2;
        });
        if (idx === -1)
          return;
        const { vm } = orientedNotifications[idx];
        if (!vm)
          return;
        userOnClose == null ? void 0 : userOnClose(vm);
        const removedHeight = vm.el.offsetHeight;
        const verticalPos = position.split("-")[0];
        orientedNotifications.splice(idx, 1);
        const len = orientedNotifications.length;
        if (len < 1)
          return;
        for (let i2 = idx; i2 < len; i2++) {
          const { el, component } = orientedNotifications[i2].vm;
          const pos = Number.parseInt(el.style[verticalPos], 10) - removedHeight - GAP_SIZE;
          component.props.offset = pos;
        }
      }
      function closeAll() {
        for (const orientedNotifications of Object.values(notifications)) {
          orientedNotifications.forEach(({ vm }) => {
            vm.component.exposed.visible.value = false;
          });
        }
      }
      notify.closeAll = closeAll;
      notify._context = null;
      const ElNotification = withInstallFunction(notify, "$notify");
      const _hoisted_1$p = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$n = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896a448 448 0 0 1 0-896zM288 512a38.4 38.4 0 0 0 38.4 38.4h371.2a38.4 38.4 0 0 0 0-76.8H326.4A38.4 38.4 0 0 0 288 512z"
      }, null, -1);
      const _hoisted_3$l = [
        _hoisted_2$n
      ];
      function render$h(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$p, _hoisted_3$l);
      }
      const __unplugin_components_13 = { name: "ep-remove-filled", render: render$h };
      const _hoisted_1$o = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$m = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M352 480h320a32 32 0 1 1 0 64H352a32 32 0 0 1 0-64z"
      }, null, -1);
      const _hoisted_3$k = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768a384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896a448 448 0 0 1 0 896z"
      }, null, -1);
      const _hoisted_4$6 = [
        _hoisted_2$m,
        _hoisted_3$k
      ];
      function render$g(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$o, _hoisted_4$6);
      }
      const __unplugin_components_12 = { name: "ep-remove", render: render$g };
      const _hoisted_1$n = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$l = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M352 192V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64H96a32 32 0 0 1 0-64h256zm64 0h192v-64H416v64zM192 960a32 32 0 0 1-32-32V256h704v672a32 32 0 0 1-32 32H192zm224-192a32 32 0 0 0 32-32V416a32 32 0 0 0-64 0v320a32 32 0 0 0 32 32zm192 0a32 32 0 0 0 32-32V416a32 32 0 0 0-64 0v320a32 32 0 0 0 32 32z"
      }, null, -1);
      const _hoisted_3$j = [
        _hoisted_2$l
      ];
      function render$f(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$n, _hoisted_3$j);
      }
      const __unplugin_components_2$1 = { name: "ep-delete-filled", render: render$f };
      const _hoisted_1$m = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$k = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32zm192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32z"
      }, null, -1);
      const _hoisted_3$i = [
        _hoisted_2$k
      ];
      function render$e(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$m, _hoisted_3$i);
      }
      const __unplugin_components_0$3 = { name: "ep-delete", render: render$e };
      const _hoisted_1$l = {
        key: 0,
        class: "default"
      };
      const _hoisted_2$j = {
        key: 0,
        class: "hover"
      };
      const _sfc_main$8 = /* @__PURE__ */ defineComponent({
        __name: "HoverButton",
        setup(__props) {
          let isHover = ref(false);
          return (_ctx, _cache) => {
            const _component_i_ep_Delete = __unplugin_components_0$3;
            const _component_el_icon = ElIcon;
            const _component_i_ep_DeleteFilled = __unplugin_components_2$1;
            return openBlock(), createElementBlock("span", {
              class: "container",
              onMouseenter: _cache[0] || (_cache[0] = ($event) => isRef(isHover) ? isHover.value = true : isHover = true),
              onMouseleave: _cache[1] || (_cache[1] = ($event) => isRef(isHover) ? isHover.value = false : isHover = false)
            }, [
              createVNode(Transition, null, {
                default: withCtx(() => [
                  !unref(isHover) ? (openBlock(), createElementBlock("span", _hoisted_1$l, [
                    renderSlot(_ctx.$slots, "default", {}, () => [
                      createVNode(_component_el_icon, null, {
                        default: withCtx(() => [
                          createVNode(_component_i_ep_Delete)
                        ]),
                        _: 1
                      })
                    ], true)
                  ])) : createCommentVNode("", true)
                ]),
                _: 3
              }),
              createVNode(Transition, null, {
                default: withCtx(() => [
                  unref(isHover) ? (openBlock(), createElementBlock("span", _hoisted_2$j, [
                    renderSlot(_ctx.$slots, "hover", {}, () => [
                      createVNode(_component_el_icon, null, {
                        default: withCtx(() => [
                          createVNode(_component_i_ep_DeleteFilled)
                        ]),
                        _: 1
                      })
                    ], true)
                  ])) : createCommentVNode("", true)
                ]),
                _: 3
              })
            ], 32);
          };
        }
      });
      const _export_sfc = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };
      const __unplugin_components_3 = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-c6eaee5b"]]);
      const _hoisted_1$k = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$i = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896a448 448 0 0 1 0-896zm-38.4 409.6H326.4a38.4 38.4 0 1 0 0 76.8h147.2v147.2a38.4 38.4 0 0 0 76.8 0V550.4h147.2a38.4 38.4 0 0 0 0-76.8H550.4V326.4a38.4 38.4 0 1 0-76.8 0v147.2z"
      }, null, -1);
      const _hoisted_3$h = [
        _hoisted_2$i
      ];
      function render$d(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$k, _hoisted_3$h);
      }
      const __unplugin_components_4$1 = { name: "ep-circle-plus-filled", render: render$d };
      const _hoisted_1$j = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$h = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M352 480h320a32 32 0 1 1 0 64H352a32 32 0 0 1 0-64z"
      }, null, -1);
      const _hoisted_3$g = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M480 672V352a32 32 0 1 1 64 0v320a32 32 0 0 1-64 0z"
      }, null, -1);
      const _hoisted_4$5 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768a384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896a448 448 0 0 1 0 896z"
      }, null, -1);
      const _hoisted_5$3 = [
        _hoisted_2$h,
        _hoisted_3$g,
        _hoisted_4$5
      ];
      function render$c(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$j, _hoisted_5$3);
      }
      const __unplugin_components_8$2 = { name: "ep-circle-plus", render: render$c };
      const _hoisted_1$i = { style: { "flex-grow": "1" } };
      const _hoisted_2$g = { style: { "flex-grow": "1" } };
      const _hoisted_3$f = { style: { "flex-grow": "1" } };
      const _hoisted_4$4 = { class: "side-button add-match-item" };
      const _hoisted_5$2 = { class: "side-button remove-match-item" };
      const _hoisted_6$2 = { style: { "flex-grow": "1" } };
      const _hoisted_7$2 = { class: "side-button add-match-item" };
      const _hoisted_8$1 = { class: "side-button remove-match-item" };
      const _hoisted_9$1 = { style: { "flex-grow": "1" } };
      const _hoisted_10$1 = { class: "side-button add-match-item" };
      const _hoisted_11$1 = { class: "side-button remove-match-item" };
      const _hoisted_12$1 = { style: { "flex-grow": "1" } };
      const _hoisted_13$1 = { class: "side-button add-match-item" };
      const _hoisted_14$1 = { class: "side-button remove-match-item" };
      const _hoisted_15$1 = { style: { "flex-grow": "1" } };
      const _hoisted_16$1 = { class: "side-button add-match-item" };
      const _hoisted_17$1 = { class: "side-button remove-match-item" };
      const _hoisted_18$1 = { style: { "flex-grow": "1" } };
      const _hoisted_19 = { class: "side-button add-match-item" };
      const _hoisted_20 = { class: "side-button remove-match-item" };
      const _hoisted_21 = { style: { "flex-grow": "1" } };
      const _hoisted_22 = { class: "side-button add-match-item" };
      const _hoisted_23 = { class: "side-button remove-match-item" };
      const _hoisted_24 = { style: { "flex-grow": "1" } };
      const _hoisted_25 = { class: "side-button add-match-item" };
      const _hoisted_26 = { class: "side-button remove-match-item" };
      const _hoisted_27 = { style: { "flex-grow": "1" } };
      const _hoisted_28 = { class: "side-button add-match-item" };
      const _hoisted_29 = { class: "side-button remove-match-item" };
      const _sfc_main$7 = /* @__PURE__ */ defineComponent({
        __name: "RuleForm",
        props: {
          formData: {}
        },
        setup(__props) {
          const props = __props;
          const info = reactive({
            activeName: "main"
          });
          const pushMatchItem = (index) => {
            const rule = props.formData;
            for (const key of rule.enumMainKey) {
              for (const item of Object.keys(rule[key])) {
                if (rule.enumMatchItemKey.includes(item)) {
                  rule[key][item].splice(index + 1, 0, "");
                }
              }
            }
            rule.matchItemCount++;
          };
          const removeMatchItem = (index) => {
            const rule = props.formData;
            if (rule.matchItemCount <= 1) {
              return;
            }
            for (const key of rule.enumMainKey) {
              for (const item of Object.keys(rule[key])) {
                if (rule.enumMatchItemKey.includes(item)) {
                  rule[key][item].splice(index, 1);
                }
              }
            }
            rule.matchItemCount--;
          };
          watch(
            () => props.formData,
            (newVal, oldVal) => {
              info.activeName = "main";
            }
          );
          return (_ctx, _cache) => {
            const _component_el_input = ElInput;
            const _component_el_form_item = ElFormItem;
            const _component_el_option = ElOption;
            const _component_el_tooltip = ElTooltip;
            const _component_el_select = ElSelect;
            const _component_el_form = ElForm;
            const _component_el_tab_pane = ElTabPane;
            const _component_el_checkbox = ElCheckbox;
            const _component_i_ep_CirclePlus = __unplugin_components_8$2;
            const _component_el_icon = ElIcon;
            const _component_i_ep_CirclePlusFilled = __unplugin_components_4$1;
            const _component_HoverButton = __unplugin_components_3;
            const _component_i_ep_Remove = __unplugin_components_12;
            const _component_i_ep_RemoveFilled = __unplugin_components_13;
            const _component_el_tabs = ElTabs;
            return _ctx.formData != void 0 ? (openBlock(), createBlock(_component_el_tabs, {
              key: 0,
              modelValue: unref(info).activeName,
              "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => unref(info).activeName = $event),
              onTabClick: _cache[17] || (_cache[17] = () => {
              })
            }, {
              default: withCtx(() => [
                createVNode(_component_el_tab_pane, {
                  label: "首选项",
                  name: "main"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: _ctx.formData.main,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_form_item, { label: "规则名称" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_input, {
                              modelValue: _ctx.formData.main.name,
                              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.formData.main.name = $event)
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_form_item, { label: "根网址" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_input, {
                              modelValue: _ctx.formData.main.domainName,
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.formData.main.domainName = $event)
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_form_item, { label: "路径过滤器" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_input, {
                              modelValue: _ctx.formData.main.pathFilter.pattern,
                              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.formData.main.pathFilter.pattern = $event),
                              placeholder: "(正则表达式)"
                            }, {
                              prefix: withCtx(() => [
                                createTextVNode(" / ")
                              ]),
                              suffix: withCtx(() => [
                                createTextVNode(" / ")
                              ]),
                              append: withCtx(() => [
                                createVNode(_component_el_select, {
                                  style: { "width": "180px" },
                                  multiple: "",
                                  modelValue: _ctx.formData.main.pathFilter.flags,
                                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.formData.main.pathFilter.flags = $event),
                                  placeholder: "修饰符"
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_tooltip, {
                                      "show-after": 500,
                                      effect: "dark",
                                      content: "global - 全局匹配",
                                      placement: "top"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(_component_el_option, {
                                          value: "g",
                                          label: "g"
                                        })
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(_component_el_tooltip, {
                                      "show-after": 500,
                                      effect: "dark",
                                      content: "ignore - 不区分大小写",
                                      placement: "top"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(_component_el_option, {
                                          value: "i",
                                          label: "i"
                                        })
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(_component_el_tooltip, {
                                      "show-after": 500,
                                      effect: "dark",
                                      content: "特殊字符圆点 . 中包含换行符 \\n",
                                      placement: "top"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(_component_el_option, {
                                          value: "s",
                                          label: "s"
                                        })
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 1
                                }, 8, ["modelValue"])
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_form_item, { label: "标题选择器" }, {
                          default: withCtx(() => [
                            createBaseVNode("span", _hoisted_1$i, [
                              createVNode(_component_el_input, {
                                modelValue: _ctx.formData.main.titleSelector,
                                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.formData.main.titleSelector = $event),
                                type: "text"
                              }, null, 8, ["modelValue"])
                            ])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_form_item, { label: "站点图标Url" }, {
                          default: withCtx(() => [
                            createBaseVNode("span", _hoisted_2$g, [
                              createVNode(_component_el_input, {
                                modelValue: _ctx.formData.main.iconUrl,
                                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => _ctx.formData.main.iconUrl = $event),
                                type: "text"
                              }, null, 8, ["modelValue"])
                            ])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_tab_pane, {
                  label: "dom限定",
                  name: "domItem"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: _ctx.formData.domItem,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_form_item, { label: "启用" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_checkbox, {
                              modelValue: _ctx.formData.domItem.enable,
                              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.formData.domItem.enable = $event),
                              type: "checkbox"
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        _ctx.formData.domItem.enable ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.formData.domItem.selector, (selector, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `css选择器${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_3$f, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.domItem.selector[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.domItem.selector[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_4$4, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_5$2, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true)
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_tab_pane, {
                  label: "链接(必填)",
                  name: "linkUrl"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: _ctx.formData.linkUrl,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.formData.linkUrl.selector, (selector, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `css选择器${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_6$2, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.linkUrl.selector[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.linkUrl.selector[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_7$2, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_8$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)),
                        createVNode(_component_el_form_item, { label: "提取类型" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: _ctx.formData.linkUrl.infoType,
                              "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => _ctx.formData.linkUrl.infoType = $event),
                              placeholder: "选择要提取的类型"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "值"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "Attribute属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "Property属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 4,
                                  label: "innerText 内部文本"
                                }),
                                createVNode(_component_el_option, {
                                  value: 5,
                                  label: "innerHTML 内部HTML"
                                }),
                                createVNode(_component_el_option, {
                                  value: 6,
                                  label: "outerHTML 全部HTML"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.formData.linkUrl.attribute, (attribute, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `匹配属性${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_9$1, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.linkUrl.attribute[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.linkUrl.attribute[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_10$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_11$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_tab_pane, {
                  label: "图链",
                  name: "picUrl"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: _ctx.formData.picUrl,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_form_item, { label: "启用" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_checkbox, {
                              modelValue: _ctx.formData.picUrl.enable,
                              "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => _ctx.formData.picUrl.enable = $event),
                              type: "checkbox"
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        _ctx.formData.picUrl.enable ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.formData.picUrl.selector, (selector, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `css选择器${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_12$1, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.picUrl.selector[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.picUrl.selector[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_13$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_14$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true),
                        _ctx.formData.picUrl.enable ? (openBlock(), createBlock(_component_el_form_item, {
                          key: 1,
                          label: "提取类型"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: _ctx.formData.picUrl.infoType,
                              "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => _ctx.formData.picUrl.infoType = $event),
                              placeholder: "选择要提取的类型"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "值"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "Attribute属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "Property属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 4,
                                  label: "innerText 内部文本"
                                }),
                                createVNode(_component_el_option, {
                                  value: 5,
                                  label: "innerHTML 内部HTML"
                                }),
                                createVNode(_component_el_option, {
                                  value: 6,
                                  label: "outerHTML 全部HTML"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })) : createCommentVNode("", true),
                        _ctx.formData.picUrl.enable ? (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(_ctx.formData.picUrl.attribute, (attribute, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `匹配属性${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_15$1, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.picUrl.attribute[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.picUrl.attribute[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_16$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_17$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true)
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_tab_pane, {
                  label: "名称",
                  name: "name"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: _ctx.formData.name,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_form_item, { label: "启用" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_checkbox, {
                              modelValue: _ctx.formData.name.enable,
                              "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => _ctx.formData.name.enable = $event),
                              type: "checkbox"
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        _ctx.formData.name.enable ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.formData.name.selector, (selector, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `css选择器${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_18$1, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.name.selector[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.name.selector[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_19, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_20, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true),
                        _ctx.formData.name.enable ? (openBlock(), createBlock(_component_el_form_item, {
                          key: 1,
                          label: "提取类型"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: _ctx.formData.name.infoType,
                              "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => _ctx.formData.name.infoType = $event),
                              placeholder: "选择要提取的类型"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "值"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "Attribute属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "Property属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 4,
                                  label: "innerText 内部文本"
                                }),
                                createVNode(_component_el_option, {
                                  value: 5,
                                  label: "innerHTML 内部HTML"
                                }),
                                createVNode(_component_el_option, {
                                  value: 6,
                                  label: "outerHTML 全部HTML"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })) : createCommentVNode("", true),
                        _ctx.formData.name.enable ? (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(_ctx.formData.name.attribute, (attribute, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `匹配属性${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_21, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.name.attribute[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.name.attribute[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_22, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_23, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true)
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_tab_pane, {
                  label: "元信息",
                  name: "meta"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: _ctx.formData.meta,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_form_item, { label: "启用" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_checkbox, {
                              modelValue: _ctx.formData.meta.enable,
                              "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => _ctx.formData.meta.enable = $event),
                              type: "checkbox"
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        _ctx.formData.meta.enable ? (openBlock(), createBlock(_component_el_form_item, {
                          key: 0,
                          label: "来源"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: _ctx.formData.meta.origin,
                              "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => _ctx.formData.meta.origin = $event),
                              placeholder: "来源"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 0,
                                  label: "单独指定目标dom"
                                }),
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "从“链接”dom获取"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "从“图链”dom获取"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "从“名称”dom获取"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })) : createCommentVNode("", true),
                        _ctx.formData.meta.enable && _ctx.formData.meta.origin === 0 ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.formData.meta.selector, (selector, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `css选择器${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_24, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.meta.selector[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.meta.selector[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_25, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_26, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true),
                        _ctx.formData.meta.enable ? (openBlock(), createBlock(_component_el_form_item, {
                          key: 2,
                          label: "提取类型"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: _ctx.formData.meta.infoType,
                              "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => _ctx.formData.meta.infoType = $event),
                              placeholder: "选择要提取的类型"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 0,
                                  label: "来源对应的dom和链接"
                                }),
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "值"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "Attribute属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "Property属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 4,
                                  label: "innerText 内部文本"
                                }),
                                createVNode(_component_el_option, {
                                  value: 5,
                                  label: "innerHTML 内部HTML"
                                }),
                                createVNode(_component_el_option, {
                                  value: 6,
                                  label: "outerHTML 全部HTML"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })) : createCommentVNode("", true),
                        _ctx.formData.meta.enable && _ctx.formData.meta.infoType !== 0 ? (openBlock(true), createElementBlock(Fragment, { key: 3 }, renderList(_ctx.formData.meta.attribute, (attribute, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `匹配属性${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_27, [
                                createVNode(_component_el_input, {
                                  modelValue: _ctx.formData.meta.attribute[index],
                                  "onUpdate:modelValue": ($event) => _ctx.formData.meta.attribute[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_28, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_29, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true),
                        _ctx.formData.meta.enable ? (openBlock(), createBlock(_component_el_form_item, {
                          key: 4,
                          label: "获取方式"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: _ctx.formData.meta.getMethod,
                              "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => _ctx.formData.meta.getMethod = $event),
                              placeholder: "选择要提取的类型"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 0,
                                  label: "自动"
                                }),
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "通过natural宽高(仅img标签有效)"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "通过Image对象(仅对图片链接有效)"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "通过Blob获取(获取实际可能较长)"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })) : createCommentVNode("", true)
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["modelValue"])) : createCommentVNode("", true);
          };
        }
      });
      const __unplugin_components_9 = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-c2c57aa8"]]);
      function tryOnScopeDispose(fn2) {
        if (getCurrentScope()) {
          onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      function toValue(r2) {
        return typeof r2 === "function" ? r2() : unref(r2);
      }
      const isClient = typeof window !== "undefined";
      const noop = () => {
      };
      function toRef(...args) {
        if (args.length !== 1)
          return toRef$1(...args);
        const r2 = args[0];
        return typeof r2 === "function" ? readonly(customRef(() => ({ get: r2, set: noop }))) : ref(r2);
      }
      function tryOnMounted(fn2, sync = true) {
        if (getCurrentInstance())
          onMounted(fn2);
        else if (sync)
          fn2();
        else
          nextTick(fn2);
      }
      function useTimeoutFn(cb, interval, options = {}) {
        const {
          immediate = true
        } = options;
        const isPending = ref(false);
        let timer = null;
        function clear2() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function stop() {
          isPending.value = false;
          clear2();
        }
        function start(...args) {
          clear2();
          isPending.value = true;
          timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            cb(...args);
          }, toValue(interval));
        }
        if (immediate) {
          isPending.value = true;
          if (isClient)
            start();
        }
        tryOnScopeDispose(stop);
        return {
          isPending: readonly(isPending),
          start,
          stop
        };
      }
      function unrefElement(elRef) {
        var _a2;
        const plain = toValue(elRef);
        return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
      }
      const defaultWindow = isClient ? window : void 0;
      const defaultNavigator = isClient ? window.navigator : void 0;
      function useEventListener(...args) {
        let target;
        let events;
        let listeners;
        let options;
        if (typeof args[0] === "string" || Array.isArray(args[0])) {
          [events, listeners, options] = args;
          target = defaultWindow;
        } else {
          [target, events, listeners, options] = args;
        }
        if (!target)
          return noop;
        if (!Array.isArray(events))
          events = [events];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = watch(
          () => [unrefElement(target), toValue(options)],
          ([el, options2]) => {
            cleanup();
            if (!el)
              return;
            cleanups.push(
              ...events.flatMap((event) => {
                return listeners.map((listener) => register(el, event, listener, options2));
              })
            );
          },
          { immediate: true, flush: "post" }
        );
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose(stop);
        return stop;
      }
      function useMounted() {
        const isMounted = ref(false);
        if (getCurrentInstance()) {
          onMounted(() => {
            isMounted.value = true;
          });
        }
        return isMounted;
      }
      function useSupported(callback) {
        const isMounted = useMounted();
        return computed(() => {
          isMounted.value;
          return Boolean(callback());
        });
      }
      function useMediaQuery(query, options = {}) {
        const { window: window2 = defaultWindow } = options;
        const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
        let mediaQuery;
        const matches = ref(false);
        const cleanup = () => {
          if (!mediaQuery)
            return;
          if ("removeEventListener" in mediaQuery)
            mediaQuery.removeEventListener("change", update);
          else
            mediaQuery.removeListener(update);
        };
        const update = () => {
          if (!isSupported.value)
            return;
          cleanup();
          mediaQuery = window2.matchMedia(toRef(query).value);
          matches.value = !!(mediaQuery == null ? void 0 : mediaQuery.matches);
          if (!mediaQuery)
            return;
          if ("addEventListener" in mediaQuery)
            mediaQuery.addEventListener("change", update);
          else
            mediaQuery.addListener(update);
        };
        watchEffect(update);
        tryOnScopeDispose(() => cleanup());
        return matches;
      }
      function useClipboard(options = {}) {
        const {
          navigator: navigator2 = defaultNavigator,
          read = false,
          source,
          copiedDuring = 1500,
          legacy = false
        } = options;
        const events = ["copy", "cut"];
        const isClipboardApiSupported = useSupported(() => navigator2 && "clipboard" in navigator2);
        const isSupported = computed(() => isClipboardApiSupported.value || legacy);
        const text = ref("");
        const copied = ref(false);
        const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);
        function updateText() {
          if (isClipboardApiSupported.value) {
            navigator2.clipboard.readText().then((value) => {
              text.value = value;
            });
          } else {
            text.value = legacyRead();
          }
        }
        if (isSupported.value && read) {
          for (const event of events)
            useEventListener(event, updateText);
        }
        async function copy(value = toValue(source)) {
          if (isSupported.value && value != null) {
            if (isClipboardApiSupported.value)
              await navigator2.clipboard.writeText(value);
            else
              legacyCopy(value);
            text.value = value;
            copied.value = true;
            timeout.start();
          }
        }
        function legacyCopy(value) {
          const ta = document.createElement("textarea");
          ta.value = value != null ? value : "";
          ta.style.position = "absolute";
          ta.style.opacity = "0";
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          ta.remove();
        }
        function legacyRead() {
          var _a2, _b, _c;
          return (_c = (_b = (_a2 = document == null ? void 0 : document.getSelection) == null ? void 0 : _a2.call(document)) == null ? void 0 : _b.toString()) != null ? _c : "";
        }
        return {
          isSupported,
          text,
          copied,
          copy
        };
      }
      function useWindowSize(options = {}) {
        const {
          window: window2 = defaultWindow,
          initialWidth = Infinity,
          initialHeight = Infinity,
          listenOrientation = true,
          includeScrollbar = true
        } = options;
        const width = ref(initialWidth);
        const height = ref(initialHeight);
        const update = () => {
          if (window2) {
            if (includeScrollbar) {
              width.value = window2.innerWidth;
              height.value = window2.innerHeight;
            } else {
              width.value = window2.document.documentElement.clientWidth;
              height.value = window2.document.documentElement.clientHeight;
            }
          }
        };
        update();
        tryOnMounted(update);
        useEventListener("resize", update, { passive: true });
        if (listenOrientation) {
          const matches = useMediaQuery("(orientation: portrait)");
          watch(matches, () => update());
        }
        return { width, height };
      }
      const _MatchRule = class _MatchRule {
        constructor(rule, status) {
          //* 计数器
          //* 主要数据枚举
          __publicField(this, "enumMainKey", ["main", "domItem", "linkUrl", "picUrl", "name", "meta"]);
          __publicField(this, "enumMatchItemKey", ["selector", "attribute"]);
          __publicField(this, "matchItemCount", 1);
          //* 当前匹配项条数
          __publicField(this, "id");
          __publicField(this, "main");
          __publicField(this, "domItem");
          __publicField(this, "linkUrl");
          __publicField(this, "picUrl");
          __publicField(this, "name");
          __publicField(this, "meta");
          __publicField(this, "status");
          __publicField(this, "backup");
          //f 获取当前匹配条目数量
          __publicField(this, "getMatchItemCount", () => {
            let max = 0;
            for (const key of this.enumMainKey) {
              Object.keys(this.linkUrl).forEach((item) => {
                if (this.enumMatchItemKey.includes(item)) {
                  if (max < this[key][item].length) {
                    max = this[key][item].length;
                  }
                }
              });
            }
            return max;
          });
          //f 创建备份
          __publicField(this, "createBackup", () => {
            this.backup = {};
            for (const key of this.enumMainKey) {
              this.backup[key] = JSON.parse(JSON.stringify(this[key]));
            }
          });
          //f 删除备份
          __publicField(this, "removeBackup", () => {
            this.backup = {};
          });
          //f 通过备份还原
          __publicField(this, "restoreByBackup", () => {
            if (this.backup != void 0) {
              for (const key of this.enumMainKey) {
                this[key] = JSON.parse(JSON.stringify(this.backup[key]));
              }
            }
          });
          //f 生成JSON数据(用于存储)
          __publicField(this, "getJsonData", () => {
            const jsonObj = {
              id: this.id,
              main: this.main,
              domItem: this.domItem,
              linkUrl: this.linkUrl,
              picUrl: this.picUrl,
              name: this.name,
              meta: this.meta
            };
            return JSON.stringify(jsonObj);
          });
          //f 生成uuid
          __publicField(this, "buildUUID", () => {
            const hexList = [];
            for (let i2 = 0; i2 <= 15; i2++) {
              hexList[i2] = i2.toString(16);
            }
            let uuid = "";
            for (let i2 = 1; i2 <= 36; i2++) {
              if (i2 === 9 || i2 === 14 || i2 === 19 || i2 === 24) {
                uuid += "-";
              } else if (i2 === 15) {
                uuid += 4;
              } else if (i2 === 20) {
                uuid += hexList[Math.random() * 4 | 8];
              } else {
                uuid += hexList[Math.random() * 16 | 0];
              }
            }
            return uuid.replace(/-/g, "");
          });
          var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t2, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J;
          _MatchRule.count++;
          this.id = (rule == null ? void 0 : rule.id) || (() => this.buildUUID())();
          this.main = {
            name: ((_a2 = rule == null ? void 0 : rule.main) == null ? void 0 : _a2.name) || "新规则",
            domainName: ((_b = rule == null ? void 0 : rule.main) == null ? void 0 : _b.domainName) || "",
            pathFilter: {
              pattern: ((_d = (_c = rule == null ? void 0 : rule.main) == null ? void 0 : _c.pathFilter) == null ? void 0 : _d.pattern) || "",
              flags: ((_f = (_e = rule == null ? void 0 : rule.main) == null ? void 0 : _e.pathFilter) == null ? void 0 : _f.flags) || []
            },
            titleSelector: ((_g = rule == null ? void 0 : rule.main) == null ? void 0 : _g.titleSelector) || "",
            iconUrl: ((_h = rule == null ? void 0 : rule.main) == null ? void 0 : _h.iconUrl) || ""
          };
          this.domItem = {
            enable: ((_i = rule == null ? void 0 : rule.domItem) == null ? void 0 : _i.enable) || false,
            method: ((_j = rule == null ? void 0 : rule.domItem) == null ? void 0 : _j.method) || 0,
            selector: ((_k = rule == null ? void 0 : rule.domItem) == null ? void 0 : _k.selector) || [""]
          };
          this.linkUrl = {
            method: ((_l = rule == null ? void 0 : rule.linkUrl) == null ? void 0 : _l.method) || 0,
            selector: ((_m = rule == null ? void 0 : rule.linkUrl) == null ? void 0 : _m.selector) || [""],
            infoType: ((_n = rule == null ? void 0 : rule.linkUrl) == null ? void 0 : _n.infoType) || 3,
            attribute: ((_o = rule == null ? void 0 : rule.linkUrl) == null ? void 0 : _o.attribute) || [""]
          };
          this.picUrl = {
            enable: ((_p = rule == null ? void 0 : rule.picUrl) == null ? void 0 : _p.enable) || false,
            origin: ((_q = rule == null ? void 0 : rule.picUrl) == null ? void 0 : _q.origin) || 0,
            method: ((_r = rule == null ? void 0 : rule.picUrl) == null ? void 0 : _r.method) || 0,
            selector: ((_s = rule == null ? void 0 : rule.picUrl) == null ? void 0 : _s.selector) || [""],
            infoType: ((_t2 = rule == null ? void 0 : rule.picUrl) == null ? void 0 : _t2.infoType) || 3,
            attribute: ((_u = rule == null ? void 0 : rule.picUrl) == null ? void 0 : _u.attribute) || [""]
          };
          this.name = {
            enable: ((_v = rule == null ? void 0 : rule.name) == null ? void 0 : _v.enable) || false,
            origin: ((_w = rule == null ? void 0 : rule.name) == null ? void 0 : _w.origin) || 0,
            method: ((_x = rule == null ? void 0 : rule.name) == null ? void 0 : _x.method) || 0,
            selector: ((_y = rule == null ? void 0 : rule.name) == null ? void 0 : _y.selector) || [""],
            infoType: ((_z = rule == null ? void 0 : rule.name) == null ? void 0 : _z.infoType) || 4,
            attribute: ((_A = rule == null ? void 0 : rule.name) == null ? void 0 : _A.attribute) || [""]
          };
          this.meta = {
            enable: ((_B = rule == null ? void 0 : rule.meta) == null ? void 0 : _B.enable) || true,
            origin: ((_C = rule == null ? void 0 : rule.meta) == null ? void 0 : _C.origin) || 2,
            method: ((_D = rule == null ? void 0 : rule.meta) == null ? void 0 : _D.method) || 0,
            selector: ((_E = rule == null ? void 0 : rule.meta) == null ? void 0 : _E.selector) || [""],
            infoType: ((_F = rule == null ? void 0 : rule.meta) == null ? void 0 : _F.infoType) !== void 0 ? (_G = rule == null ? void 0 : rule.meta) == null ? void 0 : _G.infoType : 0,
            attribute: ((_H = rule == null ? void 0 : rule.meta) == null ? void 0 : _H.attribute) || [""],
            getMethod: ((_I = rule == null ? void 0 : rule.meta) == null ? void 0 : _I.getMethod) !== void 0 ? (_J = rule == null ? void 0 : rule.meta) == null ? void 0 : _J.getMethod : 0
          };
          this.status = {
            editing: (status == null ? void 0 : status.editing) || false,
            //* 编辑状态标记
            isNewCreated: (status == null ? void 0 : status.isNewCreated) || false
            //* 标记是否为新创建的规则
          };
          this.backup = {};
        }
      };
      //? 静态成员
      __publicField(_MatchRule, "count", 0);
      let MatchRule = _MatchRule;
      //! Rule类的仅输入接口
      //! 输入输出接口
      const t = (t2, e2 = 1e4) => (t2 = parseFloat(t2 + "") || 0, Math.round((t2 + Number.EPSILON) * e2) / e2), e = function(t2) {
        if (!(t2 && t2 instanceof Element && t2.offsetParent))
          return false;
        const e2 = t2.scrollHeight > t2.clientHeight, i2 = window.getComputedStyle(t2).overflowY, n2 = -1 !== i2.indexOf("hidden"), s2 = -1 !== i2.indexOf("visible");
        return e2 && !n2 && !s2;
      }, i = function(t2, n2 = void 0) {
        return !(!t2 || t2 === document.body || n2 && t2 === n2) && (e(t2) ? t2 : i(t2.parentElement, n2));
      }, n = function(t2) {
        var e2 = new DOMParser().parseFromString(t2, "text/html").body;
        if (e2.childElementCount > 1) {
          for (var i2 = document.createElement("div"); e2.firstChild; )
            i2.appendChild(e2.firstChild);
          return i2;
        }
        return e2.firstChild;
      }, s = (t2) => `${t2 || ""}`.split(" ").filter((t3) => !!t3), o = (t2, e2, i2) => {
        s(e2).forEach((e3) => {
          t2 && t2.classList.toggle(e3, i2 || false);
        });
      };
      class a {
        constructor(t2) {
          Object.defineProperty(this, "pageX", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "pageY", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "clientX", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "clientY", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "id", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "time", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "nativePointer", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.nativePointer = t2, this.pageX = t2.pageX, this.pageY = t2.pageY, this.clientX = t2.clientX, this.clientY = t2.clientY, this.id = self.Touch && t2 instanceof Touch ? t2.identifier : -1, this.time = Date.now();
        }
      }
      const r = { passive: false };
      class l {
        constructor(t2, { start: e2 = () => true, move: i2 = () => {
        }, end: n2 = () => {
        } }) {
          Object.defineProperty(this, "element", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "startCallback", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "moveCallback", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "endCallback", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "currentPointers", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "startPointers", { enumerable: true, configurable: true, writable: true, value: [] }), this.element = t2, this.startCallback = e2, this.moveCallback = i2, this.endCallback = n2;
          for (const t3 of ["onPointerStart", "onTouchStart", "onMove", "onTouchEnd", "onPointerEnd", "onWindowBlur"])
            this[t3] = this[t3].bind(this);
          this.element.addEventListener("mousedown", this.onPointerStart, r), this.element.addEventListener("touchstart", this.onTouchStart, r), this.element.addEventListener("touchmove", this.onMove, r), this.element.addEventListener("touchend", this.onTouchEnd), this.element.addEventListener("touchcancel", this.onTouchEnd);
        }
        onPointerStart(t2) {
          if (!t2.buttons || 0 !== t2.button)
            return;
          const e2 = new a(t2);
          this.currentPointers.some((t3) => t3.id === e2.id) || this.triggerPointerStart(e2, t2) && (window.addEventListener("mousemove", this.onMove), window.addEventListener("mouseup", this.onPointerEnd), window.addEventListener("blur", this.onWindowBlur));
        }
        onTouchStart(t2) {
          for (const e2 of Array.from(t2.changedTouches || []))
            this.triggerPointerStart(new a(e2), t2);
          window.addEventListener("blur", this.onWindowBlur);
        }
        onMove(t2) {
          const e2 = this.currentPointers.slice(), i2 = "changedTouches" in t2 ? Array.from(t2.changedTouches || []).map((t3) => new a(t3)) : [new a(t2)], n2 = [];
          for (const t3 of i2) {
            const e3 = this.currentPointers.findIndex((e4) => e4.id === t3.id);
            e3 < 0 || (n2.push(t3), this.currentPointers[e3] = t3);
          }
          n2.length && this.moveCallback(t2, this.currentPointers.slice(), e2);
        }
        onPointerEnd(t2) {
          t2.buttons > 0 && 0 !== t2.button || (this.triggerPointerEnd(t2, new a(t2)), window.removeEventListener("mousemove", this.onMove), window.removeEventListener("mouseup", this.onPointerEnd), window.removeEventListener("blur", this.onWindowBlur));
        }
        onTouchEnd(t2) {
          for (const e2 of Array.from(t2.changedTouches || []))
            this.triggerPointerEnd(t2, new a(e2));
        }
        triggerPointerStart(t2, e2) {
          return !!this.startCallback(e2, t2, this.currentPointers.slice()) && (this.currentPointers.push(t2), this.startPointers.push(t2), true);
        }
        triggerPointerEnd(t2, e2) {
          const i2 = this.currentPointers.findIndex((t3) => t3.id === e2.id);
          i2 < 0 || (this.currentPointers.splice(i2, 1), this.startPointers.splice(i2, 1), this.endCallback(t2, e2, this.currentPointers.slice()));
        }
        onWindowBlur() {
          this.clear();
        }
        clear() {
          for (; this.currentPointers.length; ) {
            const t2 = this.currentPointers[this.currentPointers.length - 1];
            this.currentPointers.splice(this.currentPointers.length - 1, 1), this.startPointers.splice(this.currentPointers.length - 1, 1), this.endCallback(new Event("touchend", { bubbles: true, cancelable: true, clientX: t2.clientX, clientY: t2.clientY }), t2, this.currentPointers.slice());
          }
        }
        stop() {
          this.element.removeEventListener("mousedown", this.onPointerStart, r), this.element.removeEventListener("touchstart", this.onTouchStart, r), this.element.removeEventListener("touchmove", this.onMove, r), this.element.removeEventListener("touchend", this.onTouchEnd), this.element.removeEventListener("touchcancel", this.onTouchEnd), window.removeEventListener("mousemove", this.onMove), window.removeEventListener("mouseup", this.onPointerEnd), window.removeEventListener("blur", this.onWindowBlur);
        }
      }
      function c(t2, e2) {
        return e2 ? Math.sqrt(Math.pow(e2.clientX - t2.clientX, 2) + Math.pow(e2.clientY - t2.clientY, 2)) : 0;
      }
      function h(t2, e2) {
        return e2 ? { clientX: (t2.clientX + e2.clientX) / 2, clientY: (t2.clientY + e2.clientY) / 2 } : t2;
      }
      const d = (t2) => "object" == typeof t2 && null !== t2 && t2.constructor === Object && "[object Object]" === Object.prototype.toString.call(t2), u = (t2, ...e2) => {
        const i2 = e2.length;
        for (let n2 = 0; n2 < i2; n2++) {
          const i3 = e2[n2] || {};
          Object.entries(i3).forEach(([e3, i4]) => {
            const n3 = Array.isArray(i4) ? [] : {};
            t2[e3] || Object.assign(t2, { [e3]: n3 }), d(i4) ? Object.assign(t2[e3], u(n3, i4)) : Array.isArray(i4) ? Object.assign(t2, { [e3]: [...i4] }) : Object.assign(t2, { [e3]: i4 });
          });
        }
        return t2;
      }, p = function(t2, e2) {
        return t2.split(".").reduce((t3, e3) => "object" == typeof t3 ? t3[e3] : void 0, e2);
      };
      class f {
        constructor(t2 = {}) {
          Object.defineProperty(this, "options", { enumerable: true, configurable: true, writable: true, value: t2 }), Object.defineProperty(this, "events", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Map() }), this.setOptions(t2);
          for (const t3 of Object.getOwnPropertyNames(Object.getPrototypeOf(this)))
            t3.startsWith("on") && "function" == typeof this[t3] && (this[t3] = this[t3].bind(this));
        }
        setOptions(t2) {
          this.options = t2 ? u({}, this.constructor.defaults, t2) : {};
          for (const [t3, e2] of Object.entries(this.option("on") || {}))
            this.on(t3, e2);
        }
        option(t2, ...e2) {
          let i2 = p(t2, this.options);
          return i2 && "function" == typeof i2 && (i2 = i2.call(this, this, ...e2)), i2;
        }
        optionFor(t2, e2, i2, ...n2) {
          let s2 = p(e2, t2);
          var o2;
          "string" != typeof (o2 = s2) || isNaN(o2) || isNaN(parseFloat(o2)) || (s2 = parseFloat(s2)), "true" === s2 && (s2 = true), "false" === s2 && (s2 = false), s2 && "function" == typeof s2 && (s2 = s2.call(this, this, t2, ...n2));
          let a2 = p(e2, this.options);
          return a2 && "function" == typeof a2 ? s2 = a2.call(this, this, t2, ...n2, s2) : void 0 === s2 && (s2 = a2), void 0 === s2 ? i2 : s2;
        }
        cn(t2) {
          const e2 = this.options.classes;
          return e2 && e2[t2] || "";
        }
        localize(t2, e2 = []) {
          t2 = String(t2).replace(/\{\{(\w+).?(\w+)?\}\}/g, (t3, e3, i2) => {
            let n2 = "";
            return i2 ? n2 = this.option(`${e3[0] + e3.toLowerCase().substring(1)}.l10n.${i2}`) : e3 && (n2 = this.option(`l10n.${e3}`)), n2 || (n2 = t3), n2;
          });
          for (let i2 = 0; i2 < e2.length; i2++)
            t2 = t2.split(e2[i2][0]).join(e2[i2][1]);
          return t2 = t2.replace(/\{\{(.*?)\}\}/g, (t3, e3) => e3);
        }
        on(t2, e2) {
          let i2 = [];
          "string" == typeof t2 ? i2 = t2.split(" ") : Array.isArray(t2) && (i2 = t2), this.events || (this.events = /* @__PURE__ */ new Map()), i2.forEach((t3) => {
            let i3 = this.events.get(t3);
            i3 || (this.events.set(t3, []), i3 = []), i3.includes(e2) || i3.push(e2), this.events.set(t3, i3);
          });
        }
        off(t2, e2) {
          let i2 = [];
          "string" == typeof t2 ? i2 = t2.split(" ") : Array.isArray(t2) && (i2 = t2), i2.forEach((t3) => {
            const i3 = this.events.get(t3);
            if (Array.isArray(i3)) {
              const t4 = i3.indexOf(e2);
              t4 > -1 && i3.splice(t4, 1);
            }
          });
        }
        emit(t2, ...e2) {
          [...this.events.get(t2) || []].forEach((t3) => t3(this, ...e2)), "*" !== t2 && this.emit("*", t2, ...e2);
        }
      }
      Object.defineProperty(f, "version", { enumerable: true, configurable: true, writable: true, value: "5.0.20" }), Object.defineProperty(f, "defaults", { enumerable: true, configurable: true, writable: true, value: {} });
      class m extends f {
        constructor(t2 = {}) {
          super(t2), Object.defineProperty(this, "plugins", { enumerable: true, configurable: true, writable: true, value: {} });
        }
        attachPlugins(t2 = {}) {
          const e2 = /* @__PURE__ */ new Map();
          for (const [i2, n2] of Object.entries(t2)) {
            const t3 = this.option(i2), s2 = this.plugins[i2];
            s2 || false === t3 ? s2 && false === t3 && (s2.detach(), delete this.plugins[i2]) : e2.set(i2, new n2(this, t3 || {}));
          }
          for (const [t3, i2] of e2)
            this.plugins[t3] = i2, i2.attach();
          this.emit("attachPlugins");
        }
        detachPlugins(t2) {
          t2 = t2 || Object.keys(this.plugins);
          for (const e2 of t2) {
            const t3 = this.plugins[e2];
            t3 && t3.detach(), delete this.plugins[e2];
          }
          return this.emit("detachPlugins"), this;
        }
      }
      var g;
      !function(t2) {
        t2[t2.Init = 0] = "Init", t2[t2.Error = 1] = "Error", t2[t2.Ready = 2] = "Ready", t2[t2.Panning = 3] = "Panning", t2[t2.Mousemove = 4] = "Mousemove", t2[t2.Destroy = 5] = "Destroy";
      }(g || (g = {}));
      const b = ["a", "b", "c", "d", "e", "f"], v = { PANUP: "Move up", PANDOWN: "Move down", PANLEFT: "Move left", PANRIGHT: "Move right", ZOOMIN: "Zoom in", ZOOMOUT: "Zoom out", TOGGLEZOOM: "Toggle zoom level", TOGGLE1TO1: "Toggle zoom level", ITERATEZOOM: "Toggle zoom level", ROTATECCW: "Rotate counterclockwise", ROTATECW: "Rotate clockwise", FLIPX: "Flip horizontally", FLIPY: "Flip vertically", FITX: "Fit horizontally", FITY: "Fit vertically", RESET: "Reset", TOGGLEFS: "Toggle fullscreen" }, y = { content: null, width: "auto", height: "auto", panMode: "drag", touch: true, dragMinThreshold: 3, lockAxis: false, mouseMoveFactor: 1, mouseMoveFriction: 0.12, zoom: true, pinchToZoom: true, panOnlyZoomed: "auto", minScale: 1, maxScale: 2, friction: 0.25, dragFriction: 0.35, decelFriction: 0.05, click: "toggleZoom", dblClick: false, wheel: "zoom", wheelLimit: 7, spinner: true, bounds: "auto", infinite: false, rubberband: true, bounce: true, maxVelocity: 75, transformParent: false, classes: { content: "f-panzoom__content", isLoading: "is-loading", canZoomIn: "can-zoom_in", canZoomOut: "can-zoom_out", isDraggable: "is-draggable", isDragging: "is-dragging", inFullscreen: "in-fullscreen", htmlHasFullscreen: "with-panzoom-in-fullscreen" }, l10n: v }, w = '<div class="f-spinner"><svg viewBox="0 0 50 50"><circle cx="25" cy="25" r="20"></circle><circle cx="25" cy="25" r="20"></circle></svg></div>', x = (t2) => t2 && null !== t2 && t2 instanceof Element && "nodeType" in t2, E = (t2, e2) => {
        t2 && s(e2).forEach((e3) => {
          t2.classList.remove(e3);
        });
      }, S = (t2, e2) => {
        t2 && s(e2).forEach((e3) => {
          t2.classList.add(e3);
        });
      }, P = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 }, C = 1e5, M = 1e3, T = "mousemove", O = "drag", A = "content";
      let z = null, L = null;
      class R extends m {
        get isTouchDevice() {
          return null === L && (L = window.matchMedia("(hover: none)").matches), L;
        }
        get isMobile() {
          return null === z && (z = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)), z;
        }
        get panMode() {
          return this.options.panMode !== T || this.isTouchDevice ? O : T;
        }
        get panOnlyZoomed() {
          const t2 = this.options.panOnlyZoomed;
          return "auto" === t2 ? this.isTouchDevice : t2;
        }
        get isInfinite() {
          return this.option("infinite");
        }
        get angle() {
          return 180 * Math.atan2(this.current.b, this.current.a) / Math.PI || 0;
        }
        get targetAngle() {
          return 180 * Math.atan2(this.target.b, this.target.a) / Math.PI || 0;
        }
        get scale() {
          const { a: t2, b: e2 } = this.current;
          return Math.sqrt(t2 * t2 + e2 * e2) || 1;
        }
        get targetScale() {
          const { a: t2, b: e2 } = this.target;
          return Math.sqrt(t2 * t2 + e2 * e2) || 1;
        }
        get minScale() {
          return this.option("minScale") || 1;
        }
        get fullScale() {
          const { contentRect: t2 } = this;
          return t2.fullWidth / t2.fitWidth || 1;
        }
        get maxScale() {
          return this.fullScale * (this.option("maxScale") || 1) || 1;
        }
        get coverScale() {
          const { containerRect: t2, contentRect: e2 } = this, i2 = Math.max(t2.height / e2.fitHeight, t2.width / e2.fitWidth) || 1;
          return Math.min(this.fullScale, i2);
        }
        get isScaling() {
          return Math.abs(this.targetScale - this.scale) > 1e-5 && !this.isResting;
        }
        get isContentLoading() {
          const t2 = this.content;
          return !!(t2 && t2 instanceof HTMLImageElement) && !t2.complete;
        }
        get isResting() {
          if (this.isBouncingX || this.isBouncingY)
            return false;
          for (const t2 of b) {
            const e2 = "e" == t2 || "f" === t2 ? 1e-3 : 1e-5;
            if (Math.abs(this.target[t2] - this.current[t2]) > e2)
              return false;
          }
          return !(!this.ignoreBounds && !this.checkBounds().inBounds);
        }
        constructor(t2, e2 = {}, i2 = {}) {
          var s2;
          if (super(e2), Object.defineProperty(this, "pointerTracker", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "resizeObserver", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "updateTimer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "clickTimer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "rAF", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "isTicking", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "friction", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "ignoreBounds", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "isBouncingX", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "isBouncingY", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "clicks", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "trackingPoints", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "pwt", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "cwd", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "pmme", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: g.Init }), Object.defineProperty(this, "isDragging", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "content", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "spinner", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "containerRect", { enumerable: true, configurable: true, writable: true, value: { width: 0, height: 0, innerWidth: 0, innerHeight: 0 } }), Object.defineProperty(this, "contentRect", { enumerable: true, configurable: true, writable: true, value: { top: 0, right: 0, bottom: 0, left: 0, fullWidth: 0, fullHeight: 0, fitWidth: 0, fitHeight: 0, width: 0, height: 0 } }), Object.defineProperty(this, "dragStart", { enumerable: true, configurable: true, writable: true, value: { x: 0, y: 0, top: 0, left: 0, time: 0 } }), Object.defineProperty(this, "dragOffset", { enumerable: true, configurable: true, writable: true, value: { x: 0, y: 0, time: 0 } }), Object.defineProperty(this, "current", { enumerable: true, configurable: true, writable: true, value: Object.assign({}, P) }), Object.defineProperty(this, "target", { enumerable: true, configurable: true, writable: true, value: Object.assign({}, P) }), Object.defineProperty(this, "velocity", { enumerable: true, configurable: true, writable: true, value: { a: 0, b: 0, c: 0, d: 0, e: 0, f: 0 } }), Object.defineProperty(this, "lockedAxis", { enumerable: true, configurable: true, writable: true, value: false }), !t2)
            throw new Error("Container Element Not Found");
          this.container = t2, this.initContent(), this.attachPlugins(Object.assign(Object.assign({}, R.Plugins), i2)), this.emit("init");
          const o2 = this.content;
          if (o2.addEventListener("load", this.onLoad), o2.addEventListener("error", this.onError), this.isContentLoading) {
            if (this.option("spinner")) {
              t2.classList.add(this.cn("isLoading"));
              const e3 = n(w);
              !t2.contains(o2) || o2.parentElement instanceof HTMLPictureElement ? this.spinner = t2.appendChild(e3) : this.spinner = (null === (s2 = o2.parentElement) || void 0 === s2 ? void 0 : s2.insertBefore(e3, o2)) || null;
            }
            this.emit("beforeLoad");
          } else
            queueMicrotask(() => {
              this.enable();
            });
        }
        initContent() {
          const { container: t2 } = this, e2 = this.cn(A);
          let i2 = this.option(A) || t2.querySelector(`.${e2}`);
          if (i2 || (i2 = t2.querySelector("img,picture") || t2.firstElementChild, i2 && S(i2, e2)), i2 instanceof HTMLPictureElement && (i2 = i2.querySelector("img")), !i2)
            throw new Error("No content found");
          this.content = i2;
        }
        onLoad() {
          this.spinner && (this.spinner.remove(), this.spinner = null), this.option("spinner") && this.container.classList.remove(this.cn("isLoading")), this.emit("afterLoad"), this.state === g.Init ? this.enable() : this.updateMetrics();
        }
        onError() {
          this.state !== g.Destroy && (this.spinner && (this.spinner.remove(), this.spinner = null), this.stop(), this.detachEvents(), this.state = g.Error, this.emit("error"));
        }
        attachObserver() {
          var t2;
          const e2 = () => Math.abs(this.containerRect.width - this.container.getBoundingClientRect().width) > 0.1 || Math.abs(this.containerRect.height - this.container.getBoundingClientRect().height) > 0.1;
          this.resizeObserver || void 0 === window.ResizeObserver || (this.resizeObserver = new ResizeObserver(() => {
            this.updateTimer || (e2() ? (this.onResize(), this.isMobile && (this.updateTimer = setTimeout(() => {
              e2() && this.onResize(), this.updateTimer = null;
            }, 500))) : this.updateTimer && (clearTimeout(this.updateTimer), this.updateTimer = null));
          })), null === (t2 = this.resizeObserver) || void 0 === t2 || t2.observe(this.container);
        }
        detachObserver() {
          var t2;
          null === (t2 = this.resizeObserver) || void 0 === t2 || t2.disconnect();
        }
        attachEvents() {
          const { container: t2 } = this;
          t2.addEventListener("click", this.onClick, { passive: false, capture: false }), t2.addEventListener("wheel", this.onWheel, { passive: false }), this.pointerTracker = new l(t2, { start: this.onPointerDown, move: this.onPointerMove, end: this.onPointerUp }), document.addEventListener(T, this.onMouseMove);
        }
        detachEvents() {
          var t2;
          const { container: e2 } = this;
          e2.removeEventListener("click", this.onClick, { passive: false, capture: false }), e2.removeEventListener("wheel", this.onWheel, { passive: false }), null === (t2 = this.pointerTracker) || void 0 === t2 || t2.stop(), this.pointerTracker = null, document.removeEventListener(T, this.onMouseMove), document.removeEventListener("keydown", this.onKeydown, true), this.clickTimer && (clearTimeout(this.clickTimer), this.clickTimer = null), this.updateTimer && (clearTimeout(this.updateTimer), this.updateTimer = null);
        }
        animate() {
          const t2 = this.friction;
          this.setTargetForce();
          const e2 = this.option("maxVelocity");
          for (const i2 of b)
            t2 ? (this.velocity[i2] *= 1 - t2, e2 && !this.isScaling && (this.velocity[i2] = Math.max(Math.min(this.velocity[i2], e2), -1 * e2)), this.current[i2] += this.velocity[i2]) : this.current[i2] = this.target[i2];
          this.setTransform(), this.setEdgeForce(), !this.isResting || this.isDragging ? this.rAF = requestAnimationFrame(() => this.animate()) : this.stop("current");
        }
        setTargetForce() {
          for (const t2 of b)
            "e" === t2 && this.isBouncingX || "f" === t2 && this.isBouncingY || (this.velocity[t2] = (1 / (1 - this.friction) - 1) * (this.target[t2] - this.current[t2]));
        }
        checkBounds(t2 = 0, e2 = 0) {
          const { current: i2 } = this, n2 = i2.e + t2, s2 = i2.f + e2, o2 = this.getBounds(), { x: a2, y: r2 } = o2, l2 = a2.min, c2 = a2.max, h2 = r2.min, d2 = r2.max;
          let u2 = 0, p2 = 0;
          return l2 !== 1 / 0 && n2 < l2 ? u2 = l2 - n2 : c2 !== 1 / 0 && n2 > c2 && (u2 = c2 - n2), h2 !== 1 / 0 && s2 < h2 ? p2 = h2 - s2 : d2 !== 1 / 0 && s2 > d2 && (p2 = d2 - s2), Math.abs(u2) < 1e-3 && (u2 = 0), Math.abs(p2) < 1e-3 && (p2 = 0), Object.assign(Object.assign({}, o2), { xDiff: u2, yDiff: p2, inBounds: !u2 && !p2 });
        }
        clampTargetBounds() {
          const { target: t2 } = this, { x: e2, y: i2 } = this.getBounds();
          e2.min !== 1 / 0 && (t2.e = Math.max(t2.e, e2.min)), e2.max !== 1 / 0 && (t2.e = Math.min(t2.e, e2.max)), i2.min !== 1 / 0 && (t2.f = Math.max(t2.f, i2.min)), i2.max !== 1 / 0 && (t2.f = Math.min(t2.f, i2.max));
        }
        calculateContentDim(t2 = this.current) {
          const { content: e2, contentRect: i2 } = this, { fitWidth: n2, fitHeight: s2, fullWidth: o2, fullHeight: a2 } = i2;
          let r2 = o2, l2 = a2;
          if (this.option("zoom") || 0 !== this.angle) {
            const i3 = !(e2 instanceof HTMLImageElement) && ("none" === window.getComputedStyle(e2).maxWidth || "none" === window.getComputedStyle(e2).maxHeight), c2 = i3 ? o2 : n2, h2 = i3 ? a2 : s2, d2 = this.getMatrix(t2), u2 = new DOMPoint(0, 0).matrixTransform(d2), p2 = new DOMPoint(0 + c2, 0).matrixTransform(d2), f2 = new DOMPoint(0 + c2, 0 + h2).matrixTransform(d2), m2 = new DOMPoint(0, 0 + h2).matrixTransform(d2), g2 = Math.abs(f2.x - u2.x), b2 = Math.abs(f2.y - u2.y), v2 = Math.abs(m2.x - p2.x), y2 = Math.abs(m2.y - p2.y);
            r2 = Math.max(g2, v2), l2 = Math.max(b2, y2);
          }
          return { contentWidth: r2, contentHeight: l2 };
        }
        setEdgeForce() {
          if (this.ignoreBounds || this.isDragging || this.panMode === T || this.targetScale < this.scale)
            return this.isBouncingX = false, void (this.isBouncingY = false);
          const { target: t2 } = this, { x: e2, y: i2, xDiff: n2, yDiff: s2 } = this.checkBounds();
          const o2 = this.option("maxVelocity");
          let a2 = this.velocity.e, r2 = this.velocity.f;
          0 !== n2 ? (this.isBouncingX = true, n2 * a2 <= 0 ? a2 += 0.14 * n2 : (a2 = 0.14 * n2, e2.min !== 1 / 0 && (this.target.e = Math.max(t2.e, e2.min)), e2.max !== 1 / 0 && (this.target.e = Math.min(t2.e, e2.max))), o2 && (a2 = Math.max(Math.min(a2, o2), -1 * o2))) : this.isBouncingX = false, 0 !== s2 ? (this.isBouncingY = true, s2 * r2 <= 0 ? r2 += 0.14 * s2 : (r2 = 0.14 * s2, i2.min !== 1 / 0 && (this.target.f = Math.max(t2.f, i2.min)), i2.max !== 1 / 0 && (this.target.f = Math.min(t2.f, i2.max))), o2 && (r2 = Math.max(Math.min(r2, o2), -1 * o2))) : this.isBouncingY = false, this.isBouncingX && (this.velocity.e = a2), this.isBouncingY && (this.velocity.f = r2);
        }
        enable() {
          const { content: t2 } = this, e2 = new DOMMatrixReadOnly(window.getComputedStyle(t2).transform);
          for (const t3 of b)
            this.current[t3] = this.target[t3] = e2[t3];
          this.updateMetrics(), this.attachObserver(), this.attachEvents(), this.state = g.Ready, this.emit("ready");
        }
        onClick(t2) {
          var e2;
          this.isDragging && (null === (e2 = this.pointerTracker) || void 0 === e2 || e2.clear(), this.trackingPoints = [], this.startDecelAnim());
          const i2 = t2.target;
          if (!i2 || t2.defaultPrevented)
            return;
          if (i2 && i2.hasAttribute("disabled"))
            return t2.preventDefault(), void t2.stopPropagation();
          if ((() => {
            const t3 = window.getSelection();
            return t3 && "Range" === t3.type;
          })() && !i2.closest("button"))
            return;
          const n2 = i2.closest("[data-panzoom-action]"), s2 = i2.closest("[data-panzoom-change]"), o2 = n2 || s2, a2 = o2 && x(o2) ? o2.dataset : null;
          if (a2) {
            const e3 = a2.panzoomChange, i3 = a2.panzoomAction;
            if ((e3 || i3) && t2.preventDefault(), e3) {
              let t3 = {};
              try {
                t3 = JSON.parse(e3);
              } catch (t4) {
                console && console.warn("The given data was not valid JSON");
              }
              return void this.applyChange(t3);
            }
            if (i3)
              return void (this[i3] && this[i3]());
          }
          if (Math.abs(this.dragOffset.x) > 3 || Math.abs(this.dragOffset.y) > 3)
            return t2.preventDefault(), void t2.stopPropagation();
          const r2 = this.content.getBoundingClientRect();
          if (this.dragStart.time && !this.canZoomOut() && (Math.abs(r2.x - this.dragStart.x) > 2 || Math.abs(r2.y - this.dragStart.y) > 2))
            return;
          this.dragStart.time = 0;
          const l2 = (e3) => {
            this.option("zoom") && e3 && "string" == typeof e3 && /(iterateZoom)|(toggle(Zoom|Full|Cover|Max)|(zoomTo(Fit|Cover|Max)))/.test(e3) && "function" == typeof this[e3] && (t2.preventDefault(), this[e3]({ event: t2 }));
          }, c2 = this.option("click", t2), h2 = this.option("dblClick", t2);
          h2 ? (this.clicks++, 1 == this.clicks && (this.clickTimer = setTimeout(() => {
            1 === this.clicks ? (this.emit("click", t2), !t2.defaultPrevented && c2 && l2(c2)) : (this.emit("dblClick", t2), t2.defaultPrevented || l2(h2)), this.clicks = 0, this.clickTimer = null;
          }, 350))) : (this.emit("click", t2), !t2.defaultPrevented && c2 && l2(c2));
        }
        addTrackingPoint(t2) {
          const e2 = this.trackingPoints.filter((t3) => t3.time > Date.now() - 100);
          e2.push(t2), this.trackingPoints = e2;
        }
        onPointerDown(t2, e2, i2) {
          var n2;
          this.pwt = 0, this.dragOffset = { x: 0, y: 0, time: 0 }, this.trackingPoints = [];
          const s2 = this.content.getBoundingClientRect();
          if (this.dragStart = { x: s2.x, y: s2.y, top: s2.top, left: s2.left, time: Date.now() }, this.clickTimer)
            return false;
          if (this.panMode === T && this.targetScale > 1)
            return t2.preventDefault(), t2.stopPropagation(), false;
          if (!i2.length) {
            const e3 = t2.composedPath()[0];
            if (["A", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].includes(e3.nodeName) || e3.closest("[contenteditable]") || e3.closest("[data-selectable]") || e3.closest("[data-draggable]") || e3.closest("[data-clickable]") || e3.closest("[data-panzoom-change]") || e3.closest("[data-panzoom-action]"))
              return false;
            null === (n2 = window.getSelection()) || void 0 === n2 || n2.removeAllRanges();
          }
          if ("mousedown" === t2.type)
            t2.preventDefault();
          else if (Math.abs(this.velocity.a) > 0.3)
            return false;
          return this.target.e = this.current.e, this.target.f = this.current.f, this.stop(), this.isDragging || (this.isDragging = true, this.addTrackingPoint(e2), this.emit("touchStart", t2)), true;
        }
        onPointerMove(e2, n2, s2) {
          if (false === this.option("touch", e2))
            return;
          if (!this.isDragging)
            return;
          if (n2.length < 2 && this.panOnlyZoomed && t(this.targetScale) <= t(this.minScale))
            return;
          if (this.emit("touchMove", e2), e2.defaultPrevented)
            return;
          this.addTrackingPoint(n2[0]);
          const { content: o2 } = this, a2 = h(s2[0], s2[1]), r2 = h(n2[0], n2[1]);
          let l2 = 0, d2 = 0;
          if (n2.length > 1) {
            const t2 = o2.getBoundingClientRect();
            l2 = a2.clientX - t2.left - 0.5 * t2.width, d2 = a2.clientY - t2.top - 0.5 * t2.height;
          }
          const u2 = c(s2[0], s2[1]), p2 = c(n2[0], n2[1]);
          let f2 = u2 ? p2 / u2 : 1, m2 = r2.clientX - a2.clientX, g2 = r2.clientY - a2.clientY;
          this.dragOffset.x += m2, this.dragOffset.y += g2, this.dragOffset.time = Date.now() - this.dragStart.time;
          let b2 = t(this.targetScale) === t(this.minScale) && this.option("lockAxis");
          if (b2 && !this.lockedAxis)
            if ("xy" === b2 || "y" === b2 || "touchmove" === e2.type) {
              if (Math.abs(this.dragOffset.x) < 6 && Math.abs(this.dragOffset.y) < 6)
                return void e2.preventDefault();
              const t2 = Math.abs(180 * Math.atan2(this.dragOffset.y, this.dragOffset.x) / Math.PI);
              this.lockedAxis = t2 > 45 && t2 < 135 ? "y" : "x", this.dragOffset.x = 0, this.dragOffset.y = 0, m2 = 0, g2 = 0;
            } else
              this.lockedAxis = b2;
          if (i(e2.target, this.content) && (b2 = "x", this.dragOffset.y = 0), b2 && "xy" !== b2 && this.lockedAxis !== b2 && t(this.targetScale) === t(this.minScale))
            return;
          e2.cancelable && e2.preventDefault(), this.container.classList.add(this.cn("isDragging"));
          const v2 = this.checkBounds(m2, g2);
          this.option("rubberband") ? ("x" !== this.isInfinite && (v2.xDiff > 0 && m2 < 0 || v2.xDiff < 0 && m2 > 0) && (m2 *= Math.max(0, 0.5 - Math.abs(0.75 / this.contentRect.fitWidth * v2.xDiff))), "y" !== this.isInfinite && (v2.yDiff > 0 && g2 < 0 || v2.yDiff < 0 && g2 > 0) && (g2 *= Math.max(0, 0.5 - Math.abs(0.75 / this.contentRect.fitHeight * v2.yDiff)))) : (v2.xDiff && (m2 = 0), v2.yDiff && (g2 = 0));
          const y2 = this.targetScale, w2 = this.minScale, x2 = this.maxScale;
          y2 < 0.5 * w2 && (f2 = Math.max(f2, w2)), y2 > 1.5 * x2 && (f2 = Math.min(f2, x2)), "y" === this.lockedAxis && t(y2) === t(w2) && (m2 = 0), "x" === this.lockedAxis && t(y2) === t(w2) && (g2 = 0), this.applyChange({ originX: l2, originY: d2, panX: m2, panY: g2, scale: f2, friction: this.option("dragFriction"), ignoreBounds: true });
        }
        onPointerUp(t2, e2, n2) {
          if (n2.length)
            return this.dragOffset.x = 0, this.dragOffset.y = 0, void (this.trackingPoints = []);
          this.container.classList.remove(this.cn("isDragging")), this.isDragging && (this.addTrackingPoint(e2), this.panOnlyZoomed && this.contentRect.width - this.contentRect.fitWidth < 1 && this.contentRect.height - this.contentRect.fitHeight < 1 && (this.trackingPoints = []), i(t2.target, this.content) && "y" === this.lockedAxis && (this.trackingPoints = []), this.emit("touchEnd", t2), this.isDragging = false, this.lockedAxis = false, this.state !== g.Destroy && (t2.defaultPrevented || this.startDecelAnim()));
        }
        startDecelAnim() {
          var e2;
          const i2 = this.isScaling;
          this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.isBouncingX = false, this.isBouncingY = false;
          for (const t2 of b)
            this.velocity[t2] = 0;
          this.target.e = this.current.e, this.target.f = this.current.f, E(this.container, "is-scaling"), E(this.container, "is-animating"), this.isTicking = false;
          const { trackingPoints: n2 } = this, s2 = n2[0], o2 = n2[n2.length - 1];
          let a2 = 0, r2 = 0, l2 = 0;
          o2 && s2 && (a2 = o2.clientX - s2.clientX, r2 = o2.clientY - s2.clientY, l2 = o2.time - s2.time);
          const c2 = (null === (e2 = window.visualViewport) || void 0 === e2 ? void 0 : e2.scale) || 1;
          1 !== c2 && (a2 *= c2, r2 *= c2);
          let h2 = 0, d2 = 0, u2 = 0, p2 = 0, f2 = this.option("decelFriction");
          const m2 = this.targetScale;
          if (l2 > 0) {
            u2 = Math.abs(a2) > 3 ? a2 / (l2 / 30) : 0, p2 = Math.abs(r2) > 3 ? r2 / (l2 / 30) : 0;
            const t2 = this.option("maxVelocity");
            t2 && (u2 = Math.max(Math.min(u2, t2), -1 * t2), p2 = Math.max(Math.min(p2, t2), -1 * t2));
          }
          u2 && (h2 = u2 / (1 / (1 - f2) - 1)), p2 && (d2 = p2 / (1 / (1 - f2) - 1)), ("y" === this.option("lockAxis") || "xy" === this.option("lockAxis") && "y" === this.lockedAxis && t(m2) === this.minScale) && (h2 = u2 = 0), ("x" === this.option("lockAxis") || "xy" === this.option("lockAxis") && "x" === this.lockedAxis && t(m2) === this.minScale) && (d2 = p2 = 0);
          const g2 = this.dragOffset.x, v2 = this.dragOffset.y, y2 = this.option("dragMinThreshold") || 0;
          Math.abs(g2) < y2 && Math.abs(v2) < y2 && (h2 = d2 = 0, u2 = p2 = 0), (m2 < this.minScale - 1e-5 || m2 > this.maxScale + 1e-5 || i2 && !h2 && !d2) && (f2 = 0.35), this.applyChange({ panX: h2, panY: d2, friction: f2 }), this.emit("decel", u2, p2, g2, v2);
        }
        onWheel(t2) {
          var e2 = [-t2.deltaX || 0, -t2.deltaY || 0, -t2.detail || 0].reduce(function(t3, e3) {
            return Math.abs(e3) > Math.abs(t3) ? e3 : t3;
          });
          const i2 = Math.max(-1, Math.min(1, e2));
          if (this.emit("wheel", t2, i2), this.panMode === T)
            return;
          if (t2.defaultPrevented)
            return;
          const n2 = this.option("wheel");
          "pan" === n2 ? (t2.preventDefault(), this.panOnlyZoomed && !this.canZoomOut() || this.applyChange({ panX: 2 * -t2.deltaX, panY: 2 * -t2.deltaY, bounce: false })) : "zoom" === n2 && false !== this.option("zoom") && this.zoomWithWheel(t2);
        }
        onMouseMove(t2) {
          this.panWithMouse(t2);
        }
        onKeydown(t2) {
          "Escape" === t2.key && this.toggleFS();
        }
        onResize() {
          this.updateMetrics(), this.checkBounds().inBounds || this.requestTick();
        }
        setTransform() {
          this.emit("beforeTransform");
          const { current: e2, target: i2, content: n2, contentRect: s2 } = this, o2 = Object.assign({}, P);
          for (const n3 of b) {
            const s3 = "e" == n3 || "f" === n3 ? M : C;
            o2[n3] = t(e2[n3], s3), Math.abs(i2[n3] - e2[n3]) < ("e" == n3 || "f" === n3 ? 0.51 : 1e-3) && (e2[n3] = i2[n3]);
          }
          let { a: a2, b: r2, c: l2, d: c2, e: h2, f: d2 } = o2, u2 = `matrix(${a2}, ${r2}, ${l2}, ${c2}, ${h2}, ${d2})`, p2 = n2.parentElement instanceof HTMLPictureElement ? n2.parentElement : n2;
          if (this.option("transformParent") && (p2 = p2.parentElement || p2), p2.style.transform === u2)
            return;
          p2.style.transform = u2;
          const { contentWidth: f2, contentHeight: m2 } = this.calculateContentDim();
          s2.width = f2, s2.height = m2, this.emit("afterTransform");
        }
        updateMetrics(e2 = false) {
          var i2;
          if (!this || this.state === g.Destroy)
            return;
          if (this.isContentLoading)
            return;
          const n2 = Math.max(1, (null === (i2 = window.visualViewport) || void 0 === i2 ? void 0 : i2.scale) || 1), { container: s2, content: o2 } = this, a2 = o2 instanceof HTMLImageElement, r2 = s2.getBoundingClientRect(), l2 = getComputedStyle(this.container);
          let c2 = r2.width * n2, h2 = r2.height * n2;
          const d2 = parseFloat(l2.paddingTop) + parseFloat(l2.paddingBottom), u2 = c2 - (parseFloat(l2.paddingLeft) + parseFloat(l2.paddingRight)), p2 = h2 - d2;
          this.containerRect = { width: c2, height: h2, innerWidth: u2, innerHeight: p2 };
          let f2 = this.option("width") || "auto", m2 = this.option("height") || "auto";
          "auto" === f2 && (f2 = parseFloat(o2.dataset.width || "") || ((t2) => {
            let e3 = 0;
            return e3 = t2 instanceof HTMLImageElement ? t2.naturalWidth : t2 instanceof SVGElement ? t2.width.baseVal.value : Math.max(t2.offsetWidth, t2.scrollWidth), e3 || 0;
          })(o2)), "auto" === m2 && (m2 = parseFloat(o2.dataset.height || "") || ((t2) => {
            let e3 = 0;
            return e3 = t2 instanceof HTMLImageElement ? t2.naturalHeight : t2 instanceof SVGElement ? t2.height.baseVal.value : Math.max(t2.offsetHeight, t2.scrollHeight), e3 || 0;
          })(o2));
          let b2 = o2.parentElement instanceof HTMLPictureElement ? o2.parentElement : o2;
          this.option("transformParent") && (b2 = b2.parentElement || b2);
          const v2 = b2.getAttribute("style") || "";
          b2.style.setProperty("transform", "none", "important"), a2 && (b2.style.width = "", b2.style.height = ""), b2.offsetHeight;
          const y2 = o2.getBoundingClientRect();
          let w2 = y2.width * n2, x2 = y2.height * n2, E2 = 0, S2 = 0;
          a2 && (Math.abs(f2 - w2) > 1 || Math.abs(m2 - x2) > 1) && ({ width: w2, height: x2, top: E2, left: S2 } = ((t2, e3, i3, n3) => {
            const s3 = i3 / n3;
            return s3 > t2 / e3 ? (i3 = t2, n3 = t2 / s3) : (i3 = e3 * s3, n3 = e3), { width: i3, height: n3, top: 0.5 * (e3 - n3), left: 0.5 * (t2 - i3) };
          })(w2, x2, f2, m2)), this.contentRect = Object.assign(Object.assign({}, this.contentRect), { top: y2.top - r2.top + E2, bottom: r2.bottom - y2.bottom + E2, left: y2.left - r2.left + S2, right: r2.right - y2.right + S2, fitWidth: w2, fitHeight: x2, width: w2, height: x2, fullWidth: f2, fullHeight: m2 }), b2.style.cssText = v2, a2 && (b2.style.width = `${w2}px`, b2.style.height = `${x2}px`), this.setTransform(), true !== e2 && this.emit("refresh"), this.ignoreBounds || (t(this.targetScale) < t(this.minScale) ? this.zoomTo(this.minScale, { friction: 0 }) : this.targetScale > this.maxScale ? this.zoomTo(this.maxScale, { friction: 0 }) : this.state === g.Init || this.checkBounds().inBounds || this.requestTick()), this.updateControls();
        }
        getBounds() {
          const e2 = this.option("bounds");
          if ("auto" !== e2)
            return e2;
          const { contentWidth: i2, contentHeight: n2 } = this.calculateContentDim(this.target);
          let s2 = 0, o2 = 0, a2 = 0, r2 = 0;
          const l2 = this.option("infinite");
          if (true === l2 || this.lockedAxis && l2 === this.lockedAxis)
            s2 = -1 / 0, a2 = 1 / 0, o2 = -1 / 0, r2 = 1 / 0;
          else {
            let { containerRect: e3, contentRect: l3 } = this, c2 = t(this.contentRect.fitWidth * this.targetScale, M), h2 = t(this.contentRect.fitHeight * this.targetScale, M), { innerWidth: d2, innerHeight: u2 } = e3;
            if (this.containerRect.width === c2 && (d2 = e3.width), this.containerRect.width === h2 && (u2 = e3.height), i2 > d2) {
              a2 = 0.5 * (i2 - d2), s2 = -1 * a2;
              let t2 = 0.5 * (l3.right - l3.left);
              s2 += t2, a2 += t2;
            }
            if (this.contentRect.fitWidth > d2 && i2 < d2 && (s2 -= 0.5 * (this.contentRect.fitWidth - d2), a2 -= 0.5 * (this.contentRect.fitWidth - d2)), n2 > u2) {
              r2 = 0.5 * (n2 - u2), o2 = -1 * r2;
              let t2 = 0.5 * (l3.bottom - l3.top);
              o2 += t2, r2 += t2;
            }
            this.contentRect.fitHeight > u2 && n2 < u2 && (s2 -= 0.5 * (this.contentRect.fitHeight - u2), a2 -= 0.5 * (this.contentRect.fitHeight - u2));
          }
          return { x: { min: s2, max: a2 }, y: { min: o2, max: r2 } };
        }
        updateControls() {
          const e2 = this, i2 = e2.container, { panMode: n2, contentRect: s2, fullScale: a2, targetScale: r2, coverScale: l2, maxScale: c2, minScale: h2 } = e2;
          let d2 = { toggleMax: r2 - h2 < 0.5 * (c2 - h2) ? c2 : h2, toggleCover: r2 - h2 < 0.5 * (l2 - h2) ? l2 : h2, toggleZoom: r2 - h2 < 0.5 * (a2 - h2) ? a2 : h2 }[e2.option("click") || ""] || h2, u2 = e2.canZoomIn(), p2 = e2.canZoomOut(), f2 = p2 && n2 === O;
          t(r2) < t(h2) && !this.panOnlyZoomed && (f2 = true), (t(s2.width, 1) > t(s2.fitWidth, 1) || t(s2.height, 1) > t(s2.fitHeight, 1)) && (f2 = true), t(s2.width * r2, 1) < t(s2.fitWidth, 1) && (f2 = false), n2 === T && (f2 = false);
          let m2 = u2 && t(d2) > t(r2), g2 = !m2 && !f2 && p2 && t(d2) < t(r2);
          o(i2, this.cn("canZoomIn"), m2), o(i2, this.cn("canZoomOut"), g2), o(i2, this.cn("isDraggable"), f2);
          for (const t2 of i2.querySelectorAll('[data-panzoom-action="zoomIn"]'))
            u2 ? (t2.removeAttribute("disabled"), t2.removeAttribute("tabindex")) : (t2.setAttribute("disabled", ""), t2.setAttribute("tabindex", "-1"));
          for (const t2 of i2.querySelectorAll('[data-panzoom-action="zoomOut"]'))
            p2 ? (t2.removeAttribute("disabled"), t2.removeAttribute("tabindex")) : (t2.setAttribute("disabled", ""), t2.setAttribute("tabindex", "-1"));
          for (const t2 of i2.querySelectorAll('[data-panzoom-action="toggleZoom"],[data-panzoom-action="iterateZoom"]')) {
            u2 || p2 ? (t2.removeAttribute("disabled"), t2.removeAttribute("tabindex")) : (t2.setAttribute("disabled", ""), t2.setAttribute("tabindex", "-1"));
            const e3 = t2.querySelector("g");
            e3 && (e3.style.display = u2 ? "" : "none");
          }
        }
        panTo({ x: t2 = this.target.e, y: e2 = this.target.f, scale: i2 = this.targetScale, friction: n2 = this.option("friction"), angle: s2 = 0, originX: o2 = 0, originY: a2 = 0, flipX: r2 = false, flipY: l2 = false, ignoreBounds: c2 = false }) {
          this.state !== g.Destroy && this.applyChange({ panX: t2 - this.target.e, panY: e2 - this.target.f, scale: i2 / this.targetScale, angle: s2, originX: o2, originY: a2, friction: n2, flipX: r2, flipY: l2, ignoreBounds: c2 });
        }
        applyChange({ panX: e2 = 0, panY: i2 = 0, scale: n2 = 1, angle: s2 = 0, originX: o2 = -this.current.e, originY: a2 = -this.current.f, friction: r2 = this.option("friction"), flipX: l2 = false, flipY: c2 = false, ignoreBounds: h2 = false, bounce: d2 = this.option("bounce") }) {
          if (this.state === g.Destroy)
            return;
          this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.friction = r2 || 0, this.ignoreBounds = h2;
          const { current: u2 } = this, p2 = u2.e, f2 = u2.f, m2 = this.getMatrix(this.target);
          let v2 = new DOMMatrix().translate(p2, f2).translate(o2, a2).translate(e2, i2);
          if (this.option("zoom")) {
            if (!h2) {
              const t2 = this.targetScale, e3 = this.minScale, i3 = this.maxScale;
              t2 * n2 < e3 && (n2 = e3 / t2), t2 * n2 > i3 && (n2 = i3 / t2);
            }
            v2 = v2.scale(n2);
          }
          v2 = v2.translate(-o2, -a2).translate(-p2, -f2).multiply(m2), s2 && (v2 = v2.rotate(s2)), l2 && (v2 = v2.scale(-1, 1)), c2 && (v2 = v2.scale(1, -1));
          for (const e3 of b)
            "e" !== e3 && "f" !== e3 && (v2[e3] > this.minScale + 1e-5 || v2[e3] < this.minScale - 1e-5) ? this.target[e3] = v2[e3] : this.target[e3] = t(v2[e3], M);
          (this.targetScale < this.scale || Math.abs(n2 - 1) > 0.1 || this.panMode === T || false === d2) && !h2 && this.clampTargetBounds(), this.isResting || (this.state = g.Panning, this.requestTick());
        }
        stop(t2 = false) {
          if (this.state === g.Init || this.state === g.Destroy)
            return;
          const e2 = this.isTicking;
          this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.isBouncingX = false, this.isBouncingY = false;
          for (const e3 of b)
            this.velocity[e3] = 0, "current" === t2 ? this.current[e3] = this.target[e3] : "target" === t2 && (this.target[e3] = this.current[e3]);
          this.setTransform(), E(this.container, "is-scaling"), E(this.container, "is-animating"), this.isTicking = false, this.state = g.Ready, e2 && (this.emit("endAnimation"), this.updateControls());
        }
        requestTick() {
          this.isTicking || (this.emit("startAnimation"), this.updateControls(), S(this.container, "is-animating"), this.isScaling && S(this.container, "is-scaling")), this.isTicking = true, this.rAF || (this.rAF = requestAnimationFrame(() => this.animate()));
        }
        panWithMouse(e2, i2 = this.option("mouseMoveFriction")) {
          if (this.pmme = e2, this.panMode !== T || !e2)
            return;
          if (t(this.targetScale) <= t(this.minScale))
            return;
          this.emit("mouseMove", e2);
          const { container: n2, containerRect: s2, contentRect: o2 } = this, a2 = s2.width, r2 = s2.height, l2 = n2.getBoundingClientRect(), c2 = (e2.clientX || 0) - l2.left, h2 = (e2.clientY || 0) - l2.top;
          let { contentWidth: d2, contentHeight: u2 } = this.calculateContentDim(this.target);
          const p2 = this.option("mouseMoveFactor");
          p2 > 1 && (d2 !== a2 && (d2 *= p2), u2 !== r2 && (u2 *= p2));
          let f2 = 0.5 * (d2 - a2) - c2 / a2 * 100 / 100 * (d2 - a2);
          f2 += 0.5 * (o2.right - o2.left);
          let m2 = 0.5 * (u2 - r2) - h2 / r2 * 100 / 100 * (u2 - r2);
          m2 += 0.5 * (o2.bottom - o2.top), this.applyChange({ panX: f2 - this.target.e, panY: m2 - this.target.f, friction: i2 });
        }
        zoomWithWheel(e2) {
          if (this.state === g.Destroy || this.state === g.Init)
            return;
          const i2 = Date.now();
          if (i2 - this.pwt < 45)
            return void e2.preventDefault();
          this.pwt = i2;
          var n2 = [-e2.deltaX || 0, -e2.deltaY || 0, -e2.detail || 0].reduce(function(t2, e3) {
            return Math.abs(e3) > Math.abs(t2) ? e3 : t2;
          });
          const s2 = Math.max(-1, Math.min(1, n2)), { targetScale: o2, maxScale: a2, minScale: r2 } = this;
          let l2 = o2 * (100 + 45 * s2) / 100;
          t(l2) < t(r2) && t(o2) <= t(r2) ? (this.cwd += Math.abs(s2), l2 = r2) : t(l2) > t(a2) && t(o2) >= t(a2) ? (this.cwd += Math.abs(s2), l2 = a2) : (this.cwd = 0, l2 = Math.max(Math.min(l2, a2), r2)), this.cwd > this.option("wheelLimit") || (e2.preventDefault(), t(l2) !== t(o2) && this.zoomTo(l2, { event: e2 }));
        }
        canZoomIn() {
          return this.option("zoom") && (t(this.contentRect.width, 1) < t(this.contentRect.fitWidth, 1) || t(this.targetScale) < t(this.maxScale));
        }
        canZoomOut() {
          return this.option("zoom") && t(this.targetScale) > t(this.minScale);
        }
        zoomIn(t2 = 1.25, e2) {
          this.zoomTo(this.targetScale * t2, e2);
        }
        zoomOut(t2 = 0.8, e2) {
          this.zoomTo(this.targetScale * t2, e2);
        }
        zoomToFit(t2) {
          this.zoomTo("fit", t2);
        }
        zoomToCover(t2) {
          this.zoomTo("cover", t2);
        }
        zoomToFull(t2) {
          this.zoomTo("full", t2);
        }
        zoomToMax(t2) {
          this.zoomTo("max", t2);
        }
        toggleZoom(t2) {
          this.zoomTo(this.targetScale - this.minScale < 0.5 * (this.fullScale - this.minScale) ? "full" : "fit", t2);
        }
        toggleMax(t2) {
          this.zoomTo(this.targetScale - this.minScale < 0.5 * (this.maxScale - this.minScale) ? "max" : "fit", t2);
        }
        toggleCover(t2) {
          this.zoomTo(this.targetScale - this.minScale < 0.5 * (this.coverScale - this.minScale) ? "cover" : "fit", t2);
        }
        iterateZoom(t2) {
          this.zoomTo("next", t2);
        }
        zoomTo(t2 = 1, { friction: e2 = "auto", originX: i2 = 0, originY: n2 = 0, event: s2 } = {}) {
          if (this.isContentLoading || this.state === g.Destroy)
            return;
          const { targetScale: o2 } = this;
          this.stop();
          let a2 = 1;
          if (this.panMode === T && (s2 = this.pmme || s2), s2) {
            const t3 = this.content.getBoundingClientRect(), e3 = s2.clientX || 0, o3 = s2.clientY || 0;
            i2 = e3 - t3.left - 0.5 * t3.width, n2 = o3 - t3.top - 0.5 * t3.height;
          }
          const r2 = this.fullScale, l2 = this.maxScale;
          let c2 = this.coverScale;
          "number" == typeof t2 ? a2 = t2 / o2 : ("next" === t2 && (r2 - c2 < 0.2 && (c2 = r2), t2 = o2 < r2 - 1e-5 ? "full" : o2 < l2 - 1e-5 ? "max" : "fit"), a2 = "full" === t2 ? r2 / o2 || 1 : "cover" === t2 ? c2 / o2 || 1 : "max" === t2 ? l2 / o2 || 1 : 1 / o2 || 1), e2 = "auto" === e2 ? a2 > 1 ? 0.15 : 0.25 : e2, this.applyChange({ scale: a2, originX: i2, originY: n2, friction: e2 }), s2 && this.panMode === T && this.panWithMouse(s2, e2);
        }
        rotateCCW() {
          this.applyChange({ angle: -90 });
        }
        rotateCW() {
          this.applyChange({ angle: 90 });
        }
        flipX() {
          this.applyChange({ flipX: true });
        }
        flipY() {
          this.applyChange({ flipY: true });
        }
        fitX() {
          this.stop("target");
          const { containerRect: t2, contentRect: e2, target: i2 } = this;
          this.applyChange({ panX: 0.5 * t2.width - (e2.left + 0.5 * e2.fitWidth) - i2.e, panY: 0.5 * t2.height - (e2.top + 0.5 * e2.fitHeight) - i2.f, scale: t2.width / e2.fitWidth / this.targetScale, originX: 0, originY: 0, ignoreBounds: true });
        }
        fitY() {
          this.stop("target");
          const { containerRect: t2, contentRect: e2, target: i2 } = this;
          this.applyChange({ panX: 0.5 * t2.width - (e2.left + 0.5 * e2.fitWidth) - i2.e, panY: 0.5 * t2.innerHeight - (e2.top + 0.5 * e2.fitHeight) - i2.f, scale: t2.height / e2.fitHeight / this.targetScale, originX: 0, originY: 0, ignoreBounds: true });
        }
        toggleFS() {
          const { container: t2 } = this, e2 = this.cn("inFullscreen"), i2 = this.cn("htmlHasFullscreen");
          t2.classList.toggle(e2);
          const n2 = t2.classList.contains(e2);
          n2 ? (document.documentElement.classList.add(i2), document.addEventListener("keydown", this.onKeydown, true)) : (document.documentElement.classList.remove(i2), document.removeEventListener("keydown", this.onKeydown, true)), this.updateMetrics(), this.emit(n2 ? "enterFS" : "exitFS");
        }
        getMatrix(t2 = this.current) {
          const { a: e2, b: i2, c: n2, d: s2, e: o2, f: a2 } = t2;
          return new DOMMatrix([e2, i2, n2, s2, o2, a2]);
        }
        reset(t2) {
          if (this.state !== g.Init && this.state !== g.Destroy) {
            this.stop("current");
            for (const t3 of b)
              this.target[t3] = P[t3];
            this.target.a = this.minScale, this.target.d = this.minScale, this.clampTargetBounds(), this.isResting || (this.friction = void 0 === t2 ? this.option("friction") : t2, this.state = g.Panning, this.requestTick());
          }
        }
        destroy() {
          this.stop(), this.state = g.Destroy, this.detachEvents(), this.detachObserver();
          const { container: t2, content: e2 } = this, i2 = this.option("classes") || {};
          for (const e3 of Object.values(i2))
            t2.classList.remove(e3 + "");
          e2 && (e2.removeEventListener("load", this.onLoad), e2.removeEventListener("error", this.onError)), this.detachPlugins();
        }
      }
      Object.defineProperty(R, "defaults", { enumerable: true, configurable: true, writable: true, value: y }), Object.defineProperty(R, "Plugins", { enumerable: true, configurable: true, writable: true, value: {} });
      const k = function(t2, e2) {
        let i2 = true;
        return (...n2) => {
          i2 && (i2 = false, t2(...n2), setTimeout(() => {
            i2 = true;
          }, e2));
        };
      }, I = (t2, e2) => {
        let i2 = [];
        return t2.childNodes.forEach((t3) => {
          t3.nodeType !== Node.ELEMENT_NODE || e2 && !t3.matches(e2) || i2.push(t3);
        }), i2;
      }, D = { viewport: null, track: null, enabled: true, slides: [], axis: "x", transition: "fade", preload: 1, slidesPerPage: "auto", initialPage: 0, friction: 0.12, Panzoom: { decelFriction: 0.12 }, center: true, infinite: true, fill: true, dragFree: false, adaptiveHeight: false, direction: "ltr", classes: { container: "f-carousel", viewport: "f-carousel__viewport", track: "f-carousel__track", slide: "f-carousel__slide", isLTR: "is-ltr", isRTL: "is-rtl", isHorizontal: "is-horizontal", isVertical: "is-vertical", inTransition: "in-transition", isSelected: "is-selected" }, l10n: { NEXT: "Next slide", PREV: "Previous slide", GOTO: "Go to slide #%d" } };
      var F;
      !function(t2) {
        t2[t2.Init = 0] = "Init", t2[t2.Ready = 1] = "Ready", t2[t2.Destroy = 2] = "Destroy";
      }(F || (F = {}));
      const j = (t2) => {
        if ("string" == typeof t2 && (t2 = { html: t2 }), !(t2 instanceof String || t2 instanceof HTMLElement)) {
          const e2 = t2.thumb;
          void 0 !== e2 && ("string" == typeof e2 && (t2.thumbSrc = e2), e2 instanceof HTMLImageElement && (t2.thumbEl = e2, t2.thumbElSrc = e2.src, t2.thumbSrc = e2.src), delete t2.thumb);
        }
        return Object.assign({ html: "", el: null, isDom: false, class: "", index: -1, dim: 0, gap: 0, pos: 0, transition: false }, t2);
      }, H = (t2 = {}) => Object.assign({ index: -1, slides: [], dim: 0, pos: -1 }, t2);
      class B extends f {
        constructor(t2, e2) {
          super(e2), Object.defineProperty(this, "instance", { enumerable: true, configurable: true, writable: true, value: t2 });
        }
        attach() {
        }
        detach() {
        }
      }
      const N = { classes: { list: "f-carousel__dots", isDynamic: "is-dynamic", hasDots: "has-dots", dot: "f-carousel__dot", isBeforePrev: "is-before-prev", isPrev: "is-prev", isCurrent: "is-current", isNext: "is-next", isAfterNext: "is-after-next" }, dotTpl: '<button type="button" data-carousel-page="%i" aria-label="{{GOTO}}"><span class="f-carousel__dot" aria-hidden="true"></span></button>', dynamicFrom: 11, maxCount: 1 / 0, minCount: 2 };
      class _ extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "isDynamic", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "list", { enumerable: true, configurable: true, writable: true, value: null });
        }
        onRefresh() {
          this.refresh();
        }
        build() {
          let t2 = this.list;
          return t2 || (t2 = document.createElement("ul"), S(t2, this.cn("list")), t2.setAttribute("role", "tablist"), this.instance.container.appendChild(t2), S(this.instance.container, this.cn("hasDots")), this.list = t2), t2;
        }
        refresh() {
          var t2;
          const e2 = this.instance.pages.length, i2 = Math.min(2, this.option("minCount")), n2 = Math.max(2e3, this.option("maxCount")), s2 = this.option("dynamicFrom");
          if (e2 < i2 || e2 > n2)
            return void this.cleanup();
          const a2 = "number" == typeof s2 && e2 > 5 && e2 >= s2, r2 = !this.list || this.isDynamic !== a2 || this.list.children.length !== e2;
          r2 && this.cleanup();
          const l2 = this.build();
          if (o(l2, this.cn("isDynamic"), !!a2), r2)
            for (let t3 = 0; t3 < e2; t3++)
              l2.append(this.createItem(t3));
          let c2, h2 = 0;
          for (const e3 of [...l2.children]) {
            const i3 = h2 === this.instance.page;
            i3 && (c2 = e3), o(e3, this.cn("isCurrent"), i3), null === (t2 = e3.children[0]) || void 0 === t2 || t2.setAttribute("aria-selected", i3 ? "true" : "false");
            for (const t3 of ["isBeforePrev", "isPrev", "isNext", "isAfterNext"])
              E(e3, this.cn(t3));
            h2++;
          }
          if (c2 = c2 || l2.firstChild, a2 && c2) {
            const t3 = c2.previousElementSibling, e3 = t3 && t3.previousElementSibling;
            S(t3, this.cn("isPrev")), S(e3, this.cn("isBeforePrev"));
            const i3 = c2.nextElementSibling, n3 = i3 && i3.nextElementSibling;
            S(i3, this.cn("isNext")), S(n3, this.cn("isAfterNext"));
          }
          this.isDynamic = a2;
        }
        createItem(t2 = 0) {
          var e2;
          const i2 = document.createElement("li");
          i2.setAttribute("role", "presentation");
          const s2 = n(this.instance.localize(this.option("dotTpl"), [["%d", t2 + 1]]).replace(/\%i/g, t2 + ""));
          return i2.appendChild(s2), null === (e2 = i2.children[0]) || void 0 === e2 || e2.setAttribute("role", "tab"), i2;
        }
        cleanup() {
          this.list && (this.list.remove(), this.list = null), this.isDynamic = false, E(this.instance.container, this.cn("hasDots"));
        }
        attach() {
          this.instance.on(["refresh", "change"], this.onRefresh);
        }
        detach() {
          this.instance.off(["refresh", "change"], this.onRefresh), this.cleanup();
        }
      }
      Object.defineProperty(_, "defaults", { enumerable: true, configurable: true, writable: true, value: N });
      const W = "disabled", $ = "next", X = "prev";
      class Y extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "prev", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "next", { enumerable: true, configurable: true, writable: true, value: null });
        }
        onRefresh() {
          const t2 = this.instance, e2 = t2.pages.length, i2 = t2.page;
          if (e2 < 2)
            return void this.cleanup();
          this.build();
          let n2 = this.prev, s2 = this.next;
          n2 && s2 && (n2.removeAttribute(W), s2.removeAttribute(W), t2.isInfinite || (i2 <= 0 && n2.setAttribute(W, ""), i2 >= e2 - 1 && s2.setAttribute(W, "")));
        }
        createButton(t2) {
          const e2 = this.instance, i2 = document.createElement("button");
          i2.setAttribute("tabindex", "0"), i2.setAttribute("title", e2.localize(`{{${t2.toUpperCase()}}}`)), S(i2, this.cn("button") + " " + this.cn(t2 === $ ? "isNext" : "isPrev"));
          const n2 = e2.isRTL ? t2 === $ ? X : $ : t2;
          var s2;
          return i2.innerHTML = e2.localize(this.option(`${n2}Tpl`)), i2.dataset[`carousel${s2 = t2, s2 ? s2.match("^[a-z]") ? s2.charAt(0).toUpperCase() + s2.substring(1) : s2 : ""}`] = "true", i2;
        }
        build() {
          let t2 = this.container;
          t2 || (this.container = t2 = document.createElement("div"), S(t2, this.cn("container")), this.instance.container.appendChild(t2)), this.next || (this.next = t2.appendChild(this.createButton($))), this.prev || (this.prev = t2.appendChild(this.createButton(X)));
        }
        cleanup() {
          this.prev && this.prev.remove(), this.next && this.next.remove(), this.container && this.container.remove(), this.prev = null, this.next = null, this.container = null;
        }
        attach() {
          this.instance.on(["refresh", "change"], this.onRefresh);
        }
        detach() {
          this.instance.off(["refresh", "change"], this.onRefresh), this.cleanup();
        }
      }
      Object.defineProperty(Y, "defaults", { enumerable: true, configurable: true, writable: true, value: { classes: { container: "f-carousel__nav", button: "f-button", isNext: "is-next", isPrev: "is-prev" }, nextTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M9 3l9 9-9 9"/></svg>', prevTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M15 3l-9 9 9 9"/></svg>' } });
      class q extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "selectedIndex", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "target", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "nav", { enumerable: true, configurable: true, writable: true, value: null });
        }
        addAsTargetFor(t2) {
          this.target = this.instance, this.nav = t2, this.attachEvents();
        }
        addAsNavFor(t2) {
          this.nav = this.instance, this.target = t2, this.attachEvents();
        }
        attachEvents() {
          this.nav && this.target && (this.nav.options.initialSlide = this.target.options.initialPage, this.nav.on("ready", this.onNavReady), this.nav.state === F.Ready && this.onNavReady(this.nav), this.target.on("ready", this.onTargetReady), this.target.state === F.Ready && this.onTargetReady(this.target));
        }
        onNavReady(t2) {
          t2.on("createSlide", this.onNavCreateSlide), t2.on("Panzoom.click", this.onNavClick), t2.on("Panzoom.touchEnd", this.onNavTouch), this.onTargetChange();
        }
        onTargetReady(t2) {
          t2.on("change", this.onTargetChange), t2.on("Panzoom.refresh", this.onTargetChange), this.onTargetChange();
        }
        onNavClick(t2, e2, i2) {
          i2.pointerType || this.onNavTouch(t2, t2.panzoom, i2);
        }
        onNavTouch(t2, e2, i2) {
          var n2, s2;
          if (Math.abs(e2.dragOffset.x) > 3 || Math.abs(e2.dragOffset.y) > 3)
            return;
          const o2 = i2.target, { nav: a2, target: r2 } = this;
          if (!a2 || !r2 || !o2)
            return;
          const l2 = o2.closest("[data-index]");
          if (i2.stopPropagation(), i2.preventDefault(), !l2)
            return;
          const c2 = parseInt(l2.dataset.index || "", 10) || 0, h2 = r2.getPageForSlide(c2), d2 = a2.getPageForSlide(c2);
          a2.slideTo(d2), r2.slideTo(h2, { friction: (null === (s2 = null === (n2 = this.nav) || void 0 === n2 ? void 0 : n2.plugins) || void 0 === s2 ? void 0 : s2.Sync.option("friction")) || 0 }), this.markSelectedSlide(c2);
        }
        onNavCreateSlide(t2, e2) {
          e2.index === this.selectedIndex && this.markSelectedSlide(e2.index);
        }
        onTargetChange() {
          const { target: t2, nav: e2 } = this;
          if (!t2 || !e2)
            return;
          if (e2.state !== F.Ready || t2.state !== F.Ready)
            return;
          const i2 = t2.pages[t2.page].slides[0].index, n2 = e2.getPageForSlide(i2);
          this.markSelectedSlide(i2), e2.slideTo(n2);
        }
        markSelectedSlide(t2) {
          const e2 = this.nav;
          e2 && e2.state === F.Ready && (this.selectedIndex = t2, [...e2.slides].map((e3) => {
            e3.el && e3.el.classList[e3.index === t2 ? "add" : "remove"]("is-nav-selected");
          }));
        }
        attach() {
          const t2 = this;
          let e2 = t2.options.target, i2 = t2.options.nav;
          e2 ? t2.addAsNavFor(e2) : i2 && t2.addAsTargetFor(i2);
        }
        detach() {
          const t2 = this, e2 = t2.nav, i2 = t2.target;
          e2 && (e2.off("ready", t2.onNavReady), e2.off("createSlide", t2.onNavCreateSlide), e2.off("Panzoom.click", t2.onNavClick), e2.off("Panzoom.touchEnd", t2.onNavTouch)), t2.nav = null, i2 && (i2.off("ready", t2.onTargetReady), i2.off("refresh", t2.onTargetChange), i2.off("change", t2.onTargetChange)), t2.target = null;
        }
      }
      Object.defineProperty(q, "defaults", { enumerable: true, configurable: true, writable: true, value: { friction: 0.35 } });
      const V = { Navigation: Y, Dots: _, Sync: q };
      class Z extends m {
        get axis() {
          return this.isHorizontal ? "e" : "f";
        }
        get isEnabled() {
          return this.state === F.Ready;
        }
        get isInfinite() {
          let t2 = false;
          const { contentDim: e2, viewportDim: i2, pages: n2, slides: s2 } = this;
          return n2.length >= 2 && e2 + s2[0].dim >= i2 && (t2 = this.option("infinite")), t2;
        }
        get isRTL() {
          return "rtl" === this.option("direction");
        }
        get isHorizontal() {
          return "x" === this.option("axis");
        }
        constructor(t2, e2 = {}, i2 = {}) {
          if (super(), Object.defineProperty(this, "userOptions", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "userPlugins", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "bp", { enumerable: true, configurable: true, writable: true, value: "" }), Object.defineProperty(this, "lp", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: F.Init }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "prevPage", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "viewport", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "track", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "slides", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "pages", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "panzoom", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "inTransition", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Set() }), Object.defineProperty(this, "contentDim", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "viewportDim", { enumerable: true, configurable: true, writable: true, value: 0 }), "string" == typeof t2 && (t2 = document.querySelector(t2)), !t2 || !x(t2))
            throw new Error("No Element found");
          this.container = t2, this.slideNext = k(this.slideNext.bind(this), 150), this.slidePrev = k(this.slidePrev.bind(this), 150), this.userOptions = e2, this.userPlugins = i2, queueMicrotask(() => {
            this.processOptions();
          });
        }
        processOptions() {
          const t2 = u({}, Z.defaults, this.userOptions);
          let e2 = "";
          const i2 = t2.breakpoints;
          if (i2 && d(i2))
            for (const [n2, s2] of Object.entries(i2))
              window.matchMedia(n2).matches && d(s2) && (e2 += n2, u(t2, s2));
          e2 === this.bp && this.state !== F.Init || (this.bp = e2, this.state === F.Ready && (t2.initialSlide = this.pages[this.page].slides[0].index), this.state !== F.Init && this.destroy(), super.setOptions(t2), false === this.option("enabled") ? this.attachEvents() : setTimeout(() => {
            this.init();
          }, 0));
        }
        init() {
          this.state = F.Init, this.emit("init"), this.attachPlugins(Object.assign(Object.assign({}, Z.Plugins), this.userPlugins)), this.initLayout(), this.initSlides(), this.updateMetrics(), this.setInitialPosition(), this.initPanzoom(), this.attachEvents(), this.state = F.Ready, this.emit("ready");
        }
        initLayout() {
          const { container: t2 } = this, e2 = this.option("classes");
          S(t2, this.cn("container")), o(t2, e2.isLTR, !this.isRTL), o(t2, e2.isRTL, this.isRTL), o(t2, e2.isVertical, !this.isHorizontal), o(t2, e2.isHorizontal, this.isHorizontal);
          let i2 = this.option("viewport") || t2.querySelector(`.${e2.viewport}`);
          i2 || (i2 = document.createElement("div"), S(i2, e2.viewport), i2.append(...I(t2, `.${e2.slide}`)), t2.prepend(i2));
          let n2 = this.option("track") || t2.querySelector(`.${e2.track}`);
          n2 || (n2 = document.createElement("div"), S(n2, e2.track), n2.append(...Array.from(i2.childNodes))), n2.setAttribute("aria-live", "polite"), i2.contains(n2) || i2.prepend(n2), this.viewport = i2, this.track = n2, this.emit("initLayout");
        }
        initSlides() {
          const { track: t2 } = this;
          if (t2) {
            this.slides = [], [...I(t2, `.${this.cn("slide")}`)].forEach((t3) => {
              if (x(t3)) {
                const e2 = j({ el: t3, isDom: true, index: this.slides.length });
                this.slides.push(e2), this.emit("initSlide", e2, this.slides.length);
              }
            });
            for (let t3 of this.option("slides", [])) {
              const e2 = j(t3);
              e2.index = this.slides.length, this.slides.push(e2), this.emit("initSlide", e2, this.slides.length);
            }
            this.emit("initSlides");
          }
        }
        setInitialPage() {
          let t2 = 0;
          const e2 = this.option("initialSlide");
          t2 = "number" == typeof e2 ? this.getPageForSlide(e2) : parseInt(this.option("initialPage", 0) + "", 10) || 0, this.page = t2;
        }
        setInitialPosition() {
          if (!this.track || !this.pages.length)
            return;
          const t2 = this.isHorizontal;
          let e2 = this.page;
          this.pages[e2] || (this.page = e2 = 0);
          const i2 = this.pages[e2].pos * (this.isRTL && t2 ? 1 : -1), n2 = t2 ? `${i2}px` : "0", s2 = t2 ? "0" : `${i2}px`;
          this.track.style.transform = `translate3d(${n2}, ${s2}, 0) scale(1)`, this.option("adaptiveHeight") && this.setViewportHeight();
        }
        initPanzoom() {
          this.panzoom && (this.panzoom.destroy(), this.panzoom = null);
          const t2 = this.option("Panzoom") || {};
          this.panzoom = new R(this.viewport, u({}, { content: this.track, zoom: false, panOnlyZoomed: false, lockAxis: this.isHorizontal ? "x" : "y", infinite: this.isInfinite, click: false, dblClick: false, touch: (t3) => !(this.pages.length < 2 && !t3.options.infinite), bounds: () => this.getBounds(), maxVelocity: (t3) => Math.abs(t3.target[this.axis] - t3.current[this.axis]) < 2 * this.viewportDim ? 100 : 0 }, t2)), this.panzoom.on("*", (t3, e2, ...i2) => {
            this.emit(`Panzoom.${e2}`, t3, ...i2);
          }), this.panzoom.on("decel", this.onDecel), this.panzoom.on("refresh", this.onRefresh), this.panzoom.on("beforeTransform", this.onBeforeTransform), this.panzoom.on("endAnimation", this.onEndAnimation);
        }
        attachEvents() {
          const t2 = this.container;
          t2 && (t2.addEventListener("click", this.onClick, { passive: false, capture: false }), t2.addEventListener("slideTo", this.onSlideTo)), window.addEventListener("resize", this.onResize);
        }
        createPages() {
          let t2 = [];
          const { contentDim: e2, viewportDim: i2 } = this;
          let n2 = this.option("slidesPerPage");
          ("number" != typeof n2 || e2 <= i2) && (n2 = 1 / 0);
          let s2 = 0, o2 = 0, a2 = 0;
          for (const e3 of this.slides)
            (!t2.length || o2 + e3.dim > i2 || a2 === n2) && (t2.push(H()), s2 = t2.length - 1, o2 = 0, a2 = 0), t2[s2].slides.push(e3), o2 += e3.dim + e3.gap, a2++;
          return t2;
        }
        processPages() {
          const e2 = this.pages, { contentDim: i2, viewportDim: n2 } = this, s2 = this.option("center"), o2 = this.option("fill"), a2 = o2 && s2 && i2 > n2 && !this.isInfinite;
          if (e2.forEach((t2, e3) => {
            t2.index = e3, t2.pos = t2.slides[0].pos, t2.dim = 0;
            for (const [e4, i3] of t2.slides.entries())
              t2.dim += i3.dim, e4 < t2.slides.length - 1 && (t2.dim += i3.gap);
            a2 && t2.pos + 0.5 * t2.dim < 0.5 * n2 ? t2.pos = 0 : a2 && t2.pos + 0.5 * t2.dim >= i2 - 0.5 * n2 ? t2.pos = i2 - n2 : s2 && (t2.pos += -0.5 * (n2 - t2.dim));
          }), e2.forEach((e3, s3) => {
            o2 && !this.isInfinite && i2 > n2 && (e3.pos = Math.max(e3.pos, 0), e3.pos = Math.min(e3.pos, i2 - n2)), e3.pos = t(e3.pos, 1e3), e3.dim = t(e3.dim, 1e3), e3.pos < 0.1 && e3.pos > -0.1 && (e3.pos = 0);
          }), this.isInfinite)
            return e2;
          const r2 = [];
          let l2;
          return e2.forEach((t2) => {
            const e3 = Object.assign({}, t2);
            l2 && e3.pos === l2.pos ? (l2.dim += e3.dim, l2.slides = [...l2.slides, ...e3.slides]) : (e3.index = r2.length, l2 = e3, r2.push(e3));
          }), r2;
        }
        getPageFromIndex(t2 = 0) {
          const e2 = this.pages.length;
          let i2;
          return t2 = parseInt((t2 || 0).toString()) || 0, i2 = this.isInfinite ? (t2 % e2 + e2) % e2 : Math.max(Math.min(t2, e2 - 1), 0), i2;
        }
        getSlideMetrics(e2) {
          var i2;
          const n2 = this.isHorizontal ? "width" : "height";
          let s2 = 0, o2 = 0, a2 = e2.el;
          if (a2 ? s2 = parseFloat(a2.dataset[n2] || "") || 0 : (a2 = document.createElement("div"), a2.style.visibility = "hidden", S(a2, this.cn("slide") + " " + e2.class), (this.track || document.body).prepend(a2)), s2)
            a2.style[n2] = `${s2}px`, a2.style["width" === n2 ? "height" : "width"] = "";
          else {
            const t2 = Math.max(1, (null === (i2 = window.visualViewport) || void 0 === i2 ? void 0 : i2.scale) || 1);
            s2 = a2.getBoundingClientRect()[n2] * t2;
          }
          const r2 = getComputedStyle(a2);
          return "content-box" === r2.boxSizing && (this.isHorizontal ? (s2 += parseFloat(r2.paddingLeft) || 0, s2 += parseFloat(r2.paddingRight) || 0) : (s2 += parseFloat(r2.paddingTop) || 0, s2 += parseFloat(r2.paddingBottom) || 0)), o2 = parseFloat(r2[this.isHorizontal ? "marginRight" : "marginBottom"]) || 0, e2.el || a2.remove(), { dim: t(s2, 1e3), gap: t(o2, 1e3) };
        }
        getBounds() {
          const { isInfinite: t2, isRTL: e2, isHorizontal: i2, pages: n2 } = this;
          let s2 = { min: 0, max: 0 };
          if (t2)
            s2 = { min: -1 / 0, max: 1 / 0 };
          else if (n2.length) {
            const t3 = n2[0].pos, o2 = n2[n2.length - 1].pos;
            s2 = e2 && i2 ? { min: t3, max: o2 } : { min: -1 * o2, max: -1 * t3 };
          }
          return { x: i2 ? s2 : { min: 0, max: 0 }, y: i2 ? { min: 0, max: 0 } : s2 };
        }
        repositionSlides() {
          let e2, { isHorizontal: i2, isRTL: n2, isInfinite: s2, viewport: o2, viewportDim: a2, contentDim: r2, page: l2, pages: c2, slides: h2, panzoom: d2 } = this, u2 = 0, p2 = 0, f2 = 0, m2 = 0;
          d2 ? m2 = -1 * d2.current[this.axis] : c2[l2] && (m2 = c2[l2].pos || 0), e2 = i2 ? n2 ? "right" : "left" : "top", n2 && i2 && (m2 *= -1);
          for (const i3 of h2)
            i3.el ? ("top" === e2 ? (i3.el.style.right = "", i3.el.style.left = "") : i3.el.style.top = "", i3.index !== u2 ? i3.el.style[e2] = 0 === p2 ? "" : `${t(p2, 1e3)}px` : i3.el.style[e2] = "", f2 += i3.dim + i3.gap, u2++) : p2 += i3.dim + i3.gap;
          if (s2 && f2 && o2) {
            let n3 = getComputedStyle(o2), s3 = "padding", l3 = i2 ? "Right" : "Bottom", c3 = parseFloat(n3[s3 + (i2 ? "Left" : "Top")]);
            m2 -= c3, a2 += c3, a2 += parseFloat(n3[s3 + l3]);
            for (const i3 of h2)
              i3.el && (t(i3.pos) < t(a2) && t(i3.pos + i3.dim + i3.gap) < t(m2) && t(m2) > t(r2 - a2) && (i3.el.style[e2] = `${t(p2 + f2, 1e3)}px`), t(i3.pos + i3.gap) >= t(r2 - a2) && t(i3.pos) > t(m2 + a2) && t(m2) < t(a2) && (i3.el.style[e2] = `-${t(f2, 1e3)}px`));
          }
          let g2, b2, v2 = [...this.inTransition];
          if (v2.length > 1 && (g2 = c2[v2[0]], b2 = c2[v2[1]]), g2 && b2) {
            let i3 = 0;
            for (const n3 of h2)
              n3.el ? this.inTransition.has(n3.index) && g2.slides.indexOf(n3) < 0 && (n3.el.style[e2] = `${t(i3 + (g2.pos - b2.pos), 1e3)}px`) : i3 += n3.dim + n3.gap;
          }
        }
        createSlideEl(t2) {
          const { track: e2, slides: i2 } = this;
          if (!e2 || !t2)
            return;
          if (t2.el)
            return;
          const n2 = document.createElement("div");
          S(n2, this.cn("slide")), S(n2, t2.class), S(n2, t2.customClass), t2.html && (n2.innerHTML = t2.html);
          const s2 = [];
          i2.forEach((t3, e3) => {
            t3.el && s2.push(e3);
          });
          const o2 = t2.index;
          let a2 = null;
          if (s2.length) {
            a2 = i2[s2.reduce((t3, e3) => Math.abs(e3 - o2) < Math.abs(t3 - o2) ? e3 : t3)];
          }
          const r2 = a2 && a2.el ? a2.index < t2.index ? a2.el.nextSibling : a2.el : null;
          e2.insertBefore(n2, e2.contains(r2) ? r2 : null), t2.el = n2, this.emit("createSlide", t2);
        }
        removeSlideEl(t2, e2 = false) {
          const i2 = t2.el;
          if (!i2)
            return;
          if (E(i2, this.cn("isSelected")), t2.isDom && !e2)
            return i2.removeAttribute("aria-hidden"), i2.removeAttribute("data-index"), E(i2, this.cn("isSelected")), void (i2.style.left = "");
          this.emit("removeSlide", t2);
          const n2 = new CustomEvent("animationend");
          i2.dispatchEvent(n2), t2.el && t2.el.remove(), t2.el = null;
        }
        transitionTo(e2 = 0, i2 = this.option("transition")) {
          if (!i2)
            return false;
          const { pages: n2, panzoom: s2 } = this;
          e2 = parseInt((e2 || 0).toString()) || 0;
          const o2 = this.getPageFromIndex(e2);
          if (!s2 || !n2[o2] || n2.length < 2 || Math.abs(n2[this.page].slides[0].dim - this.viewportDim) > 1)
            return false;
          const a2 = e2 > this.page ? 1 : -1, r2 = this.pages[o2].pos * (this.isRTL ? 1 : -1);
          if (this.page === o2 && t(r2, 1e3) === t(s2.target[this.axis], 1e3))
            return false;
          this.clearTransitions();
          const l2 = s2.isResting;
          S(this.container, this.cn("inTransition"));
          const c2 = this.pages[this.page].slides[0], h2 = this.pages[o2].slides[0];
          this.inTransition.add(h2.index), this.createSlideEl(h2);
          let d2 = c2.el, u2 = h2.el;
          l2 || "slide" === i2 || (i2 = "fadeFast", d2 = null);
          const p2 = this.isRTL ? "next" : "prev", f2 = this.isRTL ? "prev" : "next";
          return d2 && (this.inTransition.add(c2.index), c2.transition = i2, d2.addEventListener("animationend", this.onAnimationEnd), d2.classList.add(`f-${i2}Out`, `to-${a2 > 0 ? f2 : p2}`)), u2 && (h2.transition = i2, u2.addEventListener("animationend", this.onAnimationEnd), u2.classList.add(`f-${i2}In`, `from-${a2 > 0 ? p2 : f2}`)), s2.panTo({ x: this.isHorizontal ? r2 : 0, y: this.isHorizontal ? 0 : r2, friction: 0 }), this.onChange(o2), true;
        }
        manageSlideVisiblity() {
          const t2 = /* @__PURE__ */ new Set(), e2 = /* @__PURE__ */ new Set(), i2 = this.getVisibleSlides(parseFloat(this.option("preload", 0) + "") || 0);
          for (const n2 of this.slides)
            i2.has(n2) ? t2.add(n2) : e2.add(n2);
          for (const e3 of this.inTransition)
            t2.add(this.slides[e3]);
          for (const e3 of t2)
            this.createSlideEl(e3), this.lazyLoadSlide(e3);
          for (const i3 of e2)
            t2.has(i3) || this.removeSlideEl(i3);
          this.markSelectedSlides(), this.repositionSlides();
        }
        markSelectedSlides() {
          if (!this.pages[this.page] || !this.pages[this.page].slides)
            return;
          const t2 = "aria-hidden";
          let e2 = this.cn("isSelected");
          if (e2)
            for (const i2 of this.slides)
              i2.el && (i2.el.dataset.index = `${i2.index}`, this.pages[this.page].slides.includes(i2) ? (i2.el.classList.contains(e2) || (S(i2.el, e2), this.emit("selectSlide", i2)), i2.el.removeAttribute(t2)) : (i2.el.classList.contains(e2) && (E(i2.el, e2), this.emit("unselectSlide", i2)), i2.el.setAttribute(t2, "true")));
        }
        flipInfiniteTrack() {
          const t2 = this.panzoom;
          if (!t2 || !this.isInfinite)
            return;
          const e2 = "x" === this.option("axis") ? "e" : "f", { viewportDim: i2, contentDim: n2 } = this;
          let s2 = t2.current[e2], o2 = t2.target[e2] - s2, a2 = 0, r2 = 0.5 * i2, l2 = n2;
          this.isRTL && this.isHorizontal ? (s2 < -r2 && (a2 = -1, s2 += l2), s2 > l2 - r2 && (a2 = 1, s2 -= l2)) : (s2 > r2 && (a2 = 1, s2 -= l2), s2 < -l2 + r2 && (a2 = -1, s2 += l2)), a2 && (t2.current[e2] = s2, t2.target[e2] = s2 + o2);
        }
        lazyLoadSlide(t2) {
          const e2 = this, i2 = t2 && t2.el;
          if (!i2)
            return;
          const s2 = /* @__PURE__ */ new Set(), o2 = "f-fadeIn";
          i2.querySelectorAll("[data-lazy-srcset]").forEach((t3) => {
            t3 instanceof HTMLImageElement && s2.add(t3);
          });
          let a2 = Array.from(i2.querySelectorAll("[data-lazy-src]"));
          i2.dataset.lazySrc && a2.push(i2), a2.map((t3) => {
            t3 instanceof HTMLImageElement ? s2.add(t3) : x(t3) && (t3.style.backgroundImage = `url('${t3.dataset.lazySrc || ""}')`, delete t3.dataset.lazySrc);
          });
          const r2 = (t3, i3, n2) => {
            n2 && (n2.remove(), n2 = null), i3.complete && (i3.classList.add(o2), setTimeout(() => {
              i3.classList.remove(o2);
            }, 350), i3.style.display = ""), this.option("adaptiveHeight") && t3.el && this.pages[this.page].slides.indexOf(t3) > -1 && (e2.updateMetrics(), e2.setViewportHeight()), this.emit("load", t3);
          };
          for (const e3 of s2) {
            let i3 = null;
            e3.src = e3.dataset.lazySrcset || e3.dataset.lazySrc || "", delete e3.dataset.lazySrc, delete e3.dataset.lazySrcset, e3.style.display = "none", e3.addEventListener("error", () => {
              r2(t2, e3, i3);
            }), e3.addEventListener("load", () => {
              r2(t2, e3, i3);
            }), setTimeout(() => {
              e3.parentNode && t2.el && (e3.complete ? r2(t2, e3, i3) : (i3 = n(w), e3.parentNode.insertBefore(i3, e3)));
            }, 300);
          }
        }
        onAnimationEnd(t2) {
          var e2;
          const i2 = t2.target, n2 = i2 ? parseInt(i2.dataset.index || "", 10) || 0 : -1, s2 = this.slides[n2], o2 = t2.animationName;
          if (!i2 || !s2 || !o2)
            return;
          const a2 = !!this.inTransition.has(n2) && s2.transition;
          a2 && o2.substring(0, a2.length + 2) === `f-${a2}` && this.inTransition.delete(n2), this.inTransition.size || this.clearTransitions(), n2 === this.page && (null === (e2 = this.panzoom) || void 0 === e2 ? void 0 : e2.isResting) && this.emit("settle");
        }
        onDecel(t2, e2 = 0, i2 = 0, n2 = 0, s2 = 0) {
          const { isRTL: o2, isHorizontal: a2, axis: r2, pages: l2 } = this, c2 = l2.length, h2 = Math.abs(Math.atan2(i2, e2) / (Math.PI / 180));
          let d2 = 0;
          if (d2 = h2 > 45 && h2 < 135 ? a2 ? 0 : i2 : a2 ? e2 : 0, !c2)
            return;
          const u2 = this.option("dragFree");
          let p2 = this.page, f2 = o2 && a2 ? 1 : -1;
          const m2 = t2.target[r2] * f2, g2 = t2.current[r2] * f2;
          let { pageIndex: b2 } = this.getPageFromPosition(m2), { pageIndex: v2 } = this.getPageFromPosition(g2);
          u2 ? this.onChange(b2) : (Math.abs(d2) > 5 ? (l2[p2].dim < document.documentElement["client" + (this.isHorizontal ? "Width" : "Height")] - 1 && (p2 = v2), p2 = o2 && a2 ? d2 < 0 ? p2 - 1 : p2 + 1 : d2 < 0 ? p2 + 1 : p2 - 1) : p2 = 0 === n2 && 0 === s2 ? p2 : v2, this.slideTo(p2, { transition: false, friction: t2.option("decelFriction") }));
        }
        onClick(t2) {
          const e2 = t2.target, i2 = e2 && x(e2) ? e2.dataset : null;
          let n2, s2;
          i2 && (void 0 !== i2.carouselPage ? (s2 = "slideTo", n2 = i2.carouselPage) : void 0 !== i2.carouselNext ? s2 = "slideNext" : void 0 !== i2.carouselPrev && (s2 = "slidePrev")), s2 ? (t2.preventDefault(), t2.stopPropagation(), e2 && !e2.hasAttribute("disabled") && this[s2](n2)) : this.emit("click", t2);
        }
        onSlideTo(t2) {
          const e2 = t2.detail || 0;
          this.slideTo(this.getPageForSlide(e2), { friction: 0 });
        }
        onChange(t2, e2 = 0) {
          const i2 = this.page;
          this.prevPage = i2, this.page = t2, this.option("adaptiveHeight") && this.setViewportHeight(), t2 !== i2 && (this.markSelectedSlides(), this.emit("change", t2, i2, e2));
        }
        onRefresh() {
          let t2 = this.contentDim, e2 = this.viewportDim;
          this.updateMetrics(), this.contentDim === t2 && this.viewportDim === e2 || this.slideTo(this.page, { friction: 0, transition: false });
        }
        onResize() {
          this.option("breakpoints") && this.processOptions();
        }
        onBeforeTransform(t2) {
          this.lp !== t2.current[this.axis] && (this.flipInfiniteTrack(), this.manageSlideVisiblity()), this.lp = t2.current.e;
        }
        onEndAnimation() {
          this.inTransition.size || this.emit("settle");
        }
        reInit(t2 = null, e2 = null) {
          this.destroy(), this.state = F.Init, this.userOptions = t2 || this.userOptions, this.userPlugins = e2 || this.userPlugins, this.processOptions();
        }
        slideTo(t2 = 0, { friction: e2 = this.option("friction"), transition: i2 = this.option("transition") } = {}) {
          if (this.state === F.Destroy)
            return;
          const { axis: n2, isHorizontal: s2, isRTL: o2, pages: a2, panzoom: r2 } = this, l2 = a2.length, c2 = o2 && s2 ? 1 : -1;
          if (!r2 || !l2)
            return;
          if (this.transitionTo(t2, i2))
            return;
          const h2 = this.getPageFromIndex(t2);
          let d2 = a2[h2].pos;
          if (this.isInfinite) {
            const e3 = this.contentDim, i3 = r2.target[n2] * c2;
            if (2 === l2)
              d2 += e3 * Math.floor(parseFloat(t2 + "") / 2);
            else {
              const t3 = i3;
              d2 = [d2, d2 - e3, d2 + e3].reduce(function(e4, i4) {
                return Math.abs(i4 - t3) < Math.abs(e4 - t3) ? i4 : e4;
              });
            }
          }
          d2 *= c2, Math.abs(r2.target[n2] - d2) < 0.1 || (r2.panTo({ x: s2 ? d2 : 0, y: s2 ? 0 : d2, friction: e2 }), this.onChange(h2));
        }
        slideToClosest(t2) {
          if (this.panzoom) {
            const { pageIndex: e2 } = this.getPageFromPosition(this.panzoom.current[this.isHorizontal ? "e" : "f"]);
            this.slideTo(e2, t2);
          }
        }
        slideNext() {
          this.slideTo(this.page + 1);
        }
        slidePrev() {
          this.slideTo(this.page - 1);
        }
        clearTransitions() {
          this.inTransition.clear(), E(this.container, this.cn("inTransition"));
          const t2 = ["to-prev", "to-next", "from-prev", "from-next"];
          for (const e2 of this.slides) {
            const i2 = e2.el;
            if (i2) {
              i2.removeEventListener("animationend", this.onAnimationEnd), i2.classList.remove(...t2);
              const n2 = e2.transition;
              n2 && i2.classList.remove(`f-${n2}Out`, `f-${n2}In`);
            }
          }
          this.manageSlideVisiblity();
        }
        prependSlide(t2) {
          var e2, i2;
          let n2 = Array.isArray(t2) ? t2 : [t2];
          for (const t3 of n2.reverse())
            this.slides.unshift(j(t3));
          for (let t3 = 0; t3 < this.slides.length; t3++)
            this.slides[t3].index = t3;
          const s2 = (null === (e2 = this.pages[this.page]) || void 0 === e2 ? void 0 : e2.pos) || 0;
          this.page += n2.length, this.updateMetrics();
          const o2 = (null === (i2 = this.pages[this.page]) || void 0 === i2 ? void 0 : i2.pos) || 0;
          if (this.panzoom) {
            const t3 = this.isRTL ? s2 - o2 : o2 - s2;
            this.panzoom.target.e -= t3, this.panzoom.current.e -= t3, this.panzoom.requestTick();
          }
        }
        appendSlide(t2) {
          let e2 = Array.isArray(t2) ? t2 : [t2];
          for (const t3 of e2) {
            const e3 = j(t3);
            e3.index = this.slides.length, this.slides.push(e3), this.emit("initSlide", e3, this.slides.length);
          }
          this.updateMetrics();
        }
        removeSlide(t2) {
          const e2 = this.slides.length;
          t2 = (t2 % e2 + e2) % e2, this.removeSlideEl(this.slides[t2], true), this.slides.splice(t2, 1);
          for (let t3 = 0; t3 < this.slides.length; t3++)
            this.slides[t3].index = t3;
          this.updateMetrics(), this.slideTo(this.page, { friction: 0, transition: false });
        }
        updateMetrics() {
          const { panzoom: e2, viewport: i2, track: n2, isHorizontal: s2 } = this;
          if (!n2)
            return;
          const o2 = s2 ? "width" : "height", a2 = s2 ? "offsetWidth" : "offsetHeight";
          if (i2) {
            let e3 = Math.max(i2[a2], t(i2.getBoundingClientRect()[o2], 1e3)), n3 = getComputedStyle(i2), r3 = "padding", l3 = s2 ? "Right" : "Bottom";
            e3 -= parseFloat(n3[r3 + (s2 ? "Left" : "Top")]) + parseFloat(n3[r3 + l3]), this.viewportDim = e3;
          }
          let r2, l2 = this.pages.length, c2 = 0;
          for (const [e3, i3] of this.slides.entries()) {
            let n3 = 0, s3 = 0;
            !i3.el && r2 ? (n3 = r2.dim, s3 = r2.gap) : ({ dim: n3, gap: s3 } = this.getSlideMetrics(i3), r2 = i3), n3 = t(n3, 1e3), s3 = t(s3, 1e3), i3.dim = n3, i3.gap = s3, i3.pos = c2, c2 += n3, (this.isInfinite || e3 < this.slides.length - 1) && (c2 += s3);
          }
          const h2 = this.contentDim;
          c2 = t(c2, 1e3), this.contentDim = c2, e2 && (e2.contentRect[o2] = c2, e2.contentRect["e" === this.axis ? "fullWidth" : "fullHeight"] = c2), this.pages = this.createPages(), this.pages = this.processPages(), this.state === F.Init && this.setInitialPage(), this.page = Math.max(0, Math.min(this.page, this.pages.length - 1)), e2 && l2 === this.pages.length && Math.abs(c2 - h2) > 0.5 && (e2.target[this.axis] = -1 * this.pages[this.page].pos, e2.current[this.axis] = -1 * this.pages[this.page].pos, e2.stop()), this.manageSlideVisiblity(), this.emit("refresh");
        }
        getProgress(e2, i2 = false) {
          void 0 === e2 && (e2 = this.page);
          const n2 = this, s2 = n2.panzoom, o2 = n2.pages[e2] || 0;
          if (!o2 || !s2)
            return 0;
          let a2 = -1 * s2.current.e, r2 = n2.contentDim;
          var l2 = [t((a2 - o2.pos) / (1 * o2.dim), 1e3), t((a2 + r2 - o2.pos) / (1 * o2.dim), 1e3), t((a2 - r2 - o2.pos) / (1 * o2.dim), 1e3)].reduce(function(t2, e3) {
            return Math.abs(e3) < Math.abs(t2) ? e3 : t2;
          });
          return i2 ? l2 : Math.max(-1, Math.min(1, l2));
        }
        setViewportHeight() {
          const { page: t2, pages: e2, viewport: i2, isHorizontal: n2 } = this;
          if (!i2 || !e2[t2])
            return;
          let s2 = 0;
          n2 && this.track && (this.track.style.height = "auto", e2[t2].slides.forEach((t3) => {
            t3.el && (s2 = Math.max(s2, t3.el.offsetHeight));
          })), i2.style.height = s2 ? `${s2}px` : "";
        }
        getPageForSlide(t2) {
          for (const e2 of this.pages)
            for (const i2 of e2.slides)
              if (i2.index === t2)
                return e2.index;
          return -1;
        }
        getVisibleSlides(t2 = 0) {
          var e2;
          const i2 = /* @__PURE__ */ new Set();
          let { contentDim: n2, viewportDim: s2, pages: o2, page: a2 } = this;
          n2 = n2 + (null === (e2 = this.slides[this.slides.length - 1]) || void 0 === e2 ? void 0 : e2.gap) || 0;
          let r2 = 0;
          r2 = this.panzoom ? -1 * this.panzoom.current[this.axis] : o2[a2] && o2[a2].pos || 0, this.isInfinite && (r2 -= Math.floor(r2 / n2) * n2), this.isRTL && this.isHorizontal && (r2 *= -1);
          const l2 = r2 - s2 * t2, c2 = r2 + s2 * (t2 + 1), h2 = this.isInfinite ? [-1, 0, 1] : [0];
          for (const t3 of this.slides)
            for (const e3 of h2) {
              const s3 = t3.pos + e3 * n2, o3 = t3.pos + t3.dim + t3.gap + e3 * n2;
              s3 < c2 && o3 > l2 && i2.add(t3);
            }
          return i2;
        }
        getPageFromPosition(t2) {
          const { viewportDim: e2, contentDim: i2 } = this, n2 = this.pages.length, s2 = this.slides.length, o2 = this.slides[s2 - 1];
          let a2 = 0, r2 = 0, l2 = 0;
          const c2 = this.option("center");
          c2 && (t2 += 0.5 * e2), this.isInfinite || (t2 = Math.max(this.slides[0].pos, Math.min(t2, o2.pos)));
          const h2 = i2 + o2.gap;
          l2 = Math.floor(t2 / h2) || 0, t2 -= l2 * h2;
          let d2 = o2, u2 = this.slides.find((e3) => {
            const i3 = t2 + (d2 && !c2 ? 0.5 * d2.dim : 0);
            return d2 = e3, e3.pos <= i3 && e3.pos + e3.dim + e3.gap > i3;
          });
          return u2 || (u2 = o2), r2 = this.getPageForSlide(u2.index), a2 = r2 + l2 * n2, { page: a2, pageIndex: r2 };
        }
        destroy() {
          if ([F.Destroy].includes(this.state))
            return;
          this.state = F.Destroy;
          const { container: t2, viewport: e2, track: i2, slides: n2, panzoom: s2 } = this, o2 = this.option("classes");
          t2.removeEventListener("click", this.onClick, { passive: false, capture: false }), t2.removeEventListener("slideTo", this.onSlideTo), window.removeEventListener("resize", this.onResize), s2 && (s2.destroy(), this.panzoom = null), n2 && n2.forEach((t3) => {
            this.removeSlideEl(t3);
          }), this.detachPlugins(), e2 && e2.offsetParent && i2 && i2.offsetParent && e2.replaceWith(...i2.childNodes);
          for (const [e3, i3] of Object.entries(o2))
            "container" !== e3 && i3 && t2.classList.remove(i3);
          this.track = null, this.viewport = null, this.page = 0, this.slides = [];
          const a2 = this.events.get("ready");
          this.events = /* @__PURE__ */ new Map(), a2 && this.events.set("ready", a2);
        }
      }
      Object.defineProperty(Z, "Panzoom", { enumerable: true, configurable: true, writable: true, value: R }), Object.defineProperty(Z, "defaults", { enumerable: true, configurable: true, writable: true, value: D }), Object.defineProperty(Z, "Plugins", { enumerable: true, configurable: true, writable: true, value: V });
      const U = function(t2) {
        const e2 = window.pageYOffset, i2 = window.pageYOffset + window.innerHeight;
        if (!x(t2))
          return 0;
        const n2 = t2.getBoundingClientRect(), s2 = n2.y + window.pageYOffset, o2 = n2.y + n2.height + window.pageYOffset;
        if (e2 > o2 || i2 < s2)
          return 0;
        if (e2 < s2 && i2 > o2)
          return 100;
        if (s2 < e2 && o2 > i2)
          return 100;
        let a2 = n2.height;
        s2 < e2 && (a2 -= window.pageYOffset - s2), o2 > i2 && (a2 -= o2 - i2);
        const r2 = a2 / window.innerHeight * 100;
        return Math.round(r2);
      }, G = !("undefined" == typeof window || !window.document || !window.document.createElement);
      let K;
      const J = ["a[href]", "area[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "button:not([disabled]):not([aria-hidden]):not(.fancybox-focus-guard)", "iframe", "object", "embed", "video", "audio", "[contenteditable]", '[tabindex]:not([tabindex^="-"]):not([disabled]):not([aria-hidden])'].join(","), Q = (t2) => {
        if (t2 && G) {
          void 0 === K && document.createElement("div").focus({ get preventScroll() {
            return K = true, false;
          } });
          try {
            if (K)
              t2.focus({ preventScroll: true });
            else {
              const e2 = window.pageXOffset || document.body.scrollTop, i2 = window.pageYOffset || document.body.scrollLeft;
              t2.focus(), document.body.scrollTo({ top: e2, left: i2, behavior: "auto" });
            }
          } catch (t3) {
          }
        }
      }, tt = { dragToClose: true, hideScrollbar: true, Carousel: { classes: { container: "fancybox__carousel", viewport: "fancybox__viewport", track: "fancybox__track", slide: "fancybox__slide" } }, contentClick: "toggleZoom", contentDblClick: false, backdropClick: "close", animated: true, idle: 3500, showClass: "f-zoomInUp", hideClass: "f-fadeOut", commonCaption: false, parentEl: null, startIndex: 0, l10n: Object.assign(Object.assign({}, v), { CLOSE: "Close", NEXT: "Next", PREV: "Previous", MODAL: "You can close this modal content with the ESC key", ERROR: "Something Went Wrong, Please Try Again Later", IMAGE_ERROR: "Image Not Found", ELEMENT_NOT_FOUND: "HTML Element Not Found", AJAX_NOT_FOUND: "Error Loading AJAX : Not Found", AJAX_FORBIDDEN: "Error Loading AJAX : Forbidden", IFRAME_ERROR: "Error Loading Page", TOGGLE_ZOOM: "Toggle zoom level", TOGGLE_THUMBS: "Toggle thumbnails", TOGGLE_SLIDESHOW: "Toggle slideshow", TOGGLE_FULLSCREEN: "Toggle full-screen mode", DOWNLOAD: "Download" }), tpl: { closeButton: '<button data-fancybox-close class="f-button is-close-btn" title="{{CLOSE}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M20 20L4 4m16 0L4 20"/></svg></button>', main: '<div class="fancybox__container" role="dialog" aria-modal="true" aria-label="{{MODAL}}" tabindex="-1">\n    <div class="fancybox__backdrop"></div>\n    <div class="fancybox__carousel"></div>\n    <div class="fancybox__footer"></div>\n  </div>' }, groupAll: false, groupAttr: "data-fancybox", defaultType: "image", defaultDisplay: "block", autoFocus: true, trapFocus: true, placeFocusBack: true, closeButton: "auto", keyboard: { Escape: "close", Delete: "close", Backspace: "close", PageUp: "next", PageDown: "prev", ArrowUp: "prev", ArrowDown: "next", ArrowRight: "next", ArrowLeft: "prev" }, Fullscreen: { autoStart: false }, compact: () => window.matchMedia("(max-width: 578px), (max-height: 578px)").matches, wheel: "zoom" };
      var et, it;
      !function(t2) {
        t2[t2.Init = 0] = "Init", t2[t2.Ready = 1] = "Ready", t2[t2.Closing = 2] = "Closing", t2[t2.CustomClosing = 3] = "CustomClosing", t2[t2.Destroy = 4] = "Destroy";
      }(et || (et = {})), function(t2) {
        t2[t2.Loading = 0] = "Loading", t2[t2.Opening = 1] = "Opening", t2[t2.Ready = 2] = "Ready", t2[t2.Closing = 3] = "Closing";
      }(it || (it = {}));
      const nt = () => {
        queueMicrotask(() => {
          (() => {
            const { slug: t2, index: e2 } = st.parseURL(), i2 = _t.getInstance();
            if (i2 && false !== i2.option("Hash")) {
              const n2 = i2.carousel;
              if (t2 && n2) {
                for (let e3 of n2.slides)
                  if (e3.slug && e3.slug === t2)
                    return n2.slideTo(e3.index);
                if (t2 === i2.option("slug"))
                  return n2.slideTo(e2 - 1);
                const s2 = i2.getSlide(), o2 = s2 && s2.triggerEl && s2.triggerEl.dataset;
                if (o2 && o2.fancybox === t2)
                  return n2.slideTo(e2 - 1);
              }
              st.hasSilentClose = true, i2.close();
            }
            st.startFromUrl();
          })();
        });
      };
      class st extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "origHash", { enumerable: true, configurable: true, writable: true, value: "" }), Object.defineProperty(this, "timer", { enumerable: true, configurable: true, writable: true, value: null });
        }
        onChange() {
          const t2 = this.instance, e2 = t2.carousel;
          this.timer && clearTimeout(this.timer);
          const i2 = t2.getSlide();
          if (!e2 || !i2)
            return;
          const n2 = t2.isOpeningSlide(i2), s2 = new URL(document.URL).hash;
          let o2, a2 = i2.slug || void 0, r2 = i2.triggerEl || void 0;
          o2 = a2 || this.instance.option("slug"), !o2 && r2 && r2.dataset && (o2 = r2.dataset.fancybox);
          let l2 = "";
          o2 && "true" !== o2 && (l2 = "#" + o2 + (!a2 && e2.slides.length > 1 ? "-" + (i2.index + 1) : "")), n2 && (this.origHash = s2 !== l2 ? s2 : ""), l2 && s2 !== l2 && (this.timer = setTimeout(() => {
            try {
              t2.state === et.Ready && window.history[n2 ? "pushState" : "replaceState"]({}, document.title, window.location.pathname + window.location.search + l2);
            } catch (t3) {
            }
          }, 300));
        }
        onClose() {
          if (this.timer && clearTimeout(this.timer), true !== st.hasSilentClose)
            try {
              window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (this.origHash || ""));
            } catch (t2) {
            }
        }
        attach() {
          const t2 = this.instance;
          t2.on("Carousel.ready", this.onChange), t2.on("Carousel.change", this.onChange), t2.on("close", this.onClose);
        }
        detach() {
          const t2 = this.instance;
          t2.off("Carousel.ready", this.onChange), t2.off("Carousel.change", this.onChange), t2.off("close", this.onClose);
        }
        static parseURL() {
          const t2 = window.location.hash.slice(1), e2 = t2.split("-"), i2 = e2[e2.length - 1], n2 = i2 && /^\+?\d+$/.test(i2) && parseInt(e2.pop() || "1", 10) || 1;
          return { hash: t2, slug: e2.join("-"), index: n2 };
        }
        static startFromUrl() {
          if (st.hasSilentClose = false, _t.getInstance() || false === _t.defaults.Hash)
            return;
          const { hash: t2, slug: e2, index: i2 } = st.parseURL();
          if (!e2)
            return;
          let n2 = document.querySelector(`[data-slug="${t2}"]`);
          if (n2 && n2.dispatchEvent(new CustomEvent("click", { bubbles: true, cancelable: true })), _t.getInstance())
            return;
          const s2 = document.querySelectorAll(`[data-fancybox="${e2}"]`);
          s2.length && (n2 = s2[i2 - 1], n2 && n2.dispatchEvent(new CustomEvent("click", { bubbles: true, cancelable: true })));
        }
        static destroy() {
          window.removeEventListener("hashchange", nt, false);
        }
      }
      function ot() {
        window.addEventListener("hashchange", nt, false), setTimeout(() => {
          st.startFromUrl();
        }, 500);
      }
      Object.defineProperty(st, "defaults", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(st, "hasSilentClose", { enumerable: true, configurable: true, writable: true, value: false }), G && (/complete|interactive|loaded/.test(document.readyState) ? ot() : document.addEventListener("DOMContentLoaded", ot));
      class at extends B {
        onCreateSlide(t2, e2, i2) {
          const n2 = this.instance.optionFor(i2, "src") || "";
          i2.el && "image" === i2.type && "string" == typeof n2 && this.setImage(i2, n2);
        }
        onRemoveSlide(t2, e2, i2) {
          i2.panzoom && i2.panzoom.destroy(), i2.panzoom = void 0, i2.imageEl = void 0;
        }
        onChange(t2, e2, i2, n2) {
          for (const t3 of e2.slides) {
            const e3 = t3.panzoom;
            e3 && t3.index !== i2 && e3.reset(0.35);
          }
        }
        onClose() {
          var t2;
          const e2 = this.instance, i2 = e2.container, n2 = e2.getSlide();
          if (!i2 || !i2.parentElement || !n2)
            return;
          const { el: s2, contentEl: o2, panzoom: a2 } = n2, r2 = n2.thumbElSrc;
          if (!s2 || !r2 || !o2 || !a2 || a2.isContentLoading || a2.state === g.Init || a2.state === g.Destroy)
            return;
          a2.updateMetrics();
          let l2 = this.getZoomInfo(n2);
          if (!l2)
            return;
          this.instance.state = et.CustomClosing, i2.classList.remove("is-zooming-in"), i2.classList.add("is-zooming-out"), o2.style.backgroundImage = `url('${r2}')`;
          const c2 = i2.getBoundingClientRect();
          1 === ((null === (t2 = window.visualViewport) || void 0 === t2 ? void 0 : t2.scale) || 1) && Object.assign(i2.style, { position: "absolute", top: `${window.pageYOffset}px`, left: `${window.pageXOffset}px`, bottom: "auto", right: "auto", width: `${c2.width}px`, height: `${c2.height}px`, overflow: "hidden" });
          const { x: h2, y: d2, scale: u2, opacity: p2 } = l2;
          if (p2) {
            const t3 = ((t4, e3, i3, n3) => {
              const s3 = e3 - t4, o3 = n3 - i3;
              return (e4) => i3 + ((e4 - t4) / s3 * o3 || 0);
            })(a2.scale, u2, 1, 0);
            a2.on("afterTransform", () => {
              o2.style.opacity = t3(a2.scale) + "";
            });
          }
          a2.on("endAnimation", () => {
            e2.destroy();
          }), a2.target.a = u2, a2.target.b = 0, a2.target.c = 0, a2.target.d = u2, a2.panTo({ x: h2, y: d2, scale: u2, friction: p2 ? 0.2 : 0.33, ignoreBounds: true }), a2.isResting && e2.destroy();
        }
        setImage(t2, e2) {
          const i2 = this.instance;
          t2.src = e2, this.process(t2, e2).then((e3) => {
            var n2;
            const s2 = t2.contentEl, o2 = t2.imageEl, a2 = t2.thumbElSrc;
            if (i2.isClosing() || !s2 || !o2)
              return;
            s2.offsetHeight;
            const r2 = !!i2.isOpeningSlide(t2) && this.getZoomInfo(t2);
            if (this.option("protected")) {
              null === (n2 = t2.el) || void 0 === n2 || n2.addEventListener("contextmenu", (t3) => {
                t3.preventDefault();
              });
              const e4 = document.createElement("div");
              S(e4, "fancybox-protected"), s2.appendChild(e4);
            }
            if (a2 && r2) {
              const n3 = e3.contentRect, o3 = Math.max(n3.fullWidth, n3.fullHeight);
              let c2 = null;
              !r2.opacity && o3 > 1200 && (c2 = document.createElement("img"), S(c2, "fancybox-ghost"), c2.src = a2, s2.appendChild(c2));
              const h2 = () => {
                c2 && (S(c2, "f-fadeFastOut"), setTimeout(() => {
                  c2 && (c2.remove(), c2 = null);
                }, 200));
              };
              (l2 = a2, new Promise((t3, e4) => {
                const i3 = new Image();
                i3.onload = t3, i3.onerror = e4, i3.src = l2;
              })).then(() => {
                t2.state = it.Opening, this.instance.emit("reveal", t2), this.zoomIn(t2).then(() => {
                  h2(), this.instance.done(t2);
                }, () => {
                  i2.hideLoading(t2);
                }), c2 && setTimeout(() => {
                  h2();
                }, o3 > 2500 ? 800 : 200);
              }, () => {
                i2.hideLoading(t2), i2.revealContent(t2);
              });
            } else {
              const n3 = this.optionFor(t2, "initialSize"), s3 = this.optionFor(t2, "zoom"), o3 = { event: i2.prevMouseMoveEvent || i2.options.event, friction: s3 ? 0.12 : 0 };
              let a3 = i2.optionFor(t2, "showClass") || void 0, r3 = true;
              i2.isOpeningSlide(t2) && ("full" === n3 ? e3.zoomToFull(o3) : "cover" === n3 ? e3.zoomToCover(o3) : "max" === n3 ? e3.zoomToMax(o3) : r3 = false, e3.stop("current")), r3 && a3 && (a3 = e3.isDragging ? "f-fadeIn" : ""), i2.revealContent(t2, a3);
            }
            var l2;
          }, () => {
            i2.setError(t2, "{{IMAGE_ERROR}}");
          });
        }
        process(t2, e2) {
          return new Promise((i2, s2) => {
            var o2, a2;
            const r2 = this.instance, l2 = t2.el;
            r2.clearContent(t2), r2.showLoading(t2);
            let c2 = this.optionFor(t2, "content");
            "string" == typeof c2 && (c2 = n(c2)), c2 && x(c2) || (c2 = document.createElement("img"), c2 instanceof HTMLImageElement && (c2.src = e2 || "", c2.alt = (null === (o2 = t2.caption) || void 0 === o2 ? void 0 : o2.replace(/<[^>]+>/gi, "").substring(0, 1e3)) || `Image ${t2.index + 1} of ${null === (a2 = r2.carousel) || void 0 === a2 ? void 0 : a2.pages.length}`, c2.draggable = false, t2.srcset && c2.setAttribute("srcset", t2.srcset)), t2.sizes && c2.setAttribute("sizes", t2.sizes)), c2.classList.add("fancybox-image"), t2.imageEl = c2, r2.setContent(t2, c2, false);
            t2.panzoom = new R(l2, u({ transformParent: true }, this.option("Panzoom") || {}, { content: c2, width: r2.optionFor(t2, "width", "auto"), height: r2.optionFor(t2, "height", "auto"), wheel: () => {
              const t3 = r2.option("wheel");
              return ("zoom" === t3 || "pan" == t3) && t3;
            }, click: (e3, i3) => {
              var n2, s3;
              if (r2.isCompact || r2.isClosing())
                return false;
              if (t2.index !== (null === (n2 = r2.getSlide()) || void 0 === n2 ? void 0 : n2.index))
                return false;
              if (i3) {
                const t3 = i3.composedPath()[0];
                if (["A", "BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].includes(t3.nodeName))
                  return false;
              }
              let o3 = !i3 || i3.target && (null === (s3 = t2.contentEl) || void 0 === s3 ? void 0 : s3.contains(i3.target));
              return r2.option(o3 ? "contentClick" : "backdropClick") || false;
            }, dblClick: () => r2.isCompact ? "toggleZoom" : r2.option("contentDblClick") || false, spinner: false, panOnlyZoomed: true, wheelLimit: 1 / 0, on: { ready: (t3) => {
              i2(t3);
            }, error: () => {
              s2();
            }, destroy: () => {
              s2();
            } } }));
          });
        }
        zoomIn(t2) {
          return new Promise((e2, i2) => {
            const n2 = this.instance, s2 = n2.container, { panzoom: o2, contentEl: a2, el: r2 } = t2;
            o2 && o2.updateMetrics();
            const l2 = this.getZoomInfo(t2);
            if (!(l2 && r2 && a2 && o2 && s2))
              return void i2();
            const { x: c2, y: h2, scale: d2, opacity: u2 } = l2, p2 = () => {
              t2.state !== it.Closing && (u2 && (a2.style.opacity = Math.max(Math.min(1, 1 - (1 - o2.scale) / (1 - d2)), 0) + ""), o2.scale >= 1 && o2.scale > o2.targetScale - 0.1 && e2(o2));
            }, f2 = (t3) => {
              E(s2, "is-zooming-in"), t3.scale < 0.99 || t3.scale > 1.01 || (a2.style.opacity = "", t3.off("endAnimation", f2), t3.off("touchStart", f2), t3.off("afterTransform", p2), e2(t3));
            };
            o2.on("endAnimation", f2), o2.on("touchStart", f2), o2.on("afterTransform", p2), o2.on(["error", "destroy"], () => {
              i2();
            }), o2.panTo({ x: c2, y: h2, scale: d2, friction: 0, ignoreBounds: true }), o2.stop("current");
            const m2 = { event: "mousemove" === o2.panMode ? n2.prevMouseMoveEvent || n2.options.event : void 0 }, g2 = this.optionFor(t2, "initialSize");
            S(s2, "is-zooming-in"), n2.hideLoading(t2), "full" === g2 ? o2.zoomToFull(m2) : "cover" === g2 ? o2.zoomToCover(m2) : "max" === g2 ? o2.zoomToMax(m2) : o2.reset(0.172);
          });
        }
        getZoomInfo(t2) {
          var e2;
          const { el: i2, imageEl: n2, thumbEl: s2, panzoom: o2 } = t2;
          if (!i2 || !n2 || !s2 || !o2 || U(s2) < 3 || !this.optionFor(t2, "zoom") || this.instance.state === et.Destroy)
            return false;
          if (1 !== ((null === (e2 = window.visualViewport) || void 0 === e2 ? void 0 : e2.scale) || 1))
            return false;
          let { top: a2, left: r2, width: l2, height: c2 } = s2.getBoundingClientRect(), { top: h2, left: d2, fitWidth: u2, fitHeight: p2 } = o2.contentRect;
          if (!(l2 && c2 && u2 && p2))
            return false;
          const f2 = o2.container.getBoundingClientRect();
          d2 += f2.left, h2 += f2.top;
          const m2 = -1 * (d2 + 0.5 * u2 - (r2 + 0.5 * l2)), g2 = -1 * (h2 + 0.5 * p2 - (a2 + 0.5 * c2)), b2 = l2 / u2;
          let v2 = this.option("zoomOpacity") || false;
          return "auto" === v2 && (v2 = Math.abs(l2 / c2 - u2 / p2) > 0.1), { x: m2, y: g2, scale: b2, opacity: v2 };
        }
        attach() {
          const t2 = this, e2 = t2.instance;
          e2.on("Carousel.change", t2.onChange), e2.on("Carousel.createSlide", t2.onCreateSlide), e2.on("Carousel.removeSlide", t2.onRemoveSlide), e2.on("close", t2.onClose);
        }
        detach() {
          const t2 = this, e2 = t2.instance;
          e2.off("Carousel.change", t2.onChange), e2.off("Carousel.createSlide", t2.onCreateSlide), e2.off("Carousel.removeSlide", t2.onRemoveSlide), e2.off("close", t2.onClose);
        }
      }
      Object.defineProperty(at, "defaults", { enumerable: true, configurable: true, writable: true, value: { initialSize: "fit", Panzoom: { maxScale: 1 }, protected: false, zoom: true, zoomOpacity: "auto" } }), "function" == typeof SuppressedError && SuppressedError;
      const rt = (t2, e2 = {}) => {
        const i2 = new URL(t2), n2 = new URLSearchParams(i2.search), s2 = new URLSearchParams();
        for (const [t3, i3] of [...n2, ...Object.entries(e2)]) {
          let e3 = i3.toString();
          "t" === t3 ? s2.set("start", parseInt(e3).toString()) : s2.set(t3, e3);
        }
        let o2 = s2.toString(), a2 = t2.match(/#t=((.*)?\d+s)/);
        return a2 && (o2 += `#t=${a2[1]}`), o2;
      }, lt = { ajax: null, autoSize: true, iframeAttr: { allow: "autoplay; fullscreen", scrolling: "auto" }, preload: true, videoAutoplay: true, videoRatio: 16 / 9, videoTpl: `<video class="fancybox__html5video" playsinline controls controlsList="nodownload" poster="{{poster}}">
  <source src="{{src}}" type="{{format}}" />Sorry, your browser doesn't support embedded videos.</video>`, videoFormat: "", vimeo: { byline: 1, color: "00adef", controls: 1, dnt: 1, muted: 0 }, youtube: { controls: 1, enablejsapi: 1, nocookie: 1, rel: 0, fs: 1 } }, ct = ["image", "html", "ajax", "inline", "clone", "iframe", "map", "pdf", "html5video", "youtube", "vimeo", "video"];
      class ht extends B {
        onInitSlide(t2, e2, i2) {
          this.processType(i2);
        }
        onCreateSlide(t2, e2, i2) {
          this.setContent(i2);
        }
        onRemoveSlide(t2, e2, i2) {
          i2.xhr && (i2.xhr.abort(), i2.xhr = null);
          const n2 = i2.iframeEl;
          n2 && (n2.onload = n2.onerror = null, n2.src = "//about:blank", i2.iframeEl = null);
          const s2 = i2.contentEl, o2 = i2.placeholderEl;
          if ("inline" === i2.type && s2 && o2)
            s2.classList.remove("fancybox__content"), "none" !== s2.style.display && (s2.style.display = "none"), o2.parentNode && o2.parentNode.insertBefore(s2, o2), o2.remove(), i2.contentEl = void 0, i2.placeholderEl = void 0;
          else
            for (; i2.el && i2.el.firstChild; )
              i2.el.removeChild(i2.el.firstChild);
        }
        onSelectSlide(t2, e2, i2) {
          i2.state === it.Ready && this.playVideo();
        }
        onUnselectSlide(t2, e2, i2) {
          var n2, s2;
          if ("html5video" === i2.type) {
            try {
              null === (s2 = null === (n2 = i2.el) || void 0 === n2 ? void 0 : n2.querySelector("video")) || void 0 === s2 || s2.pause();
            } catch (t3) {
            }
            return;
          }
          let o2;
          "vimeo" === i2.type ? o2 = { method: "pause", value: "true" } : "youtube" === i2.type && (o2 = { event: "command", func: "pauseVideo" }), o2 && i2.iframeEl && i2.iframeEl.contentWindow && i2.iframeEl.contentWindow.postMessage(JSON.stringify(o2), "*"), i2.poller && clearTimeout(i2.poller);
        }
        onDone(t2, e2) {
          t2.isCurrentSlide(e2) && !t2.isClosing() && this.playVideo();
        }
        onRefresh(t2, e2) {
          e2.slides.forEach((t3) => {
            t3.el && (this.setAspectRatio(t3), this.resizeIframe(t3));
          });
        }
        onMessage(t2) {
          try {
            let e2 = JSON.parse(t2.data);
            if ("https://player.vimeo.com" === t2.origin) {
              if ("ready" === e2.event)
                for (let e3 of Array.from(document.getElementsByClassName("fancybox__iframe")))
                  e3 instanceof HTMLIFrameElement && e3.contentWindow === t2.source && (e3.dataset.ready = "true");
            } else if (t2.origin.match(/^https:\/\/(www.)?youtube(-nocookie)?.com$/) && "onReady" === e2.event) {
              const t3 = document.getElementById(e2.id);
              t3 && (t3.dataset.ready = "true");
            }
          } catch (t3) {
          }
        }
        loadAjaxContent(t2) {
          const e2 = this.instance.optionFor(t2, "src") || "";
          this.instance.showLoading(t2);
          const i2 = this.instance, n2 = new XMLHttpRequest();
          i2.showLoading(t2), n2.onreadystatechange = function() {
            n2.readyState === XMLHttpRequest.DONE && i2.state === et.Ready && (i2.hideLoading(t2), 200 === n2.status ? i2.setContent(t2, n2.responseText) : i2.setError(t2, 404 === n2.status ? "{{AJAX_NOT_FOUND}}" : "{{AJAX_FORBIDDEN}}"));
          };
          const s2 = t2.ajax || null;
          n2.open(s2 ? "POST" : "GET", e2 + ""), n2.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), n2.setRequestHeader("X-Requested-With", "XMLHttpRequest"), n2.send(s2), t2.xhr = n2;
        }
        setInlineContent(t2) {
          let e2 = null;
          if (x(t2.src))
            e2 = t2.src;
          else if ("string" == typeof t2.src) {
            const i2 = t2.src.split("#", 2).pop();
            e2 = i2 ? document.getElementById(i2) : null;
          }
          if (e2) {
            if ("clone" === t2.type || e2.closest(".fancybox__slide")) {
              e2 = e2.cloneNode(true);
              const i2 = e2.dataset.animationName;
              i2 && (e2.classList.remove(i2), delete e2.dataset.animationName);
              let n2 = e2.getAttribute("id");
              n2 = n2 ? `${n2}--clone` : `clone-${this.instance.id}-${t2.index}`, e2.setAttribute("id", n2);
            } else if (e2.parentNode) {
              const i2 = document.createElement("div");
              i2.classList.add("fancybox-placeholder"), e2.parentNode.insertBefore(i2, e2), t2.placeholderEl = i2;
            }
            this.instance.setContent(t2, e2);
          } else
            this.instance.setError(t2, "{{ELEMENT_NOT_FOUND}}");
        }
        setIframeContent(t2) {
          const { src: e2, el: i2 } = t2;
          if (!e2 || "string" != typeof e2 || !i2)
            return;
          const n2 = this.instance, s2 = document.createElement("iframe");
          s2.className = "fancybox__iframe", s2.setAttribute("id", `fancybox__iframe_${n2.id}_${t2.index}`);
          for (const [e3, i3] of Object.entries(this.optionFor(t2, "iframeAttr") || {}))
            s2.setAttribute(e3, i3);
          s2.onerror = () => {
            n2.setError(t2, "{{IFRAME_ERROR}}");
          }, t2.iframeEl = s2;
          const o2 = this.optionFor(t2, "preload");
          if (i2.classList.add("is-loading"), "iframe" !== t2.type || false === o2)
            return s2.setAttribute("src", t2.src + ""), this.resizeIframe(t2), void n2.setContent(t2, s2);
          n2.showLoading(t2), s2.onload = () => {
            if (!s2.src.length)
              return;
            const e3 = "true" !== s2.dataset.ready;
            s2.dataset.ready = "true", this.resizeIframe(t2), e3 ? n2.revealContent(t2) : n2.hideLoading(t2);
          }, s2.setAttribute("src", e2), n2.setContent(t2, s2, false);
        }
        resizeIframe(t2) {
          const e2 = t2.iframeEl, i2 = null == e2 ? void 0 : e2.parentElement;
          if (!e2 || !i2)
            return;
          let n2 = t2.autoSize, s2 = t2.width || 0, o2 = t2.height || 0;
          s2 && o2 && (n2 = false);
          const a2 = i2 && i2.style;
          if (false !== t2.preload && false !== n2 && a2)
            try {
              const t3 = window.getComputedStyle(i2), n3 = parseFloat(t3.paddingLeft) + parseFloat(t3.paddingRight), r2 = parseFloat(t3.paddingTop) + parseFloat(t3.paddingBottom), l2 = e2.contentWindow;
              if (l2) {
                const t4 = l2.document, e3 = t4.getElementsByTagName("html")[0], i3 = t4.body;
                a2.width = "", i3.style.overflow = "hidden", s2 = s2 || e3.scrollWidth + n3, a2.width = `${s2}px`, i3.style.overflow = "", a2.flex = "0 0 auto", a2.height = `${i3.scrollHeight}px`, o2 = e3.scrollHeight + r2;
              }
            } catch (t3) {
            }
          if (s2 || o2) {
            const t3 = { flex: "0 1 auto", width: "", height: "" };
            s2 && (t3.width = `${s2}px`), o2 && (t3.height = `${o2}px`), Object.assign(a2, t3);
          }
        }
        playVideo() {
          const t2 = this.instance.getSlide();
          if (!t2)
            return;
          const { el: e2 } = t2;
          if (!e2 || !e2.offsetParent)
            return;
          if (!this.optionFor(t2, "videoAutoplay"))
            return;
          if ("html5video" === t2.type)
            try {
              const t3 = e2.querySelector("video");
              if (t3) {
                const e3 = t3.play();
                void 0 !== e3 && e3.then(() => {
                }).catch((e4) => {
                  t3.muted = true, t3.play();
                });
              }
            } catch (t3) {
            }
          if ("youtube" !== t2.type && "vimeo" !== t2.type)
            return;
          const i2 = () => {
            if (t2.iframeEl && t2.iframeEl.contentWindow) {
              let e3;
              if ("true" === t2.iframeEl.dataset.ready)
                return e3 = "youtube" === t2.type ? { event: "command", func: "playVideo" } : { method: "play", value: "true" }, e3 && t2.iframeEl.contentWindow.postMessage(JSON.stringify(e3), "*"), void (t2.poller = void 0);
              "youtube" === t2.type && (e3 = { event: "listening", id: t2.iframeEl.getAttribute("id") }, t2.iframeEl.contentWindow.postMessage(JSON.stringify(e3), "*"));
            }
            t2.poller = setTimeout(i2, 250);
          };
          i2();
        }
        processType(t2) {
          if (t2.html)
            return t2.type = "html", t2.src = t2.html, void (t2.html = "");
          const e2 = this.instance.optionFor(t2, "src", "");
          if (!e2 || "string" != typeof e2)
            return;
          let i2 = t2.type, n2 = null;
          if (n2 = e2.match(/(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(?:watch\?(?:.*&)?v=|v\/|u\/|shorts\/|embed\/?)?(videoseries\?list=(?:.*)|[\w-]{11}|\?listType=(?:.*)&list=(?:.*))(?:.*)/i)) {
            const s2 = this.optionFor(t2, "youtube"), { nocookie: o2 } = s2, a2 = function(t3, e3) {
              var i3 = {};
              for (var n3 in t3)
                Object.prototype.hasOwnProperty.call(t3, n3) && e3.indexOf(n3) < 0 && (i3[n3] = t3[n3]);
              if (null != t3 && "function" == typeof Object.getOwnPropertySymbols) {
                var s3 = 0;
                for (n3 = Object.getOwnPropertySymbols(t3); s3 < n3.length; s3++)
                  e3.indexOf(n3[s3]) < 0 && Object.prototype.propertyIsEnumerable.call(t3, n3[s3]) && (i3[n3[s3]] = t3[n3[s3]]);
              }
              return i3;
            }(s2, ["nocookie"]), r2 = `www.youtube${o2 ? "-nocookie" : ""}.com`, l2 = rt(e2, a2), c2 = encodeURIComponent(n2[2]);
            t2.videoId = c2, t2.src = `https://${r2}/embed/${c2}?${l2}`, t2.thumbSrc = t2.thumbSrc || `https://i.ytimg.com/vi/${c2}/mqdefault.jpg`, i2 = "youtube";
          } else if (n2 = e2.match(/^.+vimeo.com\/(?:\/)?([\d]+)((\/|\?h=)([a-z0-9]+))?(.*)?/)) {
            const s2 = rt(e2, this.optionFor(t2, "vimeo")), o2 = encodeURIComponent(n2[1]), a2 = n2[4] || "";
            t2.videoId = o2, t2.src = `https://player.vimeo.com/video/${o2}?${a2 ? `h=${a2}${s2 ? "&" : ""}` : ""}${s2}`, i2 = "vimeo";
          }
          if (!i2 && t2.triggerEl) {
            const e3 = t2.triggerEl.dataset.type;
            ct.includes(e3) && (i2 = e3);
          }
          i2 || "string" == typeof e2 && ("#" === e2.charAt(0) ? i2 = "inline" : (n2 = e2.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i)) ? (i2 = "html5video", t2.videoFormat = t2.videoFormat || "video/" + ("ogv" === n2[1] ? "ogg" : n2[1])) : e2.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i) ? i2 = "image" : e2.match(/\.(pdf)((\?|#).*)?$/i) ? i2 = "pdf" : (n2 = e2.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:(?:(?:maps\/(?:place\/(?:.*)\/)?\@(.*),(\d+.?\d+?)z))|(?:\?ll=))(.*)?/i)) ? (t2.src = `https://maps.google.${n2[1]}/?ll=${(n2[2] ? n2[2] + "&z=" + Math.floor(parseFloat(n2[3])) + (n2[4] ? n2[4].replace(/^\//, "&") : "") : n2[4] + "").replace(/\?/, "&")}&output=${n2[4] && n2[4].indexOf("layer=c") > 0 ? "svembed" : "embed"}`, i2 = "map") : (n2 = e2.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:maps\/search\/)(.*)/i)) && (t2.src = `https://maps.google.${n2[1]}/maps?q=${n2[2].replace("query=", "q=").replace("api=1", "")}&output=embed`, i2 = "map")), i2 = i2 || this.instance.option("defaultType"), t2.type = i2, "image" === i2 && (t2.thumbSrc = t2.thumbSrc || t2.src);
        }
        setContent(t2) {
          const e2 = this.instance.optionFor(t2, "src") || "";
          if (t2 && t2.type && e2) {
            switch (t2.type) {
              case "html":
                this.instance.setContent(t2, e2);
                break;
              case "html5video":
                const i2 = this.option("videoTpl");
                i2 && this.instance.setContent(t2, i2.replace(/\{\{src\}\}/gi, e2 + "").replace(/\{\{format\}\}/gi, this.optionFor(t2, "videoFormat") || "").replace(/\{\{poster\}\}/gi, t2.poster || t2.thumbSrc || ""));
                break;
              case "inline":
              case "clone":
                this.setInlineContent(t2);
                break;
              case "ajax":
                this.loadAjaxContent(t2);
                break;
              case "pdf":
              case "map":
              case "youtube":
              case "vimeo":
                t2.preload = false;
              case "iframe":
                this.setIframeContent(t2);
            }
            this.setAspectRatio(t2);
          }
        }
        setAspectRatio(t2) {
          var e2;
          const i2 = t2.contentEl, n2 = this.optionFor(t2, "videoRatio"), s2 = null === (e2 = t2.el) || void 0 === e2 ? void 0 : e2.getBoundingClientRect();
          if (!(i2 && s2 && n2 && 1 !== n2 && t2.type && ["video", "youtube", "vimeo", "html5video"].includes(t2.type)))
            return;
          const o2 = s2.width, a2 = s2.height;
          i2.style.aspectRatio = n2 + "", i2.style.width = o2 / a2 > n2 ? "auto" : "", i2.style.height = o2 / a2 > n2 ? "" : "auto";
        }
        attach() {
          const t2 = this, e2 = t2.instance;
          e2.on("Carousel.initSlide", t2.onInitSlide), e2.on("Carousel.createSlide", t2.onCreateSlide), e2.on("Carousel.removeSlide", t2.onRemoveSlide), e2.on("Carousel.selectSlide", t2.onSelectSlide), e2.on("Carousel.unselectSlide", t2.onUnselectSlide), e2.on("Carousel.Panzoom.refresh", t2.onRefresh), e2.on("done", t2.onDone), window.addEventListener("message", t2.onMessage);
        }
        detach() {
          const t2 = this, e2 = t2.instance;
          e2.off("Carousel.initSlide", t2.onInitSlide), e2.off("Carousel.createSlide", t2.onCreateSlide), e2.off("Carousel.removeSlide", t2.onRemoveSlide), e2.off("Carousel.selectSlide", t2.onSelectSlide), e2.off("Carousel.unselectSlide", t2.onUnselectSlide), e2.off("Carousel.Panzoom.refresh", t2.onRefresh), e2.off("done", t2.onDone), window.removeEventListener("message", t2.onMessage);
        }
      }
      Object.defineProperty(ht, "defaults", { enumerable: true, configurable: true, writable: true, value: lt });
      const dt = "play", ut = "pause", pt = "ready";
      class ft extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: pt }), Object.defineProperty(this, "inHover", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "timer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "progressBar", { enumerable: true, configurable: true, writable: true, value: null });
        }
        get isActive() {
          return this.state !== pt;
        }
        onReady(t2) {
          this.option("autoStart") && (t2.isInfinite || t2.page < t2.pages.length - 1) && this.start();
        }
        onChange() {
          var t2;
          (null === (t2 = this.instance.panzoom) || void 0 === t2 ? void 0 : t2.isResting) || (this.removeProgressBar(), this.pause());
        }
        onSettle() {
          this.resume();
        }
        onVisibilityChange() {
          "visible" === document.visibilityState ? this.resume() : this.pause();
        }
        onMouseEnter() {
          this.inHover = true, this.pause();
        }
        onMouseLeave() {
          var t2;
          this.inHover = false, (null === (t2 = this.instance.panzoom) || void 0 === t2 ? void 0 : t2.isResting) && this.resume();
        }
        onTimerEnd() {
          const t2 = this.instance;
          "play" === this.state && (t2.isInfinite || t2.page !== t2.pages.length - 1 ? t2.slideNext() : t2.slideTo(0));
        }
        removeProgressBar() {
          this.progressBar && (this.progressBar.remove(), this.progressBar = null);
        }
        createProgressBar() {
          var t2;
          if (!this.option("showProgress"))
            return null;
          this.removeProgressBar();
          const e2 = this.instance, i2 = (null === (t2 = e2.pages[e2.page]) || void 0 === t2 ? void 0 : t2.slides) || [];
          let n2 = this.option("progressParentEl");
          if (n2 || (n2 = (1 === i2.length ? i2[0].el : null) || e2.viewport), !n2)
            return null;
          const s2 = document.createElement("div");
          return S(s2, "f-progress"), n2.prepend(s2), this.progressBar = s2, s2.offsetHeight, s2;
        }
        set() {
          const t2 = this, e2 = t2.instance;
          if (e2.pages.length < 2)
            return;
          if (t2.timer)
            return;
          const i2 = t2.option("timeout");
          t2.state = dt, S(e2.container, "has-autoplay");
          let n2 = t2.createProgressBar();
          n2 && (n2.style.transitionDuration = `${i2}ms`, n2.style.transform = "scaleX(1)"), t2.timer = setTimeout(() => {
            t2.timer = null, t2.inHover || t2.onTimerEnd();
          }, i2), t2.emit("set");
        }
        clear() {
          const t2 = this;
          t2.timer && (clearTimeout(t2.timer), t2.timer = null), t2.removeProgressBar();
        }
        start() {
          const t2 = this;
          if (t2.set(), t2.state !== pt) {
            if (t2.option("pauseOnHover")) {
              const e2 = t2.instance.container;
              e2.addEventListener("mouseenter", t2.onMouseEnter, false), e2.addEventListener("mouseleave", t2.onMouseLeave, false);
            }
            document.addEventListener("visibilitychange", t2.onVisibilityChange, false), t2.emit("start");
          }
        }
        stop() {
          const t2 = this, e2 = t2.state, i2 = t2.instance.container;
          t2.clear(), t2.state = pt, i2.removeEventListener("mouseenter", t2.onMouseEnter, false), i2.removeEventListener("mouseleave", t2.onMouseLeave, false), document.removeEventListener("visibilitychange", t2.onVisibilityChange, false), E(i2, "has-autoplay"), e2 !== pt && t2.emit("stop");
        }
        pause() {
          const t2 = this;
          t2.state === dt && (t2.state = ut, t2.clear(), t2.emit(ut));
        }
        resume() {
          const t2 = this, e2 = t2.instance;
          if (e2.isInfinite || e2.page !== e2.pages.length - 1)
            if (t2.state !== dt) {
              if (t2.state === ut && !t2.inHover) {
                const e3 = new Event("resume", { bubbles: true, cancelable: true });
                t2.emit("resume", e3), e3.defaultPrevented || t2.set();
              }
            } else
              t2.set();
          else
            t2.stop();
        }
        toggle() {
          this.state === dt || this.state === ut ? this.stop() : this.start();
        }
        attach() {
          const t2 = this, e2 = t2.instance;
          e2.on("ready", t2.onReady), e2.on("Panzoom.startAnimation", t2.onChange), e2.on("Panzoom.endAnimation", t2.onSettle), e2.on("Panzoom.touchMove", t2.onChange);
        }
        detach() {
          const t2 = this, e2 = t2.instance;
          e2.off("ready", t2.onReady), e2.off("Panzoom.startAnimation", t2.onChange), e2.off("Panzoom.endAnimation", t2.onSettle), e2.off("Panzoom.touchMove", t2.onChange), t2.stop();
        }
      }
      Object.defineProperty(ft, "defaults", { enumerable: true, configurable: true, writable: true, value: { autoStart: true, pauseOnHover: true, progressParentEl: null, showProgress: true, timeout: 3e3 } });
      class mt extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "ref", { enumerable: true, configurable: true, writable: true, value: null });
        }
        onPrepare(t2) {
          const e2 = t2.carousel;
          if (!e2)
            return;
          const i2 = t2.container;
          i2 && (e2.options.Autoplay = u({ autoStart: false }, this.option("Autoplay") || {}, { pauseOnHover: false, timeout: this.option("timeout"), progressParentEl: () => this.option("progressParentEl") || null, on: { start: () => {
            t2.emit("startSlideshow");
          }, set: (e3) => {
            var n2;
            i2.classList.add("has-slideshow"), (null === (n2 = t2.getSlide()) || void 0 === n2 ? void 0 : n2.state) !== it.Ready && e3.pause();
          }, stop: () => {
            i2.classList.remove("has-slideshow"), t2.isCompact || t2.endIdle(), t2.emit("endSlideshow");
          }, resume: (e3, i3) => {
            var n2, s2, o2;
            !i3 || !i3.cancelable || (null === (n2 = t2.getSlide()) || void 0 === n2 ? void 0 : n2.state) === it.Ready && (null === (o2 = null === (s2 = t2.carousel) || void 0 === s2 ? void 0 : s2.panzoom) || void 0 === o2 ? void 0 : o2.isResting) || i3.preventDefault();
          } } }), e2.attachPlugins({ Autoplay: ft }), this.ref = e2.plugins.Autoplay);
        }
        onReady(t2) {
          const e2 = t2.carousel, i2 = this.ref;
          e2 && i2 && this.option("playOnStart") && (e2.isInfinite || e2.page < e2.pages.length - 1) && i2.start();
        }
        onDone(t2, e2) {
          const i2 = this.ref;
          if (!i2)
            return;
          const n2 = e2.panzoom;
          n2 && n2.on("startAnimation", () => {
            t2.isCurrentSlide(e2) && i2.stop();
          }), t2.isCurrentSlide(e2) && i2.resume();
        }
        onKeydown(t2, e2) {
          var i2;
          const n2 = this.ref;
          n2 && e2 === this.option("key") && "BUTTON" !== (null === (i2 = document.activeElement) || void 0 === i2 ? void 0 : i2.nodeName) && n2.toggle();
        }
        attach() {
          const t2 = this, e2 = t2.instance;
          e2.on("Carousel.init", t2.onPrepare), e2.on("Carousel.ready", t2.onReady), e2.on("done", t2.onDone), e2.on("keydown", t2.onKeydown);
        }
        detach() {
          const t2 = this, e2 = t2.instance;
          e2.off("Carousel.init", t2.onPrepare), e2.off("Carousel.ready", t2.onReady), e2.off("done", t2.onDone), e2.off("keydown", t2.onKeydown);
        }
      }
      Object.defineProperty(mt, "defaults", { enumerable: true, configurable: true, writable: true, value: { key: " ", playOnStart: false, progressParentEl: (t2) => {
        var e2;
        return (null === (e2 = t2.instance.container) || void 0 === e2 ? void 0 : e2.querySelector(".fancybox__toolbar [data-fancybox-toggle-slideshow]")) || t2.instance.container;
      }, timeout: 3e3 } });
      const gt = { classes: { container: "f-thumbs f-carousel__thumbs", viewport: "f-thumbs__viewport", track: "f-thumbs__track", slide: "f-thumbs__slide", isResting: "is-resting", isSelected: "is-selected", isLoading: "is-loading", hasThumbs: "has-thumbs" }, minCount: 2, parentEl: null, thumbTpl: '<button class="f-thumbs__slide__button" tabindex="0" type="button" aria-label="{{GOTO}}" data-carousel-index="%i"><img class="f-thumbs__slide__img" data-lazy-src="{{%s}}" alt="" /></button>', type: "modern" };
      var bt;
      !function(t2) {
        t2[t2.Init = 0] = "Init", t2[t2.Ready = 1] = "Ready", t2[t2.Hidden = 2] = "Hidden", t2[t2.Disabled = 3] = "Disabled";
      }(bt || (bt = {}));
      let vt = class extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "type", { enumerable: true, configurable: true, writable: true, value: "modern" }), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "track", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "carousel", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "panzoom", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "thumbWidth", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "thumbClipWidth", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "thumbHeight", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "thumbGap", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "thumbExtraGap", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "shouldCenter", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: bt.Init });
        }
        formatThumb(t2, e2) {
          return this.instance.localize(e2, [["%i", t2.index], ["%d", t2.index + 1], ["%s", t2.thumbSrc || "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"]]);
        }
        getSlides() {
          const t2 = [], e2 = this.option("thumbTpl") || "";
          if (e2)
            for (const i2 of this.instance.slides || []) {
              let n2 = "";
              i2.type && (n2 = `for-${i2.type}`, i2.type && ["video", "youtube", "vimeo", "html5video"].includes(i2.type) && (n2 += " for-video")), t2.push({ html: this.formatThumb(i2, e2), customClass: n2 });
            }
          return t2;
        }
        onInitSlide(t2, e2) {
          const i2 = e2.el;
          i2 && (e2.thumbSrc = i2.dataset.thumbSrc || e2.thumbSrc || "", e2.thumbClipWidth = parseFloat(i2.dataset.thumbClipWidth || "") || e2.thumbClipWidth || 0, e2.thumbHeight = parseFloat(i2.dataset.thumbHeight || "") || e2.thumbHeight || 0);
        }
        onInitSlides() {
          this.state === bt.Init && this.build();
        }
        onRefreshM() {
          this.refreshModern();
        }
        onChangeM() {
          "modern" === this.type && (this.shouldCenter = true, this.centerModern());
        }
        onClickModern(t2) {
          t2.preventDefault(), t2.stopPropagation();
          const e2 = this.instance, i2 = e2.page, n2 = (t3) => {
            if (t3) {
              const e3 = t3.closest("[data-carousel-index]");
              if (e3)
                return parseInt(e3.dataset.carouselIndex || "", 10) || 0;
            }
            return -1;
          }, s2 = (t3, e3) => {
            const i3 = document.elementFromPoint(t3, e3);
            return i3 ? n2(i3) : -1;
          };
          let o2 = n2(t2.target);
          o2 < 0 && (o2 = s2(t2.clientX + this.thumbGap, t2.clientY), o2 === i2 && (o2 = i2 - 1)), o2 < 0 && (o2 = s2(t2.clientX - this.thumbGap, t2.clientY), o2 === i2 && (o2 = i2 + 1)), o2 < 0 && (o2 = ((e3) => {
            let n3 = s2(t2.clientX - e3, t2.clientY), a2 = s2(t2.clientX + e3, t2.clientY);
            return o2 < 0 && n3 === i2 && (o2 = i2 + 1), o2 < 0 && a2 === i2 && (o2 = i2 - 1), o2;
          })(this.thumbExtraGap)), o2 === i2 ? this.centerModern() : o2 > -1 && o2 < e2.pages.length && e2.slideTo(o2);
        }
        onTransformM() {
          if ("modern" !== this.type)
            return;
          const { instance: t2, container: e2, track: i2 } = this, n2 = t2.panzoom;
          if (!(e2 && i2 && n2 && this.panzoom))
            return;
          o(e2, this.cn("isResting"), n2.state !== g.Init && n2.isResting);
          const s2 = this.thumbGap, a2 = this.thumbExtraGap, r2 = this.thumbClipWidth;
          let l2 = 0, c2 = 0, h2 = 0;
          for (const e3 of t2.slides) {
            let i3 = e3.index, n3 = e3.thumbSlideEl;
            if (!n3)
              continue;
            o(n3, this.cn("isSelected"), i3 === t2.page), c2 = 1 - Math.abs(t2.getProgress(i3)), n3.style.setProperty("--progress", c2 ? c2 + "" : "");
            const d2 = 0.5 * ((e3.thumbWidth || 0) - r2);
            l2 += s2, l2 += d2, c2 && (l2 -= c2 * (d2 + a2)), n3.style.setProperty("--shift", l2 - s2 + ""), l2 += d2, c2 && (l2 -= c2 * (d2 + a2)), l2 -= s2, 0 === i3 && (h2 = a2 * c2);
          }
          i2 && (i2.style.setProperty("--left", h2 + ""), i2.style.setProperty("--width", l2 + h2 + s2 + a2 * c2 + "")), this.shouldCenter && this.centerModern();
        }
        buildClassic() {
          const { container: t2, track: e2 } = this, i2 = this.getSlides();
          if (!t2 || !e2 || !i2)
            return;
          const n2 = new this.instance.constructor(t2, u({ track: e2, infinite: false, center: true, fill: true, dragFree: true, slidesPerPage: 1, transition: false, Dots: false, Navigation: false, classes: { container: "f-thumbs", viewport: "f-thumbs__viewport", track: "f-thumbs__track", slide: "f-thumbs__slide" } }, this.option("Carousel") || {}, { Sync: { target: this.instance }, slides: i2 }));
          this.carousel = n2, this.track = e2, n2.on("ready", () => {
            this.emit("ready");
          }), n2.on("createSlide", (t3, e3) => {
            this.emit("createSlide", e3, e3.el);
          });
        }
        buildModern() {
          if ("modern" !== this.type)
            return;
          const { container: t2, track: e2, instance: i2 } = this, s2 = this.option("thumbTpl") || "";
          if (!t2 || !e2 || !s2)
            return;
          S(t2, "is-horizontal"), this.updateModern();
          for (const t3 of i2.slides || []) {
            const i3 = document.createElement("div");
            if (S(i3, this.cn("slide")), t3.type) {
              let e3 = `for-${t3.type}`;
              ["video", "youtube", "vimeo", "html5video"].includes(t3.type) && (e3 += " for-video"), S(i3, e3);
            }
            i3.appendChild(n(this.formatThumb(t3, s2))), this.emit("createSlide", t3, i3), t3.thumbSlideEl = i3, e2.appendChild(i3), this.resizeModernSlide(t3);
          }
          const o2 = new i2.constructor.Panzoom(t2, { content: e2, lockAxis: "x", zoom: false, panOnlyZoomed: false, bounds: () => {
            let t3 = 0, e3 = 0, n2 = i2.slides[0], s3 = i2.slides[i2.slides.length - 1], o3 = i2.slides[i2.page];
            return n2 && s3 && o3 && (e3 = -1 * this.getModernThumbPos(0), 0 !== i2.page && (e3 += 0.5 * (n2.thumbWidth || 0)), t3 = -1 * this.getModernThumbPos(i2.slides.length - 1), i2.page !== i2.slides.length - 1 && (t3 += (s3.thumbWidth || 0) - (o3.thumbWidth || 0) - 0.5 * (s3.thumbWidth || 0))), { x: { min: t3, max: e3 }, y: { min: 0, max: 0 } };
          } });
          o2.on("touchStart", (t3, e3) => {
            this.shouldCenter = false;
          }), o2.on("click", (t3, e3) => this.onClickModern(e3)), o2.on("ready", () => {
            this.centerModern(), this.emit("ready");
          }), o2.on(["afterTransform", "refresh"], (t3) => {
            this.lazyLoadModern();
          }), this.panzoom = o2, this.refreshModern();
        }
        updateModern() {
          if ("modern" !== this.type)
            return;
          const { container: t2 } = this;
          t2 && (this.thumbGap = parseFloat(getComputedStyle(t2).getPropertyValue("--f-thumb-gap")) || 0, this.thumbExtraGap = parseFloat(getComputedStyle(t2).getPropertyValue("--f-thumb-extra-gap")) || 0, this.thumbWidth = parseFloat(getComputedStyle(t2).getPropertyValue("--f-thumb-width")) || 40, this.thumbClipWidth = parseFloat(getComputedStyle(t2).getPropertyValue("--f-thumb-clip-width")) || 40, this.thumbHeight = parseFloat(getComputedStyle(t2).getPropertyValue("--f-thumb-height")) || 40);
        }
        refreshModern() {
          var t2;
          if ("modern" === this.type) {
            this.updateModern();
            for (const t3 of this.instance.slides || [])
              this.resizeModernSlide(t3);
            this.onTransformM(), null === (t2 = this.panzoom) || void 0 === t2 || t2.updateMetrics(true), this.centerModern(0);
          }
        }
        centerModern(e2) {
          const i2 = this.instance, { container: n2, panzoom: s2 } = this;
          if (!n2 || !s2 || s2.state === g.Init)
            return;
          const o2 = i2.page;
          let a2 = this.getModernThumbPos(o2), r2 = a2;
          for (let t2 = i2.page - 3; t2 < i2.page + 3; t2++) {
            if (t2 < 0 || t2 > i2.pages.length - 1 || t2 === i2.page)
              continue;
            const e3 = 1 - Math.abs(i2.getProgress(t2));
            e3 > 0 && e3 < 1 && (r2 += e3 * (this.getModernThumbPos(t2) - a2));
          }
          let l2 = 100;
          void 0 === e2 && (e2 = 0.2, i2.inTransition.size > 0 && (e2 = 0.12), Math.abs(-1 * s2.current.e - r2) > s2.containerRect.width && (e2 = 0.5, l2 = 0)), s2.options.maxVelocity = l2, s2.applyChange({ panX: t(-1 * r2 - s2.target.e, 1e3), friction: null === i2.prevPage ? 0 : e2 });
        }
        lazyLoadModern() {
          const { instance: t2, panzoom: e2 } = this;
          if (!e2)
            return;
          const i2 = -1 * e2.current.e || 0;
          let s2 = this.getModernThumbPos(t2.page);
          if (e2.state !== g.Init || 0 === s2)
            for (const s3 of t2.slides || []) {
              const t3 = s3.thumbSlideEl;
              if (!t3)
                continue;
              const o2 = t3.querySelector("img[data-lazy-src]"), a2 = s3.index, r2 = this.getModernThumbPos(a2), l2 = i2 - 0.5 * e2.containerRect.innerWidth, c2 = l2 + e2.containerRect.innerWidth;
              if (!o2 || r2 < l2 || r2 > c2)
                continue;
              let h2 = o2.dataset.lazySrc;
              if (!h2 || !h2.length)
                continue;
              if (delete o2.dataset.lazySrc, o2.src = h2, o2.complete)
                continue;
              S(t3, this.cn("isLoading"));
              const d2 = n(w);
              t3.appendChild(d2), o2.addEventListener("load", () => {
                t3.offsetParent && (t3.classList.remove(this.cn("isLoading")), d2.remove());
              }, false);
            }
        }
        resizeModernSlide(t2) {
          if ("modern" !== this.type)
            return;
          if (!t2.thumbSlideEl)
            return;
          const e2 = t2.thumbClipWidth && t2.thumbHeight ? Math.round(this.thumbHeight * (t2.thumbClipWidth / t2.thumbHeight)) : this.thumbWidth;
          t2.thumbWidth = e2;
        }
        getModernThumbPos(e2) {
          const i2 = this.instance.slides[e2], n2 = this.panzoom;
          if (!n2 || !n2.contentRect.fitWidth)
            return 0;
          let s2 = n2.containerRect.innerWidth, o2 = n2.contentRect.width;
          2 === this.instance.slides.length && (e2 -= 1, o2 = 2 * this.thumbClipWidth);
          let a2 = e2 * (this.thumbClipWidth + this.thumbGap) + this.thumbExtraGap + 0.5 * (i2.thumbWidth || 0);
          return a2 -= o2 > s2 ? 0.5 * s2 : 0.5 * o2, t(a2 || 0, 1);
        }
        build() {
          const t2 = this.instance, e2 = t2.container, i2 = this.option("minCount") || 0;
          if (i2) {
            let e3 = 0;
            for (const i3 of t2.slides || [])
              i3.thumbSrc && e3++;
            if (e3 < i2)
              return this.cleanup(), void (this.state = bt.Disabled);
          }
          const n2 = this.option("type");
          if (["modern", "classic"].indexOf(n2) < 0)
            return void (this.state = bt.Disabled);
          this.type = n2;
          const s2 = document.createElement("div");
          S(s2, this.cn("container")), S(s2, `is-${n2}`);
          const o2 = this.option("parentEl");
          o2 ? o2.appendChild(s2) : e2.after(s2), this.container = s2, S(e2, this.cn("hasThumbs"));
          const a2 = document.createElement("div");
          S(a2, this.cn("track")), s2.appendChild(a2), this.track = a2, "classic" === n2 ? this.buildClassic() : this.buildModern(), this.state = bt.Ready, s2.addEventListener("click", (e3) => {
            setTimeout(() => {
              var e4;
              null === (e4 = null == s2 ? void 0 : s2.querySelector(`[data-carousel-index="${t2.page}"]`)) || void 0 === e4 || e4.focus();
            }, 100);
          });
        }
        cleanup() {
          this.carousel && this.carousel.destroy(), this.carousel = null, this.panzoom && this.panzoom.destroy(), this.panzoom = null, this.container && this.container.remove(), this.container = null, this.track = null, this.state = bt.Init, E(this.instance.container, this.cn("hasThumbs"));
        }
        attach() {
          const t2 = this, e2 = t2.instance;
          e2.on("initSlide", t2.onInitSlide), e2.state === F.Init ? e2.on("initSlides", t2.onInitSlides) : t2.onInitSlides(), e2.on("Panzoom.afterTransform", t2.onTransformM), e2.on("Panzoom.refresh", t2.onRefreshM), e2.on("change", t2.onChangeM);
        }
        detach() {
          const t2 = this, e2 = t2.instance;
          e2.off("initSlide", t2.onInitSlide), e2.off("initSlides", t2.onInitSlides), e2.off("Panzoom.afterTransform", t2.onTransformM), e2.off("Panzoom.refresh", t2.onRefreshM), e2.off("change", t2.onChangeM), t2.cleanup();
        }
      };
      Object.defineProperty(vt, "defaults", { enumerable: true, configurable: true, writable: true, value: gt });
      const yt = Object.assign(Object.assign({}, gt), { key: "t", showOnStart: true, parentEl: null }), wt = "is-masked", xt = "aria-hidden";
      class Et extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "ref", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "hidden", { enumerable: true, configurable: true, writable: true, value: false });
        }
        get isEnabled() {
          const t2 = this.ref;
          return t2 && t2.state !== bt.Disabled;
        }
        get isHidden() {
          return this.hidden;
        }
        onInit() {
          var t2;
          const e2 = this, i2 = e2.instance, n2 = i2.carousel;
          if (e2.ref || !n2)
            return;
          const s2 = e2.option("parentEl") || i2.footer || i2.container;
          if (!s2)
            return;
          const o2 = u({}, e2.options, { parentEl: s2, classes: { container: "f-thumbs fancybox__thumbs" }, Carousel: { Sync: { friction: i2.option("Carousel.friction") || 0 } }, on: { ready: (t3) => {
            const i3 = t3.container;
            i3 && this.hidden && (e2.refresh(), i3.style.transition = "none", e2.hide(), i3.offsetHeight, queueMicrotask(() => {
              i3.style.transition = "", e2.show();
            }));
          } } });
          o2.Carousel = o2.Carousel || {}, o2.Carousel.on = u((null === (t2 = e2.options.Carousel) || void 0 === t2 ? void 0 : t2.on) || {}, { click: (t3, e3) => {
            e3.stopPropagation();
          } }), n2.options.Thumbs = o2, n2.attachPlugins({ Thumbs: vt }), e2.ref = n2.plugins.Thumbs, e2.option("showOnStart") || (e2.ref.state = bt.Hidden, e2.hidden = true);
        }
        onResize() {
          var t2;
          const e2 = null === (t2 = this.ref) || void 0 === t2 ? void 0 : t2.container;
          e2 && (e2.style.maxHeight = "");
        }
        onKeydown(t2, e2) {
          const i2 = this.option("key");
          i2 && i2 === e2 && this.toggle();
        }
        toggle() {
          const t2 = this.ref;
          t2 && t2.state !== bt.Disabled && (t2.state !== bt.Hidden ? this.hidden ? this.show() : this.hide() : t2.build());
        }
        show() {
          const t2 = this.ref, e2 = t2 && t2.state !== bt.Disabled && t2.container;
          e2 && (this.refresh(), e2.offsetHeight, e2.removeAttribute(xt), e2.classList.remove(wt), this.hidden = false);
        }
        hide() {
          const t2 = this.ref, e2 = t2 && t2.container;
          e2 && (this.refresh(), e2.offsetHeight, e2.classList.add(wt), e2.setAttribute(xt, "true")), this.hidden = true;
        }
        refresh() {
          const t2 = this.ref;
          if (!t2 || t2.state === bt.Disabled)
            return;
          const e2 = t2.container, i2 = (null == e2 ? void 0 : e2.firstChild) || null;
          e2 && i2 && i2.childNodes.length && (e2.style.maxHeight = `${i2.getBoundingClientRect().height}px`);
        }
        attach() {
          const t2 = this, e2 = t2.instance;
          e2.state === et.Init ? e2.on("Carousel.init", t2.onInit) : t2.onInit(), e2.on("resize", t2.onResize), e2.on("keydown", t2.onKeydown);
        }
        detach() {
          var t2;
          const e2 = this, i2 = e2.instance;
          i2.off("Carousel.init", e2.onInit), i2.off("resize", e2.onResize), i2.off("keydown", e2.onKeydown), null === (t2 = i2.carousel) || void 0 === t2 || t2.detachPlugins(["Thumbs"]), e2.ref = null;
        }
      }
      Object.defineProperty(Et, "defaults", { enumerable: true, configurable: true, writable: true, value: yt });
      const St = { panLeft: { icon: '<svg><path d="M5 12h14M5 12l6 6M5 12l6-6"/></svg>', change: { panX: -100 } }, panRight: { icon: '<svg><path d="M5 12h14M13 18l6-6M13 6l6 6"/></svg>', change: { panX: 100 } }, panUp: { icon: '<svg><path d="M12 5v14M18 11l-6-6M6 11l6-6"/></svg>', change: { panY: -100 } }, panDown: { icon: '<svg><path d="M12 5v14M18 13l-6 6M6 13l6 6"/></svg>', change: { panY: 100 } }, zoomIn: { icon: '<svg><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M11 8v6M8 11h6"/></svg>', action: "zoomIn" }, zoomOut: { icon: '<svg><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>', action: "zoomOut" }, toggle1to1: { icon: '<svg><path d="M3.51 3.07c5.74.02 11.48-.02 17.22.02 1.37.1 2.34 1.64 2.18 3.13 0 4.08.02 8.16 0 12.23-.1 1.54-1.47 2.64-2.79 2.46-5.61-.01-11.24.02-16.86-.01-1.36-.12-2.33-1.65-2.17-3.14 0-4.07-.02-8.16 0-12.23.1-1.36 1.22-2.48 2.42-2.46Z"/><path d="M5.65 8.54h1.49v6.92m8.94-6.92h1.49v6.92M11.5 9.4v.02m0 5.18v0"/></svg>', action: "toggleZoom" }, toggleZoom: { icon: '<svg><g><line x1="11" y1="8" x2="11" y2="14"></line></g><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>', action: "toggleZoom" }, iterateZoom: { icon: '<svg><g><line x1="11" y1="8" x2="11" y2="14"></line></g><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>', action: "iterateZoom" }, rotateCCW: { icon: '<svg><path d="M15 4.55a8 8 0 0 0-6 14.9M9 15v5H4M18.37 7.16v.01M13 19.94v.01M16.84 18.37v.01M19.37 15.1v.01M19.94 11v.01"/></svg>', action: "rotateCCW" }, rotateCW: { icon: '<svg><path d="M9 4.55a8 8 0 0 1 6 14.9M15 15v5h5M5.63 7.16v.01M4.06 11v.01M4.63 15.1v.01M7.16 18.37v.01M11 19.94v.01"/></svg>', action: "rotateCW" }, flipX: { icon: '<svg style="stroke-width: 1.3"><path d="M12 3v18M16 7v10h5L16 7M8 7v10H3L8 7"/></svg>', action: "flipX" }, flipY: { icon: '<svg style="stroke-width: 1.3"><path d="M3 12h18M7 16h10L7 21v-5M7 8h10L7 3v5"/></svg>', action: "flipY" }, fitX: { icon: '<svg><path d="M4 12V6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v6M10 18H3M21 18h-7M6 15l-3 3 3 3M18 15l3 3-3 3"/></svg>', action: "fitX" }, fitY: { icon: '<svg><path d="M12 20H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h6M18 14v7M18 3v7M15 18l3 3 3-3M15 6l3-3 3 3"/></svg>', action: "fitY" }, reset: { icon: '<svg><path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"/></svg>', action: "reset" }, toggleFS: { icon: '<svg><g><path d="M14.5 9.5 21 3m0 0h-6m6 0v6M3 21l6.5-6.5M3 21v-6m0 6h6"/></g><g><path d="m14 10 7-7m-7 7h6m-6 0V4M3 21l7-7m0 0v6m0-6H4"/></g></svg>', action: "toggleFS" } };
      var Pt;
      !function(t2) {
        t2[t2.Init = 0] = "Init", t2[t2.Ready = 1] = "Ready", t2[t2.Disabled = 2] = "Disabled";
      }(Pt || (Pt = {}));
      const Ct = { absolute: "auto", display: { left: ["infobar"], middle: [], right: ["iterateZoom", "slideshow", "fullscreen", "thumbs", "close"] }, enabled: "auto", items: { infobar: { tpl: '<div class="fancybox__infobar" tabindex="-1"><span data-fancybox-current-index></span>/<span data-fancybox-count></span></div>' }, download: { tpl: '<a class="f-button" title="{{DOWNLOAD}}" data-fancybox-download href="javasript:;"><svg><path d="M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2M7 11l5 5 5-5M12 4v12"/></svg></a>' }, prev: { tpl: '<button class="f-button" title="{{PREV}}" data-fancybox-prev><svg><path d="m15 6-6 6 6 6"/></svg></button>' }, next: { tpl: '<button class="f-button" title="{{NEXT}}" data-fancybox-next><svg><path d="m9 6 6 6-6 6"/></svg></button>' }, slideshow: { tpl: '<button class="f-button" title="{{TOGGLE_SLIDESHOW}}" data-fancybox-toggle-slideshow><svg><g><path d="M8 4v16l13 -8z"></path></g><g><path d="M8 4v15M17 4v15"/></g></svg></button>' }, fullscreen: { tpl: '<button class="f-button" title="{{TOGGLE_FULLSCREEN}}" data-fancybox-toggle-fullscreen><svg><g><path d="M4 8V6a2 2 0 0 1 2-2h2M4 16v2a2 2 0 0 0 2 2h2M16 4h2a2 2 0 0 1 2 2v2M16 20h2a2 2 0 0 0 2-2v-2"/></g><g><path d="M15 19v-2a2 2 0 0 1 2-2h2M15 5v2a2 2 0 0 0 2 2h2M5 15h2a2 2 0 0 1 2 2v2M5 9h2a2 2 0 0 0 2-2V5"/></g></svg></button>' }, thumbs: { tpl: '<button class="f-button" title="{{TOGGLE_THUMBS}}" data-fancybox-toggle-thumbs><svg><circle cx="5.5" cy="5.5" r="1"/><circle cx="12" cy="5.5" r="1"/><circle cx="18.5" cy="5.5" r="1"/><circle cx="5.5" cy="12" r="1"/><circle cx="12" cy="12" r="1"/><circle cx="18.5" cy="12" r="1"/><circle cx="5.5" cy="18.5" r="1"/><circle cx="12" cy="18.5" r="1"/><circle cx="18.5" cy="18.5" r="1"/></svg></button>' }, close: { tpl: '<button class="f-button" title="{{CLOSE}}" data-fancybox-close><svg><path d="m19.5 4.5-15 15M4.5 4.5l15 15"/></svg></button>' } }, parentEl: null }, Mt = { tabindex: "-1", width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" };
      class Tt extends B {
        constructor() {
          super(...arguments), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: Pt.Init }), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: null });
        }
        onReady(t2) {
          var e2;
          if (!t2.carousel)
            return;
          let i2 = this.option("display"), n2 = this.option("absolute"), s2 = this.option("enabled");
          if ("auto" === s2) {
            const t3 = this.instance.carousel;
            let e3 = 0;
            if (t3)
              for (const i3 of t3.slides)
                (i3.panzoom || "image" === i3.type) && e3++;
            e3 || (s2 = false);
          }
          s2 || (i2 = void 0);
          let o2 = 0;
          const a2 = { left: [], middle: [], right: [] };
          if (i2)
            for (const t3 of ["left", "middle", "right"])
              for (const n3 of i2[t3]) {
                const i3 = this.createEl(n3);
                i3 && (null === (e2 = a2[t3]) || void 0 === e2 || e2.push(i3), o2++);
              }
          let r2 = null;
          if (o2 && (r2 = this.createContainer()), r2) {
            for (const [t3, e3] of Object.entries(a2)) {
              const i3 = document.createElement("div");
              S(i3, "fancybox__toolbar__column is-" + t3);
              for (const t4 of e3)
                i3.appendChild(t4);
              "auto" !== n2 || "middle" !== t3 || e3.length || (n2 = true), r2.appendChild(i3);
            }
            true === n2 && S(r2, "is-absolute"), this.state = Pt.Ready, this.onRefresh();
          } else
            this.state = Pt.Disabled;
        }
        onClick(t2) {
          var e2, i2;
          const n2 = this.instance, s2 = n2.getSlide(), o2 = null == s2 ? void 0 : s2.panzoom, a2 = t2.target, r2 = a2 && x(a2) ? a2.dataset : null;
          if (!r2)
            return;
          if (void 0 !== r2.fancyboxToggleThumbs)
            return t2.preventDefault(), t2.stopPropagation(), void (null === (e2 = n2.plugins.Thumbs) || void 0 === e2 || e2.toggle());
          if (void 0 !== r2.fancyboxToggleFullscreen)
            return t2.preventDefault(), t2.stopPropagation(), void this.instance.toggleFullscreen();
          if (void 0 !== r2.fancyboxToggleSlideshow) {
            t2.preventDefault(), t2.stopPropagation();
            const e3 = null === (i2 = n2.carousel) || void 0 === i2 ? void 0 : i2.plugins.Autoplay;
            let s3 = e3.isActive;
            return o2 && "mousemove" === o2.panMode && !s3 && o2.reset(), void (s3 ? e3.stop() : e3.start());
          }
          const l2 = r2.panzoomAction, c2 = r2.panzoomChange;
          if ((c2 || l2) && (t2.preventDefault(), t2.stopPropagation()), c2) {
            let t3 = {};
            try {
              t3 = JSON.parse(c2);
            } catch (t4) {
            }
            o2 && o2.applyChange(t3);
          } else
            l2 && o2 && o2[l2] && o2[l2]();
        }
        onChange() {
          this.onRefresh();
        }
        onRefresh() {
          if (this.instance.isClosing())
            return;
          const t2 = this.container;
          if (!t2)
            return;
          const e2 = this.instance.getSlide();
          if (!e2 || e2.state !== it.Ready)
            return;
          const i2 = e2 && !e2.error && e2.panzoom;
          for (const e3 of t2.querySelectorAll("[data-panzoom-action]"))
            i2 ? (e3.removeAttribute("disabled"), e3.removeAttribute("tabindex")) : (e3.setAttribute("disabled", ""), e3.setAttribute("tabindex", "-1"));
          let n2 = i2 && i2.canZoomIn(), s2 = i2 && i2.canZoomOut();
          for (const e3 of t2.querySelectorAll('[data-panzoom-action="zoomIn"]'))
            n2 ? (e3.removeAttribute("disabled"), e3.removeAttribute("tabindex")) : (e3.setAttribute("disabled", ""), e3.setAttribute("tabindex", "-1"));
          for (const e3 of t2.querySelectorAll('[data-panzoom-action="zoomOut"]'))
            s2 ? (e3.removeAttribute("disabled"), e3.removeAttribute("tabindex")) : (e3.setAttribute("disabled", ""), e3.setAttribute("tabindex", "-1"));
          for (const e3 of t2.querySelectorAll('[data-panzoom-action="toggleZoom"],[data-panzoom-action="iterateZoom"]')) {
            s2 || n2 ? (e3.removeAttribute("disabled"), e3.removeAttribute("tabindex")) : (e3.setAttribute("disabled", ""), e3.setAttribute("tabindex", "-1"));
            const t3 = e3.querySelector("g");
            t3 && (t3.style.display = n2 ? "" : "none");
          }
        }
        onDone(t2, e2) {
          var i2;
          null === (i2 = e2.panzoom) || void 0 === i2 || i2.on("afterTransform", () => {
            this.instance.isCurrentSlide(e2) && this.onRefresh();
          }), this.instance.isCurrentSlide(e2) && this.onRefresh();
        }
        createContainer() {
          const t2 = this.instance.container;
          if (!t2)
            return null;
          const e2 = this.option("parentEl") || t2, i2 = document.createElement("div");
          return S(i2, "fancybox__toolbar"), e2.prepend(i2), i2.addEventListener("click", this.onClick, { passive: false, capture: true }), t2 && S(t2, "has-toolbar"), this.container = i2, i2;
        }
        createEl(t2) {
          const e2 = this.instance, i2 = e2.carousel;
          if (!i2)
            return null;
          if ("toggleFS" === t2)
            return null;
          if ("fullscreen" === t2 && !e2.fsAPI)
            return null;
          let s2 = null;
          const o2 = i2.slides.length || 0;
          let a2 = 0, r2 = 0;
          for (const t3 of i2.slides)
            (t3.panzoom || "image" === t3.type) && a2++, ("image" === t3.type || t3.downloadSrc) && r2++;
          if (o2 < 2 && ["infobar", "prev", "next"].includes(t2))
            return s2;
          if (void 0 !== St[t2] && !a2)
            return null;
          if ("download" === t2 && !r2)
            return null;
          if ("thumbs" === t2) {
            const t3 = e2.plugins.Thumbs;
            if (!t3 || !t3.isEnabled)
              return null;
          }
          if ("slideshow" === t2) {
            if (!i2.plugins.Autoplay || o2 < 2)
              return null;
          }
          if (void 0 !== St[t2]) {
            const e3 = St[t2];
            s2 = document.createElement("button"), s2.setAttribute("title", this.instance.localize(`{{${t2.toUpperCase()}}}`)), S(s2, "f-button"), e3.action && (s2.dataset.panzoomAction = e3.action), e3.change && (s2.dataset.panzoomChange = JSON.stringify(e3.change)), s2.appendChild(n(this.instance.localize(e3.icon)));
          } else {
            const e3 = (this.option("items") || [])[t2];
            e3 && (s2 = n(this.instance.localize(e3.tpl)), "function" == typeof e3.click && s2.addEventListener("click", (t3) => {
              t3.preventDefault(), t3.stopPropagation(), "function" == typeof e3.click && e3.click.call(this, this, t3);
            }));
          }
          const l2 = null == s2 ? void 0 : s2.querySelector("svg");
          if (l2)
            for (const [t3, e3] of Object.entries(Mt))
              l2.getAttribute(t3) || l2.setAttribute(t3, String(e3));
          return s2;
        }
        removeContainer() {
          const t2 = this.container;
          t2 && t2.remove(), this.container = null, this.state = Pt.Disabled;
          const e2 = this.instance.container;
          e2 && E(e2, "has-toolbar");
        }
        attach() {
          const t2 = this, e2 = t2.instance;
          e2.on("Carousel.initSlides", t2.onReady), e2.on("done", t2.onDone), e2.on("reveal", t2.onChange), e2.on("Carousel.change", t2.onChange), t2.onReady(t2.instance);
        }
        detach() {
          const t2 = this, e2 = t2.instance;
          e2.off("Carousel.initSlides", t2.onReady), e2.off("done", t2.onDone), e2.off("reveal", t2.onChange), e2.off("Carousel.change", t2.onChange), t2.removeContainer();
        }
      }
      Object.defineProperty(Tt, "defaults", { enumerable: true, configurable: true, writable: true, value: Ct });
      const Ot = { Hash: st, Html: ht, Images: at, Slideshow: mt, Thumbs: Et, Toolbar: Tt }, At = "with-fancybox", zt = "hide-scrollbar", Lt = "--fancybox-scrollbar-compensate", Rt = "--fancybox-body-margin", kt = "is-animated", It = "is-compact", Dt = "is-loading", Ft = function() {
        var t2 = window.getSelection();
        return t2 && "Range" === t2.type;
      };
      let jt = null, Ht = null;
      const Bt = /* @__PURE__ */ new Map();
      let Nt = 0;
      class _t extends m {
        get isIdle() {
          return this.idle;
        }
        get isCompact() {
          return this.option("compact");
        }
        constructor(t2 = [], e2 = {}, i2 = {}) {
          super(e2), Object.defineProperty(this, "userSlides", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "userPlugins", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "idle", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "idleTimer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "clickTimer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "pwt", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "ignoreFocusChange", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: et.Init }), Object.defineProperty(this, "id", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "footer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "carousel", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "lastFocus", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "prevMouseMoveEvent", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "fsAPI", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.fsAPI = (() => {
            let t3, e3 = "", i3 = "", n2 = "";
            return document.fullscreenEnabled ? (e3 = "requestFullscreen", i3 = "exitFullscreen", n2 = "fullscreenElement") : document.webkitFullscreenEnabled && (e3 = "webkitRequestFullscreen", i3 = "webkitExitFullscreen", n2 = "webkitFullscreenElement"), e3 && (t3 = { request: function(t4) {
              return "webkitRequestFullscreen" === e3 ? t4[e3](Element.ALLOW_KEYBOARD_INPUT) : t4[e3]();
            }, exit: function() {
              return document[n2] && document[i3]();
            }, isFullscreen: function() {
              return document[n2];
            } }), t3;
          })(), this.id = e2.id || ++Nt, Bt.set(this.id, this), this.userSlides = t2, this.userPlugins = i2, queueMicrotask(() => {
            this.init();
          });
        }
        init() {
          if (this.state === et.Destroy)
            return;
          this.state = et.Init, this.attachPlugins(Object.assign(Object.assign({}, _t.Plugins), this.userPlugins)), this.emit("init"), true === this.option("hideScrollbar") && (() => {
            if (!G)
              return;
            const t3 = document.body;
            if (t3.classList.contains(zt))
              return;
            let e3 = window.innerWidth - document.documentElement.getBoundingClientRect().width;
            e3 < 0 && (e3 = 0);
            const i2 = t3.currentStyle || window.getComputedStyle(t3), n2 = parseFloat(i2.marginRight);
            document.documentElement.style.setProperty(Lt, `${e3}px`), n2 && t3.style.setProperty(Rt, `${n2}px`), t3.classList.add(zt);
          })(), this.initLayout(), this.scale();
          const t2 = () => {
            this.initCarousel(this.userSlides), this.state = et.Ready, this.attachEvents(), this.emit("ready"), setTimeout(() => {
              this.container && this.container.setAttribute("aria-hidden", "false");
            }, 16);
          }, e2 = this.fsAPI;
          this.option("Fullscreen.autoStart") && e2 && !e2.isFullscreen() ? e2.request(this.container).then(() => t2()).catch(() => t2()) : t2();
        }
        initLayout() {
          var t2, e2;
          const i2 = this.option("parentEl") || document.body, s2 = n(this.localize(this.option("tpl.main") || ""));
          s2 && (s2.setAttribute("id", `fancybox-${this.id}`), s2.setAttribute("aria-label", this.localize("{{MODAL}}")), s2.classList.toggle(It, this.isCompact), S(s2, this.option("mainClass") || ""), this.container = s2, this.footer = s2.querySelector(".fancybox__footer"), i2.appendChild(s2), S(document.documentElement, At), jt && Ht || (jt = document.createElement("span"), S(jt, "fancybox-focus-guard"), jt.setAttribute("tabindex", "0"), jt.setAttribute("aria-hidden", "true"), jt.setAttribute("aria-label", "Focus guard"), Ht = jt.cloneNode(), null === (t2 = s2.parentElement) || void 0 === t2 || t2.insertBefore(jt, s2), null === (e2 = s2.parentElement) || void 0 === e2 || e2.append(Ht)), this.option("animated") && (S(s2, kt), setTimeout(() => {
            this.isClosing() || E(s2, kt);
          }, 350)), this.emit("initLayout"));
        }
        initCarousel(t2) {
          const i2 = this.container;
          if (!i2)
            return;
          const n2 = i2.querySelector(".fancybox__carousel");
          if (!n2)
            return;
          const s2 = this.carousel = new Z(n2, u({}, { slides: t2, transition: "fade", Panzoom: { lockAxis: this.option("dragToClose") ? "xy" : "x", infinite: !!this.option("dragToClose") && "y" }, Dots: false, Navigation: { classes: { container: "fancybox__nav", button: "f-button", isNext: "is-next", isPrev: "is-prev" } }, initialPage: this.option("startIndex"), l10n: this.option("l10n") }, this.option("Carousel") || {}));
          s2.on("*", (t3, e2, ...i3) => {
            this.emit(`Carousel.${e2}`, t3, ...i3);
          }), s2.on(["ready", "change"], () => {
            var t3;
            const e2 = this.getSlide();
            e2 && (null === (t3 = e2.panzoom) || void 0 === t3 || t3.updateControls()), this.manageCaption(e2);
          }), this.on("Carousel.removeSlide", (t3, e2, i3) => {
            i3.contentEl && (i3.contentEl.remove(), i3.contentEl = void 0);
            const n3 = i3.el;
            n3 && (E(n3, "has-error"), E(n3, "has-unknown"), E(n3, `has-${i3.type || "unknown"}`)), i3.closeBtnEl && i3.closeBtnEl.remove(), i3.closeBtnEl = void 0, i3.captionEl && i3.captionEl.remove(), i3.captionEl = void 0, i3.spinnerEl && i3.spinnerEl.remove(), i3.spinnerEl = void 0, i3.state = void 0;
          }), s2.on("Panzoom.touchStart", () => {
            this.isCompact || this.endIdle();
          }), s2.on("settle", () => {
            this.idleTimer || this.isCompact || !this.option("idle") || this.setIdle(), this.option("autoFocus") && this.checkFocus();
          }), this.option("dragToClose") && (s2.on("Panzoom.afterTransform", (t3, i3) => {
            const n3 = this.getSlide();
            if (n3 && e(n3.el))
              return;
            const s3 = this.container;
            if (s3) {
              const t4 = Math.abs(i3.current.f), e2 = t4 < 1 ? "" : Math.max(0.5, Math.min(1, 1 - t4 / i3.contentRect.fitHeight * 1.5));
              s3.style.setProperty("--fancybox-ts", e2 ? "0s" : ""), s3.style.setProperty("--fancybox-opacity", e2 + "");
            }
          }), s2.on("Panzoom.touchEnd", (t3, i3, n3) => {
            var s3;
            const o2 = this.getSlide();
            if (o2 && e(o2.el))
              return;
            if (i3.isMobile && document.activeElement && -1 !== ["TEXTAREA", "INPUT"].indexOf(null === (s3 = document.activeElement) || void 0 === s3 ? void 0 : s3.nodeName))
              return;
            const a2 = Math.abs(i3.dragOffset.y);
            "y" === i3.lockedAxis && (a2 >= 200 || a2 >= 50 && i3.dragOffset.time < 300) && (n3 && n3.cancelable && n3.preventDefault(), this.close(n3, "f-throwOut" + (i3.current.f < 0 ? "Up" : "Down")));
          })), s2.on("change", (t3) => {
            var e2;
            let i3 = null === (e2 = this.getSlide()) || void 0 === e2 ? void 0 : e2.triggerEl;
            if (i3) {
              const e3 = new CustomEvent("slideTo", { bubbles: true, cancelable: true, detail: t3.page });
              i3.dispatchEvent(e3);
            }
          }), s2.on(["refresh", "change"], (t3) => {
            const e2 = this.container;
            if (!e2)
              return;
            for (const i4 of e2.querySelectorAll("[data-fancybox-current-index]"))
              i4.innerHTML = t3.page + 1;
            for (const i4 of e2.querySelectorAll("[data-fancybox-count]"))
              i4.innerHTML = t3.pages.length;
            if (!t3.isInfinite) {
              for (const i4 of e2.querySelectorAll("[data-fancybox-next]"))
                t3.page < t3.pages.length - 1 ? (i4.removeAttribute("disabled"), i4.removeAttribute("tabindex")) : (i4.setAttribute("disabled", ""), i4.setAttribute("tabindex", "-1"));
              for (const i4 of e2.querySelectorAll("[data-fancybox-prev]"))
                t3.page > 0 ? (i4.removeAttribute("disabled"), i4.removeAttribute("tabindex")) : (i4.setAttribute("disabled", ""), i4.setAttribute("tabindex", "-1"));
            }
            const i3 = this.getSlide();
            if (!i3)
              return;
            let n3 = i3.downloadSrc || "";
            n3 || "image" !== i3.type || i3.error || "string" != typeof i3.src || (n3 = i3.src);
            const s3 = "disabled", o2 = "tabindex", a2 = "download", r2 = "href";
            for (const t4 of e2.querySelectorAll("[data-fancybox-download]")) {
              const e3 = i3.downloadFilename;
              n3 ? (t4.removeAttribute(s3), t4.removeAttribute(o2), t4.setAttribute(r2, n3), t4.setAttribute(a2, e3 || n3), t4.setAttribute("target", "_blank")) : (t4.setAttribute(s3, ""), t4.setAttribute(o2, "-1"), t4.removeAttribute(r2), t4.removeAttribute(a2));
            }
          }), this.emit("initCarousel");
        }
        attachEvents() {
          const t2 = this, e2 = t2.container;
          if (!e2)
            return;
          e2.addEventListener("click", t2.onClick, { passive: false, capture: false }), e2.addEventListener("wheel", t2.onWheel, { passive: false, capture: false }), document.addEventListener("keydown", t2.onKeydown, { passive: false, capture: true }), document.addEventListener("visibilitychange", t2.onVisibilityChange, false), document.addEventListener("mousemove", t2.onMousemove), t2.option("trapFocus") && document.addEventListener("focus", t2.onFocus, true), window.addEventListener("resize", t2.onResize);
          const i2 = window.visualViewport;
          i2 && (i2.addEventListener("scroll", t2.onResize), i2.addEventListener("resize", t2.onResize));
        }
        detachEvents() {
          const t2 = this, e2 = t2.container;
          if (!e2)
            return;
          document.removeEventListener("keydown", t2.onKeydown, { passive: false, capture: true }), e2.removeEventListener("wheel", t2.onWheel, { passive: false, capture: false }), e2.removeEventListener("click", t2.onClick, { passive: false, capture: false }), document.removeEventListener("mousemove", t2.onMousemove), window.removeEventListener("resize", t2.onResize);
          const i2 = window.visualViewport;
          i2 && (i2.removeEventListener("resize", t2.onResize), i2.removeEventListener("scroll", t2.onResize)), document.removeEventListener("visibilitychange", t2.onVisibilityChange, false), document.removeEventListener("focus", t2.onFocus, true);
        }
        scale() {
          const t2 = this.container;
          if (!t2)
            return;
          const e2 = window.visualViewport, i2 = Math.max(1, (null == e2 ? void 0 : e2.scale) || 1);
          let n2 = "", s2 = "", o2 = "";
          if (e2 && i2 > 1) {
            let t3 = `${e2.offsetLeft}px`, a2 = `${e2.offsetTop}px`;
            n2 = e2.width * i2 + "px", s2 = e2.height * i2 + "px", o2 = `translate3d(${t3}, ${a2}, 0) scale(${1 / i2})`;
          }
          t2.style.transform = o2, t2.style.width = n2, t2.style.height = s2;
        }
        onClick(t2) {
          var e2, i2;
          const { container: n2, isCompact: s2 } = this;
          if (!n2 || this.isClosing())
            return;
          !s2 && this.option("idle") && this.resetIdle();
          const o2 = document.activeElement;
          if (Ft() && o2 && n2.contains(o2))
            return;
          const a2 = t2.composedPath()[0];
          if (a2 === (null === (e2 = this.carousel) || void 0 === e2 ? void 0 : e2.container))
            return;
          if (a2.closest(".f-spinner") || a2.closest("[data-fancybox-close]"))
            return t2.preventDefault(), void this.close(t2);
          if (a2.closest("[data-fancybox-prev]"))
            return t2.preventDefault(), void this.prev();
          if (a2.closest("[data-fancybox-next]"))
            return t2.preventDefault(), void this.next();
          if (s2 && "image" === (null === (i2 = this.getSlide()) || void 0 === i2 ? void 0 : i2.type))
            return void (this.clickTimer ? (clearTimeout(this.clickTimer), this.clickTimer = null) : this.clickTimer = setTimeout(() => {
              this.toggleIdle(), this.clickTimer = null;
            }, 350));
          if (this.emit("click", t2), t2.defaultPrevented)
            return;
          let r2 = false;
          if (a2.closest(".fancybox__content")) {
            if (o2) {
              if (o2.closest("[contenteditable]"))
                return;
              a2.matches(J) || o2.blur();
            }
            if (Ft())
              return;
            r2 = this.option("contentClick");
          } else
            a2.closest(".fancybox__carousel") && !a2.matches(J) && (r2 = this.option("backdropClick"));
          "close" === r2 ? (t2.preventDefault(), this.close(t2)) : "next" === r2 ? (t2.preventDefault(), this.next()) : "prev" === r2 && (t2.preventDefault(), this.prev());
        }
        onWheel(t2) {
          var e2;
          let i2 = this.option("wheel", t2);
          (null === (e2 = t2.target) || void 0 === e2 ? void 0 : e2.closest(".fancybox__thumbs")) && (i2 = "slide");
          const n2 = "slide" === i2, s2 = [-t2.deltaX || 0, -t2.deltaY || 0, -t2.detail || 0].reduce(function(t3, e3) {
            return Math.abs(e3) > Math.abs(t3) ? e3 : t3;
          }), o2 = Math.max(-1, Math.min(1, s2)), a2 = Date.now();
          this.pwt && a2 - this.pwt < 300 ? n2 && t2.preventDefault() : (this.pwt = a2, this.emit("wheel", t2), t2.defaultPrevented || ("close" === i2 ? (t2.preventDefault(), this.close(t2)) : "slide" === i2 && (t2.preventDefault(), this[o2 > 0 ? "prev" : "next"]())));
        }
        onKeydown(t2) {
          if (!this.isTopmost())
            return;
          this.isCompact || !this.option("idle") || this.isClosing() || this.resetIdle();
          const e2 = t2.key, i2 = this.option("keyboard");
          if (!i2 || t2.ctrlKey || t2.altKey || t2.shiftKey)
            return;
          const n2 = t2.composedPath()[0], s2 = document.activeElement && document.activeElement.classList, o2 = s2 && s2.contains("f-button") || n2.dataset.carouselPage || n2.dataset.carouselIndex;
          if ("Escape" !== e2 && !o2 && x(n2)) {
            if (n2.isContentEditable || -1 !== ["TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(n2.nodeName))
              return;
          }
          this.emit("keydown", e2, t2);
          const a2 = i2[e2];
          "function" == typeof this[a2] && (t2.preventDefault(), this[a2]());
        }
        onResize() {
          const t2 = It, e2 = this.container;
          if (!e2)
            return;
          const i2 = this.isCompact;
          e2.classList.toggle(t2, i2), this.manageCaption(this.getSlide()), this.isCompact ? this.clearIdle() : this.endIdle(), this.scale(), this.emit("resize");
        }
        onFocus(t2) {
          this.isTopmost() && this.checkFocus(t2);
        }
        onMousemove(t2) {
          this.prevMouseMoveEvent = t2, !this.isCompact && this.option("idle") && this.resetIdle();
        }
        onVisibilityChange() {
          "visible" === document.visibilityState ? this.checkFocus() : this.endIdle();
        }
        manageCloseBtn(t2) {
          const e2 = this.optionFor(t2, "closeButton") || false;
          if ("auto" === e2) {
            const t3 = this.plugins.Toolbar;
            if (t3 && t3.state === Pt.Ready)
              return;
          }
          if (!e2)
            return;
          if (!t2.contentEl || t2.closeBtnEl)
            return;
          const i2 = this.option("tpl.closeButton");
          if (i2) {
            const e3 = n(this.localize(i2));
            t2.closeBtnEl = t2.contentEl.appendChild(e3), t2.el && S(t2.el, "has-close-btn");
          }
        }
        manageCaption(t2 = void 0) {
          var e2, i2;
          const n2 = "fancybox__caption", s2 = "has-caption", o2 = this.container;
          if (!o2)
            return;
          const a2 = this.isCompact || this.option("commonCaption"), r2 = !a2;
          if (this.caption && this.stop(this.caption), r2 && this.caption && (this.caption.remove(), this.caption = null), a2 && !this.caption)
            for (const t3 of (null === (e2 = this.carousel) || void 0 === e2 ? void 0 : e2.slides) || [])
              t3.captionEl && (t3.captionEl.remove(), t3.captionEl = void 0, E(t3.el, s2), null === (i2 = t3.el) || void 0 === i2 || i2.removeAttribute("aria-labelledby"));
          if (t2 || (t2 = this.getSlide()), !t2 || a2 && !this.isCurrentSlide(t2))
            return;
          const l2 = t2.el;
          let c2 = this.optionFor(t2, "caption", "");
          if ("string" != typeof c2 || !c2.length)
            return void (a2 && this.caption && this.animate(this.caption, "f-fadeOut", () => {
              this.caption && (this.caption.innerHTML = "");
            }));
          let h2 = null;
          if (r2) {
            if (h2 = t2.captionEl || null, l2 && !h2) {
              const e3 = n2 + `_${this.id}_${t2.index}`;
              h2 = document.createElement("div"), S(h2, n2), h2.setAttribute("id", e3), t2.captionEl = l2.appendChild(h2), S(l2, s2), l2.setAttribute("aria-labelledby", e3);
            }
          } else {
            if (h2 = this.caption, h2 || (h2 = o2.querySelector("." + n2)), !h2) {
              h2 = document.createElement("div"), h2.dataset.fancyboxCaption = "", S(h2, n2), h2.innerHTML = c2;
              (this.footer || o2).prepend(h2);
            }
            S(o2, s2), this.caption = h2;
          }
          h2 && (h2.innerHTML = c2);
        }
        checkFocus(t2) {
          var e2;
          const i2 = document.activeElement || null;
          i2 && (null === (e2 = this.container) || void 0 === e2 ? void 0 : e2.contains(i2)) || this.focus(t2);
        }
        focus(t2) {
          var e2;
          if (this.ignoreFocusChange)
            return;
          const i2 = document.activeElement || null, n2 = (null == t2 ? void 0 : t2.target) || null, s2 = this.container, o2 = this.getSlide();
          if (!s2 || !(null === (e2 = this.carousel) || void 0 === e2 ? void 0 : e2.viewport))
            return;
          if (!t2 && i2 && s2.contains(i2))
            return;
          const a2 = o2 && o2.state === it.Ready ? o2.el : null;
          if (!a2 || a2.contains(i2) || s2 === i2)
            return;
          t2 && t2.cancelable && t2.preventDefault(), this.ignoreFocusChange = true;
          const r2 = Array.from(s2.querySelectorAll(J));
          let l2 = [], c2 = null;
          for (let t3 of r2) {
            const e3 = !t3.offsetParent || t3.closest('[aria-hidden="true"]'), i3 = a2 && a2.contains(t3), n3 = !this.carousel.viewport.contains(t3);
            if (t3 === s2 || (i3 || n3) && !e3) {
              l2.push(t3);
              const e4 = t3.dataset.origTabindex;
              void 0 !== e4 && e4 && (t3.tabIndex = parseFloat(e4)), t3.removeAttribute("data-orig-tabindex"), !t3.hasAttribute("autoFocus") && c2 || (c2 = t3);
            } else {
              const e4 = void 0 === t3.dataset.origTabindex ? t3.getAttribute("tabindex") || "" : t3.dataset.origTabindex;
              e4 && (t3.dataset.origTabindex = e4), t3.tabIndex = -1;
            }
          }
          let h2 = null;
          t2 ? (!n2 || l2.indexOf(n2) < 0) && (h2 = c2 || s2, l2.length && (i2 === Ht ? h2 = l2[0] : this.lastFocus !== s2 && i2 !== jt || (h2 = l2[l2.length - 1]))) : h2 = o2 && "image" === o2.type ? s2 : c2 || s2, h2 && Q(h2), this.lastFocus = document.activeElement, this.ignoreFocusChange = false;
        }
        next() {
          const t2 = this.carousel;
          t2 && t2.pages.length > 1 && t2.slideNext();
        }
        prev() {
          const t2 = this.carousel;
          t2 && t2.pages.length > 1 && t2.slidePrev();
        }
        jumpTo(...t2) {
          this.carousel && this.carousel.slideTo(...t2);
        }
        isTopmost() {
          var t2;
          return (null === (t2 = _t.getInstance()) || void 0 === t2 ? void 0 : t2.id) == this.id;
        }
        animate(t2 = null, e2 = "", i2) {
          if (!t2 || !e2)
            return void (i2 && i2());
          this.stop(t2);
          const n2 = (s2) => {
            s2.target === t2 && t2.dataset.animationName && (t2.removeEventListener("animationend", n2), delete t2.dataset.animationName, i2 && i2(), E(t2, e2));
          };
          t2.dataset.animationName = e2, t2.addEventListener("animationend", n2), S(t2, e2);
        }
        stop(t2) {
          t2 && t2.dispatchEvent(new CustomEvent("animationend", { bubbles: false, cancelable: true, currentTarget: t2 }));
        }
        setContent(t2, e2 = "", i2 = true) {
          if (this.isClosing())
            return;
          const s2 = t2.el;
          if (!s2)
            return;
          let o2 = null;
          if (x(e2) ? o2 = e2 : (o2 = n(e2 + ""), x(o2) || (o2 = document.createElement("div"), o2.innerHTML = e2 + "")), ["img", "picture", "iframe", "video", "audio"].includes(o2.nodeName.toLowerCase())) {
            const t3 = document.createElement("div");
            t3.appendChild(o2), o2 = t3;
          }
          x(o2) && t2.filter && !t2.error && (o2 = o2.querySelector(t2.filter)), o2 && x(o2) ? (S(o2, "fancybox__content"), t2.id && o2.setAttribute("id", t2.id), "none" !== o2.style.display && "none" !== getComputedStyle(o2).getPropertyValue("display") || (o2.style.display = t2.display || this.option("defaultDisplay") || "flex"), s2.classList.add(`has-${t2.error ? "error" : t2.type || "unknown"}`), s2.prepend(o2), t2.contentEl = o2, i2 && this.revealContent(t2), this.manageCloseBtn(t2), this.manageCaption(t2)) : this.setError(t2, "{{ELEMENT_NOT_FOUND}}");
        }
        revealContent(t2, e2) {
          const i2 = t2.el, n2 = t2.contentEl;
          i2 && n2 && (this.emit("reveal", t2), this.hideLoading(t2), t2.state = it.Opening, (e2 = this.isOpeningSlide(t2) ? void 0 === e2 ? this.optionFor(t2, "showClass") : e2 : "f-fadeIn") ? this.animate(n2, e2, () => {
            this.done(t2);
          }) : this.done(t2));
        }
        done(t2) {
          this.isClosing() || (t2.state = it.Ready, this.emit("done", t2), S(t2.el, "is-done"), this.isCurrentSlide(t2) && this.option("autoFocus") && queueMicrotask(() => {
            this.option("autoFocus") && (this.option("autoFocus") ? this.focus() : this.checkFocus());
          }), this.isOpeningSlide(t2) && !this.isCompact && this.option("idle") && this.setIdle());
        }
        isCurrentSlide(t2) {
          const e2 = this.getSlide();
          return !(!t2 || !e2) && e2.index === t2.index;
        }
        isOpeningSlide(t2) {
          var e2, i2;
          return null === (null === (e2 = this.carousel) || void 0 === e2 ? void 0 : e2.prevPage) && t2.index === (null === (i2 = this.getSlide()) || void 0 === i2 ? void 0 : i2.index);
        }
        showLoading(t2) {
          t2.state = it.Loading;
          const e2 = t2.el;
          if (!e2)
            return;
          S(e2, Dt), this.emit("loading", t2), t2.spinnerEl || setTimeout(() => {
            if (!this.isClosing() && !t2.spinnerEl && t2.state === it.Loading) {
              let i2 = n(w);
              t2.spinnerEl = i2, e2.prepend(i2), this.animate(i2, "f-fadeIn");
            }
          }, 250);
        }
        hideLoading(t2) {
          const e2 = t2.el;
          if (!e2)
            return;
          const i2 = t2.spinnerEl;
          this.isClosing() ? null == i2 || i2.remove() : (E(e2, Dt), i2 && this.animate(i2, "f-fadeOut", () => {
            i2.remove();
          }), t2.state === it.Loading && (this.emit("loaded", t2), t2.state = it.Ready));
        }
        setError(t2, e2) {
          if (this.isClosing())
            return;
          const i2 = new Event("error", { bubbles: true, cancelable: true });
          if (this.emit("error", i2, t2), i2.defaultPrevented)
            return;
          t2.error = e2, this.hideLoading(t2), this.clearContent(t2);
          const n2 = document.createElement("div");
          n2.classList.add("fancybox-error"), n2.innerHTML = this.localize(e2 || "<p>{{ERROR}}</p>"), this.setContent(t2, n2);
        }
        clearContent(t2) {
          var e2;
          null === (e2 = this.carousel) || void 0 === e2 || e2.emit("removeSlide", t2);
        }
        getSlide() {
          var t2;
          const e2 = this.carousel;
          return (null === (t2 = null == e2 ? void 0 : e2.pages[null == e2 ? void 0 : e2.page]) || void 0 === t2 ? void 0 : t2.slides[0]) || void 0;
        }
        close(t2, e2) {
          if (this.isClosing())
            return;
          const i2 = new Event("shouldClose", { bubbles: true, cancelable: true });
          if (this.emit("shouldClose", i2, t2), i2.defaultPrevented)
            return;
          t2 && t2.cancelable && (t2.preventDefault(), t2.stopPropagation());
          const n2 = this.fsAPI, s2 = () => {
            this.proceedClose(t2, e2);
          };
          n2 && n2.isFullscreen() ? Promise.resolve(n2.exit()).then(() => s2()) : s2();
        }
        clearIdle() {
          this.idleTimer && clearTimeout(this.idleTimer), this.idleTimer = null;
        }
        setIdle(t2 = false) {
          const e2 = () => {
            this.clearIdle(), this.idle = true, S(this.container, "is-idle"), this.emit("setIdle");
          };
          if (this.clearIdle(), !this.isClosing())
            if (t2)
              e2();
            else {
              const t3 = this.option("idle");
              t3 && (this.idleTimer = setTimeout(e2, t3));
            }
        }
        endIdle() {
          this.clearIdle(), this.idle && !this.isClosing() && (this.idle = false, E(this.container, "is-idle"), this.emit("endIdle"));
        }
        resetIdle() {
          this.endIdle(), this.setIdle();
        }
        toggleIdle() {
          this.idle ? this.endIdle() : this.setIdle(true);
        }
        toggleFullscreen() {
          const t2 = this.fsAPI;
          t2 && (t2.isFullscreen() ? t2.exit() : this.container && t2.request(this.container));
        }
        isClosing() {
          return [et.Closing, et.CustomClosing, et.Destroy].includes(this.state);
        }
        proceedClose(t2, e2) {
          var i2, n2;
          this.state = et.Closing, this.clearIdle(), this.detachEvents();
          const s2 = this.container, o2 = this.carousel, a2 = this.getSlide(), r2 = a2 && this.option("placeFocusBack") ? a2.triggerEl || this.option("triggerEl") : null;
          if (r2 && (U(r2) ? Q(r2) : r2.focus()), s2 && (S(s2, "is-closing"), s2.setAttribute("aria-hidden", "true"), this.option("animated") && S(s2, kt), s2.style.pointerEvents = "none"), o2) {
            o2.clearTransitions(), null === (i2 = o2.panzoom) || void 0 === i2 || i2.destroy(), null === (n2 = o2.plugins.Navigation) || void 0 === n2 || n2.detach();
            for (const t3 of o2.slides) {
              t3.state = it.Closing, this.hideLoading(t3);
              const e3 = t3.contentEl;
              e3 && this.stop(e3);
              const i3 = null == t3 ? void 0 : t3.panzoom;
              i3 && (i3.stop(), i3.detachEvents(), i3.detachObserver()), this.isCurrentSlide(t3) || o2.emit("removeSlide", t3);
            }
          }
          this.emit("close", t2), this.state !== et.CustomClosing ? (void 0 === e2 && a2 && (e2 = this.optionFor(a2, "hideClass")), e2 && a2 ? (this.animate(a2.contentEl, e2, () => {
            o2 && o2.emit("removeSlide", a2);
          }), setTimeout(() => {
            this.destroy();
          }, 500)) : this.destroy()) : setTimeout(() => {
            this.destroy();
          }, 500);
        }
        destroy() {
          var t2;
          if (this.state === et.Destroy)
            return;
          this.state = et.Destroy, null === (t2 = this.carousel) || void 0 === t2 || t2.destroy();
          const e2 = this.container;
          e2 && e2.remove(), Bt.delete(this.id);
          const i2 = _t.getInstance();
          i2 ? i2.focus() : (jt && (jt.remove(), jt = null), Ht && (Ht.remove(), Ht = null), E(document.documentElement, At), (() => {
            if (!G)
              return;
            const t3 = document, e3 = t3.body;
            e3.classList.remove(zt), e3.style.setProperty(Rt, ""), t3.documentElement.style.setProperty(Lt, "");
          })(), this.emit("destroy"));
        }
        static bind(t2, e2, i2) {
          if (!G)
            return;
          let n2, s2 = "", o2 = {};
          if (void 0 === t2 ? n2 = document.body : "string" == typeof t2 ? (n2 = document.body, s2 = t2, "object" == typeof e2 && (o2 = e2 || {})) : (n2 = t2, "string" == typeof e2 && (s2 = e2), "object" == typeof i2 && (o2 = i2 || {})), !n2 || !x(n2))
            return;
          s2 = s2 || "[data-fancybox]";
          const a2 = _t.openers.get(n2) || /* @__PURE__ */ new Map();
          a2.set(s2, o2), _t.openers.set(n2, a2), 1 === a2.size && n2.addEventListener("click", _t.fromEvent);
        }
        static unbind(t2, e2) {
          let i2, n2 = "";
          if ("string" == typeof t2 ? (i2 = document.body, n2 = t2) : (i2 = t2, "string" == typeof e2 && (n2 = e2)), !i2)
            return;
          const s2 = _t.openers.get(i2);
          s2 && n2 && s2.delete(n2), n2 && s2 || (_t.openers.delete(i2), i2.removeEventListener("click", _t.fromEvent));
        }
        static destroy() {
          let t2;
          for (; t2 = _t.getInstance(); )
            t2.destroy();
          for (const t3 of _t.openers.keys())
            t3.removeEventListener("click", _t.fromEvent);
          _t.openers = /* @__PURE__ */ new Map();
        }
        static fromEvent(t2) {
          if (t2.defaultPrevented)
            return;
          if (t2.button && 0 !== t2.button)
            return;
          if (t2.ctrlKey || t2.metaKey || t2.shiftKey)
            return;
          let e2 = t2.composedPath()[0];
          const i2 = e2.closest("[data-fancybox-trigger]");
          if (i2) {
            const t3 = i2.dataset.fancyboxTrigger || "", n3 = document.querySelectorAll(`[data-fancybox="${t3}"]`), s3 = parseInt(i2.dataset.fancyboxIndex || "", 10) || 0;
            e2 = n3[s3] || e2;
          }
          if (!(e2 && e2 instanceof Element))
            return;
          let n2, s2, o2, a2;
          if ([..._t.openers].reverse().find(([t3, i3]) => !(!t3.contains(e2) || ![...i3].reverse().find(([i4, r3]) => {
            let l3 = e2.closest(i4);
            return !!l3 && (n2 = t3, s2 = i4, o2 = l3, a2 = r3, true);
          }))), !n2 || !s2 || !o2)
            return;
          a2 = a2 || {}, t2.preventDefault(), e2 = o2;
          let r2 = [], l2 = u({}, tt, a2);
          l2.event = t2, l2.triggerEl = e2, l2.delegate = i2;
          const c2 = l2.groupAll, h2 = l2.groupAttr, d2 = h2 && e2 ? e2.getAttribute(`${h2}`) : "";
          if ((!e2 || d2 || c2) && (r2 = [].slice.call(n2.querySelectorAll(s2))), e2 && !c2 && (r2 = d2 ? r2.filter((t3) => t3.getAttribute(`${h2}`) === d2) : [e2]), !r2.length)
            return;
          const p2 = _t.getInstance();
          return p2 && p2.options.triggerEl && r2.indexOf(p2.options.triggerEl) > -1 ? void 0 : (e2 && (l2.startIndex = r2.indexOf(e2)), _t.fromNodes(r2, l2));
        }
        static fromSelector(t2, e2) {
          let i2 = null, n2 = "";
          if ("string" == typeof t2 ? (i2 = document.body, n2 = t2) : t2 instanceof HTMLElement && "string" == typeof e2 && (i2 = t2, n2 = e2), !i2 || !n2)
            return false;
          const s2 = _t.openers.get(i2);
          if (!s2)
            return false;
          const o2 = s2.get(n2);
          return !!o2 && _t.fromNodes(Array.from(i2.querySelectorAll(n2)), o2);
        }
        static fromNodes(t2, e2) {
          e2 = u({}, tt, e2 || {});
          const i2 = [];
          for (const n2 of t2) {
            const t3 = n2.dataset || {}, s2 = t3.src || n2.getAttribute("href") || n2.getAttribute("currentSrc") || n2.getAttribute("src") || void 0;
            let o2;
            const a2 = e2.delegate;
            let r2;
            a2 && i2.length === e2.startIndex && (o2 = a2 instanceof HTMLImageElement ? a2 : a2.querySelector("img:not([aria-hidden])")), o2 || (o2 = n2 instanceof HTMLImageElement ? n2 : n2.querySelector("img:not([aria-hidden])")), o2 && (r2 = o2.currentSrc || o2.src || void 0, !r2 && o2.dataset && (r2 = o2.dataset.lazySrc || o2.dataset.src || void 0));
            const l2 = { src: s2, triggerEl: n2, thumbEl: o2, thumbElSrc: r2, thumbSrc: r2 };
            for (const e3 in t3)
              l2[e3] = t3[e3] + "";
            i2.push(l2);
          }
          return new _t(i2, e2);
        }
        static getInstance(t2) {
          if (t2)
            return Bt.get(t2);
          return Array.from(Bt.values()).reverse().find((t3) => !t3.isClosing() && t3) || null;
        }
        static getSlide() {
          var t2;
          return (null === (t2 = _t.getInstance()) || void 0 === t2 ? void 0 : t2.getSlide()) || null;
        }
        static show(t2 = [], e2 = {}) {
          return new _t(t2, e2);
        }
        static next() {
          const t2 = _t.getInstance();
          t2 && t2.next();
        }
        static prev() {
          const t2 = _t.getInstance();
          t2 && t2.prev();
        }
        static close(t2 = true, ...e2) {
          if (t2)
            for (const t3 of Bt.values())
              t3.close(...e2);
          else {
            const t3 = _t.getInstance();
            t3 && t3.close(...e2);
          }
        }
      }
      Object.defineProperty(_t, "version", { enumerable: true, configurable: true, writable: true, value: "5.0.20" }), Object.defineProperty(_t, "defaults", { enumerable: true, configurable: true, writable: true, value: tt }), Object.defineProperty(_t, "Plugins", { enumerable: true, configurable: true, writable: true, value: Ot }), Object.defineProperty(_t, "openers", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Map() });
      var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
      var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();
      var _GM_xmlhttpRequest = /* @__PURE__ */ (() => typeof GM_xmlhttpRequest != "undefined" ? GM_xmlhttpRequest : void 0)();
      var _unsafeWindow = /* @__PURE__ */ (() => typeof unsafeWindow != "undefined" ? unsafeWindow : void 0)();
      class TaskQueue {
        constructor(options) {
          __publicField(this, "max");
          __publicField(this, "initMax");
          __publicField(this, "taskList");
          __publicField(this, "showMessage");
          __publicField(this, "finallyCallback");
          this.max = (options == null ? void 0 : options.max) || 10;
          this.initMax = (options == null ? void 0 : options.max) || 10;
          this.taskList = [];
          this.showMessage = (options == null ? void 0 : options.showMessage) || false;
          this.finallyCallback = (options == null ? void 0 : options.finallyCallback) || Function();
        }
        /**
         * * 添加任务到队列
         * @param {ITask} task 任务项
         */
        addTask(task) {
          if (task) {
            this.taskList.push(task);
          }
        }
        /**
         * * push任务到队列
         * @param {ITask[]} taskList 任务项
         */
        pushTask(taskList) {
          if (taskList) {
            this.taskList.push(...taskList);
          }
        }
        //f 启动任务队列
        run() {
          const length = this.taskList.length;
          if (!length) {
            if (this.max === this.initMax) {
              this.finallyCallback();
            }
            return;
          }
          const min = Math.min(length, this.max);
          for (let i2 = 0; i2 < min; i2++) {
            const task = this.taskList.shift();
            this.max--;
            if (task && (task == null ? void 0 : task.main)) {
              task == null ? void 0 : task.main().then((res) => {
                if (this.showMessage)
                  console.log(res);
                if (task.callback) {
                  task.callback(res, task.index);
                }
              }).catch((err) => {
                if (this.showMessage)
                  console.log(err);
                if (task.callback) {
                  task.callback(err, task.index);
                }
              }).finally(() => {
                this.max++;
                this.run();
              });
            } else {
              this.max++;
              this.run();
            }
          }
        }
      }
      function getBlobByUrl(url, mode = "Fetch", referer = void 0) {
        if (isEmpty(url)) {
          return new Promise((resolve2, reject) => {
            resolve2(new Blob(void 0, { type: "none" }));
          });
        }
        if (mode === "Fetch") {
          return new Promise(async (resolve2, reject) => {
            let blob = await fetch(url).then((res) => res.blob()).catch((err) => null);
            if (blob != null) {
              console.log("Fetch成功", blob);
              resolve2(blob);
            } else {
              console.log("Fetch失败", blob);
              resolve2(new Blob(void 0, { type: "none" }));
            }
          });
        } else if (mode === "GM") {
          return new Promise(async (resolve2, reject) => {
            let headers;
            if (referer != null) {
              headers = {
                referer
              };
            }
            _GM_xmlhttpRequest({
              methods: "GET",
              url,
              responseType: "blob",
              headers,
              onload: (res) => {
                if (res.status == 200) {
                  console.log(`GM成功(referer:${referer})`, res.response, res.status);
                  resolve2(res.response);
                } else {
                  console.log(`GM失败(referer:${referer})`, res.response, res.status);
                  resolve2(new Blob(void 0, { type: "none" }));
                }
              },
              onerror: (err) => {
                resolve2(new Blob(void 0, { type: "none" }));
              },
              ontimeout: () => {
                resolve2(new Blob(void 0, { type: "none" }));
              },
              onabort: () => {
                resolve2(new Blob(void 0, { type: "none" }));
              }
            });
          });
        } else {
          return new Blob(void 0, { type: "none" });
        }
      }
      async function getBlobByUrlAuto(url) {
        if (isEmpty(url)) {
          return new Blob(void 0, { type: "none" });
        }
        let blob = new Blob(void 0, { type: "none" });
        blob = await getBlobByUrl(url, "Fetch");
        if (blob.type === "none") {
          blob = await getBlobByUrl(url, "GM");
        }
        if (blob.type === "none") {
          blob = await getBlobByUrl(url, "GM", location.origin);
        }
        return blob;
      }
      function buildUUID() {
        const hexList = [];
        for (let i2 = 0; i2 <= 15; i2++) {
          hexList[i2] = i2.toString(16);
        }
        let uuid = "";
        for (let i2 = 1; i2 <= 36; i2++) {
          if (i2 === 9 || i2 === 14 || i2 === 19 || i2 === 24) {
            uuid += "-";
          } else if (i2 === 15) {
            uuid += 4;
          } else if (i2 === 20) {
            uuid += hexList[Math.random() * 4 | 8];
          } else {
            uuid += hexList[Math.random() * 16 | 0];
          }
        }
        return uuid.replace(/-/g, "");
      }
      async function getFavicon() {
        let iconUrl;
        let urls = [...document.querySelectorAll("link[rel=icon]")].map((item) => item.href).filter((url) => /\.(png|svg|jpg|jpeg|webp|icon?)$/i.test(url));
        if (urls.length > 0) {
          iconUrl = urls[0];
        } else {
          iconUrl = `${location.origin}/favicon.ico`;
        }
        return iconUrl;
      }
      function getNameByUrl(url) {
        let list = url.match(new RegExp("(?<=\\/)([^\\/\\r\\n$]+)$", "g")) || [];
        if (list.length > 0) {
          return list[0] || url;
        } else {
          return url;
        }
      }
      function isEmpty(str = "", includeSpace = false) {
        return includeSpace ? str == null || str == void 0 || str == "" || /^ +?$/.test(str) : str == null || str == void 0 || str == "";
      }
      async function getImgMetaByBlob(blob) {
        const meta = await new Promise((resolve2, reject) => {
          let reader = new FileReader();
          reader.readAsDataURL(blob);
          reader.onload = (theFile) => {
            let image = new Image();
            image.src = theFile.target.result;
            image.onload = () => {
              resolve2({
                isOk: true,
                width: image.width,
                height: image.height,
                aspectRatio: image.width / image.height
              });
            };
            image.onerror = () => {
              reject({
                isOk: false,
                width: 0,
                height: 0
              });
            };
          };
        });
        return meta;
      }
      async function getImgMetaByImage(url) {
        if (isEmpty(url)) {
          const errMeta = {
            isOk: false,
            width: 0,
            height: 0,
            aspectRatio: 3 / 4
          };
          return errMeta;
        }
        return await new Promise((resolve2, reject) => {
          const img = new Image();
          img.src = url;
          if (img.complete) {
            resolve2({
              isOk: true,
              width: img.width,
              height: img.height,
              aspectRatio: img.width / img.height
            });
          } else {
            img.onload = () => {
              resolve2({
                isOk: true,
                width: img.width,
                height: img.height,
                aspectRatio: img.width / img.height
              });
            };
            img.onerror = () => {
              resolve2({
                isOk: false,
                width: 0,
                height: 0,
                aspectRatio: 3 / 4
              });
            };
          }
        });
      }
      async function getCardsByRule(rule, nowCount, singleCallback, finallyCallback, option) {
        var _a2, _b;
        let rowCardList = [];
        console.log("开始匹配", rule);
        if (rule.domItem.enable) {
          //! 启用了dom匹配
          for (let i2 = 0, len = rule.domItem.selector.length; i2 < len; i2++) {
            let domList = await getDom(
              document.body,
              rule.domItem.method,
              rule.domItem.selector[i2],
              0
            );
            //! 对每个dom进行结果匹配
            for (let index = 0; index < domList.length; index++) {
              let card = {
                id: buildUUID(),
                //* 生成uuid
                linkUrlType: "none",
                picUrlType: "none",
                metaOrigin: "",
                dom: domList[index]
              };
              rowCardList.push(card);
              let linkUrl_Selector = rule.linkUrl.selector[i2], picUrl_Selector = rule.picUrl.selector[i2], name_Selector = rule.name.selector[i2], meta_Selector = rule.meta.selector[i2];
              //! [匹配LinkUrl]
              card.linkUrlDom = card.dom;
              if (!isEmpty(linkUrl_Selector, true)) {
                card.linkUrlDom = await getDom(
                  card.dom,
                  rule.linkUrl.method,
                  linkUrl_Selector,
                  1
                );
              }
              //! 获取对应结果(链接)
              if (card.linkUrlDom) {
                card.linkUrl = await getTagInfo(
                  card.linkUrlDom,
                  rule.linkUrl.infoType,
                  rule.linkUrl.attribute[i2]
                );
              } else {
                card.linkUrl = "";
              }
              //! [匹配PicUrl]
              if (rule.picUrl.enable == true) {
                card.picUrlDom = card.dom;
                if (!isEmpty(picUrl_Selector, true)) {
                  if (picUrl_Selector == linkUrl_Selector) {
                    card.picUrlDom = card.linkUrlDom;
                  } else {
                    card.picUrlDom = await getDom(
                      card.dom,
                      rule.picUrl.method,
                      picUrl_Selector,
                      1
                    );
                  }
                }
                if (card.picUrlDom != null) {
                  card.picUrl = await getTagInfo(
                    card.picUrlDom,
                    rule.picUrl.infoType,
                    rule.picUrl.attribute[i2]
                  );
                  if (card.picUrl == null) {
                    card.picUrl = card.linkUrl;
                  }
                } else {
                  card.picUrl = card.linkUrl;
                }
              } else {
                card.picUrl = card.linkUrl;
                card.picUrlDom = card.linkUrlDom;
              }
              //! [匹配name]
              if (rule.name.enable == true) {
                card.nameDom = card.dom;
                if (!isEmpty(name_Selector, true)) {
                  if (name_Selector == linkUrl_Selector) {
                    card.nameDom = card.linkUrlDom;
                  } else if (name_Selector == picUrl_Selector) {
                    card.nameDom = card.picUrlDom;
                  } else {
                    card.nameDom = await getDom(
                      card.dom,
                      rule.name.method,
                      name_Selector,
                      1
                    );
                  }
                }
                if (card.nameDom) {
                  card.name = await getTagInfo(
                    card.nameDom,
                    rule.name.infoType,
                    rule.name.attribute[i2]
                  );
                  if (card.name == null) {
                    card.name = card.linkUrl;
                  }
                } else {
                  card.name = card.linkUrl;
                }
              } else {
                card.name = card.linkUrl;
                card.nameDom = card.linkUrlDom;
              }
              //! [匹配meta]
              if (rule.meta.enable == true && rule.meta.origin == 0) {
                card.metaDom = card.dom;
                if (!isEmpty(meta_Selector, true)) {
                  if (meta_Selector == linkUrl_Selector) {
                    card.metaDom = card.linkUrlDom;
                  } else if (meta_Selector == picUrl_Selector) {
                    card.metaDom = card.picUrlDom;
                  } else if (meta_Selector == name_Selector) {
                    card.metaDom = card.nameDom;
                  } else {
                    card.metaDom = await getDom(
                      card.dom,
                      rule.meta.method,
                      meta_Selector,
                      1
                    );
                  }
                }
                if (card.metaDom) {
                  card.metaOrigin = await getTagInfo(
                    card.metaDom,
                    rule.meta.infoType,
                    rule.meta.attribute[i2]
                  );
                  if (card.metaOrigin == void 0) {
                    card.metaOrigin = card.linkUrl;
                  }
                } else {
                  card.metaOrigin = card.linkUrl;
                }
              } else {
                if (rule.meta.origin == 1) {
                  card.metaDom = card.linkUrlDom;
                  card.metaOrigin = card.linkUrl;
                } else if (rule.meta.origin == 2) {
                  card.metaDom = card.picUrlDom;
                  card.metaOrigin = card.picUrl;
                } else if (rule.meta.origin == 3) {
                  card.metaDom = card.nameDom;
                  card.metaOrigin = card.name;
                }
              }
            }
          }
        } else {
          //! 未启用dom匹配
          for (let i2 = 0, len = rule.linkUrl.selector.length; i2 < len; i2++) {
            let linkUrlList_temp = [];
            let picUrlList_temp = [];
            let nameList_temp = [];
            let metaTextList_temp = [];
            //! 获取linkUrls
            let linkUrlDomList = [];
            linkUrlDomList.push(
              ...await getDom(
                document.body,
                rule.linkUrl.method,
                rule.linkUrl.selector[i2],
                0
              )
            );
            for (const linkUrlDom of linkUrlDomList) {
              if (linkUrlDom) {
                linkUrlList_temp.push(
                  await getTagInfo(
                    linkUrlDom,
                    rule.linkUrl.infoType,
                    rule.linkUrl.attribute[i2]
                  )
                );
              } else {
                linkUrlList_temp.push("");
              }
            }
            console.log(linkUrlList_temp);
            //! 获取picUrls
            let picUrlDomList = [];
            if (rule.picUrl.enable && !isEmpty(rule.picUrl.selector[i2], true)) {
              picUrlDomList.push(
                ...await getDom(
                  document.body,
                  rule.picUrl.method,
                  rule.picUrl.selector[i2],
                  0
                )
              );
              for (const picUrlDom of picUrlDomList) {
                if (picUrlDom) {
                  picUrlList_temp.push(
                    await getTagInfo(
                      picUrlDom,
                      rule.picUrl.infoType,
                      rule.picUrl.attribute[i2]
                    )
                  );
                } else {
                  picUrlList_temp.push("");
                }
              }
              picUrlList_temp = fillArrayToTargetLength(
                picUrlList_temp,
                linkUrlList_temp.length,
                ""
              );
            } else {
              picUrlList_temp = Array.from(linkUrlList_temp);
              picUrlDomList = linkUrlDomList;
            }
            //! 获取名称
            let nameDomList = [];
            if (rule.name.enable && !isEmpty(rule.name.selector[i2], true)) {
              nameDomList.push(
                ...await getDom(
                  document.body,
                  rule.name.method,
                  rule.name.selector[i2],
                  0
                )
              );
              for (const nameDom of nameDomList) {
                if (nameDom != null) {
                  nameList_temp.push(
                    await getTagInfo(
                      nameDom,
                      rule.name.infoType,
                      rule.name.attribute[i2]
                    )
                  );
                } else {
                  nameList_temp.push("");
                }
              }
              nameList_temp = fillArrayToTargetLength(
                nameList_temp,
                linkUrlList_temp.length,
                ""
              );
            } else {
              nameList_temp = Array.from(linkUrlList_temp);
              nameDomList = linkUrlDomList;
            }
            //! 获取meta
            let metaDomList = [];
            if (rule.meta.enable && rule.meta.origin == 0 && !isEmpty(rule.meta.selector[i2], true)) {
              metaDomList.push(
                ...await getDom(
                  document.body,
                  rule.meta.method,
                  rule.meta.selector[i2],
                  0
                )
              );
              for (const metaDom of metaDomList) {
                if (metaDom != null) {
                  metaTextList_temp.push(
                    await getTagInfo(
                      metaDom,
                      rule.meta.infoType,
                      rule.meta.attribute[i2]
                    )
                  );
                } else {
                  metaTextList_temp.push("");
                }
              }
              metaTextList_temp = fillArrayToTargetLength(
                metaTextList_temp,
                linkUrlList_temp.length,
                ""
              );
            } else {
              if (rule.meta.origin == 1) {
                metaTextList_temp = Array.from(linkUrlList_temp);
                metaDomList = linkUrlDomList;
              } else if (rule.meta.origin == 2) {
                metaTextList_temp = Array.from(picUrlList_temp);
                metaDomList = picUrlDomList;
              } else if (rule.meta.origin == 3) {
                metaTextList_temp = Array.from(nameList_temp);
                metaDomList = nameDomList;
              }
            }
            //! 合成一批cards
            for (let index = 0; index < linkUrlList_temp.length; index++) {
              const link = linkUrlList_temp[index];
              let card = {
                id: buildUUID(),
                //* 生成uuid
                linkUrlType: "none",
                picUrlType: "none",
                metaOrigin: ""
              };
              card.linkUrl = link;
              card.picUrl = picUrlList_temp[index];
              card.name = nameList_temp[index];
              card.metaOrigin = metaTextList_temp[index];
              card.dom = linkUrlDomList[index];
              card.linkUrlDom = linkUrlDomList[index];
              card.picUrlDom = picUrlDomList[index];
              card.nameDom = nameDomList[index];
              card.metaDom = metaDomList[index];
              rowCardList.push(card);
            }
          }
        }
        rowCardList = rowCardList.filter(
          (rowCard) => rowCard.dom && !isEmpty(rowCard.picUrl)
        );
        let processedCount = 0;
        const taskQueue = new TaskQueue({ showMessage: false, max: 10 });
        let cardList = [];
        for (let index = 0; index < rowCardList.length; index++) {
          const rowCard = rowCardList[index];
          if (!((_a2 = option == null ? void 0 : option.excludeDomSet) == null ? void 0 : _a2.has(rowCard.dom)) && !((_b = option == null ? void 0 : option.excludeUrlSet) == null ? void 0 : _b.has(rowCard.picUrl))) {
            const task = {
              index,
              main: async () => {
                const card = await singleCardProcessing(rowCard, rule);
                return card;
              },
              callback: (card, realIndex) => {
                processedCount++;
                if (singleCallback)
                  singleCallback(
                    card,
                    nowCount + realIndex,
                    processedCount,
                    rowCardList.length
                  );
                cardList.push(card);
              }
            };
            taskQueue.addTask(task);
          }
        }
        taskQueue.finallyCallback = () => {
          if (finallyCallback)
            finallyCallback(cardList, rowCardList);
        };
        taskQueue.run();
      }
      async function singleCardProcessing(rowCard, rule) {
        let card = {
          id: rowCard.id,
          name: rowCard.name || "",
          linkUrl: rowCard.linkUrl || "",
          picUrl: rowCard.picUrl || "",
          originUrls: rowCard.linkUrl ? [rowCard.linkUrl] : [],
          match: false,
          selected: false,
          metaOrigin: rowCard.metaOrigin,
          meta: {
            isOk: false,
            width: 0,
            height: 0,
            aspectRatio: 3 / 4
          },
          dom: rowCard.dom,
          linkUrlDom: rowCard.linkUrlDom,
          picUrlDom: rowCard.picUrlDom,
          nameDom: rowCard.nameDom,
          metaDom: rowCard.metaDom
        };
        //! 链接处理
        if (isUrl(card.linkUrl)) {
          card.linkUrl = urlCompletion(card.linkUrl);
        }
        if (!isEmpty(card.linkUrl))
          ;
        else {
          card.linkUrl = "";
        }
        //! 图链处理
        if (rule.picUrl.enable) {
          if (isUrl(card.picUrl)) {
            card.picUrl = urlCompletion(card.picUrl);
          }
          if (!isEmpty(card.picUrl))
            ;
          else {
            card.picUrl = card.linkUrl;
          }
        } else {
          card.picUrl = card.linkUrl;
        }
        //! 名称处理
        if (rule.name.enable) {
          if (!isEmpty(card.name))
            ;
          else {
            card.name = card.linkUrl;
          }
        } else {
          card.name = card.linkUrl;
        }
        if (isPath(card.name)) {
          card.name = getNameByUrl(card.name);
        }
        //! 元信息获取
        if (rule.meta.enable) {
          if (rule.meta.origin == 0) {
            if (card.metaDom)
              ;
          } else if (rule.meta.origin == 1) {
            if (card.linkUrlDom) {
              await getMeta(
                card.linkUrlDom,
                card.linkUrl,
                card,
                rule.meta.getMethod,
                "linkBlob"
              );
            }
          } else if (rule.meta.origin == 2) {
            if (card.picUrlDom) {
              await getMeta(
                card.picUrlDom,
                card.picUrl,
                card,
                rule.meta.getMethod,
                "picBlob"
              );
            }
          } else if (rule.meta.origin == 3) {
            if (card.nameDom) {
              await getMeta(
                card.nameDom,
                card.name,
                card,
                rule.meta.getMethod,
                "nameBlob"
              );
            }
          }
        }
        async function getMeta(dom, url, card2, getMetaMethod, blobType) {
          if (!dom)
            return;
          if (getMetaMethod === 0) {
            if (dom.tagName === "IMG") {
              const { naturalWidth, naturalHeight } = dom;
              if (naturalWidth > 0 && naturalHeight > 0) {
                card2.meta.width = naturalWidth;
                card2.meta.height = naturalHeight;
                card2.meta.isOk = true;
              } else {
                card2.meta = await getImgMetaByImage(url);
              }
            } else {
              card2[blobType] = await getBlobByUrlAuto(url);
              if (/^image/.test(card2[blobType].type)) {
                card2.meta = await getImgMetaByBlob(card2[blobType]);
              }
            }
          } else if (getMetaMethod === 1) {
            const { naturalWidth, naturalHeight } = dom;
            if (naturalWidth > 0 && naturalHeight > 0) {
              card2.meta.width = naturalWidth;
              card2.meta.height = naturalHeight;
              card2.meta.isOk = true;
            }
          } else if (getMetaMethod === 2) {
            card2.meta = await getImgMetaByImage(url);
          } else if (getMetaMethod === 3) {
            card2[blobType] = await getBlobByUrlAuto(url);
            if (/^image/.test(card2[blobType].type)) {
              card2.meta = await getImgMetaByBlob(card2[blobType]);
            }
          }
        }
        if (card.meta.isOk) {
          card.match = card.meta.isOk;
          card.meta.aspectRatio = card.meta.width / card.meta.height;
        }
        if (card.linkBlob) {
          if (!card.picBlob)
            card.picBlob = card.linkBlob;
          if (!card.nameBlob)
            card.nameBlob = card.linkBlob;
        } else if (card.picBlob) {
          if (!card.linkBlob)
            card.linkBlob = card.picBlob;
          if (!card.nameBlob)
            card.nameBlob = card.picBlob;
        } else if (card.nameBlob) {
          if (!card.linkBlob)
            card.linkBlob = card.nameBlob;
          if (!card.picBlob)
            card.picBlob = card.nameBlob;
        }
        if (card.linkBlob)
          card.linkUrlExt = getExtByBlob(card.linkBlob);
        if (card.picBlob)
          card.picUrlExt = getExtByBlob(card.picBlob);
        return card;
      }
      async function getDom(startDom, method2, selector, mode = 0) {
        let selectorList = [];
        if (/\|/.test(selector)) {
          selectorList = selector.split("|");
        } else {
          selectorList = [selector];
        }
        startDom = startDom || document.body;
        let resultDomList = [];
        if (method2 == 0) {
          for (const selectorItem of selectorList) {
            if (isEmpty(selectorItem)) {
              continue;
            }
            let tempDomList = [];
            try {
              tempDomList = [
                ...startDom.querySelectorAll(selectorItem)
              ];
            } catch (err) {
              console.log("方法getDom出错!(css选择器模式)");
            }
            resultDomList.push(...tempDomList);
          }
        } else if (method2 == 1) {
          for (const selectorItem of selectorList) {
            if (isEmpty(selectorItem)) {
              continue;
            }
            let tempDomList = [];
            try {
              tempDomList = getDomByXpath(startDom, selectorItem);
            } catch (err) {
              console.log("方法getDom出错!(xpath模式)");
            }
            resultDomList.push(...tempDomList);
          }
        }
        resultDomList = resultDomList.filter((dom) => dom);
        if (mode == 0) {
          return resultDomList;
        } else {
          if (resultDomList.length > 0) {
            return resultDomList[0];
          } else {
            return null;
          }
        }
      }
      function getDomByXpath(startDom, xpath) {
        const result = [];
        const xpathResult = document.evaluate(xpath, startDom, null, 5, null);
        let resultItem;
        while (resultItem = xpathResult.iterateNext()) {
          result.push(resultItem);
        }
        return result;
      }
      async function getTagInfo(dom, type2, attr) {
        if (type2 === 0) {
          return "";
        }
        let attrList = [];
        if (/\|/.test(attr)) {
          attrList = attr.split("|");
        } else {
          attrList = [attr];
        }
        let result = "";
        if (dom == null) {
          return result;
        }
        if (type2 == 1) {
          result = dom["value"] || "";
        } else if (type2 == 2) {
          for (let i2 = 0; i2 < attrList.length; i2++) {
            const attr2 = attrList[i2];
            let temp = dom.getAttribute(attr2);
            if (!isEmpty(temp)) {
              if (attr2 == "srcset") {
                temp = getSrcsetMaximumValue(temp);
              }
              result = temp || "";
              break;
            }
          }
        } else if (type2 == 3) {
          result = "";
          for (let i2 = 0; i2 < attrList.length; i2++) {
            const attr2 = attrList[i2];
            let temp = dom[attr2];
            if (!isEmpty(temp)) {
              if (attr2 == "srcset") {
                temp = getSrcsetMaximumValue(temp);
              }
              result = temp;
              break;
            }
          }
        } else if (type2 == 4) {
          document.createElement("div");
          result = dom.innerText;
        } else if (type2 == 5) {
          result = dom.innerHTML;
        } else if (type2 == 6) {
          result = dom.outerHTML;
        }
        if (isUrl(result)) {
          result = urlCompletion(result);
        }
        return result;
      }
      function isUrl(str) {
        var v2 = /^(\/|(.\/)).+?$/i;
        return v2.test(str);
      }
      function isPath(str) {
        return /\//i.test(str);
      }
      function getSrcsetMaximumValue(srcsetString) {
        let result = srcsetString;
        if (/\d+w/.test(srcsetString)) {
          let dataList = srcsetString.split(/\, */).filter((item) => !isEmpty(item, true)).map((item) => {
            const itemDataInfos = item.split(" ");
            if (itemDataInfos.length == 2) {
              return {
                url: itemDataInfos[0],
                resolution: Number(itemDataInfos[1].split(/w|W/)[0])
              };
            } else {
              return {
                url: itemDataInfos[0],
                resolution: 0
              };
            }
          });
          let maxItem = dataList[0];
          dataList.forEach((item) => {
            if (maxItem.resolution < item.resolution) {
              maxItem = item;
            }
          });
          result = maxItem.url;
        }
        return result;
      }
      function urlCompletion(url) {
        const v1 = /^\/[^\/].*$/i;
        const v2 = /^\/\/.*$/i;
        if (v1.test(url)) {
          return window.document.location.origin + url;
        }
        if (v2.test(url)) {
          return window.document.location.protocol + url;
        }
        return url;
      }
      function fillArrayToTargetLength(input_array = [], length, content) {
        const output_array = Array.from(input_array);
        for (let i2 = 0; i2 < length; i2++) {
          if (output_array[i2] == null) {
            output_array.push(content);
          }
        }
        return output_array;
      }
      function mixSort(_a2, _b) {
        const reg = /[a-zA-Z0-9]/;
        const a2 = _a2.toString();
        const b2 = _b.toString();
        if (reg.test(a2[0]) || reg.test(b2[0])) {
          if (a2 > b2) {
            return 1;
          } else if (a2 < b2) {
            return -1;
          } else {
            return 0;
          }
        } else {
          return a2.localeCompare(b2);
        }
      }
      function getExtByBlob(blob) {
        let match = new RegExp("(?<=\\/).+$").exec(blob.type);
        let ext = (match == null ? void 0 : match.at(0)) || "";
        if (!isEmpty(ext)) {
          ext = ext === "jpeg" ? "jpg" : ext;
        }
        return ext;
      }
      function strAutofill(str, fillContent, fill_length, direction2 = "prefix") {
        if (direction2 === "prefix") {
          return str.padStart(fill_length, fillContent.toString());
        } else {
          return str.padEnd(fill_length, fillContent.toString());
        }
      }
      const useAppInfoStore = defineStore("appInfo", () => {
        const container = reactive({
          open: false,
          //* 开关标识符
          widthPercentage: 100
          //* 宽度百分比
        });
        const window2 = reactive({
          width: useWindowSize().width,
          height: useWindowSize().height
        });
        const loading = reactive({
          value: false,
          show: false,
          state: "",
          percentage: 0,
          //f 进度条初始化函数
          init: () => {
            loading.value = true;
            loading.show = true;
            loading.percentage = 0;
            loading.state = "";
          },
          //f 进度条重置函数
          reset: () => {
            setTimeout(() => {
              loading.value = false;
              loading.state = "success";
              setTimeout(() => {
                loading.show = false;
                loading.percentage = 0;
                loading.state = "";
              }, 1500);
            }, 500);
          }
        });
        return { container, window: window2, loading };
      });
      const useCardsStore = defineStore("Cards", () => {
        const appInfo = useAppInfoStore();
        const toolBar = useToolBarStore();
        useRuleEditorStore();
        const data = reactive({
          cardList: [],
          //* 卡片列表
          //f 所有匹配到的链接集合
          urlSet: /* @__PURE__ */ new Set(),
          //f 所有匹配到的dom集合
          domSet: /* @__PURE__ */ new Set()
        });
        const allValidCards = computed(() => {
          return data.cardList.filter((card) => card);
        });
        const filterCards = computed(() => {
          const filter = toolBar.filter;
          const listControl = toolBar.listControl;
          let regex = filter.formats.value.length ? new RegExp(`\\.(${filter.formats.value.join("|")})$`) : new RegExp("");
          let cardList = allValidCards.value.filter(
            (card) => card.meta.width >= filter.size.width.value[0] && card.meta.width <= filter.size.width.value[1] && card.meta.height >= filter.size.height.value[0] && card.meta.height <= filter.size.height.value[1] && regex.test(card.linkUrl)
          );
          if (listControl.sortMethod.value === "name-asc") {
            cardList = cardList.sort((a2, b2) => mixSort(a2.name, b2.name));
          } else if (listControl.sortMethod.value === "name-desc") {
            cardList = cardList.sort((a2, b2) => mixSort(b2.name, a2.name));
          } else if (listControl.sortMethod.value === "width-asc") {
            cardList = cardList.sort((a2, b2) => a2.meta.width - b2.meta.width);
          } else if (listControl.sortMethod.value === "width-desc") {
            cardList = cardList.sort((a2, b2) => b2.meta.width - a2.meta.width);
          } else if (listControl.sortMethod.value === "height-asc") {
            cardList = cardList.sort((a2, b2) => a2.meta.height - b2.meta.height);
          } else if (listControl.sortMethod.value === "height-desc") {
            cardList = cardList.sort((a2, b2) => b2.meta.height - a2.meta.height);
          }
          return cardList;
        });
        const selectedCards = computed(() => {
          return filterCards.value.filter((card) => card.selected);
        });
        const getCard = async (rule) => {
          const filter = toolBar.filter;
          appInfo.loading.init();
          const singleCallBack = (card, realIndex, processedCount, allCount) => {
            appInfo.loading.percentage = processedCount / allCount * 100;
            if (card.match && !data.urlSet.has(card.picUrl)) {
              console.log("匹配成功!", card, filter);
              data.cardList[realIndex] = card;
              data.urlSet.add(card.picUrl);
              data.domSet.add(card.dom);
              const max = filter.size.width.max = filter.size.height.max = Math.max(
                filter.size.width.max,
                filter.size.height.max,
                card.meta.width,
                card.meta.height
              );
              console.log(max);
              filter.size.width.value[1] = max;
              filter.size.height.value[1] = max;
            }
          };
          const finallyCallback = (cardList_output, rowCardList) => {
            appInfo.loading.percentage = 100;
            appInfo.loading.reset();
            if (!cardList_output.length) {
              ElMessage({
                message: "没有匹配到合适的项目(请切换/创建预设后重试)",
                type: "info",
                showClose: true,
                grouping: true,
                offset: 120
              });
            }
            data.cardList = data.cardList.filter((card) => card);
          };
          await getCardsByRule(
            rule,
            data.cardList.length,
            singleCallBack,
            finallyCallback,
            {
              excludeDomSet: data.domSet,
              excludeUrlSet: data.urlSet
            }
          );
        };
        const openFancyBox = async (startIndex = 0) => {
          const nodeList2 = filterCards.value.map((card) => card.linkUrlDom);
          _t.fromNodes(nodeList2, {
            hideScrollbar: true,
            startIndex,
            parentEl: document.querySelector(
              ".onlineGallery-child-window-container"
            ),
            groupAll: true,
            Thumbs: { type: "modern" },
            Images: {
              Panzoom: {
                maxScale: 5
              }
            },
            Toolbar: {
              display: {
                left: ["infobar"],
                middle: [
                  "zoomIn",
                  "zoomOut",
                  "toggle1to1",
                  "rotateCCW",
                  "rotateCW",
                  "flipX",
                  "flipY"
                ],
                right: ["slideshow", "download", "thumbs", "close"]
              }
            }
          });
        };
        return {
          data,
          allValidCards,
          filterCards,
          selectedCards,
          getCard,
          openFancyBox
        };
      });
      const useToolBarStore = defineStore("ToolBar", () => {
        useCardsStore();
        const ruleEditor = useRuleEditorStore();
        const filter = reactive({
          size: {
            width: {
              value: [350, 500],
              max: 500
            },
            height: {
              value: [350, 500],
              max: 500
            }
          },
          formats: {
            options: [
              { value: "png", label: "png" },
              { value: "jpg", label: "jpg" },
              { value: "jpeg", label: "jpeg" },
              { value: "gif", label: "gif" },
              { value: "bmp", label: "bmp" },
              { value: "webp", label: "webp" },
              { value: "svg", label: "svg" }
            ],
            value: ["png", "jpg", "jpeg", "gif", "webp", "bmp"]
          }
        });
        const ruleSelector = reactive({
          value: void 0,
          option: computed(() => {
            let options = [
              {
                value: "#",
                label: "(内置)默认规则",
                iconUrl: ""
              }
            ];
            options.push(
              ...ruleEditor.data.ruleList.map((rule) => {
                return {
                  value: rule.id,
                  label: rule.main.name,
                  iconUrl: rule.main.iconUrl
                };
              })
            );
            return options;
          })
        });
        const listControl = reactive({
          //* 排序方式
          sortMethod: {
            options: [
              { value: "#", label: "默认排序" },
              { value: "name-asc", label: "名称-升序" },
              { value: "name-desc", label: "名称-降序" },
              { value: "width-asc", label: "宽度-升序" },
              { value: "width-desc", label: "宽度-降序" },
              { value: "height-asc", label: "高度-升序" },
              { value: "height-desc", label: "高度-降序" }
            ],
            value: "#"
          },
          //* 显示行数
          showColumn: 3,
          allSelected: false
        });
        const selectingInitRule = () => {
          let matchedRule = ruleEditor.data.ruleList.filter((rule) => {
            return new RegExp(`${rule.main.domainName}`).test(location.origin);
          }).filter((rule) => {
            const pattern2 = rule.main.pathFilter.pattern;
            const flags = rule.main.pathFilter.flags.join("");
            return new RegExp(pattern2, flags).test(
              location.pathname + location.search
            );
          });
          if (matchedRule.length) {
            ruleSelector.value = matchedRule[0].id;
          } else {
            ruleSelector.value = "#";
          }
        };
        return { filter, listControl, ruleSelector, selectingInitRule };
      });
      const useRuleEditorStore = defineStore("ruleEditor", () => {
        const container = reactive({
          open: false
        });
        const info = reactive({
          showRuleId: "#",
          form: {
            activeName: "main",
            realTimeData: void 0
          },
          tree: {
            query: "",
            //* 查询(过滤)文本
            //* 树形列表配置信息对象
            treeProps: {
              value: "id",
              label: "label",
              children: "children",
              disabled: "disabled"
            },
            //* 树形列表数据
            treeData: computed(() => {
              let result = data.ruleList.map((rule) => {
                return {
                  id: rule.id,
                  label: rule.main.name || "未命名规则",
                  iconUrl: rule.main.iconUrl,
                  children: [],
                  disabled: false,
                  isNew: rule.status.isNewCreated
                };
              });
              result.push({
                id: "#",
                label: "创建规则",
                children: [],
                disabled: false
              });
              return result;
            })
          }
        });
        computed(() => {
          let result = data.ruleList.map((rule) => {
            return {
              id: rule.id,
              label: rule.main.name || "未命名规则",
              iconUrl: rule.main.iconUrl,
              children: [],
              disabled: false,
              isNew: rule.status.isNewCreated
            };
          });
          result.push({
            id: "#",
            label: "创建规则",
            children: [],
            disabled: false
          });
          return result;
        });
        const data = reactive({
          ruleList: []
          //* 规则列表
        });
        const getLocationRule = async () => {
          let localRuleList = _GM_getValue("ruleList");
          if (localRuleList != null) {
            data.ruleList = JSON.parse(localRuleList).map((rawRule) => {
              return new MatchRule(rawRule);
            });
            console.log("数据已导入", data);
          } else {
            data.ruleList = [];
            console.log("本地数据为空 -> 初始化数据", data);
          }
        };
        const saveRuleToLocation = async () => {
          const list = data.ruleList.map((rule) => rule.getJsonData());
          const jsonData = `[${list.join(",")}]`;
          console.log("保存数据", jsonData);
          _GM_setValue("ruleList", jsonData);
          ElMessage({
            type: "success",
            grouping: true,
            center: true,
            offset: 120,
            duration: 1e3,
            message: `保存成功!`
          });
        };
        const createRule = async () => {
          let rule = new MatchRule();
          data.ruleList.push(rule);
          rule.main.domainName = location.origin;
          rule.main.iconUrl = await getFavicon();
          console.log("规则创建", rule);
          return rule;
        };
        const deleteRule = async (id2) => {
          const index = data.ruleList.findIndex((item) => item.id === id2);
          const target = data.ruleList.splice(index, 1);
          console.log("移除规则", target);
          MatchRule.count--;
        };
        //! 默认规则
        const defaultRule = reactive({
          id: "#",
          main: {
            name: "(内置)默认规则",
            domainName: "",
            pathFilter: { pattern: "", flags: [] },
            titleSelector: "",
            iconUrl: ""
          },
          domItem: { enable: false, method: 0, selector: ["", "", "", ""] },
          linkUrl: {
            method: 0,
            selector: [
              'meta[property="og:image"]',
              "img[data-src]",
              "img[src]",
              "[srcset]"
            ],
            infoType: 2,
            attribute: [
              "content",
              "srcset|data-src|src",
              "srcset|data-src|src",
              "srcset|data-src|src"
            ]
          },
          picUrl: {
            enable: false,
            origin: 0,
            method: 0,
            selector: ["", "", "", ""],
            infoType: 3,
            attribute: ["", "", "", ""]
          },
          name: {
            enable: false,
            origin: 0,
            method: 0,
            selector: ["", "", "", ""],
            infoType: 4,
            attribute: ["", "", "", ""]
          },
          meta: {
            enable: true,
            origin: 2,
            method: 0,
            selector: ["", "", "", ""],
            infoType: 0,
            attribute: ["", "", "", ""],
            getMethod: 0
          }
        });
        return {
          container,
          info,
          data,
          defaultRule,
          getLocationRule,
          saveRuleToLocation,
          createRule,
          deleteRule
        };
      });
      defineStore("list", () => {
        const info = reactive({
          nowColumn: 3,
          allSelected: false
        });
        return { info };
      });
      const _hoisted_1$h = { class: "onlineGallery-RuleEditor-modal" };
      const _hoisted_2$f = /* @__PURE__ */ createBaseVNode("span", { style: { "color": "black", "font-size": "large" } }, "规则管理器", -1);
      const _hoisted_3$e = { style: { "color": "black", "font-size": "large" } };
      const _hoisted_4$3 = {
        key: 0,
        class: "tree-item tree-item-normal"
      };
      const _hoisted_5$1 = { class: "label-ruleName" };
      const _hoisted_6$1 = { class: "icon-button-deleteRule" };
      const _hoisted_7$1 = {
        key: 1,
        class: "tree-item tree-item-add-button"
      };
      const _sfc_main$6 = /* @__PURE__ */ defineComponent({
        __name: "RuleEditor",
        setup(__props) {
          const { text, isSupported, copy } = useClipboard();
          const appInfo = useAppInfoStore();
          const ruleEditor = useRuleEditorStore();
          const treeRef = ref();
          const info = ruleEditor.info;
          const form = ruleEditor.info.form;
          const tree = ruleEditor.info.tree;
          const data = ruleEditor.data;
          const inputFormData = async (ruleData) => {
            if (ruleData != void 0) {
              if (!ruleData.status.editing && !ruleData.status.isNewCreated) {
                ruleData.createBackup();
                ruleData.status.editing = true;
              }
              ruleData.status.isNewCreated = false;
              form.realTimeData = ruleData;
              info.showRuleId = ruleData.id;
              form.activeName = "main";
            } else {
              form.realTimeData = void 0;
              info.showRuleId = "-1";
            }
          };
          const onQueryChanged = (query) => {
            treeRef.value.filter(query);
          };
          const treeFilterMethod = (query, node) => {
            return node.label.includes(query);
          };
          const treeNodeClick = (nodeData, node, e2) => {
            const ruleIndex = data.ruleList.findIndex(
              (item) => item.id === nodeData.id
            );
            if (ruleIndex >= 0) {
              const rule = data.ruleList[ruleIndex];
              inputFormData(rule);
            }
          };
          const createRule = async () => {
            const rule = await ruleEditor.createRule();
            inputFormData(rule);
          };
          const deleteRule = async (id2, node) => {
            const ruleName = node.label;
            ElMessageBox.confirm(`确认删除规则 “${ruleName}” ？`, "提示", {
              confirmButtonText: "确认",
              cancelButtonText: "取消",
              lockScroll: false
            }).then(() => {
              ruleEditor.deleteRule(id2);
              inputFormData();
              ElMessage({
                type: "success",
                grouping: true,
                center: true,
                offset: 120,
                message: `规则 “${ruleName}” 删除成功!`
              });
            }).catch(() => {
            });
          };
          const copyNowRule = async () => {
            var _a2, _b;
            const content = (_a2 = form.realTimeData) == null ? void 0 : _a2.getJsonData();
            await copy(content);
            ElMessage({
              type: "success",
              // showClose: true,
              grouping: true,
              center: true,
              duration: 1e3,
              offset: 120,
              message: h$1("p", { style: "display:flex;gap:10px" }, [
                h$1("i", { style: "color: teal" }, "(规则)" + ((_b = form.realTimeData) == null ? void 0 : _b.main.name)),
                h$1("span", { style: "color: black" }, "复制成功！")
              ])
            });
          };
          const handleOpen = () => {
            initDialog();
            console.log("规则管理器 - Open");
          };
          const handleClose = async () => {
            ElMessageBox.confirm("确认关闭？", "提示", {
              confirmButtonText: "确认",
              cancelButtonText: "取消",
              lockScroll: false
            }).then(() => {
              ruleEditor.container.open = false;
              //! 关闭窗口
            }).catch(() => {
            });
          };
          const handleClosed = async () => {
            initDialog();
            console.log("规则管理器 - Close");
          };
          const initDialog = async () => {
            form.activeName = "main";
            inputFormData();
          };
          const allSave = async () => {
            await ruleEditor.saveRuleToLocation();
            ruleEditor.container.open = false;
            //! 关闭窗口
          };
          return (_ctx, _cache) => {
            const _component_el_input = ElInput;
            const _component_el_image = ElImage;
            const _component_el_tooltip = ElTooltip;
            const _component_HoverButton = __unplugin_components_3;
            const _component_i_ep_CirclePlusFilled = __unplugin_components_4$1;
            const _component_el_icon = ElIcon;
            const _component_el_button = ElButton;
            const _component_el_tree_v2 = ElTreeV2;
            const _component_el_aside = ElAside;
            const _component_RuleForm = __unplugin_components_9;
            const _component_el_main = ElMain;
            const _component_el_container = ElContainer;
            const _component_el_dialog = ElDialog;
            return openBlock(), createElementBlock("div", _hoisted_1$h, [
              createVNode(_component_el_dialog, {
                style: { "pointer-events": "auto !important", "padding": "0px" },
                modelValue: unref(ruleEditor).container.open,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(ruleEditor).container.open = $event),
                width: unref(appInfo).window.width > 800 ? "800px" : "100%",
                "before-close": handleClose,
                modal: false,
                "close-on-click-modal": false,
                "lock-scroll": false,
                "destroy-on-close": "",
                draggable: "",
                onOpen: handleOpen,
                onClosed: handleClosed
              }, {
                header: withCtx(() => [
                  _hoisted_2$f,
                  createBaseVNode("span", _hoisted_3$e, " (共" + toDisplayString(unref(ruleEditor).data.ruleList.length) + "条规则) ", 1)
                ]),
                default: withCtx(() => [
                  createVNode(_component_el_container, { style: { "user-select": "none" } }, {
                    default: withCtx(() => [
                      createVNode(_component_el_aside, {
                        width: "200px",
                        "show-checkbox": "",
                        "highlight-current": "",
                        style: { "padding": "5px" }
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_input, {
                            clearable: "",
                            modelValue: unref(tree).query,
                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(tree).query = $event),
                            placeholder: "输入关键词",
                            onInput: onQueryChanged
                          }, null, 8, ["modelValue"]),
                          createVNode(_component_el_tree_v2, {
                            ref_key: "treeRef",
                            ref: treeRef,
                            data: unref(tree).treeData,
                            props: unref(tree).treeProps,
                            height: 400,
                            "highlight-current": "",
                            "current-node-key": unref(info).showRuleId,
                            "filter-method": treeFilterMethod,
                            onNodeClick: treeNodeClick,
                            "item-size": 32
                          }, {
                            default: withCtx(({ node }) => [
                              node.key != "#" ? (openBlock(), createElementBlock("div", _hoisted_4$3, [
                                createVNode(_component_el_image, {
                                  style: { "width": "24px", "aspect-ratio": "1" },
                                  src: node.data.iconUrl
                                }, null, 8, ["src"]),
                                createVNode(_component_el_tooltip, {
                                  "show-after": 500,
                                  effect: "dark",
                                  content: node.label,
                                  placement: "top"
                                }, {
                                  default: withCtx(() => [
                                    createBaseVNode("span", _hoisted_5$1, toDisplayString(node.label), 1)
                                  ]),
                                  _: 2
                                }, 1032, ["content"]),
                                createBaseVNode("span", _hoisted_6$1, [
                                  createVNode(_component_HoverButton, {
                                    onClick: withModifiers(($event) => deleteRule(node.key, node), ["stop"])
                                  }, null, 8, ["onClick"])
                                ])
                              ])) : createCommentVNode("", true),
                              node.key == "#" ? (openBlock(), createElementBlock("div", _hoisted_7$1, [
                                createVNode(_component_el_button, {
                                  type: "primary",
                                  onClick: createRule
                                }, {
                                  icon: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  default: withCtx(() => [
                                    createBaseVNode("span", null, toDisplayString(node.label), 1)
                                  ]),
                                  _: 2
                                }, 1024)
                              ])) : createCommentVNode("", true)
                            ]),
                            _: 1
                          }, 8, ["data", "props", "current-node-key"])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_main, { style: { "padding": "5px" } }, {
                        default: withCtx(() => [
                          createVNode(_component_RuleForm, {
                            formData: unref(form).realTimeData
                          }, null, 8, ["formData"])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                footer: withCtx(() => [
                  createVNode(_component_el_button, {
                    type: "info",
                    onClick: copyNowRule
                  }, {
                    default: withCtx(() => [
                      createTextVNode("复制当前规则")
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: allSave
                  }, {
                    default: withCtx(() => [
                      createTextVNode("全部保存")
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_button, { onClick: handleClose }, {
                    default: withCtx(() => [
                      createTextVNode("取消")
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["modelValue", "width"])
            ]);
          };
        }
      });
      const _hoisted_1$g = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$e = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M764.416 254.72a351.68 351.68 0 0 1 86.336 149.184H960v192.064H850.752a351.68 351.68 0 0 1-86.336 149.312l54.72 94.72l-166.272 96l-54.592-94.72a352.64 352.64 0 0 1-172.48 0L371.136 936l-166.272-96l54.72-94.72a351.68 351.68 0 0 1-86.336-149.312H64v-192h109.248a351.68 351.68 0 0 1 86.336-149.312L204.8 160l166.208-96h.192l54.656 94.592a352.64 352.64 0 0 1 172.48 0L652.8 64h.128L819.2 160l-54.72 94.72zM704 499.968a192 192 0 1 0-384 0a192 192 0 0 0 384 0z"
      }, null, -1);
      const _hoisted_3$d = [
        _hoisted_2$e
      ];
      function render$b(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$g, _hoisted_3$d);
      }
      const __unplugin_components_8$1 = { name: "ep-tools", render: render$b };
      const _hoisted_1$f = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$d = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M576 128v288l96-96l96 96V128h128v768H320V128h256zm-448 0h128v768H128V128z"
      }, null, -1);
      const _hoisted_3$c = [
        _hoisted_2$d
      ];
      function render$a(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$f, _hoisted_3$c);
      }
      const __unplugin_components_7$1 = { name: "ep-management", render: render$a };
      const _hoisted_1$e = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$c = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M640 384v256H384V384h256zm64 0h192v256H704V384zm-64 512H384V704h256v192zm64 0V704h192v192H704zm-64-768v192H384V128h256zm64 0h192v192H704V128zM320 384v256H128V384h192zm0 512H128V704h192v192zm0-768v192H128V128h192z"
      }, null, -1);
      const _hoisted_3$b = [
        _hoisted_2$c
      ];
      function render$9(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$e, _hoisted_3$b);
      }
      const __unplugin_components_5$1 = { name: "ep-grid", render: render$9 };
      const _hoisted_1$d = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$b = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M338.752 104.704a64 64 0 0 0 0 90.496l316.8 316.8l-316.8 316.8a64 64 0 0 0 90.496 90.496l362.048-362.048a64 64 0 0 0 0-90.496L429.248 104.704a64 64 0 0 0-90.496 0z"
      }, null, -1);
      const _hoisted_3$a = [
        _hoisted_2$b
      ];
      function render$8(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$d, _hoisted_3$a);
      }
      const __unplugin_components_4 = { name: "ep-arrow-right-bold", render: render$8 };
      const _hoisted_1$c = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$a = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M764.288 214.592L512 466.88L259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512L214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
      }, null, -1);
      const _hoisted_3$9 = [
        _hoisted_2$a
      ];
      function render$7(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$c, _hoisted_3$9);
      }
      const __unplugin_components_1$2 = { name: "ep-close", render: render$7 };
      const _hoisted_1$b = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$9 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 320L192 704h639.936z"
      }, null, -1);
      const _hoisted_3$8 = [
        _hoisted_2$9
      ];
      function render$6(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$b, _hoisted_3$8);
      }
      const __unplugin_components_1$1 = { name: "ep-caret-top", render: render$6 };
      const _hoisted_1$a = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$8 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 928c23.936 0 117.504-68.352 192.064-153.152C803.456 661.888 864 535.808 864 416c0-189.632-155.84-320-352-320S160 226.368 160 416c0 120.32 60.544 246.4 159.936 359.232C394.432 859.84 488 928 512 928zm0-435.2a64 64 0 1 0 0-128a64 64 0 0 0 0 128zm0 140.8a204.8 204.8 0 1 1 0-409.6a204.8 204.8 0 0 1 0 409.6z"
      }, null, -1);
      const _hoisted_3$7 = [
        _hoisted_2$8
      ];
      function render$5(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$a, _hoisted_3$7);
      }
      const __unplugin_components_7 = { name: "ep-location-filled", render: render$5 };
      const _hoisted_1$9 = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$7 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64zm384-253.696l236.288-236.352l45.248 45.248L508.8 704L192 387.2l45.248-45.248L480 584.704V128h64v450.304z"
      }, null, -1);
      const _hoisted_3$6 = [
        _hoisted_2$7
      ];
      function render$4(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$9, _hoisted_3$6);
      }
      const __unplugin_components_8 = { name: "ep-download", render: render$4 };
      const _hoisted_1$8 = ["parentSelector"];
      const _sfc_main$5 = {
        __name: "Img",
        props: {
          src: String,
          parentSelector: {
            type: String,
            default: "null"
          },
          margin: {
            type: String,
            default: "0%"
          }
        },
        setup(__props) {
          onMounted(() => {
            _t.bind('[data-fancybox="onlineGallery"]', {
              Thumbs: { type: "modern" },
              Toolbar: {
                display: {
                  left: ["infobar"],
                  middle: [
                    "zoomIn",
                    "zoomOut",
                    "toggle1to1",
                    "rotateCCW",
                    "rotateCW",
                    "flipX",
                    "flipY"
                  ],
                  right: ["slideshow", "thumbs", "close"]
                }
              }
            });
          });
          const vLazy = {
            mounted(el, binding, vNode) {
              el.dataset.show = false;
              let url = binding.value;
              let observer = new IntersectionObserver(
                (entries, observer2) => {
                  entries.forEach((entire) => {
                    if (entire.isIntersecting) {
                      observer2.unobserve(el);
                      el.src = url;
                      if (el.tagName == "IMG") {
                        if (el.complete) {
                          el.dataset.show = true;
                        } else {
                          let fn2 = function() {
                            el.dataset.show = true;
                            el.removeEventListener("load", fn2);
                            el.removeEventListener("error", fn2);
                          };
                          el.addEventListener("load", fn2);
                          el.addEventListener("error", fn2);
                        }
                      } else {
                        el.dataset.show = true;
                      }
                    }
                  });
                },
                {
                  root: document.querySelector(vNode.props.parentSelector),
                  rootMargin: vNode.props.margin
                }
              );
              observer.observe(el);
            }
          };
          return (_ctx, _cache) => {
            return withDirectives((openBlock(), createElementBlock("img", {
              parentSelector: __props.parentSelector,
              "data-fancybox": "gallery"
            }, null, 8, _hoisted_1$8)), [
              [vLazy, __props.src]
            ]);
          };
        }
      };
      const __unplugin_components_0$2 = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-b78ae3cf"]]);
      const _hoisted_1$7 = ["id", "data-fancybox-index"];
      const _hoisted_2$6 = { class: "tag-group" };
      const _hoisted_3$5 = { class: "button-group" };
      const _sfc_main$4 = /* @__PURE__ */ defineComponent({
        __name: "Card",
        props: {
          card: { default: () => {
            return {
              name: "",
              linkUrl: "",
              picUrl: "",
              originUrls: [],
              metaOrigin: "",
              meta: {
                width: 0,
                height: 0,
                aspectRatio: 3 / 4
              },
              picBlob: new Blob([], { type: "none" }),
              linkBlob: new Blob([], { type: "none" }),
              nameBlob: new Blob([], { type: "none" }),
              selected: false,
              //? 选中标识符
              dom: null
            };
          } },
          index: {}
        },
        setup(__props, { expose: __expose }) {
          const props = __props;
          const { text, isSupported, copy } = useClipboard();
          const cardsStore = useCardsStore();
          const cardDom = ref();
          const appInfo = useAppInfoStore();
          const downloading = ref(false);
          const copyTagContent = async (content) => {
            await copy(content);
            ElMessage({
              type: "success",
              // showClose: true,
              grouping: true,
              center: true,
              duration: 1e3,
              offset: 120,
              message: h$1("p", { style: "display:flex;gap:10px" }, [
                h$1("i", { style: "color: teal" }, content),
                h$1("span", { style: "color: black" }, "复制成功！")
              ])
            });
          };
          const clickHandle = async (e2) => {
            cardsStore.openFancyBox(props.index);
          };
          const download = async () => {
            const card = props.card;
            downloading.value = true;
            if (card.linkBlob) {
              let ext = getExtByBlob(card.linkBlob);
              let reg = new RegExp(`(\\.${ext})+$`);
              await saveAs(card.linkBlob, `${card.name.replace(reg, "")}.${ext}`);
              downloading.value = false;
            } else {
              const url = card.linkUrl;
              let tempBlob = await getBlobByUrlAuto(url);
              console.log(tempBlob);
              if (tempBlob && tempBlob.type !== "none") {
                card.linkBlob = tempBlob;
                await saveAs(card.linkBlob, card.name);
                downloading.value = false;
              } else {
                downloading.value = false;
              }
            }
          };
          const toPosition = async () => {
            const dom = props.card.dom;
            if (dom != null) {
              appInfo.container.open = !appInfo.container.open;
              dom.scrollIntoView({
                behavior: "smooth",
                block: "center",
                inline: "center"
              });
            }
          };
          __expose({
            cardDom
          });
          return (_ctx, _cache) => {
            const _component_Img = __unplugin_components_0$2;
            const _component_el_tag = ElTag;
            const _component_el_tooltip = ElTooltip;
            const _component_el_checkbox = ElCheckbox;
            const _component_i_ep_Download = __unplugin_components_8;
            const _component_el_icon = ElIcon;
            const _component_el_button = ElButton;
            const _component_i_ep_LocationFilled = __unplugin_components_7;
            return openBlock(), createElementBlock("div", {
              ref_key: "cardDom",
              ref: cardDom,
              class: "card",
              id: `id_${_ctx.card.id}`,
              "data-fancybox-trigger": "onlineGallery",
              "data-fancybox-index": _ctx.index,
              onContextmenu: _cache[4] || (_cache[4] = withModifiers(() => {
              }, ["prevent", "self"]))
            }, [
              createVNode(_component_Img, {
                class: "content",
                "data-fancybox": "onlineGallery",
                src: _ctx.card.picUrl,
                onClick: clickHandle
              }, null, 8, ["src"]),
              createBaseVNode("div", _hoisted_2$6, [
                _ctx.card.linkBlob ? (openBlock(), createBlock(_component_el_tooltip, {
                  key: 0,
                  effect: "dark",
                  content: (_ctx.card.linkBlob.size / 1024 / 1024).toFixed(2) + "Mb",
                  placement: "top"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_tag, {
                      class: "el-tag",
                      round: "",
                      size: "small",
                      onContextmenu: _cache[0] || (_cache[0] = withModifiers(($event) => copyTagContent((_ctx.card.linkBlob.size / 1024 / 1024).toFixed(2) + "Mb"), ["right"]))
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString((_ctx.card.linkBlob.size / 1024 / 1024).toFixed(2) + "Mb"), 1)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["content"])) : createCommentVNode("", true),
                createVNode(_component_el_tooltip, {
                  effect: "dark",
                  content: `${_ctx.card.meta.width}x${_ctx.card.meta.height}`,
                  placement: "top"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_tag, {
                      class: "el-tag",
                      size: "small",
                      type: "info",
                      onContextmenu: _cache[1] || (_cache[1] = withModifiers(($event) => copyTagContent(_ctx.card.meta.width + "x" + _ctx.card.meta.height), ["right"])),
                      round: ""
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.card.meta.width) + "x" + toDisplayString(_ctx.card.meta.height), 1)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["content"]),
                createVNode(_component_el_tooltip, {
                  effect: "dark",
                  content: _ctx.card.name,
                  placement: "top"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_tag, {
                      class: "el-tag",
                      round: "",
                      size: "small",
                      onContextmenu: _cache[2] || (_cache[2] = withModifiers(($event) => copyTagContent(_ctx.card.name), ["right"]))
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.card.name), 1)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["content"])
              ]),
              createVNode(_component_el_checkbox, {
                modelValue: _ctx.card.selected,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.card.selected = $event),
                class: "checkbox"
              }, null, 8, ["modelValue"]),
              createBaseVNode("div", _hoisted_3$5, [
                createVNode(_component_el_button, {
                  class: "button download",
                  type: "primary",
                  circle: "",
                  onClick: withModifiers(download, ["stop"]),
                  loading: unref(downloading)
                }, {
                  icon: withCtx(() => [
                    createVNode(_component_el_icon, null, {
                      default: withCtx(() => [
                        createVNode(_component_i_ep_Download)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["onClick", "loading"]),
                createVNode(_component_el_button, {
                  class: "button toPosition",
                  type: "primary",
                  circle: "",
                  onClick: withModifiers(toPosition, ["stop"]),
                  loading: unref(downloading)
                }, {
                  icon: withCtx(() => [
                    createVNode(_component_el_icon, null, {
                      default: withCtx(() => [
                        createVNode(_component_i_ep_LocationFilled)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["onClick", "loading"])
              ])
            ], 40, _hoisted_1$7);
          };
        }
      });
      const __unplugin_components_0$1 = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-fbee18ec"]]);
      const _sfc_main$3 = /* @__PURE__ */ defineComponent({
        __name: "List",
        setup(__props) {
          const listContainer = ref();
          const listBody = ref();
          const scrollbarRef = ref();
          ref();
          const cardsStore = useCardsStore();
          const toolBar = useToolBarStore();
          const listControl = toolBar.listControl;
          const getStyle2 = computed(() => {
            if (listContainer.value == null) {
              return;
            }
            const containerInfo = listContainer.value.getBoundingClientRect();
            let style = {
              "--nowColumn": listControl.showColumn,
              "--listHeight": containerInfo.height - 8 * listControl.showColumn - 10 + "px",
              "--cardMaxHeight": `calc(var(--listHeight) / var(--nowColumn))`
            };
            if (listControl.showColumn <= 0) {
              style["--cardMaxHeight"] = "1000%";
            }
            return style;
          });
          const backTop = ref();
          const backTopShow = ref(false);
          const handleScroll = (scrollEvent) => {
            if (scrollEvent.scrollTop > 150) {
              backTopShow.value = true;
            } else {
              backTopShow.value = false;
            }
          };
          const backToTop = () => {
            scrollbarRef.value.setScrollTop(0);
          };
          return (_ctx, _cache) => {
            const _component_Card = __unplugin_components_0$1;
            const _component_i_ep_CaretTop = __unplugin_components_1$1;
            const _component_el_icon = ElIcon;
            const _component_el_scrollbar = ElScrollbar;
            return openBlock(), createElementBlock("div", {
              ref_key: "listContainer",
              ref: listContainer
            }, [
              createVNode(_component_el_scrollbar, {
                ref_key: "scrollbarRef",
                ref: scrollbarRef,
                onScroll: handleScroll
              }, {
                default: withCtx(() => [
                  createVNode(TransitionGroup, {
                    id: "onlineGallery-listBody",
                    class: "onlineGallery-listBody",
                    ref_key: "listBody",
                    ref: listBody,
                    style: normalizeStyle(unref(getStyle2)),
                    name: "list",
                    tag: "div"
                  }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(cardsStore).filterCards, (card, index) => {
                        return openBlock(), createBlock(_component_Card, {
                          card,
                          key: card.id,
                          index,
                          "data-index": index,
                          style: normalizeStyle({
                            "--aspect-ratio": card.meta.aspectRatio
                          })
                        }, null, 8, ["card", "index", "data-index", "style"]);
                      }), 128))
                    ]),
                    _: 1
                  }, 8, ["style"]),
                  createVNode(Transition, { name: "backTop" }, {
                    default: withCtx(() => [
                      withDirectives(createBaseVNode("div", {
                        ref_key: "backTop",
                        ref: backTop,
                        class: "onlineGallery-backTop",
                        onClick: backToTop
                      }, [
                        createVNode(_component_el_icon, null, {
                          default: withCtx(() => [
                            createVNode(_component_i_ep_CaretTop)
                          ]),
                          _: 1
                        })
                      ], 512), [
                        [vShow, unref(backTopShow)]
                      ])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 512)
            ], 512);
          };
        }
      });
      const __unplugin_components_2 = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-f25bdb68"]]);
      const _hoisted_1$6 = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$5 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M176 416a112 112 0 1 1 0 224a112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224a112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224a112 112 0 0 1 0-224z"
      }, null, -1);
      const _hoisted_3$4 = [
        _hoisted_2$5
      ];
      function render$3(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$6, _hoisted_3$4);
      }
      const __unplugin_components_10 = { name: "ep-more-filled", render: render$3 };
      const _hoisted_1$5 = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$4 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384a384 384 0 0 1-384-384a384 384 0 0 1 643.712-282.88z"
      }, null, -1);
      const _hoisted_3$3 = [
        _hoisted_2$4
      ];
      function render$2(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$5, _hoisted_3$3);
      }
      const __unplugin_components_5 = { name: "ep-refresh-right", render: render$2 };
      const _hoisted_1$4 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24"
      };
      const _hoisted_2$3 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "none",
        d: "M0 0h24v24H0z"
      }, null, -1);
      const _hoisted_3$2 = /* @__PURE__ */ createBaseVNode("path", { d: "M4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm1 2v14h14V5H5z" }, null, -1);
      const _hoisted_4$2 = [
        _hoisted_2$3,
        _hoisted_3$2
      ];
      function render$1(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$4, _hoisted_4$2);
      }
      const CheckboxNone = { render: render$1 };
      const _hoisted_1$3 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24"
      };
      const _hoisted_2$2 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "none",
        d: "M0 0h24v24H0z"
      }, null, -1);
      const _hoisted_3$1 = /* @__PURE__ */ createBaseVNode("path", { d: "M4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm7.003 13 7.07-7.071-1.414-1.414-5.656 5.657-2.829-2.829-1.414 1.414L11.003 16z" }, null, -1);
      const _hoisted_4$1 = [
        _hoisted_2$2,
        _hoisted_3$1
      ];
      function render(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$3, _hoisted_4$1);
      }
      const CheckboxAll = { render };
      const _withScopeId = (n2) => (pushScopeId("data-v-ec01773c"), n2 = n2(), popScopeId(), n2);
      const _hoisted_1$2 = { class: "onlineGallery-toolBar" };
      const _hoisted_2$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { style: { "display": "flex", "justify-content": "center" } }, " 选中 / 可见 / 总数 ", -1));
      const _hoisted_3 = { class: "filter" };
      const _hoisted_4 = { class: "size" };
      const _hoisted_5 = { class: "width row" };
      const _hoisted_6 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "label" }, "宽度", -1));
      const _hoisted_7 = { class: "height row" };
      const _hoisted_8 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "label" }, "高度", -1));
      const _hoisted_9 = { class: "format" };
      const _hoisted_10 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "label" }, "格式", -1));
      const _hoisted_11 = { class: "list-control" };
      const _hoisted_12 = { class: "zoom-slider" };
      const _hoisted_13 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "label" }, "行数", -1));
      const _hoisted_14 = { class: "sort-method" };
      const _hoisted_15 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "label" }, "排序", -1));
      const _hoisted_16 = { class: "ruleSelector" };
      const _hoisted_17 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "label" }, "预设", -1));
      const _hoisted_18 = { class: "rule-item" };
      const _sfc_main$2 = /* @__PURE__ */ defineComponent({
        __name: "Toolbar",
        setup(__props) {
          const appInfo = useAppInfoStore();
          const cardsStore = useCardsStore();
          const toolbar = useToolBarStore();
          const ruleEditor = useRuleEditorStore();
          const loading = appInfo.loading;
          const filter = toolbar.filter;
          const listControl = toolbar.listControl;
          const ruleSelector = toolbar.ruleSelector;
          const refresh = async () => {
            if (ruleSelector.value === "#") {
              await cardsStore.getCard(ruleEditor.defaultRule);
            } else {
              const ruleIndex = ruleEditor.data.ruleList.findIndex(
                (rule2) => rule2.id === ruleSelector.value
              );
              const rule = ruleEditor.data.ruleList[ruleIndex];
              if (rule) {
                await cardsStore.getCard(rule);
              } else {
                ElMessage({
                  message: "请选择预设后再尝试此操作",
                  type: "info",
                  showClose: true,
                  grouping: true,
                  offset: 120
                });
              }
            }
          };
          const allSelectSwitch = async () => {
            toolbar.listControl.allSelected = !toolbar.listControl.allSelected;
            appInfo.loading.value = true;
            cardsStore.filterCards.forEach(
              (card) => card.selected = toolbar.listControl.allSelected
            );
            appInfo.loading.value = false;
          };
          const downloadSelected = async () => {
            const downloadCards = cardsStore.selectedCards;
            if (!downloadCards.length) {
              ElMessage({
                message: "请选择要下载的数据",
                type: "info",
                showClose: true,
                grouping: true,
                offset: 120
              });
              return;
            }
            const taskQueue = new TaskQueue({ showMessage: false, max: 5 });
            loading.init();
            let finallyCount = 0;
            for (let index = 0; index < downloadCards.length; index++) {
            }
            const taskList = downloadCards.map((card, index) => {
              return {
                index,
                //* 主要执行函数
                main: async () => {
                  if (!card.linkBlob) {
                    const url = card.linkUrl;
                    card.linkBlob = await getBlobByUrlAuto(url);
                    if (card.linkBlob && card.linkBlob["type"] !== "none") {
                      return [card.name, "处理成功!"];
                    } else {
                      return [card.name, "处理失败"];
                    }
                  } else {
                    return [card.name, "处理成功!"];
                  }
                },
                //* 单次执行完成后的回调
                callback: (res, index2) => {
                  finallyCount++;
                  loading.percentage = finallyCount / downloadCards.length * 100;
                }
              };
            });
            taskQueue.pushTask(taskList);
            taskQueue.finallyCallback = async () => {
              ElMessage({
                message: "下载成功! (正在生成压缩包)",
                type: "success",
                showClose: true,
                grouping: true,
                offset: 120
              });
              const zipContainer = new JSZip();
              for (let index = 0; index < downloadCards.length; index++) {
                const card = downloadCards[index];
                if (card.name && card.linkBlob) {
                  let ext = getExtByBlob(card.linkBlob);
                  let reg = new RegExp(`(\\.${ext})+$`);
                  let fix = strAutofill(index.toString(), 0, 4);
                  zipContainer.file(
                    `${fix} - ${card.name.replace(reg, "")}.${ext}`,
                    card.linkBlob
                  );
                }
              }
              const zip = await zipContainer.generateAsync({
                type: "blob",
                compression: "DEFLATE",
                level: 9
              });
              let zipName = document.querySelector("title").innerText;
              saveAs(zip, `${zipName}.zip`);
              loading.percentage = 100;
              loading.reset();
            };
            taskQueue.run();
          };
          return (_ctx, _cache) => {
            const _component_el_statistic = ElStatistic;
            const _component_el_slider = ElSlider;
            const _component_el_select_v2 = ElSelectV2;
            const _component_el_input_number = ElInputNumber;
            const _component_el_image = ElImage;
            const _component_i_ep_RefreshRight = __unplugin_components_5;
            const _component_el_icon = ElIcon;
            const _component_el_button = ElButton;
            const _component_i_ep_Download = __unplugin_components_8;
            const _component_el_button_group = ElButtonGroup$1;
            const _component_i_ep_MoreFilled = __unplugin_components_10;
            const _component_i_ep_Management = __unplugin_components_7$1;
            const _component_el_dropdown_item = ElDropdownItem;
            const _component_i_ep_Tools = __unplugin_components_8$1;
            const _component_el_dropdown_menu = ElDropdownMenu;
            const _component_el_dropdown = ElDropdown;
            return openBlock(), createElementBlock("div", _hoisted_1$2, [
              createVNode(_component_el_statistic, {
                class: "statistic",
                value: unref(cardsStore).filterCards.length,
                prefix: unref(cardsStore).selectedCards.length.toString() + " /",
                suffix: "/ " + unref(cardsStore).allValidCards.length.toString()
              }, {
                title: withCtx(() => [
                  _hoisted_2$1
                ]),
                _: 1
              }, 8, ["value", "prefix", "suffix"]),
              createBaseVNode("div", _hoisted_3, [
                createBaseVNode("div", _hoisted_4, [
                  createBaseVNode("div", _hoisted_5, [
                    _hoisted_6,
                    createVNode(_component_el_slider, {
                      debounce: 500,
                      class: "slider",
                      label: "宽度",
                      modelValue: unref(filter).size.width.value,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(filter).size.width.value = $event),
                      range: "",
                      min: 0,
                      max: unref(filter).size.width.max,
                      placement: "right"
                    }, null, 8, ["modelValue", "max"])
                  ]),
                  createBaseVNode("div", _hoisted_7, [
                    _hoisted_8,
                    createVNode(_component_el_slider, {
                      debounce: 500,
                      class: "slider",
                      label: "高度",
                      modelValue: unref(filter).size.height.value,
                      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(filter).size.height.value = $event),
                      range: "",
                      min: 0,
                      max: unref(filter).size.height.max,
                      placement: "right"
                    }, null, 8, ["modelValue", "max"])
                  ])
                ]),
                createBaseVNode("div", _hoisted_9, [
                  _hoisted_10,
                  createVNode(_component_el_select_v2, {
                    class: "select",
                    modelValue: unref(filter).formats.value,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(filter).formats.value = $event),
                    filterable: "",
                    clearable: "",
                    "allow-create": "",
                    "collapse-tags": "",
                    "collapse-tags-tooltip": "",
                    "max-collapse-tags": 1,
                    options: unref(filter).formats.options,
                    placeholder: "格式过滤",
                    multiple: ""
                  }, null, 8, ["modelValue", "options"])
                ])
              ]),
              createBaseVNode("div", _hoisted_11, [
                createBaseVNode("div", _hoisted_12, [
                  _hoisted_13,
                  createVNode(_component_el_input_number, {
                    class: "input-number",
                    min: 1,
                    max: 6,
                    step: 1,
                    "step-strictly": "",
                    "controls-position": "right",
                    onWheel: _cache[3] || (_cache[3] = (e2) => {
                      if (e2.deltaY < 0) {
                        if (unref(toolbar).listControl.showColumn < 6)
                          unref(toolbar).listControl.showColumn++;
                      } else {
                        if (unref(toolbar).listControl.showColumn > 1)
                          unref(toolbar).listControl.showColumn--;
                      }
                    }),
                    modelValue: unref(toolbar).listControl.showColumn,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(toolbar).listControl.showColumn = $event)
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_14, [
                  _hoisted_15,
                  createVNode(_component_el_select_v2, {
                    class: "select",
                    modelValue: unref(listControl).sortMethod.value,
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => unref(listControl).sortMethod.value = $event),
                    options: unref(listControl).sortMethod.options,
                    placeholder: "排序方法"
                  }, null, 8, ["modelValue", "options"])
                ])
              ]),
              createBaseVNode("div", _hoisted_16, [
                _hoisted_17,
                createVNode(_component_el_select_v2, {
                  class: "select",
                  modelValue: unref(ruleSelector).value,
                  "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(ruleSelector).value = $event),
                  filterable: "",
                  options: unref(ruleSelector).option,
                  placeholder: "选择当前预设"
                }, {
                  empty: withCtx(() => [
                    createTextVNode(" 11 ")
                  ]),
                  default: withCtx((node) => [
                    createBaseVNode("div", _hoisted_18, [
                      createVNode(_component_el_image, {
                        class: "rule-icon",
                        src: node.item.iconUrl
                      }, null, 8, ["src"]),
                      createTextVNode(" " + toDisplayString(node.item.label), 1)
                    ])
                  ]),
                  _: 1
                }, 8, ["modelValue", "options"])
              ]),
              createVNode(_component_el_button_group, { class: "button-group" }, {
                default: withCtx(() => [
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: refresh,
                    loading: unref(loading).value
                  }, {
                    icon: withCtx(() => [
                      createVNode(_component_el_icon, null, {
                        default: withCtx(() => [
                          createVNode(_component_i_ep_RefreshRight)
                        ]),
                        _: 1
                      })
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" 刷新 ")
                    ]),
                    _: 1
                  }, 8, ["loading"]),
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: allSelectSwitch,
                    loading: unref(loading).value,
                    icon: unref(toolbar).listControl.allSelected ? unref(CheckboxAll) : unref(CheckboxNone)
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(unref(toolbar).listControl.allSelected ? "全选" : "取消全选"), 1)
                    ]),
                    _: 1
                  }, 8, ["loading", "icon"]),
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: downloadSelected,
                    loading: unref(loading).value
                  }, {
                    icon: withCtx(() => [
                      createVNode(_component_el_icon, null, {
                        default: withCtx(() => [
                          createVNode(_component_i_ep_Download)
                        ]),
                        _: 1
                      })
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" 下载选中 ")
                    ]),
                    _: 1
                  }, 8, ["loading"])
                ]),
                _: 1
              }),
              createVNode(_component_el_dropdown, null, {
                dropdown: withCtx(() => [
                  createVNode(_component_el_dropdown_menu, null, {
                    default: withCtx(() => [
                      createVNode(_component_el_dropdown_item, {
                        onClick: _cache[7] || (_cache[7] = ($event) => unref(ruleEditor).container.open = true)
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_icon, null, {
                            default: withCtx(() => [
                              createVNode(_component_i_ep_Management)
                            ]),
                            _: 1
                          }),
                          createTextVNode(" 规则管理 ")
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_dropdown_item, {
                        onClick: _cache[8] || (_cache[8] = () => {
                        })
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_icon, null, {
                            default: withCtx(() => [
                              createVNode(_component_i_ep_Tools)
                            ]),
                            _: 1
                          }),
                          createTextVNode(" 设置 ")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                default: withCtx(() => [
                  createVNode(_component_el_button, { type: "primary" }, {
                    icon: withCtx(() => [
                      createVNode(_component_el_icon, null, {
                        default: withCtx(() => [
                          createVNode(_component_i_ep_MoreFilled)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]);
          };
        }
      });
      const __unplugin_components_1 = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-ec01773c"]]);
      const _hoisted_1$1 = {
        class: "onlineGallery-body",
        ref: "body"
      };
      const _sfc_main$1 = /* @__PURE__ */ defineComponent({
        __name: "Body",
        setup(__props) {
          const appInfo = useAppInfoStore();
          const cardsStore = useCardsStore();
          let toolbar = ref();
          cardsStore.data;
          const loading = appInfo.loading;
          return (_ctx, _cache) => {
            const _component_el_progress = ElProgress;
            const _component_Toolbar = __unplugin_components_1;
            const _component_List = __unplugin_components_2;
            return openBlock(), createElementBlock("div", _hoisted_1$1, [
              withDirectives(createVNode(_component_el_progress, {
                class: "loadingBar",
                percentage: Math.round(unref(loading).percentage),
                status: unref(loading).state,
                striped: "",
                "striped-flow": ""
              }, null, 8, ["percentage", "status"]), [
                [vShow, unref(loading).show]
              ]),
              createVNode(_component_Toolbar, {
                ref_key: "toolbar",
                ref: toolbar,
                class: "toolBar"
              }, null, 512),
              createVNode(_component_List, {
                ref: "list",
                class: "listContainer"
              }, null, 512)
            ], 512);
          };
        }
      });
      const __unplugin_components_0 = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-66e65ea2"]]);
      const _hoisted_1 = ["data-open"];
      const _hoisted_2 = { class: "onlineGallery-child-window-container" };
      const _sfc_main = /* @__PURE__ */ defineComponent({
        __name: "App",
        setup(__props) {
          const appInfo = useAppInfoStore();
          const cardsStore = useCardsStore();
          const toolBar = useToolBarStore();
          const ruleEditor = useRuleEditorStore();
          const container = ref();
          const openSwitch = async () => {
            appInfo.container.open = !appInfo.container.open;
            if (appInfo.container.open) {
              document.documentElement.dataset.showScrollbar = false.toString();
              container.value.focus();
            } else {
              document.documentElement.dataset.showScrollbar = true.toString();
            }
          };
          //! 挂载完成时执行
          onMounted(async () => {
            await ruleEditor.getLocationRule();
            toolBar.selectingInitRule();
            ElNotification({
              title: "提示",
              message: h$1("i", { style: "color: teal" }, "onlineGallery 已加载"),
              // type: "success",
              duration: 3e3
            });
            if (appInfo.container.open) {
              document.documentElement.dataset.showScrollbar = "false";
              container.value.focus();
            } else {
              document.documentElement.dataset.showScrollbar = "true";
            }
          });
          return (_ctx, _cache) => {
            const _component_Body = __unplugin_components_0;
            const _component_i_ep_Close = __unplugin_components_1$2;
            const _component_el_icon = ElIcon;
            const _component_el_button = ElButton;
            const _component_i_ep_ArrowRightBold = __unplugin_components_4;
            const _component_i_ep_Grid = __unplugin_components_5$1;
            const _component_el_badge = ElBadge;
            const _component_i_ep_Management = __unplugin_components_7$1;
            const _component_i_ep_Tools = __unplugin_components_8$1;
            const _component_el_popover = ElPopover;
            const _component_RuleEditor = _sfc_main$6;
            return openBlock(), createElementBlock(Fragment, null, [
              createBaseVNode("div", {
                class: "onlineGallery-container",
                ref_key: "container",
                ref: container,
                "data-open": unref(appInfo).container.open,
                style: normalizeStyle({
                  "--width": unref(appInfo).window.width * unref(appInfo).container.widthPercentage * 0.01 + "px"
                })
              }, [
                createVNode(_component_Body),
                createVNode(_component_el_button, {
                  class: "onlineGallery-button-close",
                  type: "danger",
                  circle: "",
                  onClick: openSwitch
                }, {
                  icon: withCtx(() => [
                    createVNode(_component_el_icon, null, {
                      default: withCtx(() => [
                        createVNode(_component_i_ep_Close)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(_component_el_popover, {
                  placement: "top-start",
                  title: "快捷菜单",
                  width: "auto",
                  trigger: "hover",
                  disabled: unref(appInfo).container.open
                }, {
                  reference: withCtx(() => [
                    createVNode(_component_el_button, {
                      type: "primary",
                      size: "default",
                      onClick: openSwitch,
                      class: "onlineGallery-button-drawerOpen"
                    }, {
                      icon: withCtx(() => [
                        createVNode(_component_el_icon, null, {
                          default: withCtx(() => [
                            createVNode(_component_i_ep_ArrowRightBold, { style: { "pointer-events": "none" } })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  default: withCtx(() => [
                    createVNode(_component_el_button, {
                      type: "success",
                      size: "small",
                      onClick: openSwitch
                    }, {
                      icon: withCtx(() => [
                        createVNode(_component_el_icon, null, {
                          default: withCtx(() => [
                            createVNode(_component_i_ep_Grid)
                          ]),
                          _: 1
                        })
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_el_badge, {
                          value: unref(cardsStore).data.cardList.length,
                          max: 999
                        }, {
                          default: withCtx(() => [
                            createTextVNode(" 图库 ")
                          ]),
                          _: 1
                        }, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_button, {
                      type: "primary",
                      size: "small",
                      onClick: _cache[0] || (_cache[0] = ($event) => unref(ruleEditor).container.open = true)
                    }, {
                      icon: withCtx(() => [
                        createVNode(_component_el_icon, null, {
                          default: withCtx(() => [
                            createVNode(_component_i_ep_Management)
                          ]),
                          _: 1
                        })
                      ]),
                      default: withCtx(() => [
                        createTextVNode(" 规则管理")
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_button, {
                      type: "primary",
                      size: "small",
                      onClick: _cache[1] || (_cache[1] = () => {
                      })
                    }, {
                      icon: withCtx(() => [
                        createVNode(_component_el_icon, null, {
                          default: withCtx(() => [
                            createVNode(_component_i_ep_Tools)
                          ]),
                          _: 1
                        })
                      ]),
                      default: withCtx(() => [
                        createTextVNode(" 设置 ")
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["disabled"])
              ], 12, _hoisted_1),
              createBaseVNode("div", _hoisted_2, [
                createVNode(_component_RuleEditor)
              ])
            ], 64);
          };
        }
      });
      const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-186e1ab4"]]);
      window["JSZip"] = JSZip$1;
      window["saveAs"] = FileSaver_minExports.saveAs;
      document.documentElement.dataset.showScrollbar = "true";
      const appDom = document.createElement("div");
      const id = `app_vue_${Date.now()}`;
      appDom.id = id;
      const pinia = createPinia();
      const app = createApp(App).use(pinia).use(vueTouchEvents);
      document.documentElement.append(appDom);
      app.mount(`#${id}`);
      console.log("挂载成功！", _unsafeWindow);
    }
  });
  require_main_001();

})(JSZip);
>>>>>>> e1776b9296c401005289b678bcce7538bf7e3213
