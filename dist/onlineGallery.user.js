// ==UserScript==
// @name       onlineGallery
// @namespace  npm/vite-plugin-monkey
// @version    1.0.0
// @author     Lxs
// @license    MIT
// @icon       https://vitejs.dev/logo.svg
// @match      *://www.pixiv.net/*
// @match      http*://*
// @match      http*://*/*
// @exclude    *://element-plus.org/*
// @require    https://cdn.bootcdn.net/ajax/libs/jszip/3.7.1/jszip.min.js
// @connect    *
// @grant      GM_getValue
// @grant      GM_setValue
// @grant      GM_xmlhttpRequest
// @grant      unsafeWindow
// @run-at     document-start
// @noframes
// ==/UserScript==

(o=>{const e=document.createElement("style");e.dataset.source="vite-plugin-monkey",e.textContent=o,document.head.append(e)})(` @charset "UTF-8";.el-popper,.el-message,.el-notification,.is-message-box{z-index:9147483647!important}:root[data-show-scrollbar=false]>::-webkit-scrollbar{width:0px!important;height:0px!important;transition:all .5s}:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","\u5FAE\u8F6F\u96C5\u9ED1",Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:.3s;--el-transition-duration-fast:.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(.645, .045, .355, 1);--el-transition-function-fast-bezier:cubic-bezier(.23, 1, .32, 1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px}:root{color-scheme:light;--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary:#409eff;--el-color-primary-light-3:#79bbff;--el-color-primary-light-5:#a0cfff;--el-color-primary-light-7:#c6e2ff;--el-color-primary-light-8:#d9ecff;--el-color-primary-light-9:#ecf5ff;--el-color-primary-dark-2:#337ecc;--el-color-success:#67c23a;--el-color-success-light-3:#95d475;--el-color-success-light-5:#b3e19d;--el-color-success-light-7:#d1edc4;--el-color-success-light-8:#e1f3d8;--el-color-success-light-9:#f0f9eb;--el-color-success-dark-2:#529b2e;--el-color-warning:#e6a23c;--el-color-warning-light-3:#eebe77;--el-color-warning-light-5:#f3d19e;--el-color-warning-light-7:#f8e3c5;--el-color-warning-light-8:#faecd8;--el-color-warning-light-9:#fdf6ec;--el-color-warning-dark-2:#b88230;--el-color-danger:#f56c6c;--el-color-danger-light-3:#f89898;--el-color-danger-light-5:#fab6b6;--el-color-danger-light-7:#fcd3d3;--el-color-danger-light-8:#fde2e2;--el-color-danger-light-9:#fef0f0;--el-color-danger-dark-2:#c45656;--el-color-error:#f56c6c;--el-color-error-light-3:#f89898;--el-color-error-light-5:#fab6b6;--el-color-error-light-7:#fcd3d3;--el-color-error-light-8:#fde2e2;--el-color-error-light-9:#fef0f0;--el-color-error-dark-2:#c45656;--el-color-info:#909399;--el-color-info-light-3:#b1b3b8;--el-color-info-light-5:#c8c9cc;--el-color-info-light-7:#dedfe0;--el-color-info-light-8:#e9e9eb;--el-color-info-light-9:#f4f4f5;--el-color-info-dark-2:#73767a;--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0, 0, 0, .04),0px 8px 20px rgba(0, 0, 0, .08);--el-box-shadow-light:0px 0px 12px rgba(0, 0, 0, .12);--el-box-shadow-lighter:0px 0px 6px rgba(0, 0, 0, .12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0, 0, 0, .08),0px 12px 32px rgba(0, 0, 0, .12),0px 8px 16px -8px rgba(0, 0, 0, .16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0, 0, 0, .8);--el-overlay-color-light:rgba(0, 0, 0, .7);--el-overlay-color-lighter:rgba(0, 0, 0, .5);--el-mask-color:rgba(255, 255, 255, .9);--el-mask-color-extra-light:rgba(255, 255, 255, .3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:20px;--el-dialog-border-radius:var(--el-border-radius-small);position:relative;margin:var(--el-dialog-margin-top,15vh) auto 50px;background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:0!important}.el-dialog.is-align-center{margin:auto}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;margin-bottom:0;height:100%;overflow:auto}.el-dialog__wrapper{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto;margin:0}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-dialog__header{padding:var(--el-dialog-padding-primary);padding-bottom:10px;margin-right:16px}.el-dialog__headerbtn{position:absolute;top:6px;right:0;padding:0;width:54px;height:54px;background:0 0;border:none;outline:0;cursor:pointer;font-size:var(--el-message-close-size,16px)}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{line-height:var(--el-dialog-font-line-height);font-size:var(--el-dialog-title-font-size);color:var(--el-text-color-primary)}.el-dialog__body{padding:calc(var(--el-dialog-padding-primary) + 10px) var(--el-dialog-padding-primary);color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size)}.el-dialog__footer{padding:var(--el-dialog-padding-primary);padding-top:10px;text-align:right;box-sizing:border-box}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial;padding:25px calc(var(--el-dialog-padding-primary) + 5px) 30px}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-overlay-dialog{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto}.dialog-fade-enter-active{-webkit-animation:modal-fade-in var(--el-transition-duration);animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{-webkit-animation:dialog-fade-in var(--el-transition-duration);animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{-webkit-animation:modal-fade-out var(--el-transition-duration);animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{-webkit-animation:dialog-fade-out var(--el-transition-duration);animation:dialog-fade-out var(--el-transition-duration)}@-webkit-keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@-webkit-keyframes dialog-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}@keyframes dialog-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}@-webkit-keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@-webkit-keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}@keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}.el-overlay{position:fixed;top:0;right:0;bottom:0;left:0;z-index:2000;height:100%;background-color:var(--el-overlay-color-lighter);overflow:auto}.el-overlay .el-overlay-root{height:0}.el-container{display:flex;flex-direction:row;flex:1;flex-basis:auto;box-sizing:border-box;min-width:0}.el-container.is-vertical{flex-direction:column}.el-aside{overflow:auto;box-sizing:border-box;flex-shrink:0;width:var(--el-aside-width,300px)}.el-footer{--el-footer-padding:0 20px;--el-footer-height:60px;padding:var(--el-footer-padding);box-sizing:border-box;flex-shrink:0;height:var(--el-footer-height)}.el-header{--el-header-padding:0 20px;--el-header-height:60px;padding:var(--el-header-padding);box-sizing:border-box;flex-shrink:0;height:var(--el-header-height)}.el-main{--el-main-padding:20px;display:block;flex:1;flex-basis:auto;overflow:auto;box-sizing:border-box;padding:var(--el-main-padding)}.el-tabs{--el-tabs-header-height:40px}.el-tabs__header{padding:0;position:relative;margin:0 0 15px}.el-tabs__active-bar{position:absolute;bottom:0;left:0;height:2px;background-color:var(--el-color-primary);z-index:1;transition:width var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),transform var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);list-style:none}.el-tabs__new-tab{display:flex;align-items:center;justify-content:center;float:right;border:1px solid var(--el-border-color);height:20px;width:20px;line-height:20px;margin:10px 0 10px 10px;border-radius:3px;text-align:center;font-size:12px;color:var(--el-text-color-primary);cursor:pointer;transition:all .15s}.el-tabs__new-tab .is-icon-plus{height:inherit;width:inherit;transform:scale(.8)}.el-tabs__new-tab .is-icon-plus svg{vertical-align:middle}.el-tabs__new-tab:hover{color:var(--el-color-primary)}.el-tabs__nav-wrap{overflow:hidden;margin-bottom:-1px;position:relative}.el-tabs__nav-wrap:after{content:"";position:absolute;left:0;bottom:0;width:100%;height:2px;background-color:var(--el-border-color-light);z-index:var(--el-index-normal)}.el-tabs__nav-wrap.is-scrollable{padding:0 20px;box-sizing:border-box}.el-tabs__nav-scroll{overflow:hidden}.el-tabs__nav-next,.el-tabs__nav-prev{position:absolute;cursor:pointer;line-height:44px;font-size:12px;color:var(--el-text-color-secondary);width:20px;text-align:center}.el-tabs__nav-next{right:0}.el-tabs__nav-prev{left:0}.el-tabs__nav{display:flex;white-space:nowrap;position:relative;transition:transform var(--el-transition-duration);float:left;z-index:calc(var(--el-index-normal) + 1)}.el-tabs__nav.is-stretch{min-width:100%;display:flex}.el-tabs__nav.is-stretch>*{flex:1;text-align:center}.el-tabs__item{padding:0 20px;height:var(--el-tabs-header-height);box-sizing:border-box;display:flex;align-items:center;justify-content:center;list-style:none;font-size:var(--el-font-size-base);font-weight:500;color:var(--el-text-color-primary);position:relative}.el-tabs__item:focus,.el-tabs__item:focus:active{outline:0}.el-tabs__item:focus-visible{box-shadow:0 0 2px 2px var(--el-color-primary) inset;border-radius:3px}.el-tabs__item .is-icon-close{border-radius:50%;text-align:center;transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);margin-left:5px}.el-tabs__item .is-icon-close:before{transform:scale(.9);display:inline-block}.el-tabs__item .is-icon-close:hover{background-color:var(--el-text-color-placeholder);color:#fff}.el-tabs__item.is-active{color:var(--el-color-primary)}.el-tabs__item:hover{color:var(--el-color-primary);cursor:pointer}.el-tabs__item.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-tabs__content{overflow:hidden;position:relative}.el-tabs--card>.el-tabs__header{border-bottom:1px solid var(--el-border-color-light);height:var(--el-tabs-header-height)}.el-tabs--card>.el-tabs__header .el-tabs__nav-wrap:after{content:none}.el-tabs--card>.el-tabs__header .el-tabs__nav{border:1px solid var(--el-border-color-light);border-bottom:none;border-radius:4px 4px 0 0;box-sizing:border-box}.el-tabs--card>.el-tabs__header .el-tabs__active-bar{display:none}.el-tabs--card>.el-tabs__header .el-tabs__item .is-icon-close{position:relative;font-size:12px;width:0;height:14px;overflow:hidden;right:-2px;transform-origin:100% 50%}.el-tabs--card>.el-tabs__header .el-tabs__item{border-bottom:1px solid transparent;border-left:1px solid var(--el-border-color-light);transition:color var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),padding var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs--card>.el-tabs__header .el-tabs__item:first-child{border-left:none}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover{padding-left:13px;padding-right:13px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover .is-icon-close{width:14px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active{border-bottom-color:var(--el-bg-color)}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable{padding-left:20px;padding-right:20px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable .is-icon-close{width:14px}.el-tabs--border-card{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color)}.el-tabs--border-card>.el-tabs__content{padding:15px}.el-tabs--border-card>.el-tabs__header{background-color:var(--el-fill-color-light);border-bottom:1px solid var(--el-border-color-light);margin:0}.el-tabs--border-card>.el-tabs__header .el-tabs__nav-wrap:after{content:none}.el-tabs--border-card>.el-tabs__header .el-tabs__item{transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);border:1px solid transparent;margin-top:-1px;color:var(--el-text-color-secondary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item:first-child{margin-left:-1px}.el-tabs--border-card>.el-tabs__header .el-tabs__item+.el-tabs__item{margin-left:-1px}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-active{color:var(--el-color-primary);background-color:var(--el-bg-color-overlay);border-right-color:var(--el-border-color);border-left-color:var(--el-border-color)}.el-tabs--border-card>.el-tabs__header .el-tabs__item:not(.is-disabled):hover{color:var(--el-color-primary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-disabled{color:var(--el-disabled-text-color)}.el-tabs--border-card>.el-tabs__header .is-scrollable .el-tabs__item:first-child{margin-left:0}.el-tabs--bottom .el-tabs__item.is-bottom:nth-child(2),.el-tabs--bottom .el-tabs__item.is-top:nth-child(2),.el-tabs--top .el-tabs__item.is-bottom:nth-child(2),.el-tabs--top .el-tabs__item.is-top:nth-child(2){padding-left:0}.el-tabs--bottom .el-tabs__item.is-bottom:last-child,.el-tabs--bottom .el-tabs__item.is-top:last-child,.el-tabs--top .el-tabs__item.is-bottom:last-child,.el-tabs--top .el-tabs__item.is-top:last-child{padding-right:0}.el-tabs--bottom .el-tabs--left>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom .el-tabs--right>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top .el-tabs--left>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top .el-tabs--right>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2){padding-left:20px}.el-tabs--bottom .el-tabs--left>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--bottom .el-tabs--right>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--top .el-tabs--left>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--top .el-tabs--right>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover,.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2):not(.is-active).is-closable:hover{padding-left:13px}.el-tabs--bottom .el-tabs--left>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom .el-tabs--right>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top .el-tabs--left>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top .el-tabs--right>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:last-child{padding-right:20px}.el-tabs--bottom .el-tabs--left>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--bottom .el-tabs--right>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--top .el-tabs--left>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--top .el-tabs--right>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover,.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:last-child:not(.is-active).is-closable:hover{padding-right:13px}.el-tabs--bottom .el-tabs__header.is-bottom{margin-bottom:0;margin-top:10px}.el-tabs--bottom.el-tabs--border-card .el-tabs__header.is-bottom{border-bottom:0;border-top:1px solid var(--el-border-color)}.el-tabs--bottom.el-tabs--border-card .el-tabs__nav-wrap.is-bottom{margin-top:-1px;margin-bottom:0}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom:not(.is-active){border:1px solid transparent}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom{margin:0 -1px -1px}.el-tabs--left,.el-tabs--right{overflow:hidden}.el-tabs--left .el-tabs__header.is-left,.el-tabs--left .el-tabs__header.is-right,.el-tabs--left .el-tabs__nav-scroll,.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__header.is-left,.el-tabs--right .el-tabs__header.is-right,.el-tabs--right .el-tabs__nav-scroll,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{height:100%}.el-tabs--left .el-tabs__active-bar.is-left,.el-tabs--left .el-tabs__active-bar.is-right,.el-tabs--right .el-tabs__active-bar.is-left,.el-tabs--right .el-tabs__active-bar.is-right{top:0;bottom:auto;width:2px;height:auto}.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{margin-bottom:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{height:30px;line-height:30px;width:100%;text-align:center;cursor:pointer}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i{transform:rotate(90deg)}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{left:auto;top:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next{right:auto;bottom:0}.el-tabs--left .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--left .el-tabs__nav-wrap.is-right.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-right.is-scrollable{padding:30px 0}.el-tabs--left .el-tabs__nav-wrap.is-left:after,.el-tabs--left .el-tabs__nav-wrap.is-right:after,.el-tabs--right .el-tabs__nav-wrap.is-left:after,.el-tabs--right .el-tabs__nav-wrap.is-right:after{height:100%;width:2px;bottom:auto;top:0}.el-tabs--left .el-tabs__nav.is-left,.el-tabs--left .el-tabs__nav.is-right,.el-tabs--right .el-tabs__nav.is-left,.el-tabs--right .el-tabs__nav.is-right{flex-direction:column}.el-tabs--left .el-tabs__item.is-left,.el-tabs--right .el-tabs__item.is-left{justify-content:flex-end}.el-tabs--left .el-tabs__item.is-right,.el-tabs--right .el-tabs__item.is-right{justify-content:flex-start}.el-tabs--left .el-tabs__header.is-left{float:left;margin-bottom:0;margin-right:10px}.el-tabs--left .el-tabs__nav-wrap.is-left{margin-right:-1px}.el-tabs--left .el-tabs__nav-wrap.is-left:after{left:auto;right:0}.el-tabs--left .el-tabs__active-bar.is-left{right:0;left:auto}.el-tabs--left .el-tabs__item.is-left{text-align:right}.el-tabs--left.el-tabs--card .el-tabs__active-bar.is-left{display:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left{border-left:none;border-right:1px solid var(--el-border-color-light);border-bottom:none;border-top:1px solid var(--el-border-color-light);text-align:left}.el-tabs--left.el-tabs--card .el-tabs__item.is-left:first-child{border-right:1px solid var(--el-border-color-light);border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active{border:1px solid var(--el-border-color-light);border-right-color:#fff;border-left:none;border-bottom:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:first-child{border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:last-child{border-bottom:none}.el-tabs--left.el-tabs--card .el-tabs__nav{border-radius:4px 0 0 4px;border-bottom:1px solid var(--el-border-color-light);border-right:none}.el-tabs--left.el-tabs--card .el-tabs__new-tab{float:none}.el-tabs--left.el-tabs--border-card .el-tabs__header.is-left{border-right:1px solid var(--el-border-color)}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left{border:1px solid transparent;margin:-1px 0 -1px -1px}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left.is-active{border-color:transparent;border-top-color:#d1dbe5;border-bottom-color:#d1dbe5}.el-tabs--right .el-tabs__header.is-right{float:right;margin-bottom:0;margin-left:10px}.el-tabs--right .el-tabs__nav-wrap.is-right{margin-left:-1px}.el-tabs--right .el-tabs__nav-wrap.is-right:after{left:0;right:auto}.el-tabs--right .el-tabs__active-bar.is-right{left:0}.el-tabs--right.el-tabs--card .el-tabs__active-bar.is-right{display:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right{border-bottom:none;border-top:1px solid var(--el-border-color-light)}.el-tabs--right.el-tabs--card .el-tabs__item.is-right:first-child{border-left:1px solid var(--el-border-color-light);border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active{border:1px solid var(--el-border-color-light);border-left-color:#fff;border-right:none;border-bottom:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:first-child{border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:last-child{border-bottom:none}.el-tabs--right.el-tabs--card .el-tabs__nav{border-radius:0 4px 4px 0;border-bottom:1px solid var(--el-border-color-light);border-left:none}.el-tabs--right.el-tabs--border-card .el-tabs__header.is-right{border-left:1px solid var(--el-border-color)}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right{border:1px solid transparent;margin:-1px -1px -1px 0}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right.is-active{border-color:transparent;border-top-color:#d1dbe5;border-bottom-color:#d1dbe5}.slideInLeft-transition,.slideInRight-transition{display:inline-block}.slideInRight-enter{-webkit-animation:slideInRight-enter var(--el-transition-duration);animation:slideInRight-enter var(--el-transition-duration)}.slideInRight-leave{position:absolute;left:0;right:0;-webkit-animation:slideInRight-leave var(--el-transition-duration);animation:slideInRight-leave var(--el-transition-duration)}.slideInLeft-enter{-webkit-animation:slideInLeft-enter var(--el-transition-duration);animation:slideInLeft-enter var(--el-transition-duration)}.slideInLeft-leave{position:absolute;left:0;right:0;-webkit-animation:slideInLeft-leave var(--el-transition-duration);animation:slideInLeft-leave var(--el-transition-duration)}@-webkit-keyframes slideInRight-enter{0%{opacity:0;transform-origin:0 0;transform:translate(100%)}to{opacity:1;transform-origin:0 0;transform:translate(0)}}@keyframes slideInRight-enter{0%{opacity:0;transform-origin:0 0;transform:translate(100%)}to{opacity:1;transform-origin:0 0;transform:translate(0)}}@-webkit-keyframes slideInRight-leave{0%{transform-origin:0 0;transform:translate(0);opacity:1}to{transform-origin:0 0;transform:translate(100%);opacity:0}}@keyframes slideInRight-leave{0%{transform-origin:0 0;transform:translate(0);opacity:1}to{transform-origin:0 0;transform:translate(100%);opacity:0}}@-webkit-keyframes slideInLeft-enter{0%{opacity:0;transform-origin:0 0;transform:translate(-100%)}to{opacity:1;transform-origin:0 0;transform:translate(0)}}@keyframes slideInLeft-enter{0%{opacity:0;transform-origin:0 0;transform:translate(-100%)}to{opacity:1;transform-origin:0 0;transform:translate(0)}}@-webkit-keyframes slideInLeft-leave{0%{transform-origin:0 0;transform:translate(0);opacity:1}to{transform-origin:0 0;transform:translate(-100%);opacity:0}}@keyframes slideInLeft-leave{0%{transform-origin:0 0;transform:translate(0);opacity:1}to{transform-origin:0 0;transform:translate(-100%);opacity:0}}.el-icon-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@-webkit-keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.el-icon{--color:inherit;height:1em;width:1em;line-height:1em;display:inline-flex;justify-content:center;align-items:center;position:relative;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}.container[data-v-c6eaee5b]{position:relative;width:24px;aspect-ratio:1;display:flex;justify-content:center;align-items:center;cursor:pointer}.container>*[data-v-c6eaee5b]{position:absolute;display:flex;justify-content:center;align-items:center}.v-enter-active[data-v-c6eaee5b],.v-leave-active[data-v-c6eaee5b]{transition:opacity .5s ease}.v-enter-from[data-v-c6eaee5b],.v-leave-to[data-v-c6eaee5b]{opacity:0}.el-checkbox{--el-checkbox-font-size:14px;--el-checkbox-font-weight:var(--el-font-weight-primary);--el-checkbox-text-color:var(--el-text-color-regular);--el-checkbox-input-height:14px;--el-checkbox-input-width:14px;--el-checkbox-border-radius:var(--el-border-radius-small);--el-checkbox-bg-color:var(--el-fill-color-blank);--el-checkbox-input-border:var(--el-border);--el-checkbox-disabled-border-color:var(--el-border-color);--el-checkbox-disabled-input-fill:var(--el-fill-color-light);--el-checkbox-disabled-icon-color:var(--el-text-color-placeholder);--el-checkbox-disabled-checked-input-fill:var(--el-border-color-extra-light);--el-checkbox-disabled-checked-input-border-color:var(--el-border-color);--el-checkbox-disabled-checked-icon-color:var(--el-text-color-placeholder);--el-checkbox-checked-text-color:var(--el-color-primary);--el-checkbox-checked-input-border-color:var(--el-color-primary);--el-checkbox-checked-bg-color:var(--el-color-primary);--el-checkbox-checked-icon-color:var(--el-color-white);--el-checkbox-input-border-color-hover:var(--el-color-primary)}.el-checkbox{color:var(--el-checkbox-text-color);font-weight:var(--el-checkbox-font-weight);font-size:var(--el-font-size-base);position:relative;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin-right:30px;height:var(--el-checkbox-height,32px)}.el-checkbox.is-disabled{cursor:not-allowed}.el-checkbox.is-bordered{padding:0 15px 0 9px;border-radius:var(--el-border-radius-base);border:var(--el-border);box-sizing:border-box}.el-checkbox.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-checkbox.is-bordered.is-disabled{border-color:var(--el-border-color-lighter)}.el-checkbox.is-bordered.el-checkbox--large{padding:0 19px 0 11px;border-radius:var(--el-border-radius-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__label{font-size:var(--el-font-size-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.is-bordered.el-checkbox--small{padding:0 11px 0 7px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox input:focus-visible+.el-checkbox__inner{outline:2px solid var(--el-checkbox-input-border-color-hover);outline-offset:1px;border-radius:var(--el-checkbox-border-radius)}.el-checkbox__input{white-space:nowrap;cursor:pointer;outline:0;display:inline-flex;position:relative}.el-checkbox__input.is-disabled .el-checkbox__inner{background-color:var(--el-checkbox-disabled-input-fill);border-color:var(--el-checkbox-disabled-border-color);cursor:not-allowed}.el-checkbox__input.is-disabled .el-checkbox__inner:after{cursor:not-allowed;border-color:var(--el-checkbox-disabled-icon-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-disabled-checked-icon-color);border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled+span.el-checkbox__label{color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox__input.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-checked .el-checkbox__inner:after{transform:rotate(45deg) scaleY(1);border-color:var(--el-checkbox-checked-icon-color)}.el-checkbox__input.is-checked+.el-checkbox__label{color:var(--el-checkbox-checked-text-color)}.el-checkbox__input.is-focus:not(.is-checked) .el-checkbox__original:not(:focus-visible){border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__input.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:before{content:"";position:absolute;display:block;background-color:var(--el-checkbox-checked-icon-color);height:2px;transform:scale(.5);left:0;right:0;top:5px}.el-checkbox__input.is-indeterminate .el-checkbox__inner:after{display:none}.el-checkbox__inner{display:inline-block;position:relative;border:var(--el-checkbox-input-border);border-radius:var(--el-checkbox-border-radius);box-sizing:border-box;width:var(--el-checkbox-input-width);height:var(--el-checkbox-input-height);background-color:var(--el-checkbox-bg-color);z-index:var(--el-index-normal);transition:border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46),outline .25s cubic-bezier(.71,-.46,.29,1.46)}.el-checkbox__inner:hover{border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__inner:after{box-sizing:content-box;content:"";border:1px solid transparent;border-left:0;border-top:0;height:7px;left:4px;position:absolute;top:1px;transform:rotate(45deg) scaleY(0);width:3px;transition:transform .15s ease-in 50ms;transform-origin:center}.el-checkbox__original{opacity:0;outline:0;position:absolute;margin:0;width:0;height:0;z-index:-1}.el-checkbox__label{display:inline-block;padding-left:8px;line-height:1;font-size:var(--el-checkbox-font-size)}.el-checkbox.el-checkbox--large{height:40px}.el-checkbox.el-checkbox--large .el-checkbox__label{font-size:14px}.el-checkbox.el-checkbox--large .el-checkbox__inner{width:14px;height:14px}.el-checkbox.el-checkbox--small{height:24px}.el-checkbox.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.el-checkbox--small .el-checkbox__inner{width:12px;height:12px}.el-checkbox.el-checkbox--small .el-checkbox__input.is-indeterminate .el-checkbox__inner:before{top:4px}.el-checkbox.el-checkbox--small .el-checkbox__inner:after{width:2px;height:6px}.el-checkbox:last-of-type{margin-right:0}.el-form{--el-form-label-font-size:var(--el-font-size-base);--el-form-inline-content-width:220px}.el-form--label-left .el-form-item__label{justify-content:flex-start}.el-form--label-top .el-form-item{display:block}.el-form--label-top .el-form-item .el-form-item__label{display:block;height:auto;text-align:left;margin-bottom:8px;line-height:22px}.el-form--inline .el-form-item{display:inline-flex;vertical-align:middle;margin-right:32px}.el-form--inline.el-form--label-top{display:flex;flex-wrap:wrap}.el-form--inline.el-form--label-top .el-form-item{display:block}.el-form--large.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:12px;line-height:22px}.el-form--default.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:8px;line-height:22px}.el-form--small.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:4px;line-height:20px}.el-form-item{display:flex;--font-size:14px;margin-bottom:18px}.el-form-item .el-form-item{margin-bottom:0}.el-form-item .el-input__validateIcon{display:none}.el-form-item--large{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:22px}.el-form-item--large .el-form-item__label{height:40px;line-height:40px}.el-form-item--large .el-form-item__content{line-height:40px}.el-form-item--large .el-form-item__error{padding-top:4px}.el-form-item--default{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--default .el-form-item__label{height:32px;line-height:32px}.el-form-item--default .el-form-item__content{line-height:32px}.el-form-item--default .el-form-item__error{padding-top:2px}.el-form-item--small{--font-size:12px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--small .el-form-item__label{height:24px;line-height:24px}.el-form-item--small .el-form-item__content{line-height:24px}.el-form-item--small .el-form-item__error{padding-top:2px}.el-form-item__label-wrap{display:flex}.el-form-item__label{display:inline-flex;justify-content:flex-end;align-items:flex-start;flex:0 0 auto;font-size:var(--el-form-label-font-size);color:var(--el-text-color-regular);height:32px;line-height:32px;padding:0 12px 0 0;box-sizing:border-box}.el-form-item__content{display:flex;flex-wrap:wrap;align-items:center;flex:1;line-height:32px;position:relative;font-size:var(--font-size);min-width:0}.el-form-item__content .el-input-group{vertical-align:top}.el-form-item__error{color:var(--el-color-danger);font-size:12px;line-height:1;padding-top:2px;position:absolute;top:100%;left:0}.el-form-item__error--inline{position:relative;top:auto;left:auto;display:inline-block;margin-left:10px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label-wrap>.el-form-item__label:before,.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label:before{content:"*";color:var(--el-color-danger);margin-right:4px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label-wrap>.el-form-item__label:after,.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label:after{content:"*";color:var(--el-color-danger);margin-left:4px}.el-form-item.is-error .el-select-v2__wrapper.is-focused{border-color:transparent}.el-form-item.is-error .el-select-v2__wrapper,.el-form-item.is-error .el-select-v2__wrapper:focus,.el-form-item.is-error .el-textarea__inner,.el-form-item.is-error .el-textarea__inner:focus{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input-group__append .el-input__wrapper,.el-form-item.is-error .el-input-group__prepend .el-input__wrapper{box-shadow:0 0 0 1px transparent inset}.el-form-item.is-error .el-input__validateIcon{color:var(--el-color-danger)}.el-form-item--feedback .el-input__validateIcon{display:inline-flex}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%}.el-textarea{position:relative;display:inline-block;width:100%;vertical-align:bottom;font-size:var(--el-font-size-base)}.el-textarea__inner{position:relative;display:block;resize:vertical;padding:5px 11px;line-height:1.5;box-sizing:border-box;width:100%;font-size:inherit;font-family:inherit;color:var(--el-input-text-color,var(--el-text-color-regular));background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;-webkit-appearance:none;box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));transition:var(--el-transition-box-shadow);border:none}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{outline:0;box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-textarea .el-input__count{color:var(--el-color-info);background:var(--el-fill-color-blank);position:absolute;font-size:12px;line-height:14px;bottom:5px;right:10px}.el-textarea.is-disabled .el-textarea__inner{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%}.el-input{--el-input-height:var(--el-component-size);position:relative;font-size:var(--el-font-size-base);display:inline-flex;width:var(--el-input-width);line-height:var(--el-input-height);box-sizing:border-box;vertical-align:middle}.el-input::-webkit-scrollbar{z-index:11;width:6px}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{border-radius:5px;width:6px;background:var(--el-text-color-disabled)}.el-input::-webkit-scrollbar-corner{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);font-size:14px;cursor:pointer}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{height:100%;display:inline-flex;align-items:center;color:var(--el-color-info);font-size:12px}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);line-height:initial;display:inline-block;padding-left:8px}.el-input__wrapper{display:inline-flex;flex-grow:1;align-items:center;justify-content:center;padding:1px 11px;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));cursor:text;transition:var(--el-transition-box-shadow);transform:translateZ(0);box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px);width:100%;flex-grow:1;-webkit-appearance:none;color:var(--el-input-text-color,var(--el-text-color-regular));font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);padding:0;outline:0;border:none;background:0 0;box-sizing:border-box}.el-input__inner:focus{outline:0}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__prefix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__prefix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__suffix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{height:inherit;line-height:inherit;display:flex;justify-content:center;align-items:center;transition:all var(--el-transition-duration);margin-left:8px}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color,) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{display:inline-flex;width:100%;align-items:stretch}.el-input-group__append,.el-input-group__prepend{background-color:var(--el-fill-color-light);color:var(--el-color-info);position:relative;display:inline-flex;align-items:center;justify-content:center;min-height:100%;border-radius:var(--el-input-border-radius);padding:0 20px;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:0}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-input__wrapper,.el-input-group__append div.el-select:hover .el-input__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-input__wrapper,.el-input-group__prepend div.el-select:hover .el-input__wrapper{border-color:transparent;background-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-right:0;border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-left:0;border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-input .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select .el-input .el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__wrapper{box-shadow:1px 0 0 0 var(--el-input-focus-border-color) inset,1px 0 0 0 var(--el-input-focus-border-color),0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important;z-index:2}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__wrapper:focus{outline:0;z-index:2;box-shadow:1px 0 0 0 var(--el-input-focus-border-color) inset,1px 0 0 0 var(--el-input-focus-border-color),0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important}.el-input-group--prepend .el-input-group__prepend .el-select:hover .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select:hover .el-input__wrapper{z-index:1;box-shadow:1px 0 0 0 var(--el-input-hover-border-color) inset,1px 0 0 0 var(--el-input-hover-border-color),0 1px 0 0 var(--el-input-hover-border-color) inset,0 -1px 0 0 var(--el-input-hover-border-color) inset!important}.el-input-group--append>.el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-input .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select .el-input .el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--append .el-input-group__append .el-select .el-input.is-focus .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select .el-input.is-focus .el-input__wrapper{z-index:2;box-shadow:-1px 0 0 0 var(--el-input-focus-border-color),-1px 0 0 0 var(--el-input-focus-border-color) inset,0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important}.el-input-group--append .el-input-group__append .el-select:hover .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select:hover .el-input__wrapper{z-index:1;box-shadow:-1px 0 0 0 var(--el-input-hover-border-color),-1px 0 0 0 var(--el-input-hover-border-color) inset,0 1px 0 0 var(--el-input-hover-border-color) inset,0 -1px 0 0 var(--el-input-hover-border-color) inset!important}.el-tag{--el-tag-font-size:12px;--el-tag-border-radius:4px;--el-tag-border-radius-rounded:9999px}.el-tag{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary);--el-tag-text-color:var(--el-color-primary);background-color:var(--el-tag-bg-color);border-color:var(--el-tag-border-color);color:var(--el-tag-text-color);display:inline-flex;justify-content:center;align-items:center;vertical-align:middle;height:24px;padding:0 9px;font-size:var(--el-tag-font-size);line-height:1;border-width:1px;border-style:solid;border-radius:var(--el-tag-border-radius);box-sizing:border-box;white-space:nowrap;--el-icon-size:14px}.el-tag.el-tag--primary{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-bg-color:var(--el-color-success-light-9);--el-tag-border-color:var(--el-color-success-light-8);--el-tag-hover-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-bg-color:var(--el-color-warning-light-9);--el-tag-border-color:var(--el-color-warning-light-8);--el-tag-hover-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-bg-color:var(--el-color-danger-light-9);--el-tag-border-color:var(--el-color-danger-light-8);--el-tag-hover-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-bg-color:var(--el-color-error-light-9);--el-tag-border-color:var(--el-color-error-light-8);--el-tag-hover-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-bg-color:var(--el-color-info-light-9);--el-tag-border-color:var(--el-color-info-light-8);--el-tag-hover-color:var(--el-color-info)}.el-tag.el-tag--primary{--el-tag-text-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-text-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-text-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-text-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-text-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-text-color:var(--el-color-info)}.el-tag.is-hit{border-color:var(--el-color-primary)}.el-tag.is-round{border-radius:var(--el-tag-border-radius-rounded)}.el-tag .el-tag__close{color:var(--el-tag-text-color)}.el-tag .el-tag__close:hover{color:var(--el-color-white);background-color:var(--el-tag-hover-color)}.el-tag .el-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--el-icon-size) - 2px);height:var(--el-icon-size);width:var(--el-icon-size)}.el-tag .el-tag__close{margin-left:6px}.el-tag--dark{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3);--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--primary{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3)}.el-tag--dark.el-tag--success{--el-tag-bg-color:var(--el-color-success);--el-tag-border-color:var(--el-color-success);--el-tag-hover-color:var(--el-color-success-light-3)}.el-tag--dark.el-tag--warning{--el-tag-bg-color:var(--el-color-warning);--el-tag-border-color:var(--el-color-warning);--el-tag-hover-color:var(--el-color-warning-light-3)}.el-tag--dark.el-tag--danger{--el-tag-bg-color:var(--el-color-danger);--el-tag-border-color:var(--el-color-danger);--el-tag-hover-color:var(--el-color-danger-light-3)}.el-tag--dark.el-tag--error{--el-tag-bg-color:var(--el-color-error);--el-tag-border-color:var(--el-color-error);--el-tag-hover-color:var(--el-color-error-light-3)}.el-tag--dark.el-tag--info{--el-tag-bg-color:var(--el-color-info);--el-tag-border-color:var(--el-color-info);--el-tag-hover-color:var(--el-color-info-light-3)}.el-tag--dark.el-tag--primary,.el-tag--dark.el-tag--success,.el-tag--dark.el-tag--warning,.el-tag--dark.el-tag--danger,.el-tag--dark.el-tag--error,.el-tag--dark.el-tag--info{--el-tag-text-color:var(--el-color-white)}.el-tag--plain{--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary);--el-tag-bg-color:var(--el-fill-color-blank)}.el-tag--plain.el-tag--primary{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary)}.el-tag--plain.el-tag--success{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-success-light-5);--el-tag-hover-color:var(--el-color-success)}.el-tag--plain.el-tag--warning{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-warning-light-5);--el-tag-hover-color:var(--el-color-warning)}.el-tag--plain.el-tag--danger{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-danger-light-5);--el-tag-hover-color:var(--el-color-danger)}.el-tag--plain.el-tag--error{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-error-light-5);--el-tag-hover-color:var(--el-color-error)}.el-tag--plain.el-tag--info{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-info-light-5);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-closable{padding-right:5px}.el-tag--large{padding:0 11px;height:32px;--el-icon-size:16px}.el-tag--large .el-tag__close{margin-left:8px}.el-tag--large.is-closable{padding-right:7px}.el-tag--small{padding:0 7px;height:20px;--el-icon-size:12px}.el-tag--small .el-tag__close{margin-left:4px}.el-tag--small.is-closable{padding-right:3px}.el-tag--small .el-icon-close{transform:scale(.8)}.el-tag.el-tag--primary.is-hit{border-color:var(--el-color-primary)}.el-tag.el-tag--success.is-hit{border-color:var(--el-color-success)}.el-tag.el-tag--warning.is-hit{border-color:var(--el-color-warning)}.el-tag.el-tag--danger.is-hit{border-color:var(--el-color-danger)}.el-tag.el-tag--error.is-hit{border-color:var(--el-color-error)}.el-tag.el-tag--info.is-hit{border-color:var(--el-color-info)}.el-select-dropdown__item{font-size:var(--el-font-size-base);padding:0 32px 0 20px;position:relative;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--el-text-color-regular);height:34px;line-height:34px;box-sizing:border-box;cursor:pointer}.el-select-dropdown__item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select-dropdown__item.hover,.el-select-dropdown__item:hover{background-color:var(--el-fill-color-light)}.el-select-dropdown__item.selected{color:var(--el-color-primary);font-weight:700}.el-scrollbar{--el-scrollbar-opacity:.3;--el-scrollbar-bg-color:var(--el-text-color-secondary);--el-scrollbar-hover-opacity:.5;--el-scrollbar-hover-bg-color:var(--el-text-color-secondary)}.el-scrollbar{overflow:hidden;position:relative;height:100%}.el-scrollbar__wrap{overflow:auto;height:100%}.el-scrollbar__wrap--hidden-default{scrollbar-width:none}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.el-scrollbar__thumb{position:relative;display:block;width:0;height:0;cursor:pointer;border-radius:inherit;background-color:var(--el-scrollbar-bg-color,var(--el-text-color-secondary));transition:var(--el-transition-duration) background-color;opacity:var(--el-scrollbar-opacity,.3)}.el-scrollbar__thumb:hover{background-color:var(--el-scrollbar-hover-bg-color,var(--el-text-color-secondary));opacity:var(--el-scrollbar-hover-opacity,.5)}.el-scrollbar__bar{position:absolute;right:2px;bottom:2px;z-index:1;border-radius:4px}.el-scrollbar__bar.is-vertical{width:6px;top:2px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar-fade-enter-active{transition:opacity .34s ease-out}.el-scrollbar-fade-leave-active{transition:opacity .12s ease-out}.el-scrollbar-fade-enter-from,.el-scrollbar-fade-leave-active{opacity:0}.el-popper{--el-popper-border-radius:var(--el-popover-border-radius, 4px)}.el-popper{position:absolute;border-radius:var(--el-popper-border-radius);padding:5px 11px;z-index:2000;font-size:12px;line-height:20px;min-width:10px;word-wrap:break-word;visibility:visible}.el-popper.is-dark{color:var(--el-bg-color);background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary)}.el-popper.is-dark .el-popper__arrow:before{border:1px solid var(--el-text-color-primary);background:var(--el-text-color-primary);right:0}.el-popper.is-light{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light .el-popper__arrow:before{border:1px solid var(--el-border-color-light);background:var(--el-bg-color-overlay);right:0}.el-popper.is-pure{padding:0}.el-popper__arrow{position:absolute;width:10px;height:10px;z-index:-1}.el-popper__arrow:before{position:absolute;width:10px;height:10px;z-index:-1;content:" ";transform:rotate(45deg);background:var(--el-text-color-primary);box-sizing:border-box}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent!important;border-bottom-color:transparent!important}.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent!important;border-top-color:transparent!important}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected{color:var(--el-color-primary);background-color:var(--el-bg-color-overlay)}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected.hover{background-color:var(--el-fill-color-light)}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected:after{content:"";position:absolute;top:50%;right:20px;border-top:none;border-right:none;background-repeat:no-repeat;background-position:center;background-color:var(--el-color-primary);-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;transform:translateY(-50%);width:12px;height:12px}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected.is-disabled:after{background-color:var(--el-text-color-disabled)}.el-select-dropdown .el-select-dropdown__option-item.is-selected:after{content:"";position:absolute;top:50%;right:20px;border-top:none;border-right:none;background-repeat:no-repeat;background-position:center;background-color:var(--el-color-primary);-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;transform:translateY(-50%);width:12px;height:12px}.el-select-dropdown .el-select-dropdown__item.is-disabled:hover{background-color:unset}.el-select-dropdown .el-select-dropdown__item.is-disabled.selected{color:var(--el-text-color-disabled)}.el-select-dropdown__list{list-style:none;padding:6px 0;margin:0;box-sizing:border-box}.el-select{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px}.el-select{display:inline-block;position:relative;vertical-align:middle;line-height:32px}.el-select__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-select__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-select__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent;border-left-color:transparent}.el-select__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-select__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent;border-bottom-color:transparent}.el-select__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-select .el-select-tags-wrapper.has-prefix{margin-left:6px}.el-select--large{line-height:40px}.el-select--large .el-select-tags-wrapper.has-prefix{margin-left:8px}.el-select--small{line-height:24px}.el-select--small .el-select-tags-wrapper.has-prefix{margin-left:4px}.el-select .el-select__tags>span{display:inline-block}.el-select:hover:not(.el-select--disabled) .el-input__wrapper{box-shadow:0 0 0 1px var(--el-select-border-color-hover) inset}.el-select .el-select__tags-text{display:inline-block;line-height:normal;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select .el-input__wrapper{cursor:pointer}.el-select .el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-select-input-focus-border-color) inset!important}.el-select .el-input__inner{cursor:pointer}.el-select .el-input{display:flex}.el-select .el-input .el-select__caret{color:var(--el-select-input-color);font-size:var(--el-select-input-font-size);transition:transform var(--el-transition-duration);transform:rotate(0);cursor:pointer}.el-select .el-input .el-select__caret.is-reverse{transform:rotate(-180deg)}.el-select .el-input .el-select__caret.is-show-close{font-size:var(--el-select-font-size);text-align:center;transform:rotate(0);border-radius:var(--el-border-radius-circle);color:var(--el-select-input-color);transition:var(--el-transition-color)}.el-select .el-input .el-select__caret.is-show-close:hover{color:var(--el-select-close-hover-color)}.el-select .el-input .el-select__caret.el-icon{position:relative;height:inherit;z-index:2}.el-select .el-input.is-disabled .el-input__wrapper{cursor:not-allowed}.el-select .el-input.is-disabled .el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select .el-input.is-disabled .el-input__inner,.el-select .el-input.is-disabled .el-select__caret{cursor:not-allowed}.el-select .el-input.is-focus .el-input__wrapper{box-shadow:0 0 0 1px var(--el-select-input-focus-border-color) inset!important}.el-select__input{border:none;outline:0;padding:0;margin-left:15px;color:var(--el-select-multiple-input-color);font-size:var(--el-select-font-size);-webkit-appearance:none;-moz-appearance:none;appearance:none;height:28px;background-color:transparent}.el-select__input.is-disabled{cursor:not-allowed}.el-select__input--iOS{position:absolute;left:0;top:0;z-index:6}.el-select__input.is-small{height:14px}.el-select__close{cursor:pointer;position:absolute;top:8px;z-index:var(--el-index-top);right:25px;color:var(--el-select-input-color);line-height:18px;font-size:var(--el-select-input-font-size)}.el-select__close:hover{color:var(--el-select-close-hover-color)}.el-select__tags{position:absolute;line-height:normal;top:50%;transform:translateY(-50%);white-space:normal;z-index:var(--el-index-normal);display:flex;align-items:center;flex-wrap:wrap;cursor:pointer}.el-select__tags .el-tag{box-sizing:border-box;border-color:transparent;margin:2px 6px 2px 0}.el-select__tags .el-tag:last-child{margin-right:0}.el-select__tags .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);right:-7px;top:0;color:#fff}.el-select__tags .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-select__tags .el-tag .el-icon-close:before{display:block;transform:translateY(.5px)}.el-select__tags .el-tag--info{background-color:var(--el-fill-color)}.el-select__tags.is-disabled{cursor:not-allowed}.el-select__collapse-tags{white-space:normal;z-index:var(--el-index-normal);display:flex;align-items:center;flex-wrap:wrap;cursor:pointer}.el-select__collapse-tags .el-tag{box-sizing:border-box;border-color:transparent;margin:2px 6px 2px 0}.el-select__collapse-tags .el-tag:last-child{margin-right:0}.el-select__collapse-tags .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);right:-7px;top:0;color:#fff}.el-select__collapse-tags .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-select__collapse-tags .el-tag .el-icon-close:before{display:block;transform:translateY(.5px)}.el-select__collapse-tags .el-tag--info{background-color:var(--el-fill-color)}.el-select__collapse-tag{line-height:inherit;height:inherit;display:flex}.side-button[data-v-5a33bf4c]{position:relative;width:24px;aspect-ratio:1;display:flex;justify-content:center;align-items:center;font-size:18px}.side-button.add-match-item[data-v-5a33bf4c]{color:green}.side-button.remove-match-item[data-v-5a33bf4c]{color:red}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center top}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center bottom}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transition:var(--el-transition-md-fade);transform-origin:top left}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-tree{--el-tree-node-content-height:26px;--el-tree-node-hover-bg-color:var(--el-fill-color-light);--el-tree-text-color:var(--el-text-color-regular);--el-tree-expand-icon-color:var(--el-text-color-placeholder)}.el-tree{position:relative;cursor:default;background:var(--el-fill-color-blank);color:var(--el-tree-text-color);font-size:var(--el-font-size-base)}.el-tree__empty-block{position:relative;min-height:60px;text-align:center;width:100%;height:100%}.el-tree__empty-text{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:var(--el-text-color-secondary);font-size:var(--el-font-size-base)}.el-tree__drop-indicator{position:absolute;left:0;right:0;height:1px;background-color:var(--el-color-primary)}.el-tree-node{white-space:nowrap;outline:0}.el-tree-node:focus>.el-tree-node__content{background-color:var(--el-tree-node-hover-bg-color)}.el-tree-node.is-drop-inner>.el-tree-node__content .el-tree-node__label{background-color:var(--el-color-primary);color:#fff}.el-tree-node__content{--el-checkbox-height:var(--el-tree-node-content-height);display:flex;align-items:center;height:var(--el-tree-node-content-height);cursor:pointer}.el-tree-node__content>.el-tree-node__expand-icon{padding:6px;box-sizing:content-box}.el-tree-node__content>label.el-checkbox{margin-right:8px}.el-tree-node__content:hover{background-color:var(--el-tree-node-hover-bg-color)}.el-tree.is-dragging .el-tree-node__content{cursor:move}.el-tree.is-dragging .el-tree-node__content *{pointer-events:none}.el-tree.is-dragging.is-drop-not-allow .el-tree-node__content{cursor:not-allowed}.el-tree-node__expand-icon{cursor:pointer;color:var(--el-tree-expand-icon-color);font-size:12px;transform:rotate(0);transition:transform var(--el-transition-duration) ease-in-out}.el-tree-node__expand-icon.expanded{transform:rotate(90deg)}.el-tree-node__expand-icon.is-leaf{color:transparent;cursor:default}.el-tree-node__expand-icon.is-hidden{visibility:hidden}.el-tree-node__loading-icon{margin-right:8px;font-size:var(--el-font-size-base);color:var(--el-tree-expand-icon-color)}.el-tree-node>.el-tree-node__children{overflow:hidden;background-color:transparent}.el-tree-node.is-expanded>.el-tree-node__children{display:block}.el-tree--highlight-current .el-tree-node.is-current>.el-tree-node__content{background-color:var(--el-color-primary-light-9)}.el-vl__wrapper{position:relative}.el-vl__wrapper:hover .el-virtual-scrollbar,.el-vl__wrapper.always-on .el-virtual-scrollbar{opacity:1}.el-vl__window{scrollbar-width:none}.el-vl__window::-webkit-scrollbar{display:none}.el-virtual-scrollbar{opacity:0;transition:opacity .34s ease-out}.el-virtual-scrollbar.always-on{opacity:1}.el-vg__wrapper{position:relative}.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255, 255, 255, .5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-color-info);--el-button-active-color:var(--el-text-color-primary)}.el-button{display:inline-flex;justify-content:center;align-items:center;line-height:1;height:32px;white-space:nowrap;cursor:pointer;color:var(--el-button-text-color);text-align:center;box-sizing:border-box;outline:0;transition:.1s;font-weight:var(--el-button-font-weight);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);padding:8px 15px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button:focus,.el-button:hover{color:var(--el-button-hover-text-color);border-color:var(--el-button-hover-border-color);background-color:var(--el-button-hover-bg-color);outline:0}.el-button:active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button>span{display:inline-flex;align-items:center}.el-button+.el-button{margin-left:12px}.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button.is-disabled,.el-button.is-disabled:focus,.el-button.is-disabled:hover{color:var(--el-button-disabled-text-color);cursor:not-allowed;background-image:none;background-color:var(--el-button-disabled-bg-color);border-color:var(--el-button-disabled-border-color)}.el-button.is-loading{position:relative;pointer-events:none}.el-button.is-loading:before{z-index:1;pointer-events:none;content:"";position:absolute;left:-1px;top:-1px;right:-1px;bottom:-1px;border-radius:inherit;background-color:var(--el-mask-color-extra-light)}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{border-radius:50%;padding:8px}.el-button.is-text{color:var(--el-button-text-color);border:0 solid transparent;background-color:transparent}.el-button.is-text.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important}.el-button.is-text:not(.is-disabled):focus,.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:focus,.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{border-color:transparent;color:var(--el-button-text-color);background:0 0;padding:2px;height:auto}.el-button.is-link:focus,.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.el-button.is-link:not(.is-disabled):focus,.el-button.is-link:not(.is-disabled):hover{border-color:transparent;background-color:transparent}.el-button.is-link:not(.is-disabled):active{color:var(--el-button-active-color);border-color:transparent;background-color:transparent}.el-button--text{border-color:transparent;background:0 0;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.el-button--text:not(.is-disabled):focus,.el-button--text:not(.is-disabled):hover{color:var(--el-color-primary-light-3);border-color:transparent;background-color:transparent}.el-button--text:not(.is-disabled):active{color:var(--el-color-primary-dark-2);border-color:transparent;background-color:transparent}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{color:var(--el-color-primary-light-5);background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{color:var(--el-color-success-light-5);background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{color:var(--el-color-warning-light-5);background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{color:var(--el-color-danger-light-5);background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{color:var(--el-color-info-light-5);background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8)}.el-button--large{--el-button-size:40px;height:var(--el-button-size);padding:12px 19px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{width:var(--el-button-size);padding:12px}.el-button--small{--el-button-size:24px;height:var(--el-button-size);padding:5px 11px;font-size:12px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{width:var(--el-button-size);padding:5px}:root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:.5}.v-modal-enter{-webkit-animation:v-modal-in var(--el-transition-duration-fast) ease;animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{-webkit-animation:v-modal-out var(--el-transition-duration-fast) ease forwards;animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@-webkit-keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-in{0%{opacity:0}}@-webkit-keyframes v-modal-out{to{opacity:0}}@keyframes v-modal-out{to{opacity:0}}.v-modal{position:fixed;left:0;top:0;width:100%;height:100%;opacity:var(--el-popup-modal-opacity);background:var(--el-popup-modal-bg-color)}.el-popup-parent--hidden{overflow:hidden}.el-message-box{--el-messagebox-title-color:var(--el-text-color-primary);--el-messagebox-width:420px;--el-messagebox-border-radius:4px;--el-messagebox-font-size:var(--el-font-size-large);--el-messagebox-content-font-size:var(--el-font-size-base);--el-messagebox-content-color:var(--el-text-color-regular);--el-messagebox-error-font-size:12px;--el-messagebox-padding-primary:15px}.el-message-box{display:inline-block;max-width:var(--el-messagebox-width);width:100%;padding-bottom:10px;vertical-align:middle;background-color:var(--el-bg-color);border-radius:var(--el-messagebox-border-radius);border:1px solid var(--el-border-color-lighter);font-size:var(--el-messagebox-font-size);box-shadow:var(--el-box-shadow-light);text-align:left;overflow:hidden;-webkit-backface-visibility:hidden;backface-visibility:hidden;box-sizing:border-box}.el-message-box:focus{outline:0!important}.el-overlay.is-message-box .el-overlay-message-box{text-align:center;position:fixed;top:0;right:0;bottom:0;left:0;padding:16px;overflow:auto}.el-overlay.is-message-box .el-overlay-message-box:after{content:"";display:inline-block;height:100%;width:0;vertical-align:middle}.el-message-box.is-draggable .el-message-box__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-message-box__header{position:relative;padding:var(--el-messagebox-padding-primary);padding-bottom:10px}.el-message-box__title{padding-left:0;margin-bottom:0;font-size:var(--el-messagebox-font-size);line-height:1;color:var(--el-messagebox-title-color)}.el-message-box__headerbtn{position:absolute;top:var(--el-messagebox-padding-primary);right:var(--el-messagebox-padding-primary);padding:0;border:none;outline:0;background:0 0;font-size:var(--el-message-close-size,16px);cursor:pointer}.el-message-box__headerbtn .el-message-box__close{color:var(--el-color-info);font-size:inherit}.el-message-box__headerbtn:focus .el-message-box__close,.el-message-box__headerbtn:hover .el-message-box__close{color:var(--el-color-primary)}.el-message-box__content{padding:10px var(--el-messagebox-padding-primary);color:var(--el-messagebox-content-color);font-size:var(--el-messagebox-content-font-size)}.el-message-box__container{position:relative}.el-message-box__input{padding-top:15px}.el-message-box__input div.invalid>input{border-color:var(--el-color-error)}.el-message-box__input div.invalid>input:focus{border-color:var(--el-color-error)}.el-message-box__status{position:absolute;top:50%;transform:translateY(-50%);font-size:24px!important}.el-message-box__status:before{padding-left:1px}.el-message-box__status.el-icon{position:absolute}.el-message-box__status+.el-message-box__message{padding-left:36px;padding-right:12px;word-break:break-word}.el-message-box__status.el-message-box-icon--success{--el-messagebox-color:var(--el-color-success);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--info{--el-messagebox-color:var(--el-color-info);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--warning{--el-messagebox-color:var(--el-color-warning);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--error{--el-messagebox-color:var(--el-color-error);color:var(--el-messagebox-color)}.el-message-box__message{margin:0}.el-message-box__message p{margin:0;line-height:24px}.el-message-box__errormsg{color:var(--el-color-error);font-size:var(--el-messagebox-error-font-size);min-height:18px;margin-top:2px}.el-message-box__btns{padding:5px 15px 0;display:flex;flex-wrap:wrap;justify-content:flex-end;align-items:center}.el-message-box__btns button:nth-child(2){margin-left:10px}.el-message-box__btns-reverse{flex-direction:row-reverse}.el-message-box--center .el-message-box__title{position:relative;display:flex;align-items:center;justify-content:center}.el-message-box--center .el-message-box__status{position:relative;top:auto;padding-right:5px;text-align:center;transform:translateY(-1px)}.el-message-box--center .el-message-box__message{margin-left:0}.el-message-box--center .el-message-box__btns{justify-content:center}.el-message-box--center .el-message-box__content{padding-left:calc(var(--el-messagebox-padding-primary) + 12px);padding-right:calc(var(--el-messagebox-padding-primary) + 12px);text-align:center}.fade-in-linear-enter-active .el-overlay-message-box{-webkit-animation:msgbox-fade-in var(--el-transition-duration);animation:msgbox-fade-in var(--el-transition-duration)}.fade-in-linear-leave-active .el-overlay-message-box{animation:msgbox-fade-in var(--el-transition-duration) reverse}@-webkit-keyframes msgbox-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes msgbox-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@-webkit-keyframes msgbox-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}@keyframes msgbox-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}.el-badge{--el-badge-bg-color:var(--el-color-danger);--el-badge-radius:10px;--el-badge-font-size:12px;--el-badge-padding:6px;--el-badge-size:18px;position:relative;vertical-align:middle;display:inline-block;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content}.el-badge__content{background-color:var(--el-badge-bg-color);border-radius:var(--el-badge-radius);color:var(--el-color-white);display:inline-flex;justify-content:center;align-items:center;font-size:var(--el-badge-font-size);height:var(--el-badge-size);padding:0 var(--el-badge-padding);white-space:nowrap;border:1px solid var(--el-bg-color)}.el-badge__content.is-fixed{position:absolute;top:0;right:calc(1px + var(--el-badge-size)/ 2);transform:translateY(-50%) translate(100%);z-index:var(--el-index-normal)}.el-badge__content.is-fixed.is-dot{right:5px}.el-badge__content.is-dot{height:8px;width:8px;padding:0;right:0;border-radius:50%}.el-badge__content--primary{background-color:var(--el-color-primary)}.el-badge__content--success{background-color:var(--el-color-success)}.el-badge__content--warning{background-color:var(--el-color-warning)}.el-badge__content--info{background-color:var(--el-color-info)}.el-badge__content--danger{background-color:var(--el-color-danger)}.el-message{--el-message-bg-color:var(--el-color-info-light-9);--el-message-border-color:var(--el-border-color-lighter);--el-message-padding:15px 19px;--el-message-close-size:16px;--el-message-close-icon-color:var(--el-text-color-placeholder);--el-message-close-hover-color:var(--el-text-color-secondary)}.el-message{width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;max-width:calc(100% - 32px);box-sizing:border-box;border-radius:var(--el-border-radius-base);border-width:var(--el-border-width);border-style:var(--el-border-style);border-color:var(--el-message-border-color);position:fixed;left:50%;top:20px;transform:translate(-50%);background-color:var(--el-message-bg-color);transition:opacity var(--el-transition-duration),transform .4s,top .4s;padding:var(--el-message-padding);display:flex;align-items:center}.el-message.is-center{justify-content:center}.el-message.is-closable .el-message__content{padding-right:31px}.el-message p{margin:0}.el-message--success{--el-message-bg-color:var(--el-color-success-light-9);--el-message-border-color:var(--el-color-success-light-8);--el-message-text-color:var(--el-color-success)}.el-message--success .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--success{color:var(--el-message-text-color)}.el-message--info{--el-message-bg-color:var(--el-color-info-light-9);--el-message-border-color:var(--el-color-info-light-8);--el-message-text-color:var(--el-color-info)}.el-message--info .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--info{color:var(--el-message-text-color)}.el-message--warning{--el-message-bg-color:var(--el-color-warning-light-9);--el-message-border-color:var(--el-color-warning-light-8);--el-message-text-color:var(--el-color-warning)}.el-message--warning .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--warning{color:var(--el-message-text-color)}.el-message--error{--el-message-bg-color:var(--el-color-error-light-9);--el-message-border-color:var(--el-color-error-light-8);--el-message-text-color:var(--el-color-error)}.el-message--error .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--error{color:var(--el-message-text-color)}.el-message__icon{margin-right:10px}.el-message .el-message__badge{position:absolute;top:-8px;right:-8px}.el-message__content{padding:0;font-size:14px;line-height:1}.el-message__content:focus{outline-width:0}.el-message .el-message__closeBtn{position:absolute;top:50%;right:19px;transform:translateY(-50%);cursor:pointer;color:var(--el-message-close-icon-color);font-size:var(--el-message-close-size)}.el-message .el-message__closeBtn:focus{outline-width:0}.el-message .el-message__closeBtn:hover{color:var(--el-message-close-hover-color)}.el-message-fade-enter-from,.el-message-fade-leave-to{opacity:0;transform:translate(-50%,-100%)}.onlineGallery-RuleEditor-modal{pointer-events:none!important}.onlineGallery-RuleEditor-modal .el-dialog__header{padding:15px 10px 5px 20px}.onlineGallery-RuleEditor-modal .el-dialog__header .el-dialog__headerbtn{top:0;right:0;width:50px;height:50px}.onlineGallery-RuleEditor-modal .el-dialog__body{padding:10px}.onlineGallery-RuleEditor-modal .el-dialog__body .el-container{position:relative;height:max-content;min-height:300px}.onlineGallery-RuleEditor-modal .el-dialog__body .el-container .el-tabs{height:90%}.onlineGallery-RuleEditor-modal .el-dialog__body .tree-item{display:flex;align-items:center;justify-content:space-between;overflow:hidden}.onlineGallery-RuleEditor-modal .el-dialog__body .tree-item.tree-item-normal{position:relative;flex-grow:1}.onlineGallery-RuleEditor-modal .el-dialog__body .tree-item.tree-item-normal>.label-ruleName{flex-grow:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.onlineGallery-RuleEditor-modal .el-dialog__body .tree-item.tree-item-normal>.icon-button-deleteRule{right:2px;display:flex;justify-content:center;align-items:center;color:red;font-size:medium}.onlineGallery-RuleEditor-modal .el-dialog__body .tree-item.tree-item-add-button>button{width:100%}.onlineGallery-RuleEditor-modal .el-dialog__footer{padding:10px}.el-popover{--el-popover-bg-color:var(--el-bg-color-overlay);--el-popover-font-size:var(--el-font-size-base);--el-popover-border-color:var(--el-border-color-lighter);--el-popover-padding:12px;--el-popover-padding-large:18px 20px;--el-popover-title-font-size:16px;--el-popover-title-text-color:var(--el-text-color-primary);--el-popover-border-radius:4px}.el-popover.el-popper{background:var(--el-popover-bg-color);min-width:150px;border-radius:var(--el-popover-border-radius);border:1px solid var(--el-popover-border-color);padding:var(--el-popover-padding);z-index:var(--el-index-popper);color:var(--el-text-color-regular);line-height:1.4;text-align:justify;font-size:var(--el-popover-font-size);box-shadow:var(--el-box-shadow-light);word-break:break-all;box-sizing:border-box}.el-popover.el-popper--plain{padding:var(--el-popover-padding-large)}.el-popover__title{color:var(--el-popover-title-text-color);font-size:var(--el-popover-title-font-size);line-height:1;margin-bottom:12px}.el-popover__reference:focus:hover,.el-popover__reference:focus:not(.focusing){outline-width:0}.el-popover.el-popper.is-dark{--el-popover-bg-color:var(--el-text-color-primary);--el-popover-border-color:var(--el-text-color-primary);--el-popover-title-text-color:var(--el-bg-color);color:var(--el-bg-color)}.el-popover.el-popper:focus,.el-popover.el-popper:focus:active{outline-width:0}*[data-v-00beb0aa]{margin:0!important;padding:0!important;border:0!important;box-sizing:border-box!important;z-index:0!important}[data-show=true][data-v-00beb0aa]{opacity:1;filter:blur(0px);transition:1s}[data-show=false][data-v-00beb0aa]{opacity:0;filter:blur(10px);transition:1s}*[data-v-ef6a9296]{border:0;margin:0;box-sizing:border-box;-webkit-user-select:none;user-select:none;-webkit-user-drag:none}.card[data-v-ef6a9296]{border:0!important;margin:0!important;padding:0!important;scroll-snap-align:start;position:relative;border-radius:4px;box-shadow:var(--el-box-shadow-dark);aspect-ratio:var(--aspect-ratio);max-width:100%;max-height:var(--cardMaxHeight);width:calc(var(--cardMaxHeight) * var(--aspect-ratio))!important;background-color:transparent;overflow:hidden;cursor:pointer;transition:.5s}.card[data-v-ef6a9296]:hover{box-shadow:1px 2px 12px 6px #00000080}.card .content[data-v-ef6a9296]{border:0!important;margin:0!important;padding:0!important;width:100%;height:auto;object-position:center;-webkit-user-drag:none;background-position:center;background-repeat:repeat;background-size:contain}.card .button-group[data-v-ef6a9296]{transition:.5s}.card .button-group[data-v-ef6a9296]{position:absolute;top:4px;right:4px;margin:0;width:24px;aspect-ratio:1;max-width:30px;max-height:30px}.card .button-group .button[data-v-ef6a9296]{position:absolute;margin:auto;left:0;top:0;right:0;bottom:0;font-size:small;box-shadow:var(--el-box-shadow-light)}.card .button-group .button.download[data-v-ef6a9296]{z-index:0}.card .button-group .button.toPosition[data-v-ef6a9296]{z-index:1}.card .button-group:hover .button.download[data-v-ef6a9296]{transform:translateY(26px)}.card .checkbox[data-v-ef6a9296]{position:absolute!important;height:fit-content;top:4px!important;left:4px!important;box-shadow:var(--el-box-shadow-light)}.card .tag-group[data-v-ef6a9296]{position:absolute;width:100%;bottom:4px;left:4px;display:flex;flex-flow:row wrap;gap:2px}.card .tag-group *[data-v-ef6a9296]{box-shadow:var(--el-box-shadow-light)}*[data-v-c777563b]{border:0;margin:0;box-sizing:border-box}.onlineGallery-listBody[data-v-c777563b]{width:100%;padding:10px;display:flex;flex-flow:row wrap;justify-content:center;align-items:stretch;align-content:start;gap:8px;transition:1s;-webkit-user-select:none;user-select:none;-webkit-user-drag:none}.v-enter-active[data-v-c777563b],.v-leave-active[data-v-c777563b]{transition:opacity .5s ease}.v-enter-from[data-v-c777563b],.v-leave-to[data-v-c777563b]{opacity:0}.list-move[data-v-c777563b],.list-enter-active[data-v-c777563b],.list-leave-active[data-v-c777563b]{transition:all .5s ease}.list-enter-from[data-v-c777563b],.list-leave-to[data-v-c777563b]{opacity:0;transform:translate(30px)}.list-leave-active[data-v-c777563b]{position:absolute}.el-button-group{display:inline-block;vertical-align:middle}.el-button-group:after,.el-button-group:before{display:table;content:""}.el-button-group:after{clear:both}.el-button-group>.el-button{float:left;position:relative}.el-button-group>.el-button+.el-button{margin-left:0}.el-button-group>.el-button:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.el-button-group>.el-button:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.el-button-group>.el-button:first-child:last-child{border-top-right-radius:var(--el-border-radius-base);border-bottom-right-radius:var(--el-border-radius-base);border-top-left-radius:var(--el-border-radius-base);border-bottom-left-radius:var(--el-border-radius-base)}.el-button-group>.el-button:first-child:last-child.is-round{border-radius:var(--el-border-radius-round)}.el-button-group>.el-button:first-child:last-child.is-circle{border-radius:50%}.el-button-group>.el-button:not(:first-child):not(:last-child){border-radius:0}.el-button-group>.el-button:not(:last-child){margin-right:-1px}.el-button-group>.el-button:active,.el-button-group>.el-button:focus,.el-button-group>.el-button:hover{z-index:1}.el-button-group>.el-button.is-active{z-index:1}.el-button-group>.el-dropdown>.el-button{border-top-left-radius:0;border-bottom-left-radius:0;border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-dropdown{--el-dropdown-menu-box-shadow:var(--el-box-shadow-light);--el-dropdown-menuItem-hover-fill:var(--el-color-primary-light-9);--el-dropdown-menuItem-hover-color:var(--el-color-primary);--el-dropdown-menu-index:10;display:inline-flex;position:relative;color:var(--el-text-color-regular);font-size:var(--el-font-size-base);line-height:1;vertical-align:top}.el-dropdown.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-dropdown__popper{--el-dropdown-menu-box-shadow:var(--el-box-shadow-light);--el-dropdown-menuItem-hover-fill:var(--el-color-primary-light-9);--el-dropdown-menuItem-hover-color:var(--el-color-primary);--el-dropdown-menu-index:10}.el-dropdown__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-dropdown-menu-box-shadow)}.el-dropdown__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-dropdown__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent;border-left-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent;border-bottom-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-dropdown__popper .el-dropdown-menu{border:none}.el-dropdown__popper .el-dropdown__popper-selfdefine{outline:0}.el-dropdown__popper .el-scrollbar__bar{z-index:calc(var(--el-dropdown-menu-index) + 1)}.el-dropdown__popper .el-dropdown__list{list-style:none;padding:0;margin:0;box-sizing:border-box}.el-dropdown .el-dropdown__caret-button{padding-left:0;padding-right:0;display:inline-flex;justify-content:center;align-items:center;width:32px;border-left:none}.el-dropdown .el-dropdown__caret-button>span{display:inline-flex}.el-dropdown .el-dropdown__caret-button:before{content:"";position:absolute;display:block;width:1px;top:-1px;bottom:-1px;left:0;background:var(--el-overlay-color-lighter)}.el-dropdown .el-dropdown__caret-button.el-button:before{background:var(--el-border-color);opacity:.5}.el-dropdown .el-dropdown__caret-button .el-dropdown__icon{font-size:inherit;padding-left:0}.el-dropdown .el-dropdown-selfdefine{outline:0}.el-dropdown--large .el-dropdown__caret-button{width:40px}.el-dropdown--small .el-dropdown__caret-button{width:24px}.el-dropdown-menu{position:relative;top:0;left:0;z-index:var(--el-dropdown-menu-index);padding:5px 0;margin:0;background-color:var(--el-bg-color-overlay);border:none;border-radius:var(--el-border-radius-base);box-shadow:none;list-style:none}.el-dropdown-menu__item{display:flex;align-items:center;white-space:nowrap;list-style:none;line-height:22px;padding:5px 16px;margin:0;font-size:var(--el-font-size-base);color:var(--el-text-color-regular);cursor:pointer;outline:0}.el-dropdown-menu__item:not(.is-disabled):focus{background-color:var(--el-dropdown-menuItem-hover-fill);color:var(--el-dropdown-menuItem-hover-color)}.el-dropdown-menu__item i{margin-right:5px}.el-dropdown-menu__item--divided{margin:6px 0;border-top:1px solid var(--el-border-color-lighter)}.el-dropdown-menu__item.is-disabled{cursor:not-allowed;color:var(--el-text-color-disabled)}.el-dropdown-menu--large{padding:7px 0}.el-dropdown-menu--large .el-dropdown-menu__item{padding:7px 20px;line-height:22px;font-size:14px}.el-dropdown-menu--large .el-dropdown-menu__item--divided{margin:8px 0}.el-dropdown-menu--small{padding:3px 0}.el-dropdown-menu--small .el-dropdown-menu__item{padding:2px 12px;line-height:20px;font-size:12px}.el-dropdown-menu--small .el-dropdown-menu__item--divided{margin:4px 0}.el-select-dropdown{z-index:calc(var(--el-index-top) + 1);border-radius:var(--el-border-radius-base);box-sizing:border-box}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown__option-item.is-selected:not(.is-multiple).is-disabled{color:var(--el-text-color-disabled)}.el-select-dropdown__option-item.is-selected:not(.is-multiple).is-disabled:after{background-color:var(--el-text-color-disabled)}.el-select-dropdown__option-item:hover:not(.hover){background-color:transparent}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-disabled.is-selected{color:var(--el-text-color-disabled)}.el-select-dropdown__empty{padding:10px 0;margin:0;text-align:center;color:var(--el-text-color-secondary);font-size:var(--el-select-font-size)}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{list-style:none;margin:6px 0!important;padding:0!important;box-sizing:border-box}.el-select-dropdown__option-item{font-size:var(--el-select-font-size);padding:0 32px 0 20px;position:relative;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--el-text-color-regular);height:34px;line-height:34px;box-sizing:border-box;cursor:pointer}.el-select-dropdown__option-item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select-dropdown__option-item.is-disabled:hover{background-color:var(--el-bg-color)}.el-select-dropdown__option-item.is-selected{background-color:var(--el-fill-color-light);font-weight:700}.el-select-dropdown__option-item.is-selected:not(.is-multiple){color:var(--el-color-primary)}.el-select-dropdown__option-item.hover{background-color:var(--el-fill-color-light)!important}.el-select-dropdown__option-item:hover{background-color:var(--el-fill-color-light)}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-selected{color:var(--el-color-primary);background-color:var(--el-bg-color-overlay)}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-selected .el-icon{position:absolute;right:20px;top:0;height:inherit;font-size:12px}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-selected .el-icon svg{height:inherit;vertical-align:middle}.el-select-group{margin:0;padding:0}.el-select-group__wrap{position:relative;list-style:none;margin:0;padding:0}.el-select-group__wrap:not(:last-of-type){padding-bottom:24px}.el-select-group__wrap:not(:last-of-type):after{content:"";position:absolute;display:block;left:20px;right:20px;bottom:12px;height:1px;background:var(--el-border-color-light)}.el-select-group__split-dash{position:absolute;left:20px;right:20px;height:1px;background:var(--el-border-color-light)}.el-select-group__title{padding-left:20px;font-size:12px;color:var(--el-color-info);line-height:30px}.el-select-group .el-select-dropdown__item{padding-left:20px}.el-select-v2{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px}.el-select-v2{display:inline-block;position:relative;vertical-align:middle;font-size:14px}.el-select-v2__wrapper{display:flex;align-items:center;flex-wrap:wrap;position:relative;box-sizing:border-box;cursor:pointer;padding:1px 30px 1px 0;border:1px solid var(--el-border-color);border-radius:var(--el-border-radius-base);background-color:var(--el-fill-color-blank);transition:var(--el-transition-duration)}.el-select-v2__wrapper:hover{border-color:var(--el-text-color-placeholder)}.el-select-v2__wrapper.is-filterable{cursor:text}.el-select-v2__wrapper.is-focused{border-color:var(--el-color-primary)}.el-select-v2__wrapper.is-hovering:not(.is-focused){border-color:var(--el-border-color-hover)}.el-select-v2__wrapper.is-disabled{cursor:not-allowed;background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);border-color:var(--el-select-disabled-border)}.el-select-v2__wrapper.is-disabled:hover{border-color:var(--el-select-disabled-border)}.el-select-v2__wrapper.is-disabled.is-focus{border-color:var(--el-input-focus-border-color)}.el-select-v2__wrapper.is-disabled .is-transparent{opacity:1;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-select-v2__wrapper.is-disabled .el-select-v2__caret,.el-select-v2__wrapper.is-disabled .el-select-v2__combobox-input{cursor:not-allowed}.el-select-v2__wrapper .el-select-v2__input-wrapper{box-sizing:border-box;position:relative;-webkit-margin-start:12px;margin-inline-start:12px;max-width:100%;overflow:hidden}.el-select-v2__wrapper,.el-select-v2__wrapper .el-select-v2__input-wrapper{line-height:32px}.el-select-v2__wrapper .el-select-v2__input-wrapper input{--el-input-inner-height:calc(var(--el-component-size, 32px) - 8px);height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);min-width:4px;width:100%;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none;background:0 0;border:none;margin:2px 0;outline:0;padding:0}.el-select-v2 .el-select-v2__tags-text{display:inline-block;line-height:normal;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select-v2__empty{padding:10px 0;margin:0;text-align:center;color:var(--el-text-color-secondary);font-size:14px}.el-select-v2__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-select-v2__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-select-v2__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent;border-left-color:transparent}.el-select-v2__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-select-v2__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent;border-bottom-color:transparent}.el-select-v2__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-select-v2--large .el-select-v2__wrapper .el-select-v2__combobox-input{height:32px}.el-select-v2--large .el-select-v2__caret,.el-select-v2--large .el-select-v2__suffix{height:40px}.el-select-v2--large .el-select-v2__placeholder{font-size:14px;line-height:40px}.el-select-v2--small .el-select-v2__wrapper .el-select-v2__combobox-input{height:16px}.el-select-v2--small .el-select-v2__caret,.el-select-v2--small .el-select-v2__suffix{height:24px}.el-select-v2--small .el-select-v2__placeholder{font-size:12px;line-height:24px}.el-select-v2 .el-select-v2__selection>span{display:inline-block}.el-select-v2:hover .el-select-v2__combobox-input{border-color:var(--el-select-border-color-hover)}.el-select-v2 .el-select__selection-text{text-overflow:ellipsis;display:inline-block;overflow-x:hidden;vertical-align:bottom}.el-select-v2 .el-select-v2__combobox-input{padding-right:35px;display:block;color:var(--el-text-color-regular)}.el-select-v2 .el-select-v2__combobox-input:focus{border-color:var(--el-select-input-focus-border-color)}.el-select-v2__input{border:none;outline:0;padding:0;margin-left:15px;color:var(--el-select-multiple-input-color);font-size:var(--el-select-font-size);-webkit-appearance:none;-moz-appearance:none;appearance:none;height:28px}.el-select-v2__input.is-small{height:14px}.el-select-v2__close{cursor:pointer;position:absolute;top:8px;z-index:var(--el-index-top);right:25px;color:var(--el-select-input-color);line-height:18px;font-size:var(--el-select-input-font-size)}.el-select-v2__close:hover{color:var(--el-select-close-hover-color)}.el-select-v2__suffix{display:inline-flex;position:absolute;right:12px;height:32px;top:50%;transform:translateY(-50%);color:var(--el-input-icon-color,var(--el-text-color-placeholder))}.el-select-v2__suffix .el-input__icon{height:inherit}.el-select-v2__suffix .el-input__icon:not(:first-child){margin-left:8px}.el-select-v2__caret{color:var(--el-select-input-color);font-size:var(--el-select-input-font-size);transition:var(--el-transition-duration);transform:rotate(180deg);cursor:pointer}.el-select-v2__caret.is-reverse{transform:rotate(0)}.el-select-v2__caret.is-show-close{font-size:var(--el-select-font-size);text-align:center;transform:rotate(180deg);border-radius:var(--el-border-radius-circle);color:var(--el-select-input-color);transition:var(--el-transition-color)}.el-select-v2__caret.is-show-close:hover{color:var(--el-select-close-hover-color)}.el-select-v2__caret.el-icon{height:inherit}.el-select-v2__caret.el-icon svg{vertical-align:middle}.el-select-v2__selection{white-space:normal;z-index:var(--el-index-normal);display:flex;align-items:center;flex-wrap:wrap;width:100%}.el-select-v2__input-calculator{left:0;position:absolute;top:0;visibility:hidden;white-space:pre;z-index:999}.el-select-v2__selected-item{line-height:inherit;height:inherit;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-wrap:wrap}.el-select-v2__placeholder{position:absolute;top:50%;transform:translateY(-50%);-webkit-margin-start:12px;margin-inline-start:12px;width:calc(100% - 52px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--el-input-text-color,var(--el-text-color-regular))}.el-select-v2__placeholder.is-transparent{color:var(--el-text-color-placeholder)}.el-select-v2 .el-select-v2__selection .el-tag{box-sizing:border-box;border-color:transparent;margin:2px 0 2px 6px;background-color:var(--el-fill-color)}.el-select-v2 .el-select-v2__selection .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);right:-7px;color:var(--el-color-white)}.el-select-v2 .el-select-v2__selection .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-select-v2 .el-select-v2__selection .el-tag .el-icon-close:before{display:block;transform:translateY(.5px)}.el-select-v2.el-select-v2--small .el-select-v2__selection .el-tag{margin:1px 0 1px 6px;height:18px}.el-slider{--el-slider-main-bg-color:var(--el-color-primary);--el-slider-runway-bg-color:var(--el-border-color-light);--el-slider-stop-bg-color:var(--el-color-white);--el-slider-disabled-color:var(--el-text-color-placeholder);--el-slider-border-radius:3px;--el-slider-height:6px;--el-slider-button-size:20px;--el-slider-button-wrapper-size:36px;--el-slider-button-wrapper-offset:-15px}.el-slider{width:100%;height:32px;display:flex;align-items:center}.el-slider__runway{flex:1;height:var(--el-slider-height);background-color:var(--el-slider-runway-bg-color);border-radius:var(--el-slider-border-radius);position:relative;cursor:pointer}.el-slider__runway.show-input{margin-right:30px;width:auto}.el-slider__runway.is-disabled{cursor:default}.el-slider__runway.is-disabled .el-slider__bar{background-color:var(--el-slider-disabled-color)}.el-slider__runway.is-disabled .el-slider__button{border-color:var(--el-slider-disabled-color)}.el-slider__runway.is-disabled .el-slider__button-wrapper.hover,.el-slider__runway.is-disabled .el-slider__button-wrapper:hover,.el-slider__runway.is-disabled .el-slider__button-wrapper.dragging{cursor:not-allowed}.el-slider__runway.is-disabled .el-slider__button.dragging,.el-slider__runway.is-disabled .el-slider__button.hover,.el-slider__runway.is-disabled .el-slider__button:hover{transform:scale(1)}.el-slider__runway.is-disabled .el-slider__button.hover,.el-slider__runway.is-disabled .el-slider__button:hover,.el-slider__runway.is-disabled .el-slider__button.dragging{cursor:not-allowed}.el-slider__input{flex-shrink:0;width:130px}.el-slider__bar{height:var(--el-slider-height);background-color:var(--el-slider-main-bg-color);border-top-left-radius:var(--el-slider-border-radius);border-bottom-left-radius:var(--el-slider-border-radius);position:absolute}.el-slider__button-wrapper{height:var(--el-slider-button-wrapper-size);width:var(--el-slider-button-wrapper-size);position:absolute;z-index:1;top:var(--el-slider-button-wrapper-offset);transform:translate(-50%);background-color:transparent;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;line-height:normal;outline:0}.el-slider__button-wrapper:after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-slider__button-wrapper.hover,.el-slider__button-wrapper:hover{cursor:-webkit-grab;cursor:grab}.el-slider__button-wrapper.dragging{cursor:-webkit-grabbing;cursor:grabbing}.el-slider__button{display:inline-block;width:var(--el-slider-button-size);height:var(--el-slider-button-size);vertical-align:middle;border:solid 2px var(--el-slider-main-bg-color);background-color:var(--el-color-white);border-radius:50%;box-sizing:border-box;transition:var(--el-transition-duration-fast);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-slider__button.dragging,.el-slider__button.hover,.el-slider__button:hover{transform:scale(1.2)}.el-slider__button.hover,.el-slider__button:hover{cursor:-webkit-grab;cursor:grab}.el-slider__button.dragging{cursor:-webkit-grabbing;cursor:grabbing}.el-slider__stop{position:absolute;height:var(--el-slider-height);width:var(--el-slider-height);border-radius:var(--el-border-radius-circle);background-color:var(--el-slider-stop-bg-color);transform:translate(-50%)}.el-slider__marks{top:0;left:12px;width:18px;height:100%}.el-slider__marks-text{position:absolute;transform:translate(-50%);font-size:14px;color:var(--el-color-info);margin-top:15px;white-space:pre}.el-slider.is-vertical{position:relative;display:inline-flex;width:auto;height:100%;flex:0}.el-slider.is-vertical .el-slider__runway{width:var(--el-slider-height);height:100%;margin:0 16px}.el-slider.is-vertical .el-slider__bar{width:var(--el-slider-height);height:auto;border-radius:0 0 3px 3px}.el-slider.is-vertical .el-slider__button-wrapper{top:auto;left:var(--el-slider-button-wrapper-offset);transform:translateY(50%)}.el-slider.is-vertical .el-slider__stop{transform:translateY(50%)}.el-slider.is-vertical .el-slider__marks-text{margin-top:0;left:15px;transform:translateY(50%)}.el-slider--large{height:40px}.el-slider--small{height:24px}.el-input-number{position:relative;display:inline-flex;width:150px;line-height:30px}.el-input-number .el-input__wrapper{padding-left:42px;padding-right:42px}.el-input-number .el-input__inner{-webkit-appearance:none;-moz-appearance:textfield;text-align:center;line-height:1}.el-input-number .el-input__inner::-webkit-inner-spin-button,.el-input-number .el-input__inner::-webkit-outer-spin-button{margin:0;-webkit-appearance:none}.el-input-number__decrease,.el-input-number__increase{display:flex;justify-content:center;align-items:center;height:auto;position:absolute;z-index:1;top:1px;bottom:1px;width:32px;background:var(--el-fill-color-light);color:var(--el-text-color-regular);cursor:pointer;font-size:13px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-input-number__decrease:hover,.el-input-number__increase:hover{color:var(--el-color-primary)}.el-input-number__decrease:hover~.el-input:not(.is-disabled) .el-input__wrapper,.el-input-number__increase:hover~.el-input:not(.is-disabled) .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-input-number__decrease.is-disabled,.el-input-number__increase.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-input-number__increase{right:1px;border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0;border-left:var(--el-border)}.el-input-number__decrease{left:1px;border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);border-right:var(--el-border)}.el-input-number.is-disabled .el-input-number__decrease,.el-input-number.is-disabled .el-input-number__increase{border-color:var(--el-disabled-border-color);color:var(--el-disabled-border-color)}.el-input-number.is-disabled .el-input-number__decrease:hover,.el-input-number.is-disabled .el-input-number__increase:hover{color:var(--el-disabled-border-color);cursor:not-allowed}.el-input-number--large{width:180px;line-height:38px}.el-input-number--large .el-input-number__decrease,.el-input-number--large .el-input-number__increase{width:40px;font-size:14px}.el-input-number--large .el-input__wrapper{padding-left:47px;padding-right:47px}.el-input-number--small{width:120px;line-height:22px}.el-input-number--small .el-input-number__decrease,.el-input-number--small .el-input-number__increase{width:24px;font-size:12px}.el-input-number--small .el-input__wrapper{padding-left:31px;padding-right:31px}.el-input-number--small .el-input-number__decrease [class*=el-icon],.el-input-number--small .el-input-number__increase [class*=el-icon]{transform:scale(.9)}.el-input-number.is-without-controls .el-input__wrapper{padding-left:15px;padding-right:15px}.el-input-number.is-controls-right .el-input__wrapper{padding-left:15px;padding-right:42px}.el-input-number.is-controls-right .el-input-number__decrease,.el-input-number.is-controls-right .el-input-number__increase{--el-input-number-controls-height:15px;height:var(--el-input-number-controls-height);line-height:var(--el-input-number-controls-height)}.el-input-number.is-controls-right .el-input-number__decrease [class*=el-icon],.el-input-number.is-controls-right .el-input-number__increase [class*=el-icon]{transform:scale(.8)}.el-input-number.is-controls-right .el-input-number__increase{bottom:auto;left:auto;border-radius:0 var(--el-border-radius-base) 0 0;border-bottom:var(--el-border)}.el-input-number.is-controls-right .el-input-number__decrease{right:1px;top:auto;left:auto;border-right:none;border-left:var(--el-border);border-radius:0 0 var(--el-border-radius-base) 0}.el-input-number.is-controls-right[class*=large] [class*=decrease],.el-input-number.is-controls-right[class*=large] [class*=increase]{--el-input-number-controls-height:19px}.el-input-number.is-controls-right[class*=small] [class*=decrease],.el-input-number.is-controls-right[class*=small] [class*=increase]{--el-input-number-controls-height:11px}.el-statistic{--el-statistic-title-font-weight:400;--el-statistic-title-font-size:var(--el-font-size-extra-small);--el-statistic-title-color:var(--el-text-color-regular);--el-statistic-content-font-weight:400;--el-statistic-content-font-size:var(--el-font-size-extra-large);--el-statistic-content-color:var(--el-text-color-primary)}.el-statistic__head{font-weight:var(--el-statistic-title-font-weight);font-size:var(--el-statistic-title-font-size);color:var(--el-statistic-title-color);line-height:20px;margin-bottom:4px}.el-statistic__content{font-weight:var(--el-statistic-content-font-weight);font-size:var(--el-statistic-content-font-size);color:var(--el-statistic-content-color)}.el-statistic__value{display:inline-block}.el-statistic__prefix{margin-right:4px;display:inline-block}.el-statistic__suffix{margin-left:4px;display:inline-block}*[data-v-07826213]{font-family:win-bug-omega,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Hiragino Kaku Gothic ProN,Meiryo,sans-serif!important}.onlineGallery-toolBar[data-v-07826213]{position:relative;margin-top:10px;margin-bottom:10px;display:flex;flex-flow:row wrap;justify-content:start;align-items:center;gap:14px;color:#000;-webkit-user-select:none;user-select:none;-webkit-user-drag:none}@media (max-width: 500px){.onlineGallery-toolBar[data-v-07826213]{gap:2px;margin-top:4px;margin-bottom:8px;padding-left:20px;padding-right:20px}}.onlineGallery-toolBar .statistic[data-v-07826213]{flex-shrink:0;width:120px;font-size:16px!important;display:flex;flex-flow:column;justify-content:center;align-items:center}@media (max-width: 500px){.onlineGallery-toolBar .statistic[data-v-07826213]{width:100%;align-items:start}}.onlineGallery-toolBar .filter[data-v-07826213]{width:fit-content;display:flex;flex-flow:column;justify-content:center;align-items:center}@media (max-width: 500px){.onlineGallery-toolBar .filter[data-v-07826213]{width:100%;align-items:start;gap:2px}}.onlineGallery-toolBar .filter .size[data-v-07826213]{flex-grow:2;width:250px;display:flex;flex-flow:column nowrap}@media (max-width: 500px){.onlineGallery-toolBar .filter .size[data-v-07826213]{gap:2px}}.onlineGallery-toolBar .filter .size .row[data-v-07826213]{display:flex;flex-flow:row nowrap;gap:8px;justify-content:start;align-items:center}.onlineGallery-toolBar .filter .size .row .slider[data-v-07826213]{flex-grow:1}.onlineGallery-toolBar .filter .size .row .label[data-v-07826213]{margin:0;white-space:nowrap;font-size:16px!important}.onlineGallery-toolBar .filter .format[data-v-07826213]{width:250px;flex-grow:1;display:flex;flex-flow:row;justify-content:center;align-items:center;gap:8px}.onlineGallery-toolBar .filter .format .select[data-v-07826213]{flex-grow:1}.onlineGallery-toolBar .filter .format .label[data-v-07826213]{margin:0;text-align:center;white-space:nowrap;font-size:16px!important}.onlineGallery-toolBar .zoom-slider[data-v-07826213]{width:180px;font-size:16px!important}@media (max-width: 500px){.onlineGallery-toolBar .zoom-slider[data-v-07826213]{width:100%}}.onlineGallery-toolBar .button-group[data-v-07826213]{width:fit-content}.el-progress{position:relative;line-height:1;display:flex;align-items:center}.el-progress__text{font-size:14px;color:var(--el-text-color-regular);margin-left:5px;min-width:50px;line-height:1}.el-progress__text i{vertical-align:middle;display:block}.el-progress--circle,.el-progress--dashboard{display:inline-block}.el-progress--circle .el-progress__text,.el-progress--dashboard .el-progress__text{position:absolute;top:50%;left:0;width:100%;text-align:center;margin:0;transform:translateY(-50%)}.el-progress--circle .el-progress__text i,.el-progress--dashboard .el-progress__text i{vertical-align:middle;display:inline-block}.el-progress--without-text .el-progress__text{display:none}.el-progress--without-text .el-progress-bar{padding-right:0;margin-right:0;display:block}.el-progress--text-inside .el-progress-bar{padding-right:0;margin-right:0}.el-progress.is-success .el-progress-bar__inner{background-color:var(--el-color-success)}.el-progress.is-success .el-progress__text{color:var(--el-color-success)}.el-progress.is-warning .el-progress-bar__inner{background-color:var(--el-color-warning)}.el-progress.is-warning .el-progress__text{color:var(--el-color-warning)}.el-progress.is-exception .el-progress-bar__inner{background-color:var(--el-color-danger)}.el-progress.is-exception .el-progress__text{color:var(--el-color-danger)}.el-progress-bar{flex-grow:1;box-sizing:border-box}.el-progress-bar__outer{height:6px;border-radius:100px;background-color:var(--el-border-color-lighter);overflow:hidden;position:relative;vertical-align:middle}.el-progress-bar__inner{position:absolute;left:0;top:0;height:100%;background-color:var(--el-color-primary);text-align:right;border-radius:100px;line-height:1;white-space:nowrap;transition:width .6s ease}.el-progress-bar__inner:after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-progress-bar__inner--indeterminate{transform:translateZ(0);-webkit-animation:indeterminate 3s infinite;animation:indeterminate 3s infinite}.el-progress-bar__inner--striped{background-image:linear-gradient(45deg,rgba(0,0,0,.1) 25%,transparent 25%,transparent 50%,rgba(0,0,0,.1) 50%,rgba(0,0,0,.1) 75%,transparent 75%,transparent);background-size:1.25em 1.25em}.el-progress-bar__inner--striped.el-progress-bar__inner--striped-flow{-webkit-animation:striped-flow 3s linear infinite;animation:striped-flow 3s linear infinite}.el-progress-bar__innerText{display:inline-block;vertical-align:middle;color:#fff;font-size:12px;margin:0 5px}@-webkit-keyframes progress{0%{background-position:0 0}to{background-position:32px 0}}@keyframes progress{0%{background-position:0 0}to{background-position:32px 0}}@-webkit-keyframes indeterminate{0%{left:-100%}to{left:100%}}@keyframes indeterminate{0%{left:-100%}to{left:100%}}@-webkit-keyframes striped-flow{0%{background-position:-100%}to{background-position:100%}}@keyframes striped-flow{0%{background-position:-100%}to{background-position:100%}}*[data-v-d6047953]{border:0;margin:0;box-sizing:border-box}.onlineGallery-body[data-v-d6047953]{position:relative;width:100%;height:100%;display:flex;flex-flow:column;justify-content:stretch;align-items:center;--header-height: 80px}.onlineGallery-body .toolBar[data-v-d6047953]{flex-shrink:0;position:relative;max-width:100%;width:100%;height:max-content}.onlineGallery-body .listContainer[data-v-d6047953]{flex-grow:1;position:relative;width:100%;border-radius:6px;box-shadow:var(--el-box-shadow-light);overflow:hidden}.onlineGallery-body .loadingBar[data-v-d6047953]{position:absolute;margin:0 auto;top:2px;left:0;right:0;width:50%}@media (max-width: 500px){.onlineGallery-body .loadingBar[data-v-d6047953]{width:80%}}.el-notification{--el-notification-width:330px;--el-notification-padding:14px 26px 14px 13px;--el-notification-radius:8px;--el-notification-shadow:var(--el-box-shadow-light);--el-notification-border-color:var(--el-border-color-lighter);--el-notification-icon-size:24px;--el-notification-close-font-size:var(--el-message-close-size, 16px);--el-notification-group-margin-left:13px;--el-notification-group-margin-right:8px;--el-notification-content-font-size:var(--el-font-size-base);--el-notification-content-color:var(--el-text-color-regular);--el-notification-title-font-size:16px;--el-notification-title-color:var(--el-text-color-primary);--el-notification-close-color:var(--el-text-color-secondary);--el-notification-close-hover-color:var(--el-text-color-regular)}.el-notification{display:flex;width:var(--el-notification-width);padding:var(--el-notification-padding);border-radius:var(--el-notification-radius);box-sizing:border-box;border:1px solid var(--el-notification-border-color);position:fixed;background-color:var(--el-bg-color-overlay);box-shadow:var(--el-notification-shadow);transition:opacity var(--el-transition-duration),transform var(--el-transition-duration),left var(--el-transition-duration),right var(--el-transition-duration),top .4s,bottom var(--el-transition-duration);overflow-wrap:anywhere;overflow:hidden;z-index:9999}.el-notification.right{right:16px}.el-notification.left{left:16px}.el-notification__group{margin-left:var(--el-notification-group-margin-left);margin-right:var(--el-notification-group-margin-right)}.el-notification__title{font-weight:700;font-size:var(--el-notification-title-font-size);line-height:var(--el-notification-icon-size);color:var(--el-notification-title-color);margin:0}.el-notification__content{font-size:var(--el-notification-content-font-size);line-height:24px;margin:6px 0 0;color:var(--el-notification-content-color);text-align:justify}.el-notification__content p{margin:0}.el-notification .el-notification__icon{height:var(--el-notification-icon-size);width:var(--el-notification-icon-size);font-size:var(--el-notification-icon-size)}.el-notification .el-notification__closeBtn{position:absolute;top:18px;right:15px;cursor:pointer;color:var(--el-notification-close-color);font-size:var(--el-notification-close-font-size)}.el-notification .el-notification__closeBtn:hover{color:var(--el-notification-close-hover-color)}.el-notification .el-notification--success{--el-notification-icon-color:var(--el-color-success);color:var(--el-notification-icon-color)}.el-notification .el-notification--info{--el-notification-icon-color:var(--el-color-info);color:var(--el-notification-icon-color)}.el-notification .el-notification--warning{--el-notification-icon-color:var(--el-color-warning);color:var(--el-notification-icon-color)}.el-notification .el-notification--error{--el-notification-icon-color:var(--el-color-error);color:var(--el-notification-icon-color)}.el-notification-fade-enter-from.right{right:0;transform:translate(100%)}.el-notification-fade-enter-from.left{left:0;transform:translate(-100%)}.el-notification-fade-leave-to{opacity:0}*[data-v-e88cacf6]{box-sizing:border-box;border:0;pointer-events:auto}.onlineGallery-container[data-v-e88cacf6]{box-sizing:border-box;position:fixed;z-index:2147483646;padding:0 30px 20px;margin:0;left:calc(0px - var(--width));top:0!important;bottom:0;width:var(--width);max-width:100vw!important;background-color:#fffc;box-shadow:var(--el-box-shadow-dark);-webkit-backdrop-filter:blur(2px);backdrop-filter:blur(2px);display:flex;flex-flow:column;justify-content:start;align-items:center;transition:.5s ease}.onlineGallery-container[data-open=true][data-v-e88cacf6]{left:0px!important}.onlineGallery-container[data-v-e88cacf6]:focus{outline:none}@media (max-width: 500px){.onlineGallery-container[data-v-e88cacf6]{padding:4px}}.onlineGallery-button-drawerOpen[data-v-e88cacf6]{position:absolute;z-index:1;margin:auto 0;width:30px;height:60px;border-radius:0 30px 30px 0;right:0;top:0;bottom:0;cursor:pointer;display:flex;justify-content:center;align-items:center;font-size:xx-large}:root:has(.onlineGallery-container[data-open=false]) .onlineGallery-button-drawerOpen[data-v-e88cacf6]{border-radius:0 30px 30px 0!important;box-shadow:var(--el-box-shadow-light);right:-30px;transition:.25s .25s ease}:root:has(.onlineGallery-container[data-open=true]) .onlineGallery-button-drawerOpen[data-v-e88cacf6]{border-radius:30px 0 0 30px!important;background-color:transparent;box-shadow:none;transition:.25s .25s ease}.onlineGallery-button-drawerOpen i[data-v-e88cacf6]{transition:.25s .25s ease}:root:has(.onlineGallery-container[data-open=false]) .onlineGallery-button-drawerOpen i[data-v-e88cacf6]{transform:rotateY(0);color:auto}:root:has(.onlineGallery-container[data-open=true]) .onlineGallery-button-drawerOpen i[data-v-e88cacf6]{transform:rotateY(180deg);color:#409eff}@media (max-width: 500px){.onlineGallery-button-drawerOpen[data-v-e88cacf6]{right:-30px!important}.onlineGallery-button-drawerOpen i[data-v-e88cacf6]{transform:rotateY(0)!important}}.onlineGallery-button-close[data-v-e88cacf6]{position:absolute;right:10px;top:10px;width:fit-content;height:fit-content;box-shadow:var(--el-box-shadow-light)}.onlineGallery-child-window-container[data-v-e88cacf6]{position:fixed;z-index:2147483646;overflow:visible} `);

(function (JSZip$1) {
  'use strict';

  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var require_main_001 = __commonJS({
    "main-e78d246e.js"(exports, module) {
      function makeMap(str, expectsLowerCase) {
        const map = /* @__PURE__ */ Object.create(null);
        const list = str.split(",");
        for (let i = 0; i < list.length; i++) {
          map[list[i]] = true;
        }
        return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
      }
      const EMPTY_OBJ = {};
      const EMPTY_ARR = [];
      const NOOP = () => {
      };
      const NO = () => false;
      const onRE = /^on[^a-z]/;
      const isOn = (key) => onRE.test(key);
      const isModelListener = (key) => key.startsWith("onUpdate:");
      const extend = Object.assign;
      const remove = (arr, el) => {
        const i = arr.indexOf(el);
        if (i > -1) {
          arr.splice(i, 1);
        }
      };
      const hasOwnProperty$d = Object.prototype.hasOwnProperty;
      const hasOwn = (val, key) => hasOwnProperty$d.call(val, key);
      const isArray$2 = Array.isArray;
      const isMap$2 = (val) => toTypeString(val) === "[object Map]";
      const isSet$2 = (val) => toTypeString(val) === "[object Set]";
      const isDate = (val) => toTypeString(val) === "[object Date]";
      const isFunction$1 = (val) => typeof val === "function";
      const isString$1 = (val) => typeof val === "string";
      const isSymbol$1 = (val) => typeof val === "symbol";
      const isObject$1 = (val) => val !== null && typeof val === "object";
      const isPromise = (val) => {
        return isObject$1(val) && isFunction$1(val.then) && isFunction$1(val.catch);
      };
      const objectToString$1 = Object.prototype.toString;
      const toTypeString = (value) => objectToString$1.call(value);
      const toRawType = (value) => {
        return toTypeString(value).slice(8, -1);
      };
      const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
      const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
      const isReservedProp = /* @__PURE__ */ makeMap(
        // the leading comma is intentional so empty string "" is also included
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
      );
      const cacheStringFunction = (fn2) => {
        const cache2 = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache2[str];
          return hit || (cache2[str] = fn2(str));
        };
      };
      const camelizeRE = /-(\w)/g;
      const camelize = cacheStringFunction((str) => {
        return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
      });
      const hyphenateRE = /\B([A-Z])/g;
      const hyphenate = cacheStringFunction(
        (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
      );
      const capitalize$1 = cacheStringFunction(
        (str) => str.charAt(0).toUpperCase() + str.slice(1)
      );
      const toHandlerKey = cacheStringFunction(
        (str) => str ? `on${capitalize$1(str)}` : ``
      );
      const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
      const invokeArrayFns = (fns, arg) => {
        for (let i = 0; i < fns.length; i++) {
          fns[i](arg);
        }
      };
      const def = (obj, key, value) => {
        Object.defineProperty(obj, key, {
          configurable: true,
          enumerable: false,
          value
        });
      };
      const looseToNumber = (val) => {
        const n = parseFloat(val);
        return isNaN(n) ? val : n;
      };
      const toNumber$1 = (val) => {
        const n = isString$1(val) ? Number(val) : NaN;
        return isNaN(n) ? val : n;
      };
      let _globalThis;
      const getGlobalThis = () => {
        return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
      };
      function normalizeStyle(value) {
        if (isArray$2(value)) {
          const res = {};
          for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) {
              for (const key in normalized) {
                res[key] = normalized[key];
              }
            }
          }
          return res;
        } else if (isString$1(value)) {
          return value;
        } else if (isObject$1(value)) {
          return value;
        }
      }
      const listDelimiterRE = /;(?![^(]*\))/g;
      const propertyDelimiterRE = /:([^]+)/;
      const styleCommentRE = /\/\*[^]*?\*\//g;
      function parseStringStyle(cssText) {
        const ret = {};
        cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
          if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
          }
        });
        return ret;
      }
      function normalizeClass(value) {
        let res = "";
        if (isString$1(value)) {
          res = value;
        } else if (isArray$2(value)) {
          for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
              res += normalized + " ";
            }
          }
        } else if (isObject$1(value)) {
          for (const name in value) {
            if (value[name]) {
              res += name + " ";
            }
          }
        }
        return res.trim();
      }
      function normalizeProps(props) {
        if (!props)
          return null;
        let { class: klass, style } = props;
        if (klass && !isString$1(klass)) {
          props.class = normalizeClass(klass);
        }
        if (style) {
          props.style = normalizeStyle(style);
        }
        return props;
      }
      const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
      const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
      function includeBooleanAttr(value) {
        return !!value || value === "";
      }
      function looseCompareArrays(a, b) {
        if (a.length !== b.length)
          return false;
        let equal = true;
        for (let i = 0; equal && i < a.length; i++) {
          equal = looseEqual(a[i], b[i]);
        }
        return equal;
      }
      function looseEqual(a, b) {
        if (a === b)
          return true;
        let aValidType = isDate(a);
        let bValidType = isDate(b);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? a.getTime() === b.getTime() : false;
        }
        aValidType = isSymbol$1(a);
        bValidType = isSymbol$1(b);
        if (aValidType || bValidType) {
          return a === b;
        }
        aValidType = isArray$2(a);
        bValidType = isArray$2(b);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? looseCompareArrays(a, b) : false;
        }
        aValidType = isObject$1(a);
        bValidType = isObject$1(b);
        if (aValidType || bValidType) {
          if (!aValidType || !bValidType) {
            return false;
          }
          const aKeysCount = Object.keys(a).length;
          const bKeysCount = Object.keys(b).length;
          if (aKeysCount !== bKeysCount) {
            return false;
          }
          for (const key in a) {
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
              return false;
            }
          }
        }
        return String(a) === String(b);
      }
      function looseIndexOf(arr, val) {
        return arr.findIndex((item) => looseEqual(item, val));
      }
      const toDisplayString = (val) => {
        return isString$1(val) ? val : val == null ? "" : isArray$2(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
      };
      const replacer = (_key, val) => {
        if (val && val.__v_isRef) {
          return replacer(_key, val.value);
        } else if (isMap$2(val)) {
          return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
              entries[`${key} =>`] = val2;
              return entries;
            }, {})
          };
        } else if (isSet$2(val)) {
          return {
            [`Set(${val.size})`]: [...val.values()]
          };
        } else if (isObject$1(val) && !isArray$2(val) && !isPlainObject$1(val)) {
          return String(val);
        }
        return val;
      };
      let activeEffectScope;
      class EffectScope {
        constructor(detached = false) {
          this.detached = detached;
          this._active = true;
          this.effects = [];
          this.cleanups = [];
          this.parent = activeEffectScope;
          if (!detached && activeEffectScope) {
            this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
              this
            ) - 1;
          }
        }
        get active() {
          return this._active;
        }
        run(fn2) {
          if (this._active) {
            const currentEffectScope = activeEffectScope;
            try {
              activeEffectScope = this;
              return fn2();
            } finally {
              activeEffectScope = currentEffectScope;
            }
          }
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        on() {
          activeEffectScope = this;
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        off() {
          activeEffectScope = this.parent;
        }
        stop(fromParent) {
          if (this._active) {
            let i, l;
            for (i = 0, l = this.effects.length; i < l; i++) {
              this.effects[i].stop();
            }
            for (i = 0, l = this.cleanups.length; i < l; i++) {
              this.cleanups[i]();
            }
            if (this.scopes) {
              for (i = 0, l = this.scopes.length; i < l; i++) {
                this.scopes[i].stop(true);
              }
            }
            if (!this.detached && this.parent && !fromParent) {
              const last = this.parent.scopes.pop();
              if (last && last !== this) {
                this.parent.scopes[this.index] = last;
                last.index = this.index;
              }
            }
            this.parent = void 0;
            this._active = false;
          }
        }
      }
      function effectScope(detached) {
        return new EffectScope(detached);
      }
      function recordEffectScope(effect, scope = activeEffectScope) {
        if (scope && scope.active) {
          scope.effects.push(effect);
        }
      }
      function getCurrentScope() {
        return activeEffectScope;
      }
      function onScopeDispose(fn2) {
        if (activeEffectScope) {
          activeEffectScope.cleanups.push(fn2);
        }
      }
      const createDep = (effects) => {
        const dep = new Set(effects);
        dep.w = 0;
        dep.n = 0;
        return dep;
      };
      const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
      const newTracked = (dep) => (dep.n & trackOpBit) > 0;
      const initDepMarkers = ({ deps }) => {
        if (deps.length) {
          for (let i = 0; i < deps.length; i++) {
            deps[i].w |= trackOpBit;
          }
        }
      };
      const finalizeDepMarkers = (effect) => {
        const { deps } = effect;
        if (deps.length) {
          let ptr = 0;
          for (let i = 0; i < deps.length; i++) {
            const dep = deps[i];
            if (wasTracked(dep) && !newTracked(dep)) {
              dep.delete(effect);
            } else {
              deps[ptr++] = dep;
            }
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
          }
          deps.length = ptr;
        }
      };
      const targetMap = /* @__PURE__ */ new WeakMap();
      let effectTrackDepth = 0;
      let trackOpBit = 1;
      const maxMarkerBits = 30;
      let activeEffect;
      const ITERATE_KEY = Symbol("");
      const MAP_KEY_ITERATE_KEY = Symbol("");
      class ReactiveEffect {
        constructor(fn2, scheduler = null, scope) {
          this.fn = fn2;
          this.scheduler = scheduler;
          this.active = true;
          this.deps = [];
          this.parent = void 0;
          recordEffectScope(this, scope);
        }
        run() {
          if (!this.active) {
            return this.fn();
          }
          let parent = activeEffect;
          let lastShouldTrack = shouldTrack;
          while (parent) {
            if (parent === this) {
              return;
            }
            parent = parent.parent;
          }
          try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) {
              initDepMarkers(this);
            } else {
              cleanupEffect(this);
            }
            return this.fn();
          } finally {
            if (effectTrackDepth <= maxMarkerBits) {
              finalizeDepMarkers(this);
            }
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = void 0;
            if (this.deferStop) {
              this.stop();
            }
          }
        }
        stop() {
          if (activeEffect === this) {
            this.deferStop = true;
          } else if (this.active) {
            cleanupEffect(this);
            if (this.onStop) {
              this.onStop();
            }
            this.active = false;
          }
        }
      }
      function cleanupEffect(effect2) {
        const { deps } = effect2;
        if (deps.length) {
          for (let i = 0; i < deps.length; i++) {
            deps[i].delete(effect2);
          }
          deps.length = 0;
        }
      }
      let shouldTrack = true;
      const trackStack = [];
      function pauseTracking() {
        trackStack.push(shouldTrack);
        shouldTrack = false;
      }
      function resetTracking() {
        const last = trackStack.pop();
        shouldTrack = last === void 0 ? true : last;
      }
      function track(target, type2, key) {
        if (shouldTrack && activeEffect) {
          let depsMap = targetMap.get(target);
          if (!depsMap) {
            targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
          }
          let dep = depsMap.get(key);
          if (!dep) {
            depsMap.set(key, dep = createDep());
          }
          trackEffects(dep);
        }
      }
      function trackEffects(dep, debuggerEventExtraInfo) {
        let shouldTrack2 = false;
        if (effectTrackDepth <= maxMarkerBits) {
          if (!newTracked(dep)) {
            dep.n |= trackOpBit;
            shouldTrack2 = !wasTracked(dep);
          }
        } else {
          shouldTrack2 = !dep.has(activeEffect);
        }
        if (shouldTrack2) {
          dep.add(activeEffect);
          activeEffect.deps.push(dep);
        }
      }
      function trigger(target, type2, key, newValue, oldValue, oldTarget) {
        const depsMap = targetMap.get(target);
        if (!depsMap) {
          return;
        }
        let deps = [];
        if (type2 === "clear") {
          deps = [...depsMap.values()];
        } else if (key === "length" && isArray$2(target)) {
          const newLength = Number(newValue);
          depsMap.forEach((dep, key2) => {
            if (key2 === "length" || key2 >= newLength) {
              deps.push(dep);
            }
          });
        } else {
          if (key !== void 0) {
            deps.push(depsMap.get(key));
          }
          switch (type2) {
            case "add":
              if (!isArray$2(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
                if (isMap$2(target)) {
                  deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              } else if (isIntegerKey(key)) {
                deps.push(depsMap.get("length"));
              }
              break;
            case "delete":
              if (!isArray$2(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
                if (isMap$2(target)) {
                  deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              }
              break;
            case "set":
              if (isMap$2(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
              }
              break;
          }
        }
        if (deps.length === 1) {
          if (deps[0]) {
            {
              triggerEffects(deps[0]);
            }
          }
        } else {
          const effects = [];
          for (const dep of deps) {
            if (dep) {
              effects.push(...dep);
            }
          }
          {
            triggerEffects(createDep(effects));
          }
        }
      }
      function triggerEffects(dep, debuggerEventExtraInfo) {
        const effects = isArray$2(dep) ? dep : [...dep];
        for (const effect2 of effects) {
          if (effect2.computed) {
            triggerEffect(effect2);
          }
        }
        for (const effect2 of effects) {
          if (!effect2.computed) {
            triggerEffect(effect2);
          }
        }
      }
      function triggerEffect(effect2, debuggerEventExtraInfo) {
        if (effect2 !== activeEffect || effect2.allowRecurse) {
          if (effect2.scheduler) {
            effect2.scheduler();
          } else {
            effect2.run();
          }
        }
      }
      function getDepFromReactive(object2, key) {
        var _a2;
        return (_a2 = targetMap.get(object2)) == null ? void 0 : _a2.get(key);
      }
      const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
      const builtInSymbols = new Set(
        /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
      );
      const get$1 = /* @__PURE__ */ createGetter();
      const shallowGet = /* @__PURE__ */ createGetter(false, true);
      const readonlyGet = /* @__PURE__ */ createGetter(true);
      const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
      function createArrayInstrumentations() {
        const instrumentations = {};
        ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
          instrumentations[key] = function(...args) {
            const arr = toRaw(this);
            for (let i = 0, l = this.length; i < l; i++) {
              track(arr, "get", i + "");
            }
            const res = arr[key](...args);
            if (res === -1 || res === false) {
              return arr[key](...args.map(toRaw));
            } else {
              return res;
            }
          };
        });
        ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
          instrumentations[key] = function(...args) {
            pauseTracking();
            const res = toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
          };
        });
        return instrumentations;
      }
      function hasOwnProperty$c(key) {
        const obj = toRaw(this);
        track(obj, "has", key);
        return obj.hasOwnProperty(key);
      }
      function createGetter(isReadonly2 = false, shallow = false) {
        return function get2(target, key, receiver) {
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_isShallow") {
            return shallow;
          } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
            return target;
          }
          const targetIsArray = isArray$2(target);
          if (!isReadonly2) {
            if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
              return Reflect.get(arrayInstrumentations, key, receiver);
            }
            if (key === "hasOwnProperty") {
              return hasOwnProperty$c;
            }
          }
          const res = Reflect.get(target, key, receiver);
          if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
          }
          if (!isReadonly2) {
            track(target, "get", key);
          }
          if (shallow) {
            return res;
          }
          if (isRef(res)) {
            return targetIsArray && isIntegerKey(key) ? res : res.value;
          }
          if (isObject$1(res)) {
            return isReadonly2 ? readonly(res) : reactive(res);
          }
          return res;
        };
      }
      const set$1 = /* @__PURE__ */ createSetter();
      const shallowSet = /* @__PURE__ */ createSetter(true);
      function createSetter(shallow = false) {
        return function set2(target, key, value, receiver) {
          let oldValue = target[key];
          if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
            return false;
          }
          if (!shallow) {
            if (!isShallow(value) && !isReadonly(value)) {
              oldValue = toRaw(oldValue);
              value = toRaw(value);
            }
            if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
              oldValue.value = value;
              return true;
            }
          }
          const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
          const result = Reflect.set(target, key, value, receiver);
          if (target === toRaw(receiver)) {
            if (!hadKey) {
              trigger(target, "add", key, value);
            } else if (hasChanged(value, oldValue)) {
              trigger(target, "set", key, value);
            }
          }
          return result;
        };
      }
      function deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      }
      function has$1(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      function ownKeys(target) {
        track(target, "iterate", isArray$2(target) ? "length" : ITERATE_KEY);
        return Reflect.ownKeys(target);
      }
      const mutableHandlers = {
        get: get$1,
        set: set$1,
        deleteProperty,
        has: has$1,
        ownKeys
      };
      const readonlyHandlers = {
        get: readonlyGet,
        set(target, key) {
          return true;
        },
        deleteProperty(target, key) {
          return true;
        }
      };
      const shallowReactiveHandlers = /* @__PURE__ */ extend(
        {},
        mutableHandlers,
        {
          get: shallowGet,
          set: shallowSet
        }
      );
      const toShallow = (value) => value;
      const getProto = (v) => Reflect.getPrototypeOf(v);
      function get$2(target, key, isReadonly2 = false, isShallow2 = false) {
        target = target["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!isReadonly2) {
          if (key !== rawKey) {
            track(rawTarget, "get", key);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has: has2 } = getProto(rawTarget);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        if (has2.call(rawTarget, key)) {
          return wrap(target.get(key));
        } else if (has2.call(rawTarget, rawKey)) {
          return wrap(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key);
        }
      }
      function has(key, isReadonly2 = false) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!isReadonly2) {
          if (key !== rawKey) {
            track(rawTarget, "has", key);
          }
          track(rawTarget, "has", rawKey);
        }
        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
      }
      function size(target, isReadonly2 = false) {
        target = target["__v_raw"];
        !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return Reflect.get(target, "size", target);
      }
      function add(value) {
        value = toRaw(value);
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      }
      function set$2(key, value) {
        value = toRaw(value);
        const target = toRaw(this);
        const { has: has2, get: get2 } = getProto(target);
        let hadKey = has2.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target, key);
        }
        const oldValue = get2.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      }
      function deleteEntry(key) {
        const target = toRaw(this);
        const { has: has2, get: get2 } = getProto(target);
        let hadKey = has2.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target, key);
        }
        get2 ? get2.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      }
      function clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(target, "clear", void 0, void 0);
        }
        return result;
      }
      function createForEach(isReadonly2, isShallow2) {
        return function forEach(callback, thisArg) {
          const observed = this;
          const target = observed["__v_raw"];
          const rawTarget = toRaw(target);
          const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
          !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
          return target.forEach((value, key) => {
            return callback.call(thisArg, wrap(value), wrap(key), observed);
          });
        };
      }
      function createIterableMethod(method2, isReadonly2, isShallow2) {
        return function(...args) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const targetIsMap = isMap$2(rawTarget);
          const isPair = method2 === "entries" || method2 === Symbol.iterator && targetIsMap;
          const isKeyOnly = method2 === "keys" && targetIsMap;
          const innerIterator = target[method2](...args);
          const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
          !isReadonly2 && track(
            rawTarget,
            "iterate",
            isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
          );
          return {
            // iterator protocol
            next() {
              const { value, done } = innerIterator.next();
              return done ? { value, done } : {
                value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                done
              };
            },
            // iterable protocol
            [Symbol.iterator]() {
              return this;
            }
          };
        };
      }
      function createReadonlyMethod(type2) {
        return function(...args) {
          return type2 === "delete" ? false : this;
        };
      }
      function createInstrumentations() {
        const mutableInstrumentations2 = {
          get(key) {
            return get$2(this, key);
          },
          get size() {
            return size(this);
          },
          has,
          add,
          set: set$2,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, false)
        };
        const shallowInstrumentations2 = {
          get(key) {
            return get$2(this, key, false, true);
          },
          get size() {
            return size(this);
          },
          has,
          add,
          set: set$2,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, true)
        };
        const readonlyInstrumentations2 = {
          get(key) {
            return get$2(this, key, true);
          },
          get size() {
            return size(this, true);
          },
          has(key) {
            return has.call(this, key, true);
          },
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear"),
          forEach: createForEach(true, false)
        };
        const shallowReadonlyInstrumentations2 = {
          get(key) {
            return get$2(this, key, true, true);
          },
          get size() {
            return size(this, true);
          },
          has(key) {
            return has.call(this, key, true);
          },
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear"),
          forEach: createForEach(true, true)
        };
        const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
        iteratorMethods.forEach((method2) => {
          mutableInstrumentations2[method2] = createIterableMethod(
            method2,
            false,
            false
          );
          readonlyInstrumentations2[method2] = createIterableMethod(
            method2,
            true,
            false
          );
          shallowInstrumentations2[method2] = createIterableMethod(
            method2,
            false,
            true
          );
          shallowReadonlyInstrumentations2[method2] = createIterableMethod(
            method2,
            true,
            true
          );
        });
        return [
          mutableInstrumentations2,
          readonlyInstrumentations2,
          shallowInstrumentations2,
          shallowReadonlyInstrumentations2
        ];
      }
      const [
        mutableInstrumentations,
        readonlyInstrumentations,
        shallowInstrumentations,
        shallowReadonlyInstrumentations
      ] = /* @__PURE__ */ createInstrumentations();
      function createInstrumentationGetter(isReadonly2, shallow) {
        const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
        return (target, key, receiver) => {
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_raw") {
            return target;
          }
          return Reflect.get(
            hasOwn(instrumentations, key) && key in target ? instrumentations : target,
            key,
            receiver
          );
        };
      }
      const mutableCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, false)
      };
      const shallowCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, true)
      };
      const readonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, false)
      };
      const reactiveMap = /* @__PURE__ */ new WeakMap();
      const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
      const readonlyMap = /* @__PURE__ */ new WeakMap();
      const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
      function targetTypeMap(rawType) {
        switch (rawType) {
          case "Object":
          case "Array":
            return 1;
          case "Map":
          case "Set":
          case "WeakMap":
          case "WeakSet":
            return 2;
          default:
            return 0;
        }
      }
      function getTargetType(value) {
        return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
      }
      function reactive(target) {
        if (isReadonly(target)) {
          return target;
        }
        return createReactiveObject(
          target,
          false,
          mutableHandlers,
          mutableCollectionHandlers,
          reactiveMap
        );
      }
      function shallowReactive(target) {
        return createReactiveObject(
          target,
          false,
          shallowReactiveHandlers,
          shallowCollectionHandlers,
          shallowReactiveMap
        );
      }
      function readonly(target) {
        return createReactiveObject(
          target,
          true,
          readonlyHandlers,
          readonlyCollectionHandlers,
          readonlyMap
        );
      }
      function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
        if (!isObject$1(target)) {
          return target;
        }
        if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
          return target;
        }
        const existingProxy = proxyMap.get(target);
        if (existingProxy) {
          return existingProxy;
        }
        const targetType = getTargetType(target);
        if (targetType === 0) {
          return target;
        }
        const proxy = new Proxy(
          target,
          targetType === 2 ? collectionHandlers : baseHandlers
        );
        proxyMap.set(target, proxy);
        return proxy;
      }
      function isReactive(value) {
        if (isReadonly(value)) {
          return isReactive(value["__v_raw"]);
        }
        return !!(value && value["__v_isReactive"]);
      }
      function isReadonly(value) {
        return !!(value && value["__v_isReadonly"]);
      }
      function isShallow(value) {
        return !!(value && value["__v_isShallow"]);
      }
      function isProxy(value) {
        return isReactive(value) || isReadonly(value);
      }
      function toRaw(observed) {
        const raw = observed && observed["__v_raw"];
        return raw ? toRaw(raw) : observed;
      }
      function markRaw(value) {
        def(value, "__v_skip", true);
        return value;
      }
      const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
      const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
      function trackRefValue(ref2) {
        if (shouldTrack && activeEffect) {
          ref2 = toRaw(ref2);
          {
            trackEffects(ref2.dep || (ref2.dep = createDep()));
          }
        }
      }
      function triggerRefValue(ref2, newVal) {
        ref2 = toRaw(ref2);
        const dep = ref2.dep;
        if (dep) {
          {
            triggerEffects(dep);
          }
        }
      }
      function isRef(r) {
        return !!(r && r.__v_isRef === true);
      }
      function ref(value) {
        return createRef(value, false);
      }
      function shallowRef(value) {
        return createRef(value, true);
      }
      function createRef(rawValue, shallow) {
        if (isRef(rawValue)) {
          return rawValue;
        }
        return new RefImpl(rawValue, shallow);
      }
      class RefImpl {
        constructor(value, __v_isShallow) {
          this.__v_isShallow = __v_isShallow;
          this.dep = void 0;
          this.__v_isRef = true;
          this._rawValue = __v_isShallow ? value : toRaw(value);
          this._value = __v_isShallow ? value : toReactive(value);
        }
        get value() {
          trackRefValue(this);
          return this._value;
        }
        set value(newVal) {
          const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
          newVal = useDirectValue ? newVal : toRaw(newVal);
          if (hasChanged(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = useDirectValue ? newVal : toReactive(newVal);
            triggerRefValue(this);
          }
        }
      }
      function triggerRef(ref2) {
        triggerRefValue(ref2);
      }
      function unref(ref2) {
        return isRef(ref2) ? ref2.value : ref2;
      }
      const shallowUnwrapHandlers = {
        get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
        set: (target, key, value, receiver) => {
          const oldValue = target[key];
          if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          } else {
            return Reflect.set(target, key, value, receiver);
          }
        }
      };
      function proxyRefs(objectWithRefs) {
        return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
      }
      class CustomRefImpl {
        constructor(factory) {
          this.dep = void 0;
          this.__v_isRef = true;
          const { get: get2, set: set2 } = factory(
            () => trackRefValue(this),
            () => triggerRefValue(this)
          );
          this._get = get2;
          this._set = set2;
        }
        get value() {
          return this._get();
        }
        set value(newVal) {
          this._set(newVal);
        }
      }
      function customRef(factory) {
        return new CustomRefImpl(factory);
      }
      function toRefs(object2) {
        const ret = isArray$2(object2) ? new Array(object2.length) : {};
        for (const key in object2) {
          ret[key] = propertyToRef(object2, key);
        }
        return ret;
      }
      class ObjectRefImpl {
        constructor(_object, _key, _defaultValue) {
          this._object = _object;
          this._key = _key;
          this._defaultValue = _defaultValue;
          this.__v_isRef = true;
        }
        get value() {
          const val = this._object[this._key];
          return val === void 0 ? this._defaultValue : val;
        }
        set value(newVal) {
          this._object[this._key] = newVal;
        }
        get dep() {
          return getDepFromReactive(toRaw(this._object), this._key);
        }
      }
      class GetterRefImpl {
        constructor(_getter) {
          this._getter = _getter;
          this.__v_isRef = true;
          this.__v_isReadonly = true;
        }
        get value() {
          return this._getter();
        }
      }
      function toRef$1(source, key, defaultValue) {
        if (isRef(source)) {
          return source;
        } else if (isFunction$1(source)) {
          return new GetterRefImpl(source);
        } else if (isObject$1(source) && arguments.length > 1) {
          return propertyToRef(source, key, defaultValue);
        } else {
          return ref(source);
        }
      }
      function propertyToRef(source, key, defaultValue) {
        const val = source[key];
        return isRef(val) ? val : new ObjectRefImpl(
          source,
          key,
          defaultValue
        );
      }
      class ComputedRefImpl {
        constructor(getter, _setter, isReadonly2, isSSR) {
          this._setter = _setter;
          this.dep = void 0;
          this.__v_isRef = true;
          this["__v_isReadonly"] = false;
          this._dirty = true;
          this.effect = new ReactiveEffect(getter, () => {
            if (!this._dirty) {
              this._dirty = true;
              triggerRefValue(this);
            }
          });
          this.effect.computed = this;
          this.effect.active = this._cacheable = !isSSR;
          this["__v_isReadonly"] = isReadonly2;
        }
        get value() {
          const self2 = toRaw(this);
          trackRefValue(self2);
          if (self2._dirty || !self2._cacheable) {
            self2._dirty = false;
            self2._value = self2.effect.run();
          }
          return self2._value;
        }
        set value(newValue) {
          this._setter(newValue);
        }
      }
      function computed$1(getterOrOptions, debugOptions, isSSR = false) {
        let getter;
        let setter;
        const onlyGetter = isFunction$1(getterOrOptions);
        if (onlyGetter) {
          getter = getterOrOptions;
          setter = NOOP;
        } else {
          getter = getterOrOptions.get;
          setter = getterOrOptions.set;
        }
        const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
        return cRef;
      }
      function warn(msg, ...args) {
        return;
      }
      function callWithErrorHandling(fn2, instance, type2, args) {
        let res;
        try {
          res = args ? fn2(...args) : fn2();
        } catch (err) {
          handleError(err, instance, type2);
        }
        return res;
      }
      function callWithAsyncErrorHandling(fn2, instance, type2, args) {
        if (isFunction$1(fn2)) {
          const res = callWithErrorHandling(fn2, instance, type2, args);
          if (res && isPromise(res)) {
            res.catch((err) => {
              handleError(err, instance, type2);
            });
          }
          return res;
        }
        const values = [];
        for (let i = 0; i < fn2.length; i++) {
          values.push(callWithAsyncErrorHandling(fn2[i], instance, type2, args));
        }
        return values;
      }
      function handleError(err, instance, type2, throwInDev = true) {
        const contextVNode = instance ? instance.vnode : null;
        if (instance) {
          let cur = instance.parent;
          const exposedInstance = instance.proxy;
          const errorInfo = type2;
          while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
              for (let i = 0; i < errorCapturedHooks.length; i++) {
                if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                  return;
                }
              }
            }
            cur = cur.parent;
          }
          const appErrorHandler = instance.appContext.config.errorHandler;
          if (appErrorHandler) {
            callWithErrorHandling(
              appErrorHandler,
              null,
              10,
              [err, exposedInstance, errorInfo]
            );
            return;
          }
        }
        logError(err, type2, contextVNode, throwInDev);
      }
      function logError(err, type2, contextVNode, throwInDev = true) {
        {
          console.error(err);
        }
      }
      let isFlushing = false;
      let isFlushPending = false;
      const queue = [];
      let flushIndex = 0;
      const pendingPostFlushCbs = [];
      let activePostFlushCbs = null;
      let postFlushIndex = 0;
      const resolvedPromise = /* @__PURE__ */ Promise.resolve();
      let currentFlushPromise = null;
      function nextTick(fn2) {
        const p2 = currentFlushPromise || resolvedPromise;
        return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
      }
      function findInsertionIndex(id2) {
        let start = flushIndex + 1;
        let end2 = queue.length;
        while (start < end2) {
          const middle = start + end2 >>> 1;
          const middleJobId = getId(queue[middle]);
          middleJobId < id2 ? start = middle + 1 : end2 = middle;
        }
        return start;
      }
      function queueJob(job) {
        if (!queue.length || !queue.includes(
          job,
          isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
        )) {
          if (job.id == null) {
            queue.push(job);
          } else {
            queue.splice(findInsertionIndex(job.id), 0, job);
          }
          queueFlush();
        }
      }
      function queueFlush() {
        if (!isFlushing && !isFlushPending) {
          isFlushPending = true;
          currentFlushPromise = resolvedPromise.then(flushJobs);
        }
      }
      function invalidateJob(job) {
        const i = queue.indexOf(job);
        if (i > flushIndex) {
          queue.splice(i, 1);
        }
      }
      function queuePostFlushCb(cb) {
        if (!isArray$2(cb)) {
          if (!activePostFlushCbs || !activePostFlushCbs.includes(
            cb,
            cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
          )) {
            pendingPostFlushCbs.push(cb);
          }
        } else {
          pendingPostFlushCbs.push(...cb);
        }
        queueFlush();
      }
      function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
        for (; i < queue.length; i++) {
          const cb = queue[i];
          if (cb && cb.pre) {
            queue.splice(i, 1);
            i--;
            cb();
          }
        }
      }
      function flushPostFlushCbs(seen) {
        if (pendingPostFlushCbs.length) {
          const deduped = [...new Set(pendingPostFlushCbs)];
          pendingPostFlushCbs.length = 0;
          if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
          }
          activePostFlushCbs = deduped;
          activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
          for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            activePostFlushCbs[postFlushIndex]();
          }
          activePostFlushCbs = null;
          postFlushIndex = 0;
        }
      }
      const getId = (job) => job.id == null ? Infinity : job.id;
      const comparator = (a, b) => {
        const diff = getId(a) - getId(b);
        if (diff === 0) {
          if (a.pre && !b.pre)
            return -1;
          if (b.pre && !a.pre)
            return 1;
        }
        return diff;
      };
      function flushJobs(seen) {
        isFlushPending = false;
        isFlushing = true;
        queue.sort(comparator);
        try {
          for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job && job.active !== false) {
              if (false)
                ;
              callWithErrorHandling(job, null, 14);
            }
          }
        } finally {
          flushIndex = 0;
          queue.length = 0;
          flushPostFlushCbs();
          isFlushing = false;
          currentFlushPromise = null;
          if (queue.length || pendingPostFlushCbs.length) {
            flushJobs();
          }
        }
      }
      function emit(instance, event, ...rawArgs) {
        if (instance.isUnmounted)
          return;
        const props = instance.vnode.props || EMPTY_OBJ;
        let args = rawArgs;
        const isModelListener2 = event.startsWith("update:");
        const modelArg = isModelListener2 && event.slice(7);
        if (modelArg && modelArg in props) {
          const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
          const { number: number2, trim } = props[modifiersKey] || EMPTY_OBJ;
          if (trim) {
            args = rawArgs.map((a) => isString$1(a) ? a.trim() : a);
          }
          if (number2) {
            args = rawArgs.map(looseToNumber);
          }
        }
        let handlerName;
        let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
        props[handlerName = toHandlerKey(camelize(event))];
        if (!handler && isModelListener2) {
          handler = props[handlerName = toHandlerKey(hyphenate(event))];
        }
        if (handler) {
          callWithAsyncErrorHandling(
            handler,
            instance,
            6,
            args
          );
        }
        const onceHandler = props[handlerName + `Once`];
        if (onceHandler) {
          if (!instance.emitted) {
            instance.emitted = {};
          } else if (instance.emitted[handlerName]) {
            return;
          }
          instance.emitted[handlerName] = true;
          callWithAsyncErrorHandling(
            onceHandler,
            instance,
            6,
            args
          );
        }
      }
      function normalizeEmitsOptions(comp, appContext, asMixin = false) {
        const cache2 = appContext.emitsCache;
        const cached = cache2.get(comp);
        if (cached !== void 0) {
          return cached;
        }
        const raw = comp.emits;
        let normalized = {};
        let hasExtends = false;
        if (!isFunction$1(comp)) {
          const extendEmits = (raw2) => {
            const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
            if (normalizedFromExtend) {
              hasExtends = true;
              extend(normalized, normalizedFromExtend);
            }
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
          }
          if (comp.extends) {
            extendEmits(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
          }
        }
        if (!raw && !hasExtends) {
          if (isObject$1(comp)) {
            cache2.set(comp, null);
          }
          return null;
        }
        if (isArray$2(raw)) {
          raw.forEach((key) => normalized[key] = null);
        } else {
          extend(normalized, raw);
        }
        if (isObject$1(comp)) {
          cache2.set(comp, normalized);
        }
        return normalized;
      }
      function isEmitListener(options, key) {
        if (!options || !isOn(key)) {
          return false;
        }
        key = key.slice(2).replace(/Once$/, "");
        return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
      }
      let currentRenderingInstance = null;
      let currentScopeId = null;
      function setCurrentRenderingInstance(instance) {
        const prev = currentRenderingInstance;
        currentRenderingInstance = instance;
        currentScopeId = instance && instance.type.__scopeId || null;
        return prev;
      }
      function pushScopeId(id2) {
        currentScopeId = id2;
      }
      function popScopeId() {
        currentScopeId = null;
      }
      function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
        if (!ctx)
          return fn2;
        if (fn2._n) {
          return fn2;
        }
        const renderFnWithContext = (...args) => {
          if (renderFnWithContext._d) {
            setBlockTracking(-1);
          }
          const prevInstance = setCurrentRenderingInstance(ctx);
          let res;
          try {
            res = fn2(...args);
          } finally {
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) {
              setBlockTracking(1);
            }
          }
          return res;
        };
        renderFnWithContext._n = true;
        renderFnWithContext._c = true;
        renderFnWithContext._d = true;
        return renderFnWithContext;
      }
      function markAttrsAccessed() {
      }
      function renderComponentRoot(instance) {
        const {
          type: Component,
          vnode,
          proxy,
          withProxy,
          props,
          propsOptions: [propsOptions],
          slots,
          attrs,
          emit: emit2,
          render: render2,
          renderCache,
          data,
          setupState,
          ctx,
          inheritAttrs
        } = instance;
        let result;
        let fallthroughAttrs;
        const prev = setCurrentRenderingInstance(instance);
        try {
          if (vnode.shapeFlag & 4) {
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(
              render2.call(
                proxyToUse,
                proxyToUse,
                renderCache,
                props,
                setupState,
                data,
                ctx
              )
            );
            fallthroughAttrs = attrs;
          } else {
            const render22 = Component;
            if (false)
              ;
            result = normalizeVNode(
              render22.length > 1 ? render22(
                props,
                false ? {
                  get attrs() {
                    markAttrsAccessed();
                    return attrs;
                  },
                  slots,
                  emit: emit2
                } : { attrs, slots, emit: emit2 }
              ) : render22(
                props,
                null
                /* we know it doesn't need it */
              )
            );
            fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
          }
        } catch (err) {
          blockStack.length = 0;
          handleError(err, instance, 1);
          result = createVNode(Comment);
        }
        let root2 = result;
        if (fallthroughAttrs && inheritAttrs !== false) {
          const keys2 = Object.keys(fallthroughAttrs);
          const { shapeFlag } = root2;
          if (keys2.length) {
            if (shapeFlag & (1 | 6)) {
              if (propsOptions && keys2.some(isModelListener)) {
                fallthroughAttrs = filterModelListeners(
                  fallthroughAttrs,
                  propsOptions
                );
              }
              root2 = cloneVNode(root2, fallthroughAttrs);
            }
          }
        }
        if (vnode.dirs) {
          root2 = cloneVNode(root2);
          root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
        }
        if (vnode.transition) {
          root2.transition = vnode.transition;
        }
        {
          result = root2;
        }
        setCurrentRenderingInstance(prev);
        return result;
      }
      const getFunctionalFallthrough = (attrs) => {
        let res;
        for (const key in attrs) {
          if (key === "class" || key === "style" || isOn(key)) {
            (res || (res = {}))[key] = attrs[key];
          }
        }
        return res;
      };
      const filterModelListeners = (attrs, props) => {
        const res = {};
        for (const key in attrs) {
          if (!isModelListener(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
          }
        }
        return res;
      };
      function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
        const { props: prevProps, children: prevChildren, component } = prevVNode;
        const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
        const emits = component.emitsOptions;
        if (nextVNode.dirs || nextVNode.transition) {
          return true;
        }
        if (optimized && patchFlag >= 0) {
          if (patchFlag & 1024) {
            return true;
          }
          if (patchFlag & 16) {
            if (!prevProps) {
              return !!nextProps;
            }
            return hasPropsChanged(prevProps, nextProps, emits);
          } else if (patchFlag & 8) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
              const key = dynamicProps[i];
              if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
                return true;
              }
            }
          }
        } else {
          if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
              return true;
            }
          }
          if (prevProps === nextProps) {
            return false;
          }
          if (!prevProps) {
            return !!nextProps;
          }
          if (!nextProps) {
            return true;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        }
        return false;
      }
      function hasPropsChanged(prevProps, nextProps, emitsOptions) {
        const nextKeys = Object.keys(nextProps);
        if (nextKeys.length !== Object.keys(prevProps).length) {
          return true;
        }
        for (let i = 0; i < nextKeys.length; i++) {
          const key = nextKeys[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
            return true;
          }
        }
        return false;
      }
      function updateHOCHostEl({ vnode, parent }, el) {
        while (parent && parent.subTree === vnode) {
          (vnode = parent.vnode).el = el;
          parent = parent.parent;
        }
      }
      const isSuspense = (type2) => type2.__isSuspense;
      function queueEffectWithSuspense(fn2, suspense) {
        if (suspense && suspense.pendingBranch) {
          if (isArray$2(fn2)) {
            suspense.effects.push(...fn2);
          } else {
            suspense.effects.push(fn2);
          }
        } else {
          queuePostFlushCb(fn2);
        }
      }
      function watchEffect(effect, options) {
        return doWatch(effect, null, options);
      }
      const INITIAL_WATCHER_VALUE = {};
      function watch(source, cb, options) {
        return doWatch(source, cb, options);
      }
      function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
        var _a2;
        const instance = getCurrentScope() === ((_a2 = currentInstance) == null ? void 0 : _a2.scope) ? currentInstance : null;
        let getter;
        let forceTrigger = false;
        let isMultiSource = false;
        if (isRef(source)) {
          getter = () => source.value;
          forceTrigger = isShallow(source);
        } else if (isReactive(source)) {
          getter = () => source;
          deep = true;
        } else if (isArray$2(source)) {
          isMultiSource = true;
          forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
          getter = () => source.map((s) => {
            if (isRef(s)) {
              return s.value;
            } else if (isReactive(s)) {
              return traverse(s);
            } else if (isFunction$1(s)) {
              return callWithErrorHandling(s, instance, 2);
            } else
              ;
          });
        } else if (isFunction$1(source)) {
          if (cb) {
            getter = () => callWithErrorHandling(source, instance, 2);
          } else {
            getter = () => {
              if (instance && instance.isUnmounted) {
                return;
              }
              if (cleanup) {
                cleanup();
              }
              return callWithAsyncErrorHandling(
                source,
                instance,
                3,
                [onCleanup]
              );
            };
          }
        } else {
          getter = NOOP;
        }
        if (cb && deep) {
          const baseGetter = getter;
          getter = () => traverse(baseGetter());
        }
        let cleanup;
        let onCleanup = (fn2) => {
          cleanup = effect.onStop = () => {
            callWithErrorHandling(fn2, instance, 4);
          };
        };
        let ssrCleanup;
        if (isInSSRComponentSetup) {
          onCleanup = NOOP;
          if (!cb) {
            getter();
          } else if (immediate) {
            callWithAsyncErrorHandling(cb, instance, 3, [
              getter(),
              isMultiSource ? [] : void 0,
              onCleanup
            ]);
          }
          if (flush === "sync") {
            const ctx = useSSRContext();
            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
          } else {
            return NOOP;
          }
        }
        let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
        const job = () => {
          if (!effect.active) {
            return;
          }
          if (cb) {
            const newValue = effect.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some(
              (v, i) => hasChanged(v, oldValue[i])
            ) : hasChanged(newValue, oldValue)) || false) {
              if (cleanup) {
                cleanup();
              }
              callWithAsyncErrorHandling(cb, instance, 3, [
                newValue,
                // pass undefined as the old value when it's changed for the first time
                oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                onCleanup
              ]);
              oldValue = newValue;
            }
          } else {
            effect.run();
          }
        };
        job.allowRecurse = !!cb;
        let scheduler;
        if (flush === "sync") {
          scheduler = job;
        } else if (flush === "post") {
          scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
        } else {
          job.pre = true;
          if (instance)
            job.id = instance.uid;
          scheduler = () => queueJob(job);
        }
        const effect = new ReactiveEffect(getter, scheduler);
        if (cb) {
          if (immediate) {
            job();
          } else {
            oldValue = effect.run();
          }
        } else if (flush === "post") {
          queuePostRenderEffect(
            effect.run.bind(effect),
            instance && instance.suspense
          );
        } else {
          effect.run();
        }
        const unwatch = () => {
          effect.stop();
          if (instance && instance.scope) {
            remove(instance.scope.effects, effect);
          }
        };
        if (ssrCleanup)
          ssrCleanup.push(unwatch);
        return unwatch;
      }
      function instanceWatch(source, value, options) {
        const publicThis = this.proxy;
        const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
        let cb;
        if (isFunction$1(value)) {
          cb = value;
        } else {
          cb = value.handler;
          options = value;
        }
        const cur = currentInstance;
        setCurrentInstance(this);
        const res = doWatch(getter, cb.bind(publicThis), options);
        if (cur) {
          setCurrentInstance(cur);
        } else {
          unsetCurrentInstance();
        }
        return res;
      }
      function createPathGetter(ctx, path) {
        const segments = path.split(".");
        return () => {
          let cur = ctx;
          for (let i = 0; i < segments.length && cur; i++) {
            cur = cur[segments[i]];
          }
          return cur;
        };
      }
      function traverse(value, seen) {
        if (!isObject$1(value) || value["__v_skip"]) {
          return value;
        }
        seen = seen || /* @__PURE__ */ new Set();
        if (seen.has(value)) {
          return value;
        }
        seen.add(value);
        if (isRef(value)) {
          traverse(value.value, seen);
        } else if (isArray$2(value)) {
          for (let i = 0; i < value.length; i++) {
            traverse(value[i], seen);
          }
        } else if (isSet$2(value) || isMap$2(value)) {
          value.forEach((v) => {
            traverse(v, seen);
          });
        } else if (isPlainObject$1(value)) {
          for (const key in value) {
            traverse(value[key], seen);
          }
        }
        return value;
      }
      function withDirectives(vnode, directives) {
        const internalInstance = currentRenderingInstance;
        if (internalInstance === null) {
          return vnode;
        }
        const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
        const bindings = vnode.dirs || (vnode.dirs = []);
        for (let i = 0; i < directives.length; i++) {
          let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
          if (dir) {
            if (isFunction$1(dir)) {
              dir = {
                mounted: dir,
                updated: dir
              };
            }
            if (dir.deep) {
              traverse(value);
            }
            bindings.push({
              dir,
              instance,
              value,
              oldValue: void 0,
              arg,
              modifiers
            });
          }
        }
        return vnode;
      }
      function invokeDirectiveHook(vnode, prevVNode, instance, name) {
        const bindings = vnode.dirs;
        const oldBindings = prevVNode && prevVNode.dirs;
        for (let i = 0; i < bindings.length; i++) {
          const binding = bindings[i];
          if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
          }
          let hook = binding.dir[name];
          if (hook) {
            pauseTracking();
            callWithAsyncErrorHandling(hook, instance, 8, [
              vnode.el,
              binding,
              vnode,
              prevVNode
            ]);
            resetTracking();
          }
        }
      }
      function useTransitionState() {
        const state = {
          isMounted: false,
          isLeaving: false,
          isUnmounting: false,
          leavingVNodes: /* @__PURE__ */ new Map()
        };
        onMounted(() => {
          state.isMounted = true;
        });
        onBeforeUnmount(() => {
          state.isUnmounting = true;
        });
        return state;
      }
      const TransitionHookValidator = [Function, Array];
      const BaseTransitionPropsValidators = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
      };
      const BaseTransitionImpl = {
        name: `BaseTransition`,
        props: BaseTransitionPropsValidators,
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          let prevTransitionKey;
          return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
              return;
            }
            let child = children[0];
            if (children.length > 1) {
              for (const c of children) {
                if (c.type !== Comment) {
                  child = c;
                  break;
                }
              }
            }
            const rawProps = toRaw(props);
            const { mode } = rawProps;
            if (state.isLeaving) {
              return emptyPlaceholder(child);
            }
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
              return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(
              innerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
              const key = getTransitionKey();
              if (prevTransitionKey === void 0) {
                prevTransitionKey = key;
              } else if (key !== prevTransitionKey) {
                prevTransitionKey = key;
                transitionKeyChanged = true;
              }
            }
            if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
              const leavingHooks = resolveTransitionHooks(
                oldInnerChild,
                rawProps,
                state,
                instance
              );
              setTransitionHooks(oldInnerChild, leavingHooks);
              if (mode === "out-in") {
                state.isLeaving = true;
                leavingHooks.afterLeave = () => {
                  state.isLeaving = false;
                  if (instance.update.active !== false) {
                    instance.update();
                  }
                };
                return emptyPlaceholder(child);
              } else if (mode === "in-out" && innerChild.type !== Comment) {
                leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                  const leavingVNodesCache = getLeavingNodesForType(
                    state,
                    oldInnerChild
                  );
                  leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                  el._leaveCb = () => {
                    earlyRemove();
                    el._leaveCb = void 0;
                    delete enterHooks.delayedLeave;
                  };
                  enterHooks.delayedLeave = delayedLeave;
                };
              }
            }
            return child;
          };
        }
      };
      const BaseTransition = BaseTransitionImpl;
      function getLeavingNodesForType(state, vnode) {
        const { leavingVNodes } = state;
        let leavingVNodesCache = leavingVNodes.get(vnode.type);
        if (!leavingVNodesCache) {
          leavingVNodesCache = /* @__PURE__ */ Object.create(null);
          leavingVNodes.set(vnode.type, leavingVNodesCache);
        }
        return leavingVNodesCache;
      }
      function resolveTransitionHooks(vnode, props, state, instance) {
        const {
          appear,
          mode,
          persisted = false,
          onBeforeEnter,
          onEnter,
          onAfterEnter,
          onEnterCancelled,
          onBeforeLeave,
          onLeave,
          onAfterLeave,
          onLeaveCancelled,
          onBeforeAppear,
          onAppear,
          onAfterAppear,
          onAppearCancelled
        } = props;
        const key = String(vnode.key);
        const leavingVNodesCache = getLeavingNodesForType(state, vnode);
        const callHook2 = (hook, args) => {
          hook && callWithAsyncErrorHandling(
            hook,
            instance,
            9,
            args
          );
        };
        const callAsyncHook = (hook, args) => {
          const done = args[1];
          callHook2(hook, args);
          if (isArray$2(hook)) {
            if (hook.every((hook2) => hook2.length <= 1))
              done();
          } else if (hook.length <= 1) {
            done();
          }
        };
        const hooks = {
          mode,
          persisted,
          beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
              if (appear) {
                hook = onBeforeAppear || onBeforeEnter;
              } else {
                return;
              }
            }
            if (el._leaveCb) {
              el._leaveCb(
                true
                /* cancelled */
              );
            }
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
              leavingVNode.el._leaveCb();
            }
            callHook2(hook, [el]);
          },
          enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
              if (appear) {
                hook = onAppear || onEnter;
                afterHook = onAfterAppear || onAfterEnter;
                cancelHook = onAppearCancelled || onEnterCancelled;
              } else {
                return;
              }
            }
            let called = false;
            const done = el._enterCb = (cancelled) => {
              if (called)
                return;
              called = true;
              if (cancelled) {
                callHook2(cancelHook, [el]);
              } else {
                callHook2(afterHook, [el]);
              }
              if (hooks.delayedLeave) {
                hooks.delayedLeave();
              }
              el._enterCb = void 0;
            };
            if (hook) {
              callAsyncHook(hook, [el, done]);
            } else {
              done();
            }
          },
          leave(el, remove2) {
            const key2 = String(vnode.key);
            if (el._enterCb) {
              el._enterCb(
                true
                /* cancelled */
              );
            }
            if (state.isUnmounting) {
              return remove2();
            }
            callHook2(onBeforeLeave, [el]);
            let called = false;
            const done = el._leaveCb = (cancelled) => {
              if (called)
                return;
              called = true;
              remove2();
              if (cancelled) {
                callHook2(onLeaveCancelled, [el]);
              } else {
                callHook2(onAfterLeave, [el]);
              }
              el._leaveCb = void 0;
              if (leavingVNodesCache[key2] === vnode) {
                delete leavingVNodesCache[key2];
              }
            };
            leavingVNodesCache[key2] = vnode;
            if (onLeave) {
              callAsyncHook(onLeave, [el, done]);
            } else {
              done();
            }
          },
          clone(vnode2) {
            return resolveTransitionHooks(vnode2, props, state, instance);
          }
        };
        return hooks;
      }
      function emptyPlaceholder(vnode) {
        if (isKeepAlive(vnode)) {
          vnode = cloneVNode(vnode);
          vnode.children = null;
          return vnode;
        }
      }
      function getKeepAliveChild(vnode) {
        return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
      }
      function setTransitionHooks(vnode, hooks) {
        if (vnode.shapeFlag & 6 && vnode.component) {
          setTransitionHooks(vnode.component.subTree, hooks);
        } else if (vnode.shapeFlag & 128) {
          vnode.ssContent.transition = hooks.clone(vnode.ssContent);
          vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
        } else {
          vnode.transition = hooks;
        }
      }
      function getTransitionRawChildren(children, keepComment = false, parentKey) {
        let ret = [];
        let keyedFragmentCount = 0;
        for (let i = 0; i < children.length; i++) {
          let child = children[i];
          const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
          if (child.type === Fragment) {
            if (child.patchFlag & 128)
              keyedFragmentCount++;
            ret = ret.concat(
              getTransitionRawChildren(child.children, keepComment, key)
            );
          } else if (keepComment || child.type !== Comment) {
            ret.push(key != null ? cloneVNode(child, { key }) : child);
          }
        }
        if (keyedFragmentCount > 1) {
          for (let i = 0; i < ret.length; i++) {
            ret[i].patchFlag = -2;
          }
        }
        return ret;
      }
      function defineComponent(options, extraOptions) {
        return isFunction$1(options) ? (
          // #8326: extend call and options.name access are considered side-effects
          // by Rollup, so we have to wrap it in a pure-annotated IIFE.
          /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
        ) : options;
      }
      const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
      const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
      function onActivated(hook, target) {
        registerKeepAliveHook(hook, "a", target);
      }
      function onDeactivated(hook, target) {
        registerKeepAliveHook(hook, "da", target);
      }
      function registerKeepAliveHook(hook, type2, target = currentInstance) {
        const wrappedHook = hook.__wdc || (hook.__wdc = () => {
          let current = target;
          while (current) {
            if (current.isDeactivated) {
              return;
            }
            current = current.parent;
          }
          return hook();
        });
        injectHook(type2, wrappedHook, target);
        if (target) {
          let current = target.parent;
          while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
              injectToKeepAliveRoot(wrappedHook, type2, target, current);
            }
            current = current.parent;
          }
        }
      }
      function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
        const injected = injectHook(
          type2,
          hook,
          keepAliveRoot,
          true
          /* prepend */
        );
        onUnmounted(() => {
          remove(keepAliveRoot[type2], injected);
        }, target);
      }
      function injectHook(type2, hook, target = currentInstance, prepend = false) {
        if (target) {
          const hooks = target[type2] || (target[type2] = []);
          const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
            if (target.isUnmounted) {
              return;
            }
            pauseTracking();
            setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type2, args);
            unsetCurrentInstance();
            resetTracking();
            return res;
          });
          if (prepend) {
            hooks.unshift(wrappedHook);
          } else {
            hooks.push(wrappedHook);
          }
          return wrappedHook;
        }
      }
      const createHook = (lifecycle) => (hook, target = currentInstance) => (
        // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
        (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
      );
      const onBeforeMount = createHook("bm");
      const onMounted = createHook("m");
      const onBeforeUpdate = createHook("bu");
      const onUpdated = createHook("u");
      const onBeforeUnmount = createHook("bum");
      const onUnmounted = createHook("um");
      const onServerPrefetch = createHook("sp");
      const onRenderTriggered = createHook(
        "rtg"
      );
      const onRenderTracked = createHook(
        "rtc"
      );
      function onErrorCaptured(hook, target = currentInstance) {
        injectHook("ec", hook, target);
      }
      const COMPONENTS = "components";
      const DIRECTIVES = "directives";
      function resolveComponent(name, maybeSelfReference) {
        return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
      }
      const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
      function resolveDynamicComponent(component) {
        if (isString$1(component)) {
          return resolveAsset(COMPONENTS, component, false) || component;
        } else {
          return component || NULL_DYNAMIC_COMPONENT;
        }
      }
      function resolveDirective(name) {
        return resolveAsset(DIRECTIVES, name);
      }
      function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
        const instance = currentRenderingInstance || currentInstance;
        if (instance) {
          const Component = instance.type;
          if (type2 === COMPONENTS) {
            const selfName = getComponentName(
              Component,
              false
              /* do not include inferred name to avoid breaking existing code */
            );
            if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
              return Component;
            }
          }
          const res = (
            // local registration
            // check instance[type] first which is resolved for options API
            resolve(instance[type2] || Component[type2], name) || // global registration
            resolve(instance.appContext[type2], name)
          );
          if (!res && maybeSelfReference) {
            return Component;
          }
          return res;
        }
      }
      function resolve(registry, name) {
        return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
      }
      function renderList(source, renderItem, cache2, index) {
        let ret;
        const cached = cache2 && cache2[index];
        if (isArray$2(source) || isString$1(source)) {
          ret = new Array(source.length);
          for (let i = 0, l = source.length; i < l; i++) {
            ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
          }
        } else if (typeof source === "number") {
          ret = new Array(source);
          for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
          }
        } else if (isObject$1(source)) {
          if (source[Symbol.iterator]) {
            ret = Array.from(
              source,
              (item, i) => renderItem(item, i, void 0, cached && cached[i])
            );
          } else {
            const keys2 = Object.keys(source);
            ret = new Array(keys2.length);
            for (let i = 0, l = keys2.length; i < l; i++) {
              const key = keys2[i];
              ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
          }
        } else {
          ret = [];
        }
        if (cache2) {
          cache2[index] = ret;
        }
        return ret;
      }
      function createSlots(slots, dynamicSlots) {
        for (let i = 0; i < dynamicSlots.length; i++) {
          const slot = dynamicSlots[i];
          if (isArray$2(slot)) {
            for (let j = 0; j < slot.length; j++) {
              slots[slot[j].name] = slot[j].fn;
            }
          } else if (slot) {
            slots[slot.name] = slot.key ? (...args) => {
              const res = slot.fn(...args);
              if (res)
                res.key = slot.key;
              return res;
            } : slot.fn;
          }
        }
        return slots;
      }
      function renderSlot(slots, name, props = {}, fallback, noSlotted) {
        if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
          if (name !== "default")
            props.name = name;
          return createVNode("slot", props, fallback && fallback());
        }
        let slot = slots[name];
        if (slot && slot._c) {
          slot._d = false;
        }
        openBlock();
        const validSlotContent = slot && ensureValidVNode(slot(props));
        const rendered = createBlock(
          Fragment,
          {
            key: props.key || // slot content array of a dynamic conditional slot may have a branch
            // key attached in the `createSlots` helper, respect that
            validSlotContent && validSlotContent.key || `_${name}`
          },
          validSlotContent || (fallback ? fallback() : []),
          validSlotContent && slots._ === 1 ? 64 : -2
        );
        if (!noSlotted && rendered.scopeId) {
          rendered.slotScopeIds = [rendered.scopeId + "-s"];
        }
        if (slot && slot._c) {
          slot._d = true;
        }
        return rendered;
      }
      function ensureValidVNode(vnodes) {
        return vnodes.some((child) => {
          if (!isVNode(child))
            return true;
          if (child.type === Comment)
            return false;
          if (child.type === Fragment && !ensureValidVNode(child.children))
            return false;
          return true;
        }) ? vnodes : null;
      }
      const getPublicInstance = (i) => {
        if (!i)
          return null;
        if (isStatefulComponent(i))
          return getExposeProxy(i) || i.proxy;
        return getPublicInstance(i.parent);
      };
      const publicPropertiesMap = (
        // Move PURE marker to new line to workaround compiler discarding it
        // due to type annotation
        /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
          $: (i) => i,
          $el: (i) => i.vnode.el,
          $data: (i) => i.data,
          $props: (i) => i.props,
          $attrs: (i) => i.attrs,
          $slots: (i) => i.slots,
          $refs: (i) => i.refs,
          $parent: (i) => getPublicInstance(i.parent),
          $root: (i) => getPublicInstance(i.root),
          $emit: (i) => i.emit,
          $options: (i) => resolveMergedOptions(i),
          $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
          $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
          $watch: (i) => instanceWatch.bind(i)
        })
      );
      const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
      const PublicInstanceProxyHandlers = {
        get({ _: instance }, key) {
          const { ctx, setupState, data, props, accessCache, type: type2, appContext } = instance;
          let normalizedProps;
          if (key[0] !== "$") {
            const n = accessCache[key];
            if (n !== void 0) {
              switch (n) {
                case 1:
                  return setupState[key];
                case 2:
                  return data[key];
                case 4:
                  return ctx[key];
                case 3:
                  return props[key];
              }
            } else if (hasSetupBinding(setupState, key)) {
              accessCache[key] = 1;
              return setupState[key];
            } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
              accessCache[key] = 2;
              return data[key];
            } else if (
              // only cache other properties when instance has declared (thus stable)
              // props
              (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
            ) {
              accessCache[key] = 3;
              return props[key];
            } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
              accessCache[key] = 4;
              return ctx[key];
            } else if (shouldCacheAccess) {
              accessCache[key] = 0;
            }
          }
          const publicGetter = publicPropertiesMap[key];
          let cssModule, globalProperties;
          if (publicGetter) {
            if (key === "$attrs") {
              track(instance, "get", key);
            }
            return publicGetter(instance);
          } else if (
            // css module (injected by vue-loader)
            (cssModule = type2.__cssModules) && (cssModule = cssModule[key])
          ) {
            return cssModule;
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (
            // global properties
            globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
          ) {
            {
              return globalProperties[key];
            }
          } else
            ;
        },
        set({ _: instance }, key, value) {
          const { data, setupState, ctx } = instance;
          if (hasSetupBinding(setupState, key)) {
            setupState[key] = value;
            return true;
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            data[key] = value;
            return true;
          } else if (hasOwn(instance.props, key)) {
            return false;
          }
          if (key[0] === "$" && key.slice(1) in instance) {
            return false;
          } else {
            {
              ctx[key] = value;
            }
          }
          return true;
        },
        has({
          _: { data, setupState, accessCache, ctx, appContext, propsOptions }
        }, key) {
          let normalizedProps;
          return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
        },
        defineProperty(target, key, descriptor) {
          if (descriptor.get != null) {
            target._.accessCache[key] = 0;
          } else if (hasOwn(descriptor, "value")) {
            this.set(target, key, descriptor.value, null);
          }
          return Reflect.defineProperty(target, key, descriptor);
        }
      };
      function useSlots() {
        return getContext().slots;
      }
      function useAttrs$1() {
        return getContext().attrs;
      }
      function getContext() {
        const i = getCurrentInstance();
        return i.setupContext || (i.setupContext = createSetupContext(i));
      }
      function normalizePropsOrEmits(props) {
        return isArray$2(props) ? props.reduce(
          (normalized, p2) => (normalized[p2] = null, normalized),
          {}
        ) : props;
      }
      let shouldCacheAccess = true;
      function applyOptions(instance) {
        const options = resolveMergedOptions(instance);
        const publicThis = instance.proxy;
        const ctx = instance.ctx;
        shouldCacheAccess = false;
        if (options.beforeCreate) {
          callHook$1(options.beforeCreate, instance, "bc");
        }
        const {
          // state
          data: dataOptions,
          computed: computedOptions,
          methods,
          watch: watchOptions,
          provide: provideOptions,
          inject: injectOptions,
          // lifecycle
          created,
          beforeMount,
          mounted,
          beforeUpdate,
          updated,
          activated,
          deactivated,
          beforeDestroy,
          beforeUnmount,
          destroyed,
          unmounted,
          render: render2,
          renderTracked,
          renderTriggered,
          errorCaptured,
          serverPrefetch,
          // public API
          expose,
          inheritAttrs,
          // assets
          components,
          directives,
          filters
        } = options;
        const checkDuplicateProperties = null;
        if (injectOptions) {
          resolveInjections(injectOptions, ctx, checkDuplicateProperties);
        }
        if (methods) {
          for (const key in methods) {
            const methodHandler = methods[key];
            if (isFunction$1(methodHandler)) {
              {
                ctx[key] = methodHandler.bind(publicThis);
              }
            }
          }
        }
        if (dataOptions) {
          const data = dataOptions.call(publicThis, publicThis);
          if (!isObject$1(data))
            ;
          else {
            instance.data = reactive(data);
          }
        }
        shouldCacheAccess = true;
        if (computedOptions) {
          for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
            const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
            const c = computed({
              get: get2,
              set: set2
            });
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => c.value,
              set: (v) => c.value = v
            });
          }
        }
        if (watchOptions) {
          for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
          }
        }
        if (provideOptions) {
          const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
          Reflect.ownKeys(provides).forEach((key) => {
            provide(key, provides[key]);
          });
        }
        if (created) {
          callHook$1(created, instance, "c");
        }
        function registerLifecycleHook(register, hook) {
          if (isArray$2(hook)) {
            hook.forEach((_hook) => register(_hook.bind(publicThis)));
          } else if (hook) {
            register(hook.bind(publicThis));
          }
        }
        registerLifecycleHook(onBeforeMount, beforeMount);
        registerLifecycleHook(onMounted, mounted);
        registerLifecycleHook(onBeforeUpdate, beforeUpdate);
        registerLifecycleHook(onUpdated, updated);
        registerLifecycleHook(onActivated, activated);
        registerLifecycleHook(onDeactivated, deactivated);
        registerLifecycleHook(onErrorCaptured, errorCaptured);
        registerLifecycleHook(onRenderTracked, renderTracked);
        registerLifecycleHook(onRenderTriggered, renderTriggered);
        registerLifecycleHook(onBeforeUnmount, beforeUnmount);
        registerLifecycleHook(onUnmounted, unmounted);
        registerLifecycleHook(onServerPrefetch, serverPrefetch);
        if (isArray$2(expose)) {
          if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach((key) => {
              Object.defineProperty(exposed, key, {
                get: () => publicThis[key],
                set: (val) => publicThis[key] = val
              });
            });
          } else if (!instance.exposed) {
            instance.exposed = {};
          }
        }
        if (render2 && instance.render === NOOP) {
          instance.render = render2;
        }
        if (inheritAttrs != null) {
          instance.inheritAttrs = inheritAttrs;
        }
        if (components)
          instance.components = components;
        if (directives)
          instance.directives = directives;
      }
      function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
        if (isArray$2(injectOptions)) {
          injectOptions = normalizeInject(injectOptions);
        }
        for (const key in injectOptions) {
          const opt = injectOptions[key];
          let injected;
          if (isObject$1(opt)) {
            if ("default" in opt) {
              injected = inject(
                opt.from || key,
                opt.default,
                true
                /* treat default function as factory */
              );
            } else {
              injected = inject(opt.from || key);
            }
          } else {
            injected = inject(opt);
          }
          if (isRef(injected)) {
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => injected.value,
              set: (v) => injected.value = v
            });
          } else {
            ctx[key] = injected;
          }
        }
      }
      function callHook$1(hook, instance, type2) {
        callWithAsyncErrorHandling(
          isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
          instance,
          type2
        );
      }
      function createWatcher(raw, ctx, publicThis, key) {
        const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
        if (isString$1(raw)) {
          const handler = ctx[raw];
          if (isFunction$1(handler)) {
            watch(getter, handler);
          }
        } else if (isFunction$1(raw)) {
          watch(getter, raw.bind(publicThis));
        } else if (isObject$1(raw)) {
          if (isArray$2(raw)) {
            raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
          } else {
            const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if (isFunction$1(handler)) {
              watch(getter, handler, raw);
            }
          }
        } else
          ;
      }
      function resolveMergedOptions(instance) {
        const base2 = instance.type;
        const { mixins, extends: extendsOptions } = base2;
        const {
          mixins: globalMixins,
          optionsCache: cache2,
          config: { optionMergeStrategies }
        } = instance.appContext;
        const cached = cache2.get(base2);
        let resolved;
        if (cached) {
          resolved = cached;
        } else if (!globalMixins.length && !mixins && !extendsOptions) {
          {
            resolved = base2;
          }
        } else {
          resolved = {};
          if (globalMixins.length) {
            globalMixins.forEach(
              (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
            );
          }
          mergeOptions(resolved, base2, optionMergeStrategies);
        }
        if (isObject$1(base2)) {
          cache2.set(base2, resolved);
        }
        return resolved;
      }
      function mergeOptions(to, from, strats, asMixin = false) {
        const { mixins, extends: extendsOptions } = from;
        if (extendsOptions) {
          mergeOptions(to, extendsOptions, strats, true);
        }
        if (mixins) {
          mixins.forEach(
            (m) => mergeOptions(to, m, strats, true)
          );
        }
        for (const key in from) {
          if (asMixin && key === "expose")
            ;
          else {
            const strat = internalOptionMergeStrats[key] || strats && strats[key];
            to[key] = strat ? strat(to[key], from[key]) : from[key];
          }
        }
        return to;
      }
      const internalOptionMergeStrats = {
        data: mergeDataFn,
        props: mergeEmitsOrPropsOptions,
        emits: mergeEmitsOrPropsOptions,
        // objects
        methods: mergeObjectOptions,
        computed: mergeObjectOptions,
        // lifecycle
        beforeCreate: mergeAsArray,
        created: mergeAsArray,
        beforeMount: mergeAsArray,
        mounted: mergeAsArray,
        beforeUpdate: mergeAsArray,
        updated: mergeAsArray,
        beforeDestroy: mergeAsArray,
        beforeUnmount: mergeAsArray,
        destroyed: mergeAsArray,
        unmounted: mergeAsArray,
        activated: mergeAsArray,
        deactivated: mergeAsArray,
        errorCaptured: mergeAsArray,
        serverPrefetch: mergeAsArray,
        // assets
        components: mergeObjectOptions,
        directives: mergeObjectOptions,
        // watch
        watch: mergeWatchOptions,
        // provide / inject
        provide: mergeDataFn,
        inject: mergeInject
      };
      function mergeDataFn(to, from) {
        if (!from) {
          return to;
        }
        if (!to) {
          return from;
        }
        return function mergedDataFn() {
          return extend(
            isFunction$1(to) ? to.call(this, this) : to,
            isFunction$1(from) ? from.call(this, this) : from
          );
        };
      }
      function mergeInject(to, from) {
        return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
      }
      function normalizeInject(raw) {
        if (isArray$2(raw)) {
          const res = {};
          for (let i = 0; i < raw.length; i++) {
            res[raw[i]] = raw[i];
          }
          return res;
        }
        return raw;
      }
      function mergeAsArray(to, from) {
        return to ? [...new Set([].concat(to, from))] : from;
      }
      function mergeObjectOptions(to, from) {
        return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
      }
      function mergeEmitsOrPropsOptions(to, from) {
        if (to) {
          if (isArray$2(to) && isArray$2(from)) {
            return [.../* @__PURE__ */ new Set([...to, ...from])];
          }
          return extend(
            /* @__PURE__ */ Object.create(null),
            normalizePropsOrEmits(to),
            normalizePropsOrEmits(from != null ? from : {})
          );
        } else {
          return from;
        }
      }
      function mergeWatchOptions(to, from) {
        if (!to)
          return from;
        if (!from)
          return to;
        const merged = extend(/* @__PURE__ */ Object.create(null), to);
        for (const key in from) {
          merged[key] = mergeAsArray(to[key], from[key]);
        }
        return merged;
      }
      function createAppContext() {
        return {
          app: null,
          config: {
            isNativeTag: NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
          },
          mixins: [],
          components: {},
          directives: {},
          provides: /* @__PURE__ */ Object.create(null),
          optionsCache: /* @__PURE__ */ new WeakMap(),
          propsCache: /* @__PURE__ */ new WeakMap(),
          emitsCache: /* @__PURE__ */ new WeakMap()
        };
      }
      let uid$1 = 0;
      function createAppAPI(render2, hydrate) {
        return function createApp2(rootComponent, rootProps = null) {
          if (!isFunction$1(rootComponent)) {
            rootComponent = extend({}, rootComponent);
          }
          if (rootProps != null && !isObject$1(rootProps)) {
            rootProps = null;
          }
          const context = createAppContext();
          const installedPlugins = /* @__PURE__ */ new Set();
          let isMounted = false;
          const app2 = context.app = {
            _uid: uid$1++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config() {
              return context.config;
            },
            set config(v) {
            },
            use(plugin, ...options) {
              if (installedPlugins.has(plugin))
                ;
              else if (plugin && isFunction$1(plugin.install)) {
                installedPlugins.add(plugin);
                plugin.install(app2, ...options);
              } else if (isFunction$1(plugin)) {
                installedPlugins.add(plugin);
                plugin(app2, ...options);
              } else
                ;
              return app2;
            },
            mixin(mixin) {
              {
                if (!context.mixins.includes(mixin)) {
                  context.mixins.push(mixin);
                }
              }
              return app2;
            },
            component(name, component) {
              if (!component) {
                return context.components[name];
              }
              context.components[name] = component;
              return app2;
            },
            directive(name, directive) {
              if (!directive) {
                return context.directives[name];
              }
              context.directives[name] = directive;
              return app2;
            },
            mount(rootContainer, isHydrate, isSVG) {
              if (!isMounted) {
                const vnode = createVNode(
                  rootComponent,
                  rootProps
                );
                vnode.appContext = context;
                if (isHydrate && hydrate) {
                  hydrate(vnode, rootContainer);
                } else {
                  render2(vnode, rootContainer, isSVG);
                }
                isMounted = true;
                app2._container = rootContainer;
                rootContainer.__vue_app__ = app2;
                return getExposeProxy(vnode.component) || vnode.component.proxy;
              }
            },
            unmount() {
              if (isMounted) {
                render2(null, app2._container);
                delete app2._container.__vue_app__;
              }
            },
            provide(key, value) {
              context.provides[key] = value;
              return app2;
            },
            runWithContext(fn2) {
              currentApp = app2;
              try {
                return fn2();
              } finally {
                currentApp = null;
              }
            }
          };
          return app2;
        };
      }
      let currentApp = null;
      function provide(key, value) {
        if (!currentInstance)
          ;
        else {
          let provides = currentInstance.provides;
          const parentProvides = currentInstance.parent && currentInstance.parent.provides;
          if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
          }
          provides[key] = value;
        }
      }
      function inject(key, defaultValue, treatDefaultAsFactory = false) {
        const instance = currentInstance || currentRenderingInstance;
        if (instance || currentApp) {
          const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
          if (provides && key in provides) {
            return provides[key];
          } else if (arguments.length > 1) {
            return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
          } else
            ;
        }
      }
      function hasInjectionContext() {
        return !!(currentInstance || currentRenderingInstance || currentApp);
      }
      function initProps(instance, rawProps, isStateful, isSSR = false) {
        const props = {};
        const attrs = {};
        def(attrs, InternalObjectKey, 1);
        instance.propsDefaults = /* @__PURE__ */ Object.create(null);
        setFullProps(instance, rawProps, props, attrs);
        for (const key in instance.propsOptions[0]) {
          if (!(key in props)) {
            props[key] = void 0;
          }
        }
        if (isStateful) {
          instance.props = isSSR ? props : shallowReactive(props);
        } else {
          if (!instance.type.props) {
            instance.props = attrs;
          } else {
            instance.props = props;
          }
        }
        instance.attrs = attrs;
      }
      function updateProps(instance, rawProps, rawPrevProps, optimized) {
        const {
          props,
          attrs,
          vnode: { patchFlag }
        } = instance;
        const rawCurrentProps = toRaw(props);
        const [options] = instance.propsOptions;
        let hasAttrsChanged = false;
        if (
          // always force full diff in dev
          // - #1942 if hmr is enabled with sfc component
          // - vite#872 non-sfc component used by sfc component
          (optimized || patchFlag > 0) && !(patchFlag & 16)
        ) {
          if (patchFlag & 8) {
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              let key = propsToUpdate[i];
              if (isEmitListener(instance.emitsOptions, key)) {
                continue;
              }
              const value = rawProps[key];
              if (options) {
                if (hasOwn(attrs, key)) {
                  if (value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                  }
                } else {
                  const camelizedKey = camelize(key);
                  props[camelizedKey] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    camelizedKey,
                    value,
                    instance,
                    false
                    /* isAbsent */
                  );
                }
              } else {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              }
            }
          }
        } else {
          if (setFullProps(instance, rawProps, props, attrs)) {
            hasAttrsChanged = true;
          }
          let kebabKey;
          for (const key in rawCurrentProps) {
            if (!rawProps || // for camelCase
            !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
            // and converted to camelCase (#955)
            ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
              if (options) {
                if (rawPrevProps && // for camelCase
                (rawPrevProps[key] !== void 0 || // for kebab-case
                rawPrevProps[kebabKey] !== void 0)) {
                  props[key] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    key,
                    void 0,
                    instance,
                    true
                    /* isAbsent */
                  );
                }
              } else {
                delete props[key];
              }
            }
          }
          if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
              if (!rawProps || !hasOwn(rawProps, key) && true) {
                delete attrs[key];
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (hasAttrsChanged) {
          trigger(instance, "set", "$attrs");
        }
      }
      function setFullProps(instance, rawProps, props, attrs) {
        const [options, needCastKeys] = instance.propsOptions;
        let hasAttrsChanged = false;
        let rawCastValues;
        if (rawProps) {
          for (let key in rawProps) {
            if (isReservedProp(key)) {
              continue;
            }
            const value = rawProps[key];
            let camelKey;
            if (options && hasOwn(options, camelKey = camelize(key))) {
              if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                props[camelKey] = value;
              } else {
                (rawCastValues || (rawCastValues = {}))[camelKey] = value;
              }
            } else if (!isEmitListener(instance.emitsOptions, key)) {
              if (!(key in attrs) || value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (needCastKeys) {
          const rawCurrentProps = toRaw(props);
          const castValues = rawCastValues || EMPTY_OBJ;
          for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              castValues[key],
              instance,
              !hasOwn(castValues, key)
            );
          }
        }
        return hasAttrsChanged;
      }
      function resolvePropValue(options, props, key, value, instance, isAbsent) {
        const opt = options[key];
        if (opt != null) {
          const hasDefault = hasOwn(opt, "default");
          if (hasDefault && value === void 0) {
            const defaultValue = opt.default;
            if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
              const { propsDefaults } = instance;
              if (key in propsDefaults) {
                value = propsDefaults[key];
              } else {
                setCurrentInstance(instance);
                value = propsDefaults[key] = defaultValue.call(
                  null,
                  props
                );
                unsetCurrentInstance();
              }
            } else {
              value = defaultValue;
            }
          }
          if (opt[
            0
            /* shouldCast */
          ]) {
            if (isAbsent && !hasDefault) {
              value = false;
            } else if (opt[
              1
              /* shouldCastTrue */
            ] && (value === "" || value === hyphenate(key))) {
              value = true;
            }
          }
        }
        return value;
      }
      function normalizePropsOptions(comp, appContext, asMixin = false) {
        const cache2 = appContext.propsCache;
        const cached = cache2.get(comp);
        if (cached) {
          return cached;
        }
        const raw = comp.props;
        const normalized = {};
        const needCastKeys = [];
        let hasExtends = false;
        if (!isFunction$1(comp)) {
          const extendProps = (raw2) => {
            hasExtends = true;
            const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
            extend(normalized, props);
            if (keys2)
              needCastKeys.push(...keys2);
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
          }
          if (comp.extends) {
            extendProps(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendProps);
          }
        }
        if (!raw && !hasExtends) {
          if (isObject$1(comp)) {
            cache2.set(comp, EMPTY_ARR);
          }
          return EMPTY_ARR;
        }
        if (isArray$2(raw)) {
          for (let i = 0; i < raw.length; i++) {
            const normalizedKey = camelize(raw[i]);
            if (validatePropName(normalizedKey)) {
              normalized[normalizedKey] = EMPTY_OBJ;
            }
          }
        } else if (raw) {
          for (const key in raw) {
            const normalizedKey = camelize(key);
            if (validatePropName(normalizedKey)) {
              const opt = raw[key];
              const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
              if (prop) {
                const booleanIndex = getTypeIndex(Boolean, prop.type);
                const stringIndex = getTypeIndex(String, prop.type);
                prop[
                  0
                  /* shouldCast */
                ] = booleanIndex > -1;
                prop[
                  1
                  /* shouldCastTrue */
                ] = stringIndex < 0 || booleanIndex < stringIndex;
                if (booleanIndex > -1 || hasOwn(prop, "default")) {
                  needCastKeys.push(normalizedKey);
                }
              }
            }
          }
        }
        const res = [normalized, needCastKeys];
        if (isObject$1(comp)) {
          cache2.set(comp, res);
        }
        return res;
      }
      function validatePropName(key) {
        if (key[0] !== "$") {
          return true;
        }
        return false;
      }
      function getType(ctor) {
        const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
        return match ? match[2] : ctor === null ? "null" : "";
      }
      function isSameType(a, b) {
        return getType(a) === getType(b);
      }
      function getTypeIndex(type2, expectedTypes) {
        if (isArray$2(expectedTypes)) {
          return expectedTypes.findIndex((t) => isSameType(t, type2));
        } else if (isFunction$1(expectedTypes)) {
          return isSameType(expectedTypes, type2) ? 0 : -1;
        }
        return -1;
      }
      const isInternalKey = (key) => key[0] === "_" || key === "$stable";
      const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
      const normalizeSlot = (key, rawSlot, ctx) => {
        if (rawSlot._n) {
          return rawSlot;
        }
        const normalized = withCtx((...args) => {
          if (false)
            ;
          return normalizeSlotValue(rawSlot(...args));
        }, ctx);
        normalized._c = false;
        return normalized;
      };
      const normalizeObjectSlots = (rawSlots, slots, instance) => {
        const ctx = rawSlots._ctx;
        for (const key in rawSlots) {
          if (isInternalKey(key))
            continue;
          const value = rawSlots[key];
          if (isFunction$1(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
          } else if (value != null) {
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
          }
        }
      };
      const normalizeVNodeSlots = (instance, children) => {
        const normalized = normalizeSlotValue(children);
        instance.slots.default = () => normalized;
      };
      const initSlots = (instance, children) => {
        if (instance.vnode.shapeFlag & 32) {
          const type2 = children._;
          if (type2) {
            instance.slots = toRaw(children);
            def(children, "_", type2);
          } else {
            normalizeObjectSlots(
              children,
              instance.slots = {}
            );
          }
        } else {
          instance.slots = {};
          if (children) {
            normalizeVNodeSlots(instance, children);
          }
        }
        def(instance.slots, InternalObjectKey, 1);
      };
      const updateSlots = (instance, children, optimized) => {
        const { vnode, slots } = instance;
        let needDeletionCheck = true;
        let deletionComparisonTarget = EMPTY_OBJ;
        if (vnode.shapeFlag & 32) {
          const type2 = children._;
          if (type2) {
            if (optimized && type2 === 1) {
              needDeletionCheck = false;
            } else {
              extend(slots, children);
              if (!optimized && type2 === 1) {
                delete slots._;
              }
            }
          } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
          }
          deletionComparisonTarget = children;
        } else if (children) {
          normalizeVNodeSlots(instance, children);
          deletionComparisonTarget = { default: 1 };
        }
        if (needDeletionCheck) {
          for (const key in slots) {
            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
              delete slots[key];
            }
          }
        }
      };
      function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
        if (isArray$2(rawRef)) {
          rawRef.forEach(
            (r, i) => setRef(
              r,
              oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef),
              parentSuspense,
              vnode,
              isUnmount
            )
          );
          return;
        }
        if (isAsyncWrapper(vnode) && !isUnmount) {
          return;
        }
        const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
        const value = isUnmount ? null : refValue;
        const { i: owner, r: ref2 } = rawRef;
        const oldRef = oldRawRef && oldRawRef.r;
        const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
        const setupState = owner.setupState;
        if (oldRef != null && oldRef !== ref2) {
          if (isString$1(oldRef)) {
            refs[oldRef] = null;
            if (hasOwn(setupState, oldRef)) {
              setupState[oldRef] = null;
            }
          } else if (isRef(oldRef)) {
            oldRef.value = null;
          }
        }
        if (isFunction$1(ref2)) {
          callWithErrorHandling(ref2, owner, 12, [value, refs]);
        } else {
          const _isString = isString$1(ref2);
          const _isRef = isRef(ref2);
          if (_isString || _isRef) {
            const doSet = () => {
              if (rawRef.f) {
                const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
                if (isUnmount) {
                  isArray$2(existing) && remove(existing, refValue);
                } else {
                  if (!isArray$2(existing)) {
                    if (_isString) {
                      refs[ref2] = [refValue];
                      if (hasOwn(setupState, ref2)) {
                        setupState[ref2] = refs[ref2];
                      }
                    } else {
                      ref2.value = [refValue];
                      if (rawRef.k)
                        refs[rawRef.k] = ref2.value;
                    }
                  } else if (!existing.includes(refValue)) {
                    existing.push(refValue);
                  }
                }
              } else if (_isString) {
                refs[ref2] = value;
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = value;
                }
              } else if (_isRef) {
                ref2.value = value;
                if (rawRef.k)
                  refs[rawRef.k] = value;
              } else
                ;
            };
            if (value) {
              doSet.id = -1;
              queuePostRenderEffect(doSet, parentSuspense);
            } else {
              doSet();
            }
          }
        }
      }
      const queuePostRenderEffect = queueEffectWithSuspense;
      function createRenderer(options) {
        return baseCreateRenderer(options);
      }
      function baseCreateRenderer(options, createHydrationFns) {
        const target = getGlobalThis();
        target.__VUE__ = true;
        const {
          insert: hostInsert,
          remove: hostRemove,
          patchProp: hostPatchProp,
          createElement: hostCreateElement,
          createText: hostCreateText,
          createComment: hostCreateComment,
          setText: hostSetText,
          setElementText: hostSetElementText,
          parentNode: hostParentNode,
          nextSibling: hostNextSibling,
          setScopeId: hostSetScopeId = NOOP,
          insertStaticContent: hostInsertStaticContent
        } = options;
        const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
          if (n1 === n2) {
            return;
          }
          if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
          }
          if (n2.patchFlag === -2) {
            optimized = false;
            n2.dynamicChildren = null;
          }
          const { type: type2, ref: ref2, shapeFlag } = n2;
          switch (type2) {
            case Text:
              processText(n1, n2, container, anchor);
              break;
            case Comment:
              processCommentNode(n1, n2, container, anchor);
              break;
            case Static:
              if (n1 == null) {
                mountStaticNode(n2, container, anchor, isSVG);
              }
              break;
            case Fragment:
              processFragment(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              break;
            default:
              if (shapeFlag & 1) {
                processElement(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else if (shapeFlag & 6) {
                processComponent(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else if (shapeFlag & 64) {
                type2.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized,
                  internals
                );
              } else if (shapeFlag & 128) {
                type2.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized,
                  internals
                );
              } else
                ;
          }
          if (ref2 != null && parentComponent) {
            setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
          }
        };
        const processText = (n1, n2, container, anchor) => {
          if (n1 == null) {
            hostInsert(
              n2.el = hostCreateText(n2.children),
              container,
              anchor
            );
          } else {
            const el = n2.el = n1.el;
            if (n2.children !== n1.children) {
              hostSetText(el, n2.children);
            }
          }
        };
        const processCommentNode = (n1, n2, container, anchor) => {
          if (n1 == null) {
            hostInsert(
              n2.el = hostCreateComment(n2.children || ""),
              container,
              anchor
            );
          } else {
            n2.el = n1.el;
          }
        };
        const mountStaticNode = (n2, container, anchor, isSVG) => {
          [n2.el, n2.anchor] = hostInsertStaticContent(
            n2.children,
            container,
            anchor,
            isSVG,
            n2.el,
            n2.anchor
          );
        };
        const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
          let next;
          while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
          }
          hostInsert(anchor, container, nextSibling);
        };
        const removeStaticNode = ({ el, anchor }) => {
          let next;
          while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
          }
          hostRemove(anchor);
        };
        const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          isSVG = isSVG || n2.type === "svg";
          if (n1 == null) {
            mountElement(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          } else {
            patchElement(
              n1,
              n2,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          }
        };
        const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          let el;
          let vnodeHook;
          const { type: type2, props, shapeFlag, transition, dirs } = vnode;
          el = vnode.el = hostCreateElement(
            vnode.type,
            isSVG,
            props && props.is,
            props
          );
          if (shapeFlag & 8) {
            hostSetElementText(el, vnode.children);
          } else if (shapeFlag & 16) {
            mountChildren(
              vnode.children,
              el,
              null,
              parentComponent,
              parentSuspense,
              isSVG && type2 !== "foreignObject",
              slotScopeIds,
              optimized
            );
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "created");
          }
          setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
          if (props) {
            for (const key in props) {
              if (key !== "value" && !isReservedProp(key)) {
                hostPatchProp(
                  el,
                  key,
                  null,
                  props[key],
                  isSVG,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
            if ("value" in props) {
              hostPatchProp(el, "value", null, props.value);
            }
            if (vnodeHook = props.onVnodeBeforeMount) {
              invokeVNodeHook(vnodeHook, parentComponent, vnode);
            }
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
          }
          const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
          if (needCallTransitionHooks) {
            transition.beforeEnter(el);
          }
          hostInsert(el, container, anchor);
          if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              needCallTransitionHooks && transition.enter(el);
              dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
          }
        };
        const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
          if (scopeId) {
            hostSetScopeId(el, scopeId);
          }
          if (slotScopeIds) {
            for (let i = 0; i < slotScopeIds.length; i++) {
              hostSetScopeId(el, slotScopeIds[i]);
            }
          }
          if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (vnode === subTree) {
              const parentVNode = parentComponent.vnode;
              setScopeId(
                el,
                parentVNode,
                parentVNode.scopeId,
                parentVNode.slotScopeIds,
                parentComponent.parent
              );
            }
          }
        };
        const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
          for (let i = start; i < children.length; i++) {
            const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
            patch(
              null,
              child,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          }
        };
        const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          const el = n2.el = n1.el;
          let { patchFlag, dynamicChildren, dirs } = n2;
          patchFlag |= n1.patchFlag & 16;
          const oldProps = n1.props || EMPTY_OBJ;
          const newProps = n2.props || EMPTY_OBJ;
          let vnodeHook;
          parentComponent && toggleRecurse(parentComponent, false);
          if (vnodeHook = newProps.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          }
          if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
          }
          parentComponent && toggleRecurse(parentComponent, true);
          const areChildrenSVG = isSVG && n2.type !== "foreignObject";
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              el,
              parentComponent,
              parentSuspense,
              areChildrenSVG,
              slotScopeIds
            );
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              el,
              null,
              parentComponent,
              parentSuspense,
              areChildrenSVG,
              slotScopeIds,
              false
            );
          }
          if (patchFlag > 0) {
            if (patchFlag & 16) {
              patchProps(
                el,
                n2,
                oldProps,
                newProps,
                parentComponent,
                parentSuspense,
                isSVG
              );
            } else {
              if (patchFlag & 2) {
                if (oldProps.class !== newProps.class) {
                  hostPatchProp(el, "class", null, newProps.class, isSVG);
                }
              }
              if (patchFlag & 4) {
                hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
              }
              if (patchFlag & 8) {
                const propsToUpdate = n2.dynamicProps;
                for (let i = 0; i < propsToUpdate.length; i++) {
                  const key = propsToUpdate[i];
                  const prev = oldProps[key];
                  const next = newProps[key];
                  if (next !== prev || key === "value") {
                    hostPatchProp(
                      el,
                      key,
                      prev,
                      next,
                      isSVG,
                      n1.children,
                      parentComponent,
                      parentSuspense,
                      unmountChildren
                    );
                  }
                }
              }
            }
            if (patchFlag & 1) {
              if (n1.children !== n2.children) {
                hostSetElementText(el, n2.children);
              }
            }
          } else if (!optimized && dynamicChildren == null) {
            patchProps(
              el,
              n2,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              isSVG
            );
          }
          if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
              dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
            }, parentSuspense);
          }
        };
        const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
          for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            const container = (
              // oldVNode may be an errored async setup() component inside Suspense
              // which will not have a mounted element
              oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
              // of the Fragment itself so it can move its children.
              (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
              // which also requires the correct parent container
              !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
              oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
                // In other cases, the parent container is not actually used so we
                // just pass the block element here to avoid a DOM parentNode call.
                fallbackContainer
              )
            );
            patch(
              oldVNode,
              newVNode,
              container,
              null,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              true
            );
          }
        };
        const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
          if (oldProps !== newProps) {
            if (oldProps !== EMPTY_OBJ) {
              for (const key in oldProps) {
                if (!isReservedProp(key) && !(key in newProps)) {
                  hostPatchProp(
                    el,
                    key,
                    oldProps[key],
                    null,
                    isSVG,
                    vnode.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
            }
            for (const key in newProps) {
              if (isReservedProp(key))
                continue;
              const next = newProps[key];
              const prev = oldProps[key];
              if (next !== prev && key !== "value") {
                hostPatchProp(
                  el,
                  key,
                  prev,
                  next,
                  isSVG,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
            if ("value" in newProps) {
              hostPatchProp(el, "value", oldProps.value, newProps.value);
            }
          }
        };
        const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
          const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
          let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
          if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
          }
          if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            mountChildren(
              n2.children,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          } else {
            if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
            // of renderSlot() with no valid children
            n1.dynamicChildren) {
              patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                container,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds
              );
              if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n2.key != null || parentComponent && n2 === parentComponent.subTree
              ) {
                traverseStaticChildren(
                  n1,
                  n2,
                  true
                  /* shallow */
                );
              }
            } else {
              patchChildren(
                n1,
                n2,
                container,
                fragmentEndAnchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            }
          }
        };
        const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          n2.slotScopeIds = slotScopeIds;
          if (n1 == null) {
            if (n2.shapeFlag & 512) {
              parentComponent.ctx.activate(
                n2,
                container,
                anchor,
                isSVG,
                optimized
              );
            } else {
              mountComponent(
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                optimized
              );
            }
          } else {
            updateComponent(n1, n2, optimized);
          }
        };
        const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
          const instance = initialVNode.component = createComponentInstance(
            initialVNode,
            parentComponent,
            parentSuspense
          );
          if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
          }
          {
            setupComponent(instance);
          }
          if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            if (!initialVNode.el) {
              const placeholder = instance.subTree = createVNode(Comment);
              processCommentNode(null, placeholder, container, anchor);
            }
            return;
          }
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            isSVG,
            optimized
          );
        };
        const updateComponent = (n1, n2, optimized) => {
          const instance = n2.component = n1.component;
          if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
              updateComponentPreRender(instance, n2, optimized);
              return;
            } else {
              instance.next = n2;
              invalidateJob(instance.update);
              instance.update();
            }
          } else {
            n2.el = n1.el;
            instance.vnode = n2;
          }
        };
        const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
          const componentUpdateFn = () => {
            if (!instance.isMounted) {
              let vnodeHook;
              const { el, props } = initialVNode;
              const { bm, m, parent } = instance;
              const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
              toggleRecurse(instance, false);
              if (bm) {
                invokeArrayFns(bm);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHook, parent, initialVNode);
              }
              toggleRecurse(instance, true);
              if (el && hydrateNode) {
                const hydrateSubTree = () => {
                  instance.subTree = renderComponentRoot(instance);
                  hydrateNode(
                    el,
                    instance.subTree,
                    instance,
                    parentSuspense,
                    null
                  );
                };
                if (isAsyncWrapperVNode) {
                  initialVNode.type.__asyncLoader().then(
                    // note: we are moving the render call into an async callback,
                    // which means it won't track dependencies - but it's ok because
                    // a server-rendered async wrapper is already in resolved state
                    // and it will never need to change.
                    () => !instance.isUnmounted && hydrateSubTree()
                  );
                } else {
                  hydrateSubTree();
                }
              } else {
                const subTree = instance.subTree = renderComponentRoot(instance);
                patch(
                  null,
                  subTree,
                  container,
                  anchor,
                  instance,
                  parentSuspense,
                  isSVG
                );
                initialVNode.el = subTree.el;
              }
              if (m) {
                queuePostRenderEffect(m, parentSuspense);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                const scopedInitialVNode = initialVNode;
                queuePostRenderEffect(
                  () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                  parentSuspense
                );
              }
              if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
                instance.a && queuePostRenderEffect(instance.a, parentSuspense);
              }
              instance.isMounted = true;
              initialVNode = container = anchor = null;
            } else {
              let { next, bu, u, parent, vnode } = instance;
              let originNext = next;
              let vnodeHook;
              toggleRecurse(instance, false);
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              } else {
                next = vnode;
              }
              if (bu) {
                invokeArrayFns(bu);
              }
              if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
                invokeVNodeHook(vnodeHook, parent, next, vnode);
              }
              toggleRecurse(instance, true);
              const nextTree = renderComponentRoot(instance);
              const prevTree = instance.subTree;
              instance.subTree = nextTree;
              patch(
                prevTree,
                nextTree,
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el),
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree),
                instance,
                parentSuspense,
                isSVG
              );
              next.el = nextTree.el;
              if (originNext === null) {
                updateHOCHostEl(instance, nextTree.el);
              }
              if (u) {
                queuePostRenderEffect(u, parentSuspense);
              }
              if (vnodeHook = next.props && next.props.onVnodeUpdated) {
                queuePostRenderEffect(
                  () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                  parentSuspense
                );
              }
            }
          };
          const effect = instance.effect = new ReactiveEffect(
            componentUpdateFn,
            () => queueJob(update),
            instance.scope
            // track it in component's effect scope
          );
          const update = instance.update = () => effect.run();
          update.id = instance.uid;
          toggleRecurse(instance, true);
          update();
        };
        const updateComponentPreRender = (instance, nextVNode, optimized) => {
          nextVNode.component = instance;
          const prevProps = instance.vnode.props;
          instance.vnode = nextVNode;
          instance.next = null;
          updateProps(instance, nextVNode.props, prevProps, optimized);
          updateSlots(instance, nextVNode.children, optimized);
          pauseTracking();
          flushPreFlushCbs();
          resetTracking();
        };
        const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
          const c1 = n1 && n1.children;
          const prevShapeFlag = n1 ? n1.shapeFlag : 0;
          const c2 = n2.children;
          const { patchFlag, shapeFlag } = n2;
          if (patchFlag > 0) {
            if (patchFlag & 128) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              return;
            } else if (patchFlag & 256) {
              patchUnkeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              return;
            }
          }
          if (shapeFlag & 8) {
            if (prevShapeFlag & 16) {
              unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
              hostSetElementText(container, c2);
            }
          } else {
            if (prevShapeFlag & 16) {
              if (shapeFlag & 16) {
                patchKeyedChildren(
                  c1,
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else {
                unmountChildren(c1, parentComponent, parentSuspense, true);
              }
            } else {
              if (prevShapeFlag & 8) {
                hostSetElementText(container, "");
              }
              if (shapeFlag & 16) {
                mountChildren(
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              }
            }
          }
        };
        const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          c1 = c1 || EMPTY_ARR;
          c2 = c2 || EMPTY_ARR;
          const oldLength = c1.length;
          const newLength = c2.length;
          const commonLength = Math.min(oldLength, newLength);
          let i;
          for (i = 0; i < commonLength; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            patch(
              c1[i],
              nextChild,
              container,
              null,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          }
          if (oldLength > newLength) {
            unmountChildren(
              c1,
              parentComponent,
              parentSuspense,
              true,
              false,
              commonLength
            );
          } else {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized,
              commonLength
            );
          }
        };
        const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          let i = 0;
          const l2 = c2.length;
          let e1 = c1.length - 1;
          let e2 = l2 - 1;
          while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (isSameVNodeType(n1, n2)) {
              patch(
                n1,
                n2,
                container,
                null,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            } else {
              break;
            }
            i++;
          }
          while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
            if (isSameVNodeType(n1, n2)) {
              patch(
                n1,
                n2,
                container,
                null,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            } else {
              break;
            }
            e1--;
            e2--;
          }
          if (i > e1) {
            if (i <= e2) {
              const nextPos = e2 + 1;
              const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
              while (i <= e2) {
                patch(
                  null,
                  c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                i++;
              }
            }
          } else if (i > e2) {
            while (i <= e1) {
              unmount(c1[i], parentComponent, parentSuspense, true);
              i++;
            }
          } else {
            const s1 = i;
            const s2 = i;
            const keyToNewIndexMap = /* @__PURE__ */ new Map();
            for (i = s2; i <= e2; i++) {
              const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
              if (nextChild.key != null) {
                keyToNewIndexMap.set(nextChild.key, i);
              }
            }
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            let maxNewIndexSoFar = 0;
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++)
              newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
              const prevChild = c1[i];
              if (patched >= toBePatched) {
                unmount(prevChild, parentComponent, parentSuspense, true);
                continue;
              }
              let newIndex;
              if (prevChild.key != null) {
                newIndex = keyToNewIndexMap.get(prevChild.key);
              } else {
                for (j = s2; j <= e2; j++) {
                  if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                    newIndex = j;
                    break;
                  }
                }
              }
              if (newIndex === void 0) {
                unmount(prevChild, parentComponent, parentSuspense, true);
              } else {
                newIndexToOldIndexMap[newIndex - s2] = i + 1;
                if (newIndex >= maxNewIndexSoFar) {
                  maxNewIndexSoFar = newIndex;
                } else {
                  moved = true;
                }
                patch(
                  prevChild,
                  c2[newIndex],
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                patched++;
              }
            }
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
            j = increasingNewIndexSequence.length - 1;
            for (i = toBePatched - 1; i >= 0; i--) {
              const nextIndex = s2 + i;
              const nextChild = c2[nextIndex];
              const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
              if (newIndexToOldIndexMap[i] === 0) {
                patch(
                  null,
                  nextChild,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              } else if (moved) {
                if (j < 0 || i !== increasingNewIndexSequence[j]) {
                  move(nextChild, container, anchor, 2);
                } else {
                  j--;
                }
              }
            }
          }
        };
        const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
          const { el, type: type2, transition, children, shapeFlag } = vnode;
          if (shapeFlag & 6) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
          }
          if (shapeFlag & 128) {
            vnode.suspense.move(container, anchor, moveType);
            return;
          }
          if (shapeFlag & 64) {
            type2.move(vnode, container, anchor, internals);
            return;
          }
          if (type2 === Fragment) {
            hostInsert(el, container, anchor);
            for (let i = 0; i < children.length; i++) {
              move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
          }
          if (type2 === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
          }
          const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
          if (needTransition) {
            if (moveType === 0) {
              transition.beforeEnter(el);
              hostInsert(el, container, anchor);
              queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            } else {
              const { leave, delayLeave, afterLeave } = transition;
              const remove22 = () => hostInsert(el, container, anchor);
              const performLeave = () => {
                leave(el, () => {
                  remove22();
                  afterLeave && afterLeave();
                });
              };
              if (delayLeave) {
                delayLeave(el, remove22, performLeave);
              } else {
                performLeave();
              }
            }
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
          const {
            type: type2,
            props,
            ref: ref2,
            children,
            dynamicChildren,
            shapeFlag,
            patchFlag,
            dirs
          } = vnode;
          if (ref2 != null) {
            setRef(ref2, null, parentSuspense, vnode, true);
          }
          if (shapeFlag & 256) {
            parentComponent.ctx.deactivate(vnode);
            return;
          }
          const shouldInvokeDirs = shapeFlag & 1 && dirs;
          const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
          let vnodeHook;
          if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
          if (shapeFlag & 6) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
          } else {
            if (shapeFlag & 128) {
              vnode.suspense.unmount(parentSuspense, doRemove);
              return;
            }
            if (shouldInvokeDirs) {
              invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
            }
            if (shapeFlag & 64) {
              vnode.type.remove(
                vnode,
                parentComponent,
                parentSuspense,
                optimized,
                internals,
                doRemove
              );
            } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
            (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
              unmountChildren(
                dynamicChildren,
                parentComponent,
                parentSuspense,
                false,
                true
              );
            } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
              unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
              remove2(vnode);
            }
          }
          if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
            }, parentSuspense);
          }
        };
        const remove2 = (vnode) => {
          const { type: type2, el, anchor, transition } = vnode;
          if (type2 === Fragment) {
            {
              removeFragment(el, anchor);
            }
            return;
          }
          if (type2 === Static) {
            removeStaticNode(vnode);
            return;
          }
          const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
              transition.afterLeave();
            }
          };
          if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
              delayLeave(vnode.el, performRemove, performLeave);
            } else {
              performLeave();
            }
          } else {
            performRemove();
          }
        };
        const removeFragment = (cur, end2) => {
          let next;
          while (cur !== end2) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
          }
          hostRemove(end2);
        };
        const unmountComponent = (instance, parentSuspense, doRemove) => {
          const { bum, scope, update, subTree, um } = instance;
          if (bum) {
            invokeArrayFns(bum);
          }
          scope.stop();
          if (update) {
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
          }
          if (um) {
            queuePostRenderEffect(um, parentSuspense);
          }
          queuePostRenderEffect(() => {
            instance.isUnmounted = true;
          }, parentSuspense);
          if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
              parentSuspense.resolve();
            }
          }
        };
        const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
          for (let i = start; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
          }
        };
        const getNextHostNode = (vnode) => {
          if (vnode.shapeFlag & 6) {
            return getNextHostNode(vnode.component.subTree);
          }
          if (vnode.shapeFlag & 128) {
            return vnode.suspense.next();
          }
          return hostNextSibling(vnode.anchor || vnode.el);
        };
        const render2 = (vnode, container, isSVG) => {
          if (vnode == null) {
            if (container._vnode) {
              unmount(container._vnode, null, null, true);
            }
          } else {
            patch(container._vnode || null, vnode, container, null, null, null, isSVG);
          }
          flushPreFlushCbs();
          flushPostFlushCbs();
          container._vnode = vnode;
        };
        const internals = {
          p: patch,
          um: unmount,
          m: move,
          r: remove2,
          mt: mountComponent,
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          n: getNextHostNode,
          o: options
        };
        let hydrate;
        let hydrateNode;
        if (createHydrationFns) {
          [hydrate, hydrateNode] = createHydrationFns(
            internals
          );
        }
        return {
          render: render2,
          hydrate,
          createApp: createAppAPI(render2, hydrate)
        };
      }
      function toggleRecurse({ effect, update }, allowed) {
        effect.allowRecurse = update.allowRecurse = allowed;
      }
      function traverseStaticChildren(n1, n2, shallow = false) {
        const ch1 = n1.children;
        const ch2 = n2.children;
        if (isArray$2(ch1) && isArray$2(ch2)) {
          for (let i = 0; i < ch1.length; i++) {
            const c1 = ch1[i];
            let c2 = ch2[i];
            if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
              if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                c2 = ch2[i] = cloneIfMounted(ch2[i]);
                c2.el = c1.el;
              }
              if (!shallow)
                traverseStaticChildren(c1, c2);
            }
            if (c2.type === Text) {
              c2.el = c1.el;
            }
          }
        }
      }
      function getSequence(arr) {
        const p2 = arr.slice();
        const result = [0];
        let i, j, u, v, c;
        const len = arr.length;
        for (i = 0; i < len; i++) {
          const arrI = arr[i];
          if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
              p2[i] = j;
              result.push(i);
              continue;
            }
            u = 0;
            v = result.length - 1;
            while (u < v) {
              c = u + v >> 1;
              if (arr[result[c]] < arrI) {
                u = c + 1;
              } else {
                v = c;
              }
            }
            if (arrI < arr[result[u]]) {
              if (u > 0) {
                p2[i] = result[u - 1];
              }
              result[u] = i;
            }
          }
        }
        u = result.length;
        v = result[u - 1];
        while (u-- > 0) {
          result[u] = v;
          v = p2[v];
        }
        return result;
      }
      const isTeleport = (type2) => type2.__isTeleport;
      const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
      const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
      const resolveTarget = (props, select) => {
        const targetSelector = props && props.to;
        if (isString$1(targetSelector)) {
          if (!select) {
            return null;
          } else {
            const target = select(targetSelector);
            return target;
          }
        } else {
          return targetSelector;
        }
      };
      const TeleportImpl = {
        __isTeleport: true,
        process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
          const {
            mc: mountChildren,
            pc: patchChildren,
            pbc: patchBlockChildren,
            o: { insert, querySelector, createText, createComment }
          } = internals;
          const disabled = isTeleportDisabled(n2.props);
          let { shapeFlag, children, dynamicChildren } = n2;
          if (n1 == null) {
            const placeholder = n2.el = createText("");
            const mainAnchor = n2.anchor = createText("");
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = n2.targetAnchor = createText("");
            if (target) {
              insert(targetAnchor, target);
              isSVG = isSVG || isTargetSVG(target);
            }
            const mount = (container2, anchor2) => {
              if (shapeFlag & 16) {
                mountChildren(
                  children,
                  container2,
                  anchor2,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  slotScopeIds,
                  optimized
                );
              }
            };
            if (disabled) {
              mount(container, mainAnchor);
            } else if (target) {
              mount(target, targetAnchor);
            }
          } else {
            n2.el = n1.el;
            const mainAnchor = n2.anchor = n1.anchor;
            const target = n2.target = n1.target;
            const targetAnchor = n2.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
              patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                currentContainer,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds
              );
              traverseStaticChildren(n1, n2, true);
            } else if (!optimized) {
              patchChildren(
                n1,
                n2,
                currentContainer,
                currentAnchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                false
              );
            }
            if (disabled) {
              if (!wasDisabled) {
                moveTeleport(
                  n2,
                  container,
                  mainAnchor,
                  internals,
                  1
                );
              }
            } else {
              if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                const nextTarget = n2.target = resolveTarget(
                  n2.props,
                  querySelector
                );
                if (nextTarget) {
                  moveTeleport(
                    n2,
                    nextTarget,
                    null,
                    internals,
                    0
                  );
                }
              } else if (wasDisabled) {
                moveTeleport(
                  n2,
                  target,
                  targetAnchor,
                  internals,
                  1
                );
              }
            }
          }
          updateCssVars(n2);
        },
        remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
          const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
          if (target) {
            hostRemove(targetAnchor);
          }
          if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16) {
              for (let i = 0; i < children.length; i++) {
                const child = children[i];
                unmount(
                  child,
                  parentComponent,
                  parentSuspense,
                  true,
                  !!child.dynamicChildren
                );
              }
            }
          }
        },
        move: moveTeleport,
        hydrate: hydrateTeleport
      };
      function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
        if (moveType === 0) {
          insert(vnode.targetAnchor, container, parentAnchor);
        }
        const { el, anchor, shapeFlag, children, props } = vnode;
        const isReorder = moveType === 2;
        if (isReorder) {
          insert(el, container, parentAnchor);
        }
        if (!isReorder || isTeleportDisabled(props)) {
          if (shapeFlag & 16) {
            for (let i = 0; i < children.length; i++) {
              move(
                children[i],
                container,
                parentAnchor,
                2
              );
            }
          }
        }
        if (isReorder) {
          insert(anchor, container, parentAnchor);
        }
      }
      function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
        o: { nextSibling, parentNode, querySelector }
      }, hydrateChildren) {
        const target = vnode.target = resolveTarget(
          vnode.props,
          querySelector
        );
        if (target) {
          const targetNode = target._lpa || target.firstChild;
          if (vnode.shapeFlag & 16) {
            if (isTeleportDisabled(vnode.props)) {
              vnode.anchor = hydrateChildren(
                nextSibling(node),
                vnode,
                parentNode(node),
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
              vnode.targetAnchor = targetNode;
            } else {
              vnode.anchor = nextSibling(node);
              let targetAnchor = targetNode;
              while (targetAnchor) {
                targetAnchor = nextSibling(targetAnchor);
                if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                  vnode.targetAnchor = targetAnchor;
                  target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                  break;
                }
              }
              hydrateChildren(
                targetNode,
                vnode,
                target,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
            }
          }
          updateCssVars(vnode);
        }
        return vnode.anchor && nextSibling(vnode.anchor);
      }
      const Teleport = TeleportImpl;
      function updateCssVars(vnode) {
        const ctx = vnode.ctx;
        if (ctx && ctx.ut) {
          let node = vnode.children[0].el;
          while (node !== vnode.targetAnchor) {
            if (node.nodeType === 1)
              node.setAttribute("data-v-owner", ctx.uid);
            node = node.nextSibling;
          }
          ctx.ut();
        }
      }
      const Fragment = Symbol.for("v-fgt");
      const Text = Symbol.for("v-txt");
      const Comment = Symbol.for("v-cmt");
      const Static = Symbol.for("v-stc");
      const blockStack = [];
      let currentBlock = null;
      function openBlock(disableTracking = false) {
        blockStack.push(currentBlock = disableTracking ? null : []);
      }
      function closeBlock() {
        blockStack.pop();
        currentBlock = blockStack[blockStack.length - 1] || null;
      }
      let isBlockTreeEnabled = 1;
      function setBlockTracking(value) {
        isBlockTreeEnabled += value;
      }
      function setupBlock(vnode) {
        vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
        closeBlock();
        if (isBlockTreeEnabled > 0 && currentBlock) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
        return setupBlock(
          createBaseVNode(
            type2,
            props,
            children,
            patchFlag,
            dynamicProps,
            shapeFlag,
            true
            /* isBlock */
          )
        );
      }
      function createBlock(type2, props, children, patchFlag, dynamicProps) {
        return setupBlock(
          createVNode(
            type2,
            props,
            children,
            patchFlag,
            dynamicProps,
            true
            /* isBlock: prevent a block from tracking itself */
          )
        );
      }
      function isVNode(value) {
        return value ? value.__v_isVNode === true : false;
      }
      function isSameVNodeType(n1, n2) {
        return n1.type === n2.type && n1.key === n2.key;
      }
      const InternalObjectKey = `__vInternal`;
      const normalizeKey = ({ key }) => key != null ? key : null;
      const normalizeRef = ({
        ref: ref2,
        ref_key,
        ref_for
      }) => {
        if (typeof ref2 === "number") {
          ref2 = "" + ref2;
        }
        return ref2 != null ? isString$1(ref2) || isRef(ref2) || isFunction$1(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
      };
      function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
        const vnode = {
          __v_isVNode: true,
          __v_skip: true,
          type: type2,
          props,
          key: props && normalizeKey(props),
          ref: props && normalizeRef(props),
          scopeId: currentScopeId,
          slotScopeIds: null,
          children,
          component: null,
          suspense: null,
          ssContent: null,
          ssFallback: null,
          dirs: null,
          transition: null,
          el: null,
          anchor: null,
          target: null,
          targetAnchor: null,
          staticCount: 0,
          shapeFlag,
          patchFlag,
          dynamicProps,
          dynamicChildren: null,
          appContext: null,
          ctx: currentRenderingInstance
        };
        if (needFullChildrenNormalization) {
          normalizeChildren(vnode, children);
          if (shapeFlag & 128) {
            type2.normalize(vnode);
          }
        } else if (children) {
          vnode.shapeFlag |= isString$1(children) ? 8 : 16;
        }
        if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
        !isBlockNode && // has current parent block
        currentBlock && // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        vnode.patchFlag !== 32) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      const createVNode = _createVNode;
      function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
        if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
          type2 = Comment;
        }
        if (isVNode(type2)) {
          const cloned = cloneVNode(
            type2,
            props,
            true
            /* mergeRef: true */
          );
          if (children) {
            normalizeChildren(cloned, children);
          }
          if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6) {
              currentBlock[currentBlock.indexOf(type2)] = cloned;
            } else {
              currentBlock.push(cloned);
            }
          }
          cloned.patchFlag |= -2;
          return cloned;
        }
        if (isClassComponent(type2)) {
          type2 = type2.__vccOpts;
        }
        if (props) {
          props = guardReactiveProps(props);
          let { class: klass, style } = props;
          if (klass && !isString$1(klass)) {
            props.class = normalizeClass(klass);
          }
          if (isObject$1(style)) {
            if (isProxy(style) && !isArray$2(style)) {
              style = extend({}, style);
            }
            props.style = normalizeStyle(style);
          }
        }
        const shapeFlag = isString$1(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject$1(type2) ? 4 : isFunction$1(type2) ? 2 : 0;
        return createBaseVNode(
          type2,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          isBlockNode,
          true
        );
      }
      function guardReactiveProps(props) {
        if (!props)
          return null;
        return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
      }
      function cloneVNode(vnode, extraProps, mergeRef = false) {
        const { props, ref: ref2, patchFlag, children } = vnode;
        const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
        const cloned = {
          __v_isVNode: true,
          __v_skip: true,
          type: vnode.type,
          props: mergedProps,
          key: mergedProps && normalizeKey(mergedProps),
          ref: extraProps && extraProps.ref ? (
            // #2078 in the case of <component :is="vnode" ref="extra"/>
            // if the vnode itself already has a ref, cloneVNode will need to merge
            // the refs so the single vnode can be set on multiple refs
            mergeRef && ref2 ? isArray$2(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
          ) : ref2,
          scopeId: vnode.scopeId,
          slotScopeIds: vnode.slotScopeIds,
          children,
          target: vnode.target,
          targetAnchor: vnode.targetAnchor,
          staticCount: vnode.staticCount,
          shapeFlag: vnode.shapeFlag,
          // if the vnode is cloned with extra props, we can no longer assume its
          // existing patch flag to be reliable and need to add the FULL_PROPS flag.
          // note: preserve flag for fragments since they use the flag for children
          // fast paths only.
          patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
          dynamicProps: vnode.dynamicProps,
          dynamicChildren: vnode.dynamicChildren,
          appContext: vnode.appContext,
          dirs: vnode.dirs,
          transition: vnode.transition,
          // These should technically only be non-null on mounted VNodes. However,
          // they *should* be copied for kept-alive vnodes. So we just always copy
          // them since them being non-null during a mount doesn't affect the logic as
          // they will simply be overwritten.
          component: vnode.component,
          suspense: vnode.suspense,
          ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
          ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
          el: vnode.el,
          anchor: vnode.anchor,
          ctx: vnode.ctx,
          ce: vnode.ce
        };
        return cloned;
      }
      function createTextVNode(text = " ", flag = 0) {
        return createVNode(Text, null, text, flag);
      }
      function createCommentVNode(text = "", asBlock = false) {
        return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
      }
      function normalizeVNode(child) {
        if (child == null || typeof child === "boolean") {
          return createVNode(Comment);
        } else if (isArray$2(child)) {
          return createVNode(
            Fragment,
            null,
            // #3666, avoid reference pollution when reusing vnode
            child.slice()
          );
        } else if (typeof child === "object") {
          return cloneIfMounted(child);
        } else {
          return createVNode(Text, null, String(child));
        }
      }
      function cloneIfMounted(child) {
        return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
      }
      function normalizeChildren(vnode, children) {
        let type2 = 0;
        const { shapeFlag } = vnode;
        if (children == null) {
          children = null;
        } else if (isArray$2(children)) {
          type2 = 16;
        } else if (typeof children === "object") {
          if (shapeFlag & (1 | 64)) {
            const slot = children.default;
            if (slot) {
              slot._c && (slot._d = false);
              normalizeChildren(vnode, slot());
              slot._c && (slot._d = true);
            }
            return;
          } else {
            type2 = 32;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) {
              children._ctx = currentRenderingInstance;
            } else if (slotFlag === 3 && currentRenderingInstance) {
              if (currentRenderingInstance.slots._ === 1) {
                children._ = 1;
              } else {
                children._ = 2;
                vnode.patchFlag |= 1024;
              }
            }
          }
        } else if (isFunction$1(children)) {
          children = { default: children, _ctx: currentRenderingInstance };
          type2 = 32;
        } else {
          children = String(children);
          if (shapeFlag & 64) {
            type2 = 16;
            children = [createTextVNode(children)];
          } else {
            type2 = 8;
          }
        }
        vnode.children = children;
        vnode.shapeFlag |= type2;
      }
      function mergeProps(...args) {
        const ret = {};
        for (let i = 0; i < args.length; i++) {
          const toMerge = args[i];
          for (const key in toMerge) {
            if (key === "class") {
              if (ret.class !== toMerge.class) {
                ret.class = normalizeClass([ret.class, toMerge.class]);
              }
            } else if (key === "style") {
              ret.style = normalizeStyle([ret.style, toMerge.style]);
            } else if (isOn(key)) {
              const existing = ret[key];
              const incoming = toMerge[key];
              if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
                ret[key] = existing ? [].concat(existing, incoming) : incoming;
              }
            } else if (key !== "") {
              ret[key] = toMerge[key];
            }
          }
        }
        return ret;
      }
      function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
        callWithAsyncErrorHandling(hook, instance, 7, [
          vnode,
          prevVNode
        ]);
      }
      const emptyAppContext = createAppContext();
      let uid = 0;
      function createComponentInstance(vnode, parent, suspense) {
        const type2 = vnode.type;
        const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
        const instance = {
          uid: uid++,
          vnode,
          type: type2,
          parent,
          appContext,
          root: null,
          // to be immediately set
          next: null,
          subTree: null,
          // will be set synchronously right after creation
          effect: null,
          update: null,
          // will be set synchronously right after creation
          scope: new EffectScope(
            true
            /* detached */
          ),
          render: null,
          proxy: null,
          exposed: null,
          exposeProxy: null,
          withProxy: null,
          provides: parent ? parent.provides : Object.create(appContext.provides),
          accessCache: null,
          renderCache: [],
          // local resolved assets
          components: null,
          directives: null,
          // resolved props and emits options
          propsOptions: normalizePropsOptions(type2, appContext),
          emitsOptions: normalizeEmitsOptions(type2, appContext),
          // emit
          emit: null,
          // to be set immediately
          emitted: null,
          // props default value
          propsDefaults: EMPTY_OBJ,
          // inheritAttrs
          inheritAttrs: type2.inheritAttrs,
          // state
          ctx: EMPTY_OBJ,
          data: EMPTY_OBJ,
          props: EMPTY_OBJ,
          attrs: EMPTY_OBJ,
          slots: EMPTY_OBJ,
          refs: EMPTY_OBJ,
          setupState: EMPTY_OBJ,
          setupContext: null,
          attrsProxy: null,
          slotsProxy: null,
          // suspense related
          suspense,
          suspenseId: suspense ? suspense.pendingId : 0,
          asyncDep: null,
          asyncResolved: false,
          // lifecycle hooks
          // not using enums here because it results in computed properties
          isMounted: false,
          isUnmounted: false,
          isDeactivated: false,
          bc: null,
          c: null,
          bm: null,
          m: null,
          bu: null,
          u: null,
          um: null,
          bum: null,
          da: null,
          a: null,
          rtg: null,
          rtc: null,
          ec: null,
          sp: null
        };
        {
          instance.ctx = { _: instance };
        }
        instance.root = parent ? parent.root : instance;
        instance.emit = emit.bind(null, instance);
        if (vnode.ce) {
          vnode.ce(instance);
        }
        return instance;
      }
      let currentInstance = null;
      const getCurrentInstance = () => currentInstance || currentRenderingInstance;
      let internalSetCurrentInstance;
      let globalCurrentInstanceSetters;
      let settersKey = "__VUE_INSTANCE_SETTERS__";
      {
        if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
          globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
        }
        globalCurrentInstanceSetters.push((i) => currentInstance = i);
        internalSetCurrentInstance = (instance) => {
          if (globalCurrentInstanceSetters.length > 1) {
            globalCurrentInstanceSetters.forEach((s) => s(instance));
          } else {
            globalCurrentInstanceSetters[0](instance);
          }
        };
      }
      const setCurrentInstance = (instance) => {
        internalSetCurrentInstance(instance);
        instance.scope.on();
      };
      const unsetCurrentInstance = () => {
        currentInstance && currentInstance.scope.off();
        internalSetCurrentInstance(null);
      };
      function isStatefulComponent(instance) {
        return instance.vnode.shapeFlag & 4;
      }
      let isInSSRComponentSetup = false;
      function setupComponent(instance, isSSR = false) {
        isInSSRComponentSetup = isSSR;
        const { props, children } = instance.vnode;
        const isStateful = isStatefulComponent(instance);
        initProps(instance, props, isStateful, isSSR);
        initSlots(instance, children);
        const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
        isInSSRComponentSetup = false;
        return setupResult;
      }
      function setupStatefulComponent(instance, isSSR) {
        const Component = instance.type;
        instance.accessCache = /* @__PURE__ */ Object.create(null);
        instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
        const { setup } = Component;
        if (setup) {
          const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
          setCurrentInstance(instance);
          pauseTracking();
          const setupResult = callWithErrorHandling(
            setup,
            instance,
            0,
            [instance.props, setupContext]
          );
          resetTracking();
          unsetCurrentInstance();
          if (isPromise(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
              return setupResult.then((resolvedResult) => {
                handleSetupResult(instance, resolvedResult, isSSR);
              }).catch((e) => {
                handleError(e, instance, 0);
              });
            } else {
              instance.asyncDep = setupResult;
            }
          } else {
            handleSetupResult(instance, setupResult, isSSR);
          }
        } else {
          finishComponentSetup(instance, isSSR);
        }
      }
      function handleSetupResult(instance, setupResult, isSSR) {
        if (isFunction$1(setupResult)) {
          if (instance.type.__ssrInlineRender) {
            instance.ssrRender = setupResult;
          } else {
            instance.render = setupResult;
          }
        } else if (isObject$1(setupResult)) {
          instance.setupState = proxyRefs(setupResult);
        } else
          ;
        finishComponentSetup(instance, isSSR);
      }
      let compile;
      function finishComponentSetup(instance, isSSR, skipOptions) {
        const Component = instance.type;
        if (!instance.render) {
          if (!isSSR && compile && !Component.render) {
            const template = Component.template || resolveMergedOptions(instance).template;
            if (template) {
              const { isCustomElement, compilerOptions } = instance.appContext.config;
              const { delimiters, compilerOptions: componentCompilerOptions } = Component;
              const finalCompilerOptions = extend(
                extend(
                  {
                    isCustomElement,
                    delimiters
                  },
                  compilerOptions
                ),
                componentCompilerOptions
              );
              Component.render = compile(template, finalCompilerOptions);
            }
          }
          instance.render = Component.render || NOOP;
        }
        {
          setCurrentInstance(instance);
          pauseTracking();
          applyOptions(instance);
          resetTracking();
          unsetCurrentInstance();
        }
      }
      function getAttrsProxy(instance) {
        return instance.attrsProxy || (instance.attrsProxy = new Proxy(
          instance.attrs,
          {
            get(target, key) {
              track(instance, "get", "$attrs");
              return target[key];
            }
          }
        ));
      }
      function createSetupContext(instance) {
        const expose = (exposed) => {
          instance.exposed = exposed || {};
        };
        {
          return {
            get attrs() {
              return getAttrsProxy(instance);
            },
            slots: instance.slots,
            emit: instance.emit,
            expose
          };
        }
      }
      function getExposeProxy(instance) {
        if (instance.exposed) {
          return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
            get(target, key) {
              if (key in target) {
                return target[key];
              } else if (key in publicPropertiesMap) {
                return publicPropertiesMap[key](instance);
              }
            },
            has(target, key) {
              return key in target || key in publicPropertiesMap;
            }
          }));
        }
      }
      function getComponentName(Component, includeInferred = true) {
        return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
      }
      function isClassComponent(value) {
        return isFunction$1(value) && "__vccOpts" in value;
      }
      const computed = (getterOrOptions, debugOptions) => {
        return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
      };
      function h(type2, propsOrChildren, children) {
        const l = arguments.length;
        if (l === 2) {
          if (isObject$1(propsOrChildren) && !isArray$2(propsOrChildren)) {
            if (isVNode(propsOrChildren)) {
              return createVNode(type2, null, [propsOrChildren]);
            }
            return createVNode(type2, propsOrChildren);
          } else {
            return createVNode(type2, null, propsOrChildren);
          }
        } else {
          if (l > 3) {
            children = Array.prototype.slice.call(arguments, 2);
          } else if (l === 3 && isVNode(children)) {
            children = [children];
          }
          return createVNode(type2, propsOrChildren, children);
        }
      }
      const ssrContextKey = Symbol.for("v-scx");
      const useSSRContext = () => {
        {
          const ctx = inject(ssrContextKey);
          return ctx;
        }
      };
      const version = "3.3.4";
      const svgNS = "http://www.w3.org/2000/svg";
      const doc = typeof document !== "undefined" ? document : null;
      const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
      const nodeOps = {
        insert: (child, parent, anchor) => {
          parent.insertBefore(child, anchor || null);
        },
        remove: (child) => {
          const parent = child.parentNode;
          if (parent) {
            parent.removeChild(child);
          }
        },
        createElement: (tag, isSVG, is, props) => {
          const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
          if (tag === "select" && props && props.multiple != null) {
            el.setAttribute("multiple", props.multiple);
          }
          return el;
        },
        createText: (text) => doc.createTextNode(text),
        createComment: (text) => doc.createComment(text),
        setText: (node, text) => {
          node.nodeValue = text;
        },
        setElementText: (el, text) => {
          el.textContent = text;
        },
        parentNode: (node) => node.parentNode,
        nextSibling: (node) => node.nextSibling,
        querySelector: (selector) => doc.querySelector(selector),
        setScopeId(el, id2) {
          el.setAttribute(id2, "");
        },
        // __UNSAFE__
        // Reason: innerHTML.
        // Static content here can only come from compiled templates.
        // As long as the user only uses trusted templates, this is safe.
        insertStaticContent(content, parent, anchor, isSVG, start, end2) {
          const before = anchor ? anchor.previousSibling : parent.lastChild;
          if (start && (start === end2 || start.nextSibling)) {
            while (true) {
              parent.insertBefore(start.cloneNode(true), anchor);
              if (start === end2 || !(start = start.nextSibling))
                break;
            }
          } else {
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template = templateContainer.content;
            if (isSVG) {
              const wrapper = template.firstChild;
              while (wrapper.firstChild) {
                template.appendChild(wrapper.firstChild);
              }
              template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
          }
          return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
          ];
        }
      };
      function patchClass(el, value, isSVG) {
        const transitionClasses = el._vtc;
        if (transitionClasses) {
          value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
        }
        if (value == null) {
          el.removeAttribute("class");
        } else if (isSVG) {
          el.setAttribute("class", value);
        } else {
          el.className = value;
        }
      }
      function patchStyle(el, prev, next) {
        const style = el.style;
        const isCssString = isString$1(next);
        if (next && !isCssString) {
          if (prev && !isString$1(prev)) {
            for (const key in prev) {
              if (next[key] == null) {
                setStyle(style, key, "");
              }
            }
          }
          for (const key in next) {
            setStyle(style, key, next[key]);
          }
        } else {
          const currentDisplay = style.display;
          if (isCssString) {
            if (prev !== next) {
              style.cssText = next;
            }
          } else if (prev) {
            el.removeAttribute("style");
          }
          if ("_vod" in el) {
            style.display = currentDisplay;
          }
        }
      }
      const importantRE = /\s*!important$/;
      function setStyle(style, name, val) {
        if (isArray$2(val)) {
          val.forEach((v) => setStyle(style, name, v));
        } else {
          if (val == null)
            val = "";
          if (name.startsWith("--")) {
            style.setProperty(name, val);
          } else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
              style.setProperty(
                hyphenate(prefixed),
                val.replace(importantRE, ""),
                "important"
              );
            } else {
              style[prefixed] = val;
            }
          }
        }
      }
      const prefixes = ["Webkit", "Moz", "ms"];
      const prefixCache = {};
      function autoPrefix(style, rawName) {
        const cached = prefixCache[rawName];
        if (cached) {
          return cached;
        }
        let name = camelize(rawName);
        if (name !== "filter" && name in style) {
          return prefixCache[rawName] = name;
        }
        name = capitalize$1(name);
        for (let i = 0; i < prefixes.length; i++) {
          const prefixed = prefixes[i] + name;
          if (prefixed in style) {
            return prefixCache[rawName] = prefixed;
          }
        }
        return rawName;
      }
      const xlinkNS = "http://www.w3.org/1999/xlink";
      function patchAttr(el, key, value, isSVG, instance) {
        if (isSVG && key.startsWith("xlink:")) {
          if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
          } else {
            el.setAttributeNS(xlinkNS, key, value);
          }
        } else {
          const isBoolean2 = isSpecialBooleanAttr(key);
          if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
            el.removeAttribute(key);
          } else {
            el.setAttribute(key, isBoolean2 ? "" : value);
          }
        }
      }
      function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
        if (key === "innerHTML" || key === "textContent") {
          if (prevChildren) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
          }
          el[key] = value == null ? "" : value;
          return;
        }
        const tag = el.tagName;
        if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
        !tag.includes("-")) {
          el._value = value;
          const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
          const newValue = value == null ? "" : value;
          if (oldValue !== newValue) {
            el.value = newValue;
          }
          if (value == null) {
            el.removeAttribute(key);
          }
          return;
        }
        let needRemove = false;
        if (value === "" || value == null) {
          const type2 = typeof el[key];
          if (type2 === "boolean") {
            value = includeBooleanAttr(value);
          } else if (value == null && type2 === "string") {
            value = "";
            needRemove = true;
          } else if (type2 === "number") {
            value = 0;
            needRemove = true;
          }
        }
        try {
          el[key] = value;
        } catch (e) {
        }
        needRemove && el.removeAttribute(key);
      }
      function addEventListener(el, event, handler, options) {
        el.addEventListener(event, handler, options);
      }
      function removeEventListener(el, event, handler, options) {
        el.removeEventListener(event, handler, options);
      }
      function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
        const invokers = el._vei || (el._vei = {});
        const existingInvoker = invokers[rawName];
        if (nextValue && existingInvoker) {
          existingInvoker.value = nextValue;
        } else {
          const [name, options] = parseName(rawName);
          if (nextValue) {
            const invoker = invokers[rawName] = createInvoker(nextValue, instance);
            addEventListener(el, name, invoker, options);
          } else if (existingInvoker) {
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = void 0;
          }
        }
      }
      const optionsModifierRE = /(?:Once|Passive|Capture)$/;
      function parseName(name) {
        let options;
        if (optionsModifierRE.test(name)) {
          options = {};
          let m;
          while (m = name.match(optionsModifierRE)) {
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
          }
        }
        const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
        return [event, options];
      }
      let cachedNow = 0;
      const p = /* @__PURE__ */ Promise.resolve();
      const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
      function createInvoker(initialValue, instance) {
        const invoker = (e) => {
          if (!e._vts) {
            e._vts = Date.now();
          } else if (e._vts <= invoker.attached) {
            return;
          }
          callWithAsyncErrorHandling(
            patchStopImmediatePropagation(e, invoker.value),
            instance,
            5,
            [e]
          );
        };
        invoker.value = initialValue;
        invoker.attached = getNow();
        return invoker;
      }
      function patchStopImmediatePropagation(e, value) {
        if (isArray$2(value)) {
          const originalStop = e.stopImmediatePropagation;
          e.stopImmediatePropagation = () => {
            originalStop.call(e);
            e._stopped = true;
          };
          return value.map((fn2) => (e2) => !e2._stopped && fn2 && fn2(e2));
        } else {
          return value;
        }
      }
      const nativeOnRE = /^on[a-z]/;
      const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
        if (key === "class") {
          patchClass(el, nextValue, isSVG);
        } else if (key === "style") {
          patchStyle(el, prevValue, nextValue);
        } else if (isOn(key)) {
          if (!isModelListener(key)) {
            patchEvent(el, key, prevValue, nextValue, parentComponent);
          }
        } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
          patchDOMProp(
            el,
            key,
            nextValue,
            prevChildren,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        } else {
          if (key === "true-value") {
            el._trueValue = nextValue;
          } else if (key === "false-value") {
            el._falseValue = nextValue;
          }
          patchAttr(el, key, nextValue, isSVG);
        }
      };
      function shouldSetAsProp(el, key, value, isSVG) {
        if (isSVG) {
          if (key === "innerHTML" || key === "textContent") {
            return true;
          }
          if (key in el && nativeOnRE.test(key) && isFunction$1(value)) {
            return true;
          }
          return false;
        }
        if (key === "spellcheck" || key === "draggable" || key === "translate") {
          return false;
        }
        if (key === "form") {
          return false;
        }
        if (key === "list" && el.tagName === "INPUT") {
          return false;
        }
        if (key === "type" && el.tagName === "TEXTAREA") {
          return false;
        }
        if (nativeOnRE.test(key) && isString$1(value)) {
          return false;
        }
        return key in el;
      }
      const TRANSITION = "transition";
      const ANIMATION = "animation";
      const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
      Transition.displayName = "Transition";
      const DOMTransitionPropsValidators = {
        name: String,
        type: String,
        css: {
          type: Boolean,
          default: true
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
      };
      const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
        {},
        BaseTransitionPropsValidators,
        DOMTransitionPropsValidators
      );
      const callHook = (hook, args = []) => {
        if (isArray$2(hook)) {
          hook.forEach((h2) => h2(...args));
        } else if (hook) {
          hook(...args);
        }
      };
      const hasExplicitCallback = (hook) => {
        return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
      };
      function resolveTransitionProps(rawProps) {
        const baseProps = {};
        for (const key in rawProps) {
          if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
          }
        }
        if (rawProps.css === false) {
          return baseProps;
        }
        const {
          name = "v",
          type: type2,
          duration,
          enterFromClass = `${name}-enter-from`,
          enterActiveClass = `${name}-enter-active`,
          enterToClass = `${name}-enter-to`,
          appearFromClass = enterFromClass,
          appearActiveClass = enterActiveClass,
          appearToClass = enterToClass,
          leaveFromClass = `${name}-leave-from`,
          leaveActiveClass = `${name}-leave-active`,
          leaveToClass = `${name}-leave-to`
        } = rawProps;
        const durations = normalizeDuration(duration);
        const enterDuration = durations && durations[0];
        const leaveDuration = durations && durations[1];
        const {
          onBeforeEnter,
          onEnter,
          onEnterCancelled,
          onLeave,
          onLeaveCancelled,
          onBeforeAppear = onBeforeEnter,
          onAppear = onEnter,
          onAppearCancelled = onEnterCancelled
        } = baseProps;
        const finishEnter = (el, isAppear, done) => {
          removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
          removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
          done && done();
        };
        const finishLeave = (el, done) => {
          el._isLeaving = false;
          removeTransitionClass(el, leaveFromClass);
          removeTransitionClass(el, leaveToClass);
          removeTransitionClass(el, leaveActiveClass);
          done && done();
        };
        const makeEnterHook = (isAppear) => {
          return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve2 = () => finishEnter(el, isAppear, done);
            callHook(hook, [el, resolve2]);
            nextFrame(() => {
              removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
              addTransitionClass(el, isAppear ? appearToClass : enterToClass);
              if (!hasExplicitCallback(hook)) {
                whenTransitionEnds(el, type2, enterDuration, resolve2);
              }
            });
          };
        };
        return extend(baseProps, {
          onBeforeEnter(el) {
            callHook(onBeforeEnter, [el]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
          },
          onBeforeAppear(el) {
            callHook(onBeforeAppear, [el]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
          },
          onEnter: makeEnterHook(false),
          onAppear: makeEnterHook(true),
          onLeave(el, done) {
            el._isLeaving = true;
            const resolve2 = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
              if (!el._isLeaving) {
                return;
              }
              removeTransitionClass(el, leaveFromClass);
              addTransitionClass(el, leaveToClass);
              if (!hasExplicitCallback(onLeave)) {
                whenTransitionEnds(el, type2, leaveDuration, resolve2);
              }
            });
            callHook(onLeave, [el, resolve2]);
          },
          onEnterCancelled(el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [el]);
          },
          onAppearCancelled(el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [el]);
          },
          onLeaveCancelled(el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [el]);
          }
        });
      }
      function normalizeDuration(duration) {
        if (duration == null) {
          return null;
        } else if (isObject$1(duration)) {
          return [NumberOf(duration.enter), NumberOf(duration.leave)];
        } else {
          const n = NumberOf(duration);
          return [n, n];
        }
      }
      function NumberOf(val) {
        const res = toNumber$1(val);
        return res;
      }
      function addTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
        (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
      }
      function removeTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
        const { _vtc } = el;
        if (_vtc) {
          _vtc.delete(cls);
          if (!_vtc.size) {
            el._vtc = void 0;
          }
        }
      }
      function nextFrame(cb) {
        requestAnimationFrame(() => {
          requestAnimationFrame(cb);
        });
      }
      let endId = 0;
      function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
        const id2 = el._endId = ++endId;
        const resolveIfNotStale = () => {
          if (id2 === el._endId) {
            resolve2();
          }
        };
        if (explicitTimeout) {
          return setTimeout(resolveIfNotStale, explicitTimeout);
        }
        const { type: type2, timeout, propCount } = getTransitionInfo(el, expectedType);
        if (!type2) {
          return resolve2();
        }
        const endEvent = type2 + "end";
        let ended = 0;
        const end2 = () => {
          el.removeEventListener(endEvent, onEnd);
          resolveIfNotStale();
        };
        const onEnd = (e) => {
          if (e.target === el && ++ended >= propCount) {
            end2();
          }
        };
        setTimeout(() => {
          if (ended < propCount) {
            end2();
          }
        }, timeout + 1);
        el.addEventListener(endEvent, onEnd);
      }
      function getTransitionInfo(el, expectedType) {
        const styles = window.getComputedStyle(el);
        const getStyleProperties = (key) => (styles[key] || "").split(", ");
        const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
        const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
        const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
        const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
        const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
        const animationTimeout = getTimeout(animationDelays, animationDurations);
        let type2 = null;
        let timeout = 0;
        let propCount = 0;
        if (expectedType === TRANSITION) {
          if (transitionTimeout > 0) {
            type2 = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
          }
        } else if (expectedType === ANIMATION) {
          if (animationTimeout > 0) {
            type2 = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
          }
        } else {
          timeout = Math.max(transitionTimeout, animationTimeout);
          type2 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
          propCount = type2 ? type2 === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
        }
        const hasTransform = type2 === TRANSITION && /\b(transform|all)(,|$)/.test(
          getStyleProperties(`${TRANSITION}Property`).toString()
        );
        return {
          type: type2,
          timeout,
          propCount,
          hasTransform
        };
      }
      function getTimeout(delays, durations) {
        while (delays.length < durations.length) {
          delays = delays.concat(delays);
        }
        return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
      }
      function toMs(s) {
        return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
      }
      function forceReflow() {
        return document.body.offsetHeight;
      }
      const positionMap = /* @__PURE__ */ new WeakMap();
      const newPositionMap = /* @__PURE__ */ new WeakMap();
      const TransitionGroupImpl = {
        name: "TransitionGroup",
        props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
          tag: String,
          moveClass: String
        }),
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          let prevChildren;
          let children;
          onUpdated(() => {
            if (!prevChildren.length) {
              return;
            }
            const moveClass = props.moveClass || `${props.name || "v"}-move`;
            if (!hasCSSTransform(
              prevChildren[0].el,
              instance.vnode.el,
              moveClass
            )) {
              return;
            }
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            forceReflow();
            movedChildren.forEach((c) => {
              const el = c.el;
              const style = el.style;
              addTransitionClass(el, moveClass);
              style.transform = style.webkitTransform = style.transitionDuration = "";
              const cb = el._moveCb = (e) => {
                if (e && e.target !== el) {
                  return;
                }
                if (!e || /transform$/.test(e.propertyName)) {
                  el.removeEventListener("transitionend", cb);
                  el._moveCb = null;
                  removeTransitionClass(el, moveClass);
                }
              };
              el.addEventListener("transitionend", cb);
            });
          });
          return () => {
            const rawProps = toRaw(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || Fragment;
            prevChildren = children;
            children = slots.default ? getTransitionRawChildren(slots.default()) : [];
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (child.key != null) {
                setTransitionHooks(
                  child,
                  resolveTransitionHooks(child, cssTransitionProps, state, instance)
                );
              }
            }
            if (prevChildren) {
              for (let i = 0; i < prevChildren.length; i++) {
                const child = prevChildren[i];
                setTransitionHooks(
                  child,
                  resolveTransitionHooks(child, cssTransitionProps, state, instance)
                );
                positionMap.set(child, child.el.getBoundingClientRect());
              }
            }
            return createVNode(tag, null, children);
          };
        }
      };
      const removeMode = (props) => delete props.mode;
      /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
      const TransitionGroup = TransitionGroupImpl;
      function callPendingCbs(c) {
        const el = c.el;
        if (el._moveCb) {
          el._moveCb();
        }
        if (el._enterCb) {
          el._enterCb();
        }
      }
      function recordPosition(c) {
        newPositionMap.set(c, c.el.getBoundingClientRect());
      }
      function applyTranslation(c) {
        const oldPos = positionMap.get(c);
        const newPos = newPositionMap.get(c);
        const dx = oldPos.left - newPos.left;
        const dy = oldPos.top - newPos.top;
        if (dx || dy) {
          const s = c.el.style;
          s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
          s.transitionDuration = "0s";
          return c;
        }
      }
      function hasCSSTransform(el, root2, moveClass) {
        const clone2 = el.cloneNode();
        if (el._vtc) {
          el._vtc.forEach((cls) => {
            cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
          });
        }
        moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
        clone2.style.display = "none";
        const container = root2.nodeType === 1 ? root2 : root2.parentNode;
        container.appendChild(clone2);
        const { hasTransform } = getTransitionInfo(clone2);
        container.removeChild(clone2);
        return hasTransform;
      }
      const getModelAssigner = (vnode) => {
        const fn2 = vnode.props["onUpdate:modelValue"] || false;
        return isArray$2(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
      };
      function onCompositionStart(e) {
        e.target.composing = true;
      }
      function onCompositionEnd(e) {
        const target = e.target;
        if (target.composing) {
          target.composing = false;
          target.dispatchEvent(new Event("input"));
        }
      }
      const vModelText = {
        created(el, { modifiers: { lazy, trim, number: number2 } }, vnode) {
          el._assign = getModelAssigner(vnode);
          const castToNumber = number2 || vnode.props && vnode.props.type === "number";
          addEventListener(el, lazy ? "change" : "input", (e) => {
            if (e.target.composing)
              return;
            let domValue = el.value;
            if (trim) {
              domValue = domValue.trim();
            }
            if (castToNumber) {
              domValue = looseToNumber(domValue);
            }
            el._assign(domValue);
          });
          if (trim) {
            addEventListener(el, "change", () => {
              el.value = el.value.trim();
            });
          }
          if (!lazy) {
            addEventListener(el, "compositionstart", onCompositionStart);
            addEventListener(el, "compositionend", onCompositionEnd);
            addEventListener(el, "change", onCompositionEnd);
          }
        },
        // set value on mounted so it's after min/max for type="range"
        mounted(el, { value }) {
          el.value = value == null ? "" : value;
        },
        beforeUpdate(el, { value, modifiers: { lazy, trim, number: number2 } }, vnode) {
          el._assign = getModelAssigner(vnode);
          if (el.composing)
            return;
          if (document.activeElement === el && el.type !== "range") {
            if (lazy) {
              return;
            }
            if (trim && el.value.trim() === value) {
              return;
            }
            if ((number2 || el.type === "number") && looseToNumber(el.value) === value) {
              return;
            }
          }
          const newValue = value == null ? "" : value;
          if (el.value !== newValue) {
            el.value = newValue;
          }
        }
      };
      const vModelCheckbox = {
        // #4096 array checkboxes need to be deep traversed
        deep: true,
        created(el, _, vnode) {
          el._assign = getModelAssigner(vnode);
          addEventListener(el, "change", () => {
            const modelValue = el._modelValue;
            const elementValue = getValue$2(el);
            const checked = el.checked;
            const assign2 = el._assign;
            if (isArray$2(modelValue)) {
              const index = looseIndexOf(modelValue, elementValue);
              const found = index !== -1;
              if (checked && !found) {
                assign2(modelValue.concat(elementValue));
              } else if (!checked && found) {
                const filtered = [...modelValue];
                filtered.splice(index, 1);
                assign2(filtered);
              }
            } else if (isSet$2(modelValue)) {
              const cloned = new Set(modelValue);
              if (checked) {
                cloned.add(elementValue);
              } else {
                cloned.delete(elementValue);
              }
              assign2(cloned);
            } else {
              assign2(getCheckboxValue(el, checked));
            }
          });
        },
        // set initial checked on mount to wait for true-value/false-value
        mounted: setChecked,
        beforeUpdate(el, binding, vnode) {
          el._assign = getModelAssigner(vnode);
          setChecked(el, binding, vnode);
        }
      };
      function setChecked(el, { value, oldValue }, vnode) {
        el._modelValue = value;
        if (isArray$2(value)) {
          el.checked = looseIndexOf(value, vnode.props.value) > -1;
        } else if (isSet$2(value)) {
          el.checked = value.has(vnode.props.value);
        } else if (value !== oldValue) {
          el.checked = looseEqual(value, getCheckboxValue(el, true));
        }
      }
      function getValue$2(el) {
        return "_value" in el ? el._value : el.value;
      }
      function getCheckboxValue(el, checked) {
        const key = checked ? "_trueValue" : "_falseValue";
        return key in el ? el[key] : checked;
      }
      const systemModifiers = ["ctrl", "shift", "alt", "meta"];
      const modifierGuards = {
        stop: (e) => e.stopPropagation(),
        prevent: (e) => e.preventDefault(),
        self: (e) => e.target !== e.currentTarget,
        ctrl: (e) => !e.ctrlKey,
        shift: (e) => !e.shiftKey,
        alt: (e) => !e.altKey,
        meta: (e) => !e.metaKey,
        left: (e) => "button" in e && e.button !== 0,
        middle: (e) => "button" in e && e.button !== 1,
        right: (e) => "button" in e && e.button !== 2,
        exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
      };
      const withModifiers = (fn2, modifiers) => {
        return (event, ...args) => {
          for (let i = 0; i < modifiers.length; i++) {
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers))
              return;
          }
          return fn2(event, ...args);
        };
      };
      const keyNames = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
      };
      const withKeys = (fn2, modifiers) => {
        return (event) => {
          if (!("key" in event)) {
            return;
          }
          const eventKey = hyphenate(event.key);
          if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
            return fn2(event);
          }
        };
      };
      const vShow = {
        beforeMount(el, { value }, { transition }) {
          el._vod = el.style.display === "none" ? "" : el.style.display;
          if (transition && value) {
            transition.beforeEnter(el);
          } else {
            setDisplay(el, value);
          }
        },
        mounted(el, { value }, { transition }) {
          if (transition && value) {
            transition.enter(el);
          }
        },
        updated(el, { value, oldValue }, { transition }) {
          if (!value === !oldValue)
            return;
          if (transition) {
            if (value) {
              transition.beforeEnter(el);
              setDisplay(el, true);
              transition.enter(el);
            } else {
              transition.leave(el, () => {
                setDisplay(el, false);
              });
            }
          } else {
            setDisplay(el, value);
          }
        },
        beforeUnmount(el, { value }) {
          setDisplay(el, value);
        }
      };
      function setDisplay(el, value) {
        el.style.display = value ? el._vod : "none";
      }
      const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
      let renderer;
      function ensureRenderer() {
        return renderer || (renderer = createRenderer(rendererOptions));
      }
      const render$h = (...args) => {
        ensureRenderer().render(...args);
      };
      const createApp = (...args) => {
        const app2 = ensureRenderer().createApp(...args);
        const { mount } = app2;
        app2.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (!container)
            return;
          const component = app2._component;
          if (!isFunction$1(component) && !component.render && !component.template) {
            component.template = container.innerHTML;
          }
          container.innerHTML = "";
          const proxy = mount(container, false, container instanceof SVGElement);
          if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
          }
          return proxy;
        };
        return app2;
      };
      function normalizeContainer(container) {
        if (isString$1(container)) {
          const res = document.querySelector(container);
          return res;
        }
        return container;
      }
      function touchX(event) {
        if (event.type.indexOf("mouse") !== -1) {
          return event.clientX;
        }
        return event.touches[0].clientX;
      }
      function touchY(event) {
        if (event.type.indexOf("mouse") !== -1) {
          return event.clientY;
        }
        return event.touches[0].clientY;
      }
      var isPassiveSupported = function() {
        var supportsPassive = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supportsPassive = true;
            }
          });
          window.addEventListener("test", null, opts);
        } catch (e) {
        }
        return supportsPassive;
      }();
      var vueTouchEvents = {
        install: function(app2, constructorOptions) {
          var globalOptions = Object.assign({}, {
            disableClick: false,
            tapTolerance: 10,
            // px
            swipeTolerance: 30,
            // px
            touchHoldTolerance: 400,
            // ms
            longTapTimeInterval: 400,
            // ms
            touchClass: "",
            dragFrequency: 100,
            // ms
            rollOverFrequency: 100
            // ms
          }, constructorOptions);
          function touchStartEvent(event) {
            var $this = this.$$touchObj, isTouchEvent = event.type.indexOf("touch") >= 0, isMouseEvent = event.type.indexOf("mouse") >= 0, $el = this;
            if (isTouchEvent) {
              $this.lastTouchStartTime = event.timeStamp;
            }
            if (isMouseEvent && $this.lastTouchStartTime && event.timeStamp - $this.lastTouchStartTime < 350) {
              return;
            }
            if ($this.touchStarted) {
              return;
            }
            addTouchClass(this);
            $this.touchStarted = true;
            $this.touchMoved = false;
            $this.swipeOutBounded = false;
            $this.startX = touchX(event);
            $this.startY = touchY(event);
            $this.currentX = 0;
            $this.currentY = 0;
            $this.touchStartTime = event.timeStamp;
            $this.hasSwipe = hasEvent(this, "swipe") || hasEvent(this, "swipe.left") || hasEvent(this, "swipe.right") || hasEvent(this, "swipe.top") || hasEvent(this, "swipe.bottom");
            if (hasEvent(this, "hold")) {
              $this.touchHoldTimer = setTimeout(function() {
                $this.touchHoldTimer = null;
                triggerEvent(event, $el, "hold");
              }, $this.options.touchHoldTolerance);
            }
            triggerEvent(event, this, "press");
          }
          function touchMoveEvent(event) {
            var $this = this.$$touchObj;
            var curX = touchX(event);
            var curY = touchY(event);
            var movedAgain = $this.currentX != curX || $this.currentY != curY;
            $this.currentX = curX;
            $this.currentY = curY;
            if (!$this.touchMoved) {
              var tapTolerance = $this.options.tapTolerance;
              $this.touchMoved = Math.abs($this.startX - $this.currentX) > tapTolerance || Math.abs($this.startY - $this.currentY) > tapTolerance;
              if ($this.touchMoved) {
                cancelTouchHoldTimer($this);
                triggerEvent(event, this, "drag.once");
              }
            } else if ($this.hasSwipe && !$this.swipeOutBounded) {
              var swipeOutBounded = $this.options.swipeTolerance;
              $this.swipeOutBounded = Math.abs($this.startX - $this.currentX) > swipeOutBounded && Math.abs($this.startY - $this.currentY) > swipeOutBounded;
            }
            if (hasEvent(this, "rollover") && movedAgain) {
              var now2 = event.timeStamp;
              var throttle = $this.options.rollOverFrequency;
              if ($this.touchRollTime == null || now2 > $this.touchRollTime + throttle) {
                $this.touchRollTime = now2;
                triggerEvent(event, this, "rollover");
              }
            }
            if (hasEvent(this, "drag") && $this.touchStarted && $this.touchMoved && movedAgain) {
              var now2 = event.timeStamp;
              var throttle = $this.options.dragFrequency;
              if ($this.touchDragTime == null || now2 > $this.touchDragTime + throttle) {
                $this.touchDragTime = now2;
                triggerEvent(event, this, "drag");
              }
            }
          }
          function touchCancelEvent() {
            var $this = this.$$touchObj;
            cancelTouchHoldTimer($this);
            removeTouchClass(this);
            $this.touchStarted = $this.touchMoved = false;
            $this.startX = $this.startY = 0;
          }
          function touchEndEvent(event) {
            var $this = this.$$touchObj, isTouchEvent = event.type.indexOf("touch") >= 0, isMouseEvent = event.type.indexOf("mouse") >= 0;
            if (isTouchEvent) {
              $this.lastTouchEndTime = event.timeStamp;
            }
            var touchholdEnd = isTouchEvent && !$this.touchHoldTimer;
            cancelTouchHoldTimer($this);
            $this.touchStarted = false;
            removeTouchClass(this);
            if (isMouseEvent && $this.lastTouchEndTime && event.timeStamp - $this.lastTouchEndTime < 350) {
              return;
            }
            triggerEvent(event, this, "release");
            if (!$this.touchMoved) {
              if (hasEvent(this, "longtap") && event.timeStamp - $this.touchStartTime > $this.options.longTapTimeInterval) {
                if (event.cancelable) {
                  event.preventDefault();
                }
                triggerEvent(event, this, "longtap");
              } else if (hasEvent(this, "hold") && touchholdEnd) {
                if (event.cancelable) {
                  event.preventDefault();
                }
                return;
              } else {
                triggerEvent(event, this, "tap");
              }
            } else if ($this.hasSwipe && !$this.swipeOutBounded) {
              var swipeOutBounded = $this.options.swipeTolerance, direction2, distanceY = Math.abs($this.startY - $this.currentY), distanceX = Math.abs($this.startX - $this.currentX);
              if (distanceY > swipeOutBounded || distanceX > swipeOutBounded) {
                if (distanceY > swipeOutBounded) {
                  direction2 = $this.startY > $this.currentY ? "top" : "bottom";
                } else {
                  direction2 = $this.startX > $this.currentX ? "left" : "right";
                }
                if (hasEvent(this, "swipe." + direction2)) {
                  triggerEvent(event, this, "swipe." + direction2, direction2);
                } else {
                  triggerEvent(event, this, "swipe", direction2);
                }
              }
            }
          }
          function mouseEnterEvent() {
            addTouchClass(this);
          }
          function mouseLeaveEvent() {
            removeTouchClass(this);
          }
          function hasEvent($el, eventType) {
            var callbacks = $el.$$touchObj.callbacks[eventType];
            return callbacks != null && callbacks.length > 0;
          }
          function triggerEvent(e, $el, eventType, param) {
            var $this = $el.$$touchObj;
            var callbacks = $this.callbacks[eventType];
            if (callbacks == null || callbacks.length === 0) {
              return null;
            }
            for (var i = 0; i < callbacks.length; i++) {
              var binding = callbacks[i];
              if (binding.modifiers.stop) {
                e.stopPropagation();
              }
              if (binding.modifiers.prevent) {
                e.preventDefault();
              }
              if (binding.modifiers.self && e.target !== e.currentTarget) {
                continue;
              }
              if (typeof binding.value === "function") {
                if (param) {
                  binding.value(param, e);
                } else {
                  binding.value(e);
                }
              }
            }
          }
          function addTouchClass($el) {
            var className = $el.$$touchObj.options.touchClass;
            className && $el.classList.add(className);
          }
          function removeTouchClass($el) {
            var className = $el.$$touchObj.options.touchClass;
            className && $el.classList.remove(className);
          }
          function cancelTouchHoldTimer($this) {
            if ($this.touchHoldTimer) {
              clearTimeout($this.touchHoldTimer);
              $this.touchHoldTimer = null;
            }
          }
          function buildTouchObj($el, extraOptions) {
            var touchObj = $el.$$touchObj || {
              // an object contains all callbacks registered,
              // key is event name, value is an array
              callbacks: {},
              // prevent bind twice, set to true when event bound
              hasBindTouchEvents: false,
              // default options, would be override by v-touch-options
              options: globalOptions
            };
            if (extraOptions) {
              touchObj.options = Object.assign({}, touchObj.options, extraOptions);
            }
            $el.$$touchObj = touchObj;
            return $el.$$touchObj;
          }
          app2.directive("touch", {
            beforeMount: function($el, binding) {
              var $this = buildTouchObj($el);
              var passiveOpt = isPassiveSupported ? { passive: true } : false;
              var eventType = binding.arg || "tap";
              switch (eventType) {
                case "swipe":
                  var _m = binding.modifiers;
                  if (_m.left || _m.right || _m.top || _m.bottom) {
                    for (var i in binding.modifiers) {
                      if (["left", "right", "top", "bottom"].indexOf(i) >= 0) {
                        var _e = "swipe." + i;
                        $this.callbacks[_e] = $this.callbacks[_e] || [];
                        $this.callbacks[_e].push(binding);
                      }
                    }
                  } else {
                    $this.callbacks.swipe = $this.callbacks.swipe || [];
                    $this.callbacks.swipe.push(binding);
                  }
                  break;
                case "press":
                case "drag":
                  if (binding.modifiers.disablePassive) {
                    passiveOpt = false;
                  }
                default:
                  $this.callbacks[eventType] = $this.callbacks[eventType] || [];
                  $this.callbacks[eventType].push(binding);
              }
              if ($this.hasBindTouchEvents) {
                return;
              }
              $el.addEventListener("touchstart", touchStartEvent, passiveOpt);
              $el.addEventListener("touchmove", touchMoveEvent, passiveOpt);
              $el.addEventListener("touchcancel", touchCancelEvent);
              $el.addEventListener("touchend", touchEndEvent);
              if (!$this.options.disableClick) {
                $el.addEventListener("mousedown", touchStartEvent);
                $el.addEventListener("mousemove", touchMoveEvent);
                $el.addEventListener("mouseup", touchEndEvent);
                $el.addEventListener("mouseenter", mouseEnterEvent);
                $el.addEventListener("mouseleave", mouseLeaveEvent);
              }
              $this.hasBindTouchEvents = true;
            },
            unmounted: function($el) {
              $el.removeEventListener("touchstart", touchStartEvent);
              $el.removeEventListener("touchmove", touchMoveEvent);
              $el.removeEventListener("touchcancel", touchCancelEvent);
              $el.removeEventListener("touchend", touchEndEvent);
              if ($el.$$touchObj && !$el.$$touchObj.options.disableClick) {
                $el.removeEventListener("mousedown", touchStartEvent);
                $el.removeEventListener("mousemove", touchMoveEvent);
                $el.removeEventListener("mouseup", touchEndEvent);
                $el.removeEventListener("mouseenter", mouseEnterEvent);
                $el.removeEventListener("mouseleave", mouseLeaveEvent);
              }
              delete $el.$$touchObj;
            }
          });
          app2.directive("touch-class", {
            beforeMount: function($el, binding) {
              buildTouchObj($el, {
                touchClass: binding.value
              });
            }
          });
          app2.directive("touch-options", {
            beforeMount: function($el, binding) {
              buildTouchObj($el, binding.value);
            }
          });
        }
      };
      var isVue2 = false;
      /*!
        * pinia v2.1.4
        * (c) 2023 Eduardo San Martin Morote
        * @license MIT
        */
      let activePinia;
      const setActivePinia = (pinia2) => activePinia = pinia2;
      const piniaSymbol = (
        /* istanbul ignore next */
        Symbol()
      );
      function isPlainObject(o) {
        return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
      }
      var MutationType;
      (function(MutationType2) {
        MutationType2["direct"] = "direct";
        MutationType2["patchObject"] = "patch object";
        MutationType2["patchFunction"] = "patch function";
      })(MutationType || (MutationType = {}));
      function createPinia() {
        const scope = effectScope(true);
        const state = scope.run(() => ref({}));
        let _p = [];
        let toBeInstalled = [];
        const pinia2 = markRaw({
          install(app2) {
            setActivePinia(pinia2);
            {
              pinia2._a = app2;
              app2.provide(piniaSymbol, pinia2);
              app2.config.globalProperties.$pinia = pinia2;
              toBeInstalled.forEach((plugin) => _p.push(plugin));
              toBeInstalled = [];
            }
          },
          use(plugin) {
            if (!this._a && !isVue2) {
              toBeInstalled.push(plugin);
            } else {
              _p.push(plugin);
            }
            return this;
          },
          _p,
          // it's actually undefined here
          // @ts-expect-error
          _a: null,
          _e: scope,
          _s: /* @__PURE__ */ new Map(),
          state
        });
        return pinia2;
      }
      const noop$2 = () => {
      };
      function addSubscription(subscriptions, callback, detached, onCleanup = noop$2) {
        subscriptions.push(callback);
        const removeSubscription = () => {
          const idx = subscriptions.indexOf(callback);
          if (idx > -1) {
            subscriptions.splice(idx, 1);
            onCleanup();
          }
        };
        if (!detached && getCurrentScope()) {
          onScopeDispose(removeSubscription);
        }
        return removeSubscription;
      }
      function triggerSubscriptions(subscriptions, ...args) {
        subscriptions.slice().forEach((callback) => {
          callback(...args);
        });
      }
      const fallbackRunWithContext = (fn2) => fn2();
      function mergeReactiveObjects(target, patchToApply) {
        if (target instanceof Map && patchToApply instanceof Map) {
          patchToApply.forEach((value, key) => target.set(key, value));
        }
        if (target instanceof Set && patchToApply instanceof Set) {
          patchToApply.forEach(target.add, target);
        }
        for (const key in patchToApply) {
          if (!patchToApply.hasOwnProperty(key))
            continue;
          const subPatch = patchToApply[key];
          const targetValue = target[key];
          if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
            target[key] = mergeReactiveObjects(targetValue, subPatch);
          } else {
            target[key] = subPatch;
          }
        }
        return target;
      }
      const skipHydrateSymbol = (
        /* istanbul ignore next */
        Symbol()
      );
      function shouldHydrate(obj) {
        return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
      }
      const { assign } = Object;
      function isComputed(o) {
        return !!(isRef(o) && o.effect);
      }
      function createOptionsStore(id2, options, pinia2, hot) {
        const { state, actions, getters } = options;
        const initialState = pinia2.state.value[id2];
        let store;
        function setup() {
          if (!initialState && true) {
            {
              pinia2.state.value[id2] = state ? state() : {};
            }
          }
          const localState = toRefs(pinia2.state.value[id2]);
          return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
            computedGetters[name] = markRaw(computed(() => {
              setActivePinia(pinia2);
              const store2 = pinia2._s.get(id2);
              return getters[name].call(store2, store2);
            }));
            return computedGetters;
          }, {}));
        }
        store = createSetupStore(id2, setup, options, pinia2, hot, true);
        return store;
      }
      function createSetupStore($id, setup, options = {}, pinia2, hot, isOptionsStore) {
        let scope;
        const optionsForPlugin = assign({ actions: {} }, options);
        const $subscribeOptions = {
          deep: true
          // flush: 'post',
        };
        let isListening;
        let isSyncListening;
        let subscriptions = [];
        let actionSubscriptions = [];
        let debuggerEvents;
        const initialState = pinia2.state.value[$id];
        if (!isOptionsStore && !initialState && true) {
          {
            pinia2.state.value[$id] = {};
          }
        }
        ref({});
        let activeListener;
        function $patch(partialStateOrMutator) {
          let subscriptionMutation;
          isListening = isSyncListening = false;
          if (typeof partialStateOrMutator === "function") {
            partialStateOrMutator(pinia2.state.value[$id]);
            subscriptionMutation = {
              type: MutationType.patchFunction,
              storeId: $id,
              events: debuggerEvents
            };
          } else {
            mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
            subscriptionMutation = {
              type: MutationType.patchObject,
              payload: partialStateOrMutator,
              storeId: $id,
              events: debuggerEvents
            };
          }
          const myListenerId = activeListener = Symbol();
          nextTick().then(() => {
            if (activeListener === myListenerId) {
              isListening = true;
            }
          });
          isSyncListening = true;
          triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
        }
        const $reset = isOptionsStore ? function $reset2() {
          const { state } = options;
          const newState = state ? state() : {};
          this.$patch(($state) => {
            assign($state, newState);
          });
        } : (
          /* istanbul ignore next */
          noop$2
        );
        function $dispose() {
          scope.stop();
          subscriptions = [];
          actionSubscriptions = [];
          pinia2._s.delete($id);
        }
        function wrapAction(name, action) {
          return function() {
            setActivePinia(pinia2);
            const args = Array.from(arguments);
            const afterCallbackList = [];
            const onErrorCallbackList = [];
            function after(callback) {
              afterCallbackList.push(callback);
            }
            function onError(callback) {
              onErrorCallbackList.push(callback);
            }
            triggerSubscriptions(actionSubscriptions, {
              args,
              name,
              store,
              after,
              onError
            });
            let ret;
            try {
              ret = action.apply(this && this.$id === $id ? this : store, args);
            } catch (error) {
              triggerSubscriptions(onErrorCallbackList, error);
              throw error;
            }
            if (ret instanceof Promise) {
              return ret.then((value) => {
                triggerSubscriptions(afterCallbackList, value);
                return value;
              }).catch((error) => {
                triggerSubscriptions(onErrorCallbackList, error);
                return Promise.reject(error);
              });
            }
            triggerSubscriptions(afterCallbackList, ret);
            return ret;
          };
        }
        const partialStore = {
          _p: pinia2,
          // _s: scope,
          $id,
          $onAction: addSubscription.bind(null, actionSubscriptions),
          $patch,
          $reset,
          $subscribe(callback, options2 = {}) {
            const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
            const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
              if (options2.flush === "sync" ? isSyncListening : isListening) {
                callback({
                  storeId: $id,
                  type: MutationType.direct,
                  events: debuggerEvents
                }, state);
              }
            }, assign({}, $subscribeOptions, options2)));
            return removeSubscription;
          },
          $dispose
        };
        const store = reactive(partialStore);
        pinia2._s.set($id, store);
        const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
        const setupStore = pinia2._e.run(() => {
          scope = effectScope();
          return runWithContext(() => scope.run(setup));
        });
        for (const key in setupStore) {
          const prop = setupStore[key];
          if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
            if (!isOptionsStore) {
              if (initialState && shouldHydrate(prop)) {
                if (isRef(prop)) {
                  prop.value = initialState[key];
                } else {
                  mergeReactiveObjects(prop, initialState[key]);
                }
              }
              {
                pinia2.state.value[$id][key] = prop;
              }
            }
          } else if (typeof prop === "function") {
            const actionValue = wrapAction(key, prop);
            {
              setupStore[key] = actionValue;
            }
            optionsForPlugin.actions[key] = prop;
          } else
            ;
        }
        {
          assign(store, setupStore);
          assign(toRaw(store), setupStore);
        }
        Object.defineProperty(store, "$state", {
          get: () => pinia2.state.value[$id],
          set: (state) => {
            $patch(($state) => {
              assign($state, state);
            });
          }
        });
        pinia2._p.forEach((extender) => {
          {
            assign(store, scope.run(() => extender({
              store,
              app: pinia2._a,
              pinia: pinia2,
              options: optionsForPlugin
            })));
          }
        });
        if (initialState && isOptionsStore && options.hydrate) {
          options.hydrate(store.$state, initialState);
        }
        isListening = true;
        isSyncListening = true;
        return store;
      }
      function defineStore(idOrOptions, setup, setupOptions) {
        let id2;
        let options;
        const isSetupStore = typeof setup === "function";
        if (typeof idOrOptions === "string") {
          id2 = idOrOptions;
          options = isSetupStore ? setupOptions : setup;
        } else {
          options = idOrOptions;
          id2 = idOrOptions.id;
        }
        function useStore(pinia2, hot) {
          const hasContext = hasInjectionContext();
          pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
          // pinia instance with getActivePinia()
          pinia2 || (hasContext ? inject(piniaSymbol, null) : null);
          if (pinia2)
            setActivePinia(pinia2);
          pinia2 = activePinia;
          if (!pinia2._s.has(id2)) {
            if (isSetupStore) {
              createSetupStore(id2, setup, options, pinia2);
            } else {
              createOptionsStore(id2, options, pinia2);
            }
          }
          const store = pinia2._s.get(id2);
          return store;
        }
        useStore.$id = id2;
        return useStore;
      }
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      var FileSaver_min = { exports: {} };
      (function(module2, exports2) {
        (function(a, b) {
          b();
        })(commonjsGlobal, function() {
          function b(a2, b2) {
            return "undefined" == typeof b2 ? b2 = { autoBom: false } : "object" != typeof b2 && (console.warn("Deprecated: Expected third argument to be a object"), b2 = { autoBom: !b2 }), b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2;
          }
          function c(a2, b2, c2) {
            var d2 = new XMLHttpRequest();
            d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
              g(d2.response, b2, c2);
            }, d2.onerror = function() {
              console.error("could not download file");
            }, d2.send();
          }
          function d(a2) {
            var b2 = new XMLHttpRequest();
            b2.open("HEAD", a2, false);
            try {
              b2.send();
            } catch (a3) {
            }
            return 200 <= b2.status && 299 >= b2.status;
          }
          function e(a2) {
            try {
              a2.dispatchEvent(new MouseEvent("click"));
            } catch (c2) {
              var b2 = document.createEvent("MouseEvents");
              b2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b2);
            }
          }
          var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof commonjsGlobal && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {
          } : "download" in HTMLAnchorElement.prototype && !a ? function(b2, g2, h2) {
            var i = f.URL || f.webkitURL, j = document.createElement("a");
            g2 = g2 || b2.name || "download", j.download = g2, j.rel = "noopener", "string" == typeof b2 ? (j.href = b2, j.origin === location.origin ? e(j) : d(j.href) ? c(b2, g2, h2) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b2), setTimeout(function() {
              i.revokeObjectURL(j.href);
            }, 4e4), setTimeout(function() {
              e(j);
            }, 0));
          } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h2) {
            if (g2 = g2 || f2.name || "download", "string" != typeof f2)
              navigator.msSaveOrOpenBlob(b(f2, h2), g2);
            else if (d(f2))
              c(f2, g2, h2);
            else {
              var i = document.createElement("a");
              i.href = f2, i.target = "_blank", setTimeout(function() {
                e(i);
              });
            }
          } : function(b2, d2, e2, g2) {
            if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), "string" == typeof b2)
              return c(b2, d2, e2);
            var h2 = "application/octet-stream" === b2.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
            if ((j || h2 && i || a) && "undefined" != typeof FileReader) {
              var k = new FileReader();
              k.onloadend = function() {
                var a2 = k.result;
                a2 = j ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a2 : location = a2, g2 = null;
              }, k.readAsDataURL(b2);
            } else {
              var l = f.URL || f.webkitURL, m = l.createObjectURL(b2);
              g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
                l.revokeObjectURL(m);
              }, 4e4);
            }
          });
          f.saveAs = g.saveAs = g, module2.exports = g;
        });
      })(FileSaver_min);
      var FileSaver_minExports = FileSaver_min.exports;
      const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
      const isVisible = (element) => {
        const computed2 = getComputedStyle(element);
        return computed2.position === "fixed" ? false : element.offsetParent !== null;
      };
      const obtainAllFocusableElements$1 = (element) => {
        return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter((item) => isFocusable(item) && isVisible(item));
      };
      const isFocusable = (element) => {
        if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
          return true;
        }
        if (element.disabled) {
          return false;
        }
        switch (element.nodeName) {
          case "A": {
            return !!element.href && element.rel !== "ignore";
          }
          case "INPUT": {
            return !(element.type === "hidden" || element.type === "file");
          }
          case "BUTTON":
          case "SELECT":
          case "TEXTAREA": {
            return true;
          }
          default: {
            return false;
          }
        }
      };
      const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
        const handleEvent = (event) => {
          const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
          if (checkForDefaultPrevented === false || !shouldPrevent) {
            return oursHandler == null ? void 0 : oursHandler(event);
          }
        };
        return handleEvent;
      };
      const whenMouse = (handler) => {
        return (e) => e.pointerType === "mouse" ? handler(e) : void 0;
      };
      var __defProp$9 = Object.defineProperty;
      var __defProps$6 = Object.defineProperties;
      var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
      var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
      var __hasOwnProp$b = Object.prototype.hasOwnProperty;
      var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
      var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues$9 = (a, b) => {
        for (var prop in b || (b = {}))
          if (__hasOwnProp$b.call(b, prop))
            __defNormalProp$9(a, prop, b[prop]);
        if (__getOwnPropSymbols$b)
          for (var prop of __getOwnPropSymbols$b(b)) {
            if (__propIsEnum$b.call(b, prop))
              __defNormalProp$9(a, prop, b[prop]);
          }
        return a;
      };
      var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
      function computedEager(fn2, options) {
        var _a2;
        const result = shallowRef();
        watchEffect(() => {
          result.value = fn2();
        }, __spreadProps$6(__spreadValues$9({}, options), {
          flush: (_a2 = options == null ? void 0 : options.flush) != null ? _a2 : "sync"
        }));
        return readonly(result);
      }
      var _a;
      const isClient$1 = typeof window !== "undefined";
      const isString = (val) => typeof val === "string";
      const noop$1 = () => {
      };
      const isIOS = isClient$1 && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
      function resolveUnref(r) {
        return typeof r === "function" ? r() : unref(r);
      }
      function createFilterWrapper(filter, fn2) {
        function wrapper(...args) {
          return new Promise((resolve2, reject) => {
            Promise.resolve(filter(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve2).catch(reject);
          });
        }
        return wrapper;
      }
      function debounceFilter(ms, options = {}) {
        let timer;
        let maxTimer;
        let lastRejector = noop$1;
        const _clearTimeout = (timer2) => {
          clearTimeout(timer2);
          lastRejector();
          lastRejector = noop$1;
        };
        const filter = (invoke) => {
          const duration = resolveUnref(ms);
          const maxDuration = resolveUnref(options.maxWait);
          if (timer)
            _clearTimeout(timer);
          if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
            if (maxTimer) {
              _clearTimeout(maxTimer);
              maxTimer = null;
            }
            return Promise.resolve(invoke());
          }
          return new Promise((resolve2, reject) => {
            lastRejector = options.rejectOnCancel ? reject : resolve2;
            if (maxDuration && !maxTimer) {
              maxTimer = setTimeout(() => {
                if (timer)
                  _clearTimeout(timer);
                maxTimer = null;
                resolve2(invoke());
              }, maxDuration);
            }
            timer = setTimeout(() => {
              if (maxTimer)
                _clearTimeout(maxTimer);
              maxTimer = null;
              resolve2(invoke());
            }, duration);
          });
        };
        return filter;
      }
      function identity$1(arg) {
        return arg;
      }
      function tryOnScopeDispose$1(fn2) {
        if (getCurrentScope()) {
          onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      function useDebounceFn(fn2, ms = 200, options = {}) {
        return createFilterWrapper(debounceFilter(ms, options), fn2);
      }
      function refDebounced(value, ms = 200, options = {}) {
        const debounced = ref(value.value);
        const updater = useDebounceFn(() => {
          debounced.value = value.value;
        }, ms, options);
        watch(value, () => updater());
        return debounced;
      }
      function tryOnMounted$1(fn2, sync = true) {
        if (getCurrentInstance())
          onMounted(fn2);
        else if (sync)
          fn2();
        else
          nextTick(fn2);
      }
      function useTimeoutFn$1(cb, interval, options = {}) {
        const {
          immediate = true
        } = options;
        const isPending = ref(false);
        let timer = null;
        function clear2() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function stop() {
          isPending.value = false;
          clear2();
        }
        function start(...args) {
          clear2();
          isPending.value = true;
          timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            cb(...args);
          }, resolveUnref(interval));
        }
        if (immediate) {
          isPending.value = true;
          if (isClient$1)
            start();
        }
        tryOnScopeDispose$1(stop);
        return {
          isPending: readonly(isPending),
          start,
          stop
        };
      }
      function unrefElement$1(elRef) {
        var _a2;
        const plain = resolveUnref(elRef);
        return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
      }
      const defaultWindow$1 = isClient$1 ? window : void 0;
      const defaultDocument = isClient$1 ? window.document : void 0;
      function useEventListener$1(...args) {
        let target;
        let events;
        let listeners;
        let options;
        if (isString(args[0]) || Array.isArray(args[0])) {
          [events, listeners, options] = args;
          target = defaultWindow$1;
        } else {
          [target, events, listeners, options] = args;
        }
        if (!target)
          return noop$1;
        if (!Array.isArray(events))
          events = [events];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = watch(() => [unrefElement$1(target), resolveUnref(options)], ([el, options2]) => {
          cleanup();
          if (!el)
            return;
          cleanups.push(...events.flatMap((event) => {
            return listeners.map((listener) => register(el, event, listener, options2));
          }));
        }, { immediate: true, flush: "post" });
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose$1(stop);
        return stop;
      }
      let _iOSWorkaround = false;
      function onClickOutside(target, handler, options = {}) {
        const { window: window2 = defaultWindow$1, ignore = [], capture = true, detectIframe = false } = options;
        if (!window2)
          return;
        if (isIOS && !_iOSWorkaround) {
          _iOSWorkaround = true;
          Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop$1));
        }
        let shouldListen = true;
        const shouldIgnore = (event) => {
          return ignore.some((target2) => {
            if (typeof target2 === "string") {
              return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
            } else {
              const el = unrefElement$1(target2);
              return el && (event.target === el || event.composedPath().includes(el));
            }
          });
        };
        const listener = (event) => {
          const el = unrefElement$1(target);
          if (!el || el === event.target || event.composedPath().includes(el))
            return;
          if (event.detail === 0)
            shouldListen = !shouldIgnore(event);
          if (!shouldListen) {
            shouldListen = true;
            return;
          }
          handler(event);
        };
        const cleanup = [
          useEventListener$1(window2, "click", listener, { passive: true, capture }),
          useEventListener$1(window2, "pointerdown", (e) => {
            const el = unrefElement$1(target);
            if (el)
              shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);
          }, { passive: true }),
          detectIframe && useEventListener$1(window2, "blur", (event) => {
            var _a2;
            const el = unrefElement$1(target);
            if (((_a2 = window2.document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
              handler(event);
          })
        ].filter(Boolean);
        const stop = () => cleanup.forEach((fn2) => fn2());
        return stop;
      }
      function useSupported$1(callback, sync = false) {
        const isSupported = ref();
        const update = () => isSupported.value = Boolean(callback());
        update();
        tryOnMounted$1(update, sync);
        return isSupported;
      }
      const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      const globalKey = "__vueuse_ssr_handlers__";
      _global[globalKey] = _global[globalKey] || {};
      function useDocumentVisibility({ document: document2 = defaultDocument } = {}) {
        if (!document2)
          return ref("visible");
        const visibility = ref(document2.visibilityState);
        useEventListener$1(document2, "visibilitychange", () => {
          visibility.value = document2.visibilityState;
        });
        return visibility;
      }
      var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
      var __hasOwnProp$g = Object.prototype.hasOwnProperty;
      var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
      var __objRest$2 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$g)
          for (var prop of __getOwnPropSymbols$g(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useResizeObserver(target, callback, options = {}) {
        const _a2 = options, { window: window2 = defaultWindow$1 } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
        let observer;
        const isSupported = useSupported$1(() => window2 && "ResizeObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = watch(() => unrefElement$1(target), (el) => {
          cleanup();
          if (isSupported.value && window2 && el) {
            observer = new ResizeObserver(callback);
            observer.observe(el, observerOptions);
          }
        }, { immediate: true, flush: "post" });
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose$1(stop);
        return {
          isSupported,
          stop
        };
      }
      var SwipeDirection;
      (function(SwipeDirection2) {
        SwipeDirection2["UP"] = "UP";
        SwipeDirection2["RIGHT"] = "RIGHT";
        SwipeDirection2["DOWN"] = "DOWN";
        SwipeDirection2["LEFT"] = "LEFT";
        SwipeDirection2["NONE"] = "NONE";
      })(SwipeDirection || (SwipeDirection = {}));
      var __defProp2 = Object.defineProperty;
      var __getOwnPropSymbols = Object.getOwnPropertySymbols;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __propIsEnum = Object.prototype.propertyIsEnumerable;
      var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues = (a, b) => {
        for (var prop in b || (b = {}))
          if (__hasOwnProp.call(b, prop))
            __defNormalProp2(a, prop, b[prop]);
        if (__getOwnPropSymbols)
          for (var prop of __getOwnPropSymbols(b)) {
            if (__propIsEnum.call(b, prop))
              __defNormalProp2(a, prop, b[prop]);
          }
        return a;
      };
      const _TransitionPresets = {
        easeInSine: [0.12, 0, 0.39, 0],
        easeOutSine: [0.61, 1, 0.88, 1],
        easeInOutSine: [0.37, 0, 0.63, 1],
        easeInQuad: [0.11, 0, 0.5, 0],
        easeOutQuad: [0.5, 1, 0.89, 1],
        easeInOutQuad: [0.45, 0, 0.55, 1],
        easeInCubic: [0.32, 0, 0.67, 0],
        easeOutCubic: [0.33, 1, 0.68, 1],
        easeInOutCubic: [0.65, 0, 0.35, 1],
        easeInQuart: [0.5, 0, 0.75, 0],
        easeOutQuart: [0.25, 1, 0.5, 1],
        easeInOutQuart: [0.76, 0, 0.24, 1],
        easeInQuint: [0.64, 0, 0.78, 0],
        easeOutQuint: [0.22, 1, 0.36, 1],
        easeInOutQuint: [0.83, 0, 0.17, 1],
        easeInExpo: [0.7, 0, 0.84, 0],
        easeOutExpo: [0.16, 1, 0.3, 1],
        easeInOutExpo: [0.87, 0, 0.13, 1],
        easeInCirc: [0.55, 0, 1, 0.45],
        easeOutCirc: [0, 0.55, 0.45, 1],
        easeInOutCirc: [0.85, 0, 0.15, 1],
        easeInBack: [0.36, 0, 0.66, -0.56],
        easeOutBack: [0.34, 1.56, 0.64, 1],
        easeInOutBack: [0.68, -0.6, 0.32, 1.6]
      };
      __spreadValues({
        linear: identity$1
      }, _TransitionPresets);
      function useWindowFocus({ window: window2 = defaultWindow$1 } = {}) {
        if (!window2)
          return ref(false);
        const focused = ref(window2.document.hasFocus());
        useEventListener$1(window2, "blur", () => {
          focused.value = false;
        });
        useEventListener$1(window2, "focus", () => {
          focused.value = true;
        });
        return focused;
      }
      const isFirefox = () => isClient$1 && /firefox/i.test(window.navigator.userAgent);
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      const freeGlobal$1 = freeGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal$1 || freeSelf || Function("return this")();
      const root$1 = root;
      var Symbol$1 = root$1.Symbol;
      const Symbol$2 = Symbol$1;
      var objectProto$e = Object.prototype;
      var hasOwnProperty$b = objectProto$e.hasOwnProperty;
      var nativeObjectToString$1 = objectProto$e.toString;
      var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString$1.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result;
      }
      var objectProto$d = Object.prototype;
      var nativeObjectToString = objectProto$d.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var symbolTag$3 = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
      }
      function arrayMap(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array2[index], index, array2);
        }
        return result;
      }
      var isArray = Array.isArray;
      const isArray$1 = isArray;
      var INFINITY$1 = 1 / 0;
      var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray$1(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
      }
      var reWhitespace = /\s/;
      function trimmedEndIndex(string2) {
        var index = string2.length;
        while (index-- && reWhitespace.test(string2.charAt(index))) {
        }
        return index;
      }
      var reTrimStart = /^\s+/;
      function baseTrim(string2) {
        return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
      }
      function isObject(value) {
        var type2 = typeof value;
        return value != null && (type2 == "object" || type2 == "function");
      }
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function identity(value) {
        return value;
      }
      var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
      }
      var coreJsData = root$1["__core-js_shared__"];
      const coreJsData$1 = coreJsData;
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var funcProto$1 = Function.prototype;
      var funcToString$1 = funcProto$1.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString$1.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype, objectProto$c = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty$a = objectProto$c.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern2 = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern2.test(toSource(value));
      }
      function getValue$1(object2, key) {
        return object2 == null ? void 0 : object2[key];
      }
      function getNative(object2, key) {
        var value = getValue$1(object2, key);
        return baseIsNative(value) ? value : void 0;
      }
      var WeakMap$1 = getNative(root$1, "WeakMap");
      const WeakMap$2 = WeakMap$1;
      var objectCreate = Object.create;
      var baseCreate = function() {
        function object2() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object2.prototype = proto;
          var result = new object2();
          object2.prototype = void 0;
          return result;
        };
      }();
      const baseCreate$1 = baseCreate;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function copyArray(source, array2) {
        var index = -1, length = source.length;
        array2 || (array2 = Array(length));
        while (++index < length) {
          array2[index] = source[index];
        }
        return array2;
      }
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      const defineProperty$1 = defineProperty;
      var baseSetToString = !defineProperty$1 ? identity : function(func, string2) {
        return defineProperty$1(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string2),
          "writable": true
        });
      };
      const baseSetToString$1 = baseSetToString;
      var setToString = shortOut(baseSetToString$1);
      const setToString$1 = setToString;
      function arrayEach(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (iteratee(array2[index], index, array2) === false) {
            break;
          }
        }
        return array2;
      }
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type2 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER$1 : length;
        return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function baseAssignValue(object2, key, value) {
        if (key == "__proto__" && defineProperty$1) {
          defineProperty$1(object2, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object2[key] = value;
        }
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var objectProto$b = Object.prototype;
      var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
      function assignValue(object2, key, value) {
        var objValue = object2[key];
        if (!(hasOwnProperty$9.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
          baseAssignValue(object2, key, value);
        }
      }
      function copyObject(source, props, object2, customizer) {
        var isNew = !object2;
        object2 || (object2 = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object2, key, newValue);
          } else {
            assignValue(object2, key, newValue);
          }
        }
        return object2;
      }
      var nativeMax$1 = Math.max;
      function overRest(func, start, transform) {
        start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array2 = Array(length);
          while (++index < length) {
            array2[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array2);
          return apply(func, this, otherArgs);
        };
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      var objectProto$a = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
        return value === proto;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      var argsTag$3 = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag$3;
      }
      var objectProto$9 = Object.prototype;
      var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
      var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
      };
      const isArguments$1 = isArguments;
      function stubFalse() {
        return false;
      }
      var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
      var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;
      var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      const isBuffer$1 = isBuffer;
      var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
      var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
      typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var freeProcess = moduleExports$1 && freeGlobal$1.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      const nodeUtil$1 = nodeUtil;
      var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      const isTypedArray$1 = isTypedArray;
      var objectProto$8 = Object.prototype;
      var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var nativeKeys = overArg(Object.keys, Object);
      const nativeKeys$1 = nativeKeys;
      var objectProto$7 = Object.prototype;
      var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
      function baseKeys(object2) {
        if (!isPrototype(object2)) {
          return nativeKeys$1(object2);
        }
        var result = [];
        for (var key in Object(object2)) {
          if (hasOwnProperty$6.call(object2, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function keys(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
      }
      function nativeKeysIn(object2) {
        var result = [];
        if (object2 != null) {
          for (var key in Object(object2)) {
            result.push(key);
          }
        }
        return result;
      }
      var objectProto$6 = Object.prototype;
      var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
      function baseKeysIn(object2) {
        if (!isObject(object2)) {
          return nativeKeysIn(object2);
        }
        var isProto = isPrototype(object2), result = [];
        for (var key in object2) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty$5.call(object2, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function keysIn(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
      }
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
      function isKey(value, object2) {
        if (isArray$1(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
      }
      var nativeCreate = getNative(Object, "create");
      const nativeCreate$1 = nativeCreate;
      function hashClear() {
        this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
      var objectProto$5 = Object.prototype;
      var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate$1) {
          var result = data[key];
          return result === HASH_UNDEFINED$2 ? void 0 : result;
        }
        return hasOwnProperty$4.call(data, key) ? data[key] : void 0;
      }
      var objectProto$4 = Object.prototype;
      var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$3.call(data, key);
      }
      var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
        return this;
      }
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function assocIndexOf(array2, key) {
        var length = array2.length;
        while (length--) {
          if (eq(array2[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      var Map$1 = getNative(root$1, "Map");
      const Map$2 = Map$1;
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map$2 || ListCache)(),
          "string": new Hash()
        };
      }
      function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      var FUNC_ERROR_TEXT$1 = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$1);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache2.set(key, result) || cache2;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result.cache;
        return result;
      }
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string2) {
        var result = [];
        if (string2.charCodeAt(0) === 46) {
          result.push("");
        }
        string2.replace(rePropName, function(match, number2, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
        });
        return result;
      });
      const stringToPath$1 = stringToPath;
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      function castPath(value, object2) {
        if (isArray$1(value)) {
          return value;
        }
        return isKey(value, object2) ? [value] : stringToPath$1(toString(value));
      }
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function baseGet(object2, path) {
        path = castPath(path, object2);
        var index = 0, length = path.length;
        while (object2 != null && index < length) {
          object2 = object2[toKey(path[index++])];
        }
        return index && index == length ? object2 : void 0;
      }
      function get(object2, path, defaultValue) {
        var result = object2 == null ? void 0 : baseGet(object2, path);
        return result === void 0 ? defaultValue : result;
      }
      function arrayPush(array2, values) {
        var index = -1, length = values.length, offset = array2.length;
        while (++index < length) {
          array2[offset + index] = values[index];
        }
        return array2;
      }
      var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray$1(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function baseFlatten(array2, depth, predicate, isStrict, result) {
        var index = -1, length = array2.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array2[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      function flatten(array2) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseFlatten(array2, 1) : [];
      }
      function flatRest(func) {
        return setToString$1(overRest(func, void 0, flatten), func + "");
      }
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      const getPrototype$1 = getPrototype;
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray$1(value) ? value : [value];
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function baseAssign(object2, source) {
        return object2 && copyObject(source, keys(source), object2);
      }
      function baseAssignIn(object2, source) {
        return object2 && copyObject(source, keysIn(source), object2);
      }
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      function arrayFilter(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (predicate(value, index, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function stubArray() {
        return [];
      }
      var objectProto$3 = Object.prototype;
      var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
      var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object2) {
        if (object2 == null) {
          return [];
        }
        object2 = Object(object2);
        return arrayFilter(nativeGetSymbols$1(object2), function(symbol) {
          return propertyIsEnumerable.call(object2, symbol);
        });
      };
      const getSymbols$1 = getSymbols;
      function copySymbols(source, object2) {
        return copyObject(source, getSymbols$1(source), object2);
      }
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
        var result = [];
        while (object2) {
          arrayPush(result, getSymbols$1(object2));
          object2 = getPrototype$1(object2);
        }
        return result;
      };
      const getSymbolsIn$1 = getSymbolsIn;
      function copySymbolsIn(source, object2) {
        return copyObject(source, getSymbolsIn$1(source), object2);
      }
      function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
        var result = keysFunc(object2);
        return isArray$1(object2) ? result : arrayPush(result, symbolsFunc(object2));
      }
      function getAllKeys(object2) {
        return baseGetAllKeys(object2, keys, getSymbols$1);
      }
      function getAllKeysIn(object2) {
        return baseGetAllKeys(object2, keysIn, getSymbolsIn$1);
      }
      var DataView = getNative(root$1, "DataView");
      const DataView$1 = DataView;
      var Promise$1 = getNative(root$1, "Promise");
      const Promise$2 = Promise$1;
      var Set$1 = getNative(root$1, "Set");
      const Set$2 = Set$1;
      var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
      var dataViewTag$3 = "[object DataView]";
      var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
      var getTag = baseGetTag;
      if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$2 && getTag(new Map$2()) != mapTag$4 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$4 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag$3;
              case mapCtorString:
                return mapTag$4;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag$4;
              case weakMapCtorString:
                return weakMapTag$1;
            }
          }
          return result;
        };
      }
      const getTag$1 = getTag;
      var objectProto$2 = Object.prototype;
      var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
      function initCloneArray(array2) {
        var length = array2.length, result = new array2.constructor(length);
        if (length && typeof array2[0] == "string" && hasOwnProperty$2.call(array2, "index")) {
          result.index = array2.index;
          result.input = array2.input;
        }
        return result;
      }
      var Uint8Array2 = root$1.Uint8Array;
      const Uint8Array$1 = Uint8Array2;
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
        return result;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      var reFlags = /\w*$/;
      function cloneRegExp(regexp2) {
        var result = new regexp2.constructor(regexp2.source, reFlags.exec(regexp2));
        result.lastIndex = regexp2.lastIndex;
        return result;
      }
      var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
      var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
      function initCloneByTag(object2, tag, isDeep) {
        var Ctor = object2.constructor;
        switch (tag) {
          case arrayBufferTag$2:
            return cloneArrayBuffer(object2);
          case boolTag$2:
          case dateTag$2:
            return new Ctor(+object2);
          case dataViewTag$2:
            return cloneDataView(object2, isDeep);
          case float32Tag$1:
          case float64Tag$1:
          case int8Tag$1:
          case int16Tag$1:
          case int32Tag$1:
          case uint8Tag$1:
          case uint8ClampedTag$1:
          case uint16Tag$1:
          case uint32Tag$1:
            return cloneTypedArray(object2, isDeep);
          case mapTag$3:
            return new Ctor();
          case numberTag$2:
          case stringTag$2:
            return new Ctor(object2);
          case regexpTag$2:
            return cloneRegExp(object2);
          case setTag$3:
            return new Ctor();
          case symbolTag$2:
            return cloneSymbol(object2);
        }
      }
      function initCloneObject(object2) {
        return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate$1(getPrototype$1(object2)) : {};
      }
      var mapTag$2 = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag$1(value) == mapTag$2;
      }
      var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      const isMap$1 = isMap;
      var setTag$2 = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag$1(value) == setTag$2;
      }
      var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      const isSet$1 = isSet;
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
      var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
      var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object2, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
        if (customizer) {
          result = object2 ? customizer(value, key, object2, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray$1(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer$1(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object2) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object2 ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet$1(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap$1(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? void 0 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result;
      }
      var CLONE_SYMBOLS_FLAG = 4;
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function arraySome(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (predicate(array2[index], index, array2)) {
            return true;
          }
        }
        return false;
      }
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
      function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array2);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array2;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
        stack.set(array2, other);
        stack.set(other, array2);
        while (++index < arrLength) {
          var arrValue = array2[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array2);
        stack["delete"](other);
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
      var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
      var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
              return false;
            }
            object2 = object2.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object2), new Uint8Array$1(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object2, +other);
          case errorTag:
            return object2.name == other.name && object2.message == other.message;
          case regexpTag:
          case stringTag:
            return object2 == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
            convert || (convert = setToArray);
            if (object2.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object2);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object2, other);
            var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object2);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object2) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      var COMPARE_PARTIAL_FLAG$1 = 1;
      var objectProto$1 = Object.prototype;
      var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
      function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object2);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object2;
        }
        var result = true;
        stack.set(object2, other);
        stack.set(other, object2);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object2[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object2.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object2);
        stack["delete"](other);
        return result;
      }
      var COMPARE_PARTIAL_FLAG = 1;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray$1(object2), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object2), othTag = othIsArr ? arrayTag : getTag$1(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer$1(object2)) {
          if (!isBuffer$1(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray$1(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseHasIn(object2, key) {
        return object2 != null && key in Object(object2);
      }
      function hasPath(object2, path, hasFunc) {
        path = castPath(path, object2);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object2 != null && hasFunc(object2, key))) {
            break;
          }
          object2 = object2[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object2 == null ? 0 : object2.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object2) || isArguments$1(object2));
      }
      function hasIn(object2, path) {
        return object2 != null && hasPath(object2, path, baseHasIn);
      }
      var now = function() {
        return root$1.Date.now();
      };
      const now$1 = now;
      var FUNC_ERROR_TEXT = "Expected a function";
      var nativeMax = Math.max, nativeMin = Math.min;
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now$1();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now$1());
        }
        function debounced() {
          var time = now$1(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
        while (++index < length) {
          var pair = pairs[index];
          result[pair[0]] = pair[1];
        }
        return result;
      }
      function isEqual$1(value, other) {
        return baseIsEqual(value, other);
      }
      function isNil(value) {
        return value == null;
      }
      function isUndefined$1(value) {
        return value === void 0;
      }
      function baseSet(object2, path, value, customizer) {
        if (!isObject(object2)) {
          return object2;
        }
        path = castPath(path, object2);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object2;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object2;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object2;
      }
      function basePickBy(object2, paths, predicate) {
        var index = -1, length = paths.length, result = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object2, path);
          if (predicate(value, path)) {
            baseSet(result, castPath(path, object2), value);
          }
        }
        return result;
      }
      function basePick(object2, paths) {
        return basePickBy(object2, paths, function(value, path) {
          return hasIn(object2, path);
        });
      }
      var pick = flatRest(function(object2, paths) {
        return object2 == null ? {} : basePick(object2, paths);
      });
      const pick$1 = pick;
      function set(object2, path, value) {
        return object2 == null ? object2 : baseSet(object2, path, value);
      }
      const isUndefined = (val) => val === void 0;
      const isBoolean = (val) => typeof val === "boolean";
      const isNumber = (val) => typeof val === "number";
      const isElement = (e) => {
        if (typeof Element === "undefined")
          return false;
        return e instanceof Element;
      };
      const isStringNumber = (val) => {
        if (!isString$1(val)) {
          return false;
        }
        return !Number.isNaN(Number(val));
      };
      const escapeStringRegexp = (string2 = "") => string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      const capitalize = (str) => capitalize$1(str);
      const keysOf = (arr) => Object.keys(arr);
      const getProp = (obj, path, defaultValue) => {
        return {
          get value() {
            return get(obj, path, defaultValue);
          },
          set value(val) {
            set(obj, path, val);
          }
        };
      };
      class ElementPlusError extends Error {
        constructor(m) {
          super(m);
          this.name = "ElementPlusError";
        }
      }
      function throwError(scope, m) {
        throw new ElementPlusError(`[${scope}] ${m}`);
      }
      function debugWarn(scope, message2) {
      }
      const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
      const hasClass = (el, cls) => {
        if (!el || !cls)
          return false;
        if (cls.includes(" "))
          throw new Error("className should not contain space.");
        return el.classList.contains(cls);
      };
      const addClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.add(...classNameToArray(cls));
      };
      const removeClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.remove(...classNameToArray(cls));
      };
      const getStyle = (element, styleName) => {
        var _a2;
        if (!isClient$1 || !element || !styleName)
          return "";
        let key = camelize(styleName);
        if (key === "float")
          key = "cssFloat";
        try {
          const style = element.style[key];
          if (style)
            return style;
          const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
          return computed2 ? computed2[key] : "";
        } catch (e) {
          return element.style[key];
        }
      };
      function addUnit(value, defaultUnit = "px") {
        if (!value)
          return "";
        if (isNumber(value) || isStringNumber(value)) {
          return `${value}${defaultUnit}`;
        } else if (isString$1(value)) {
          return value;
        }
      }
      let scrollBarWidth;
      const getScrollBarWidth = (namespace) => {
        var _a2;
        if (!isClient$1)
          return 0;
        if (scrollBarWidth !== void 0)
          return scrollBarWidth;
        const outer = document.createElement("div");
        outer.className = `${namespace}-scrollbar__wrap`;
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        outer.style.position = "absolute";
        outer.style.top = "-9999px";
        document.body.appendChild(outer);
        const widthNoScroll = outer.offsetWidth;
        outer.style.overflow = "scroll";
        const inner = document.createElement("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        const widthWithScroll = inner.offsetWidth;
        (_a2 = outer.parentNode) == null ? void 0 : _a2.removeChild(outer);
        scrollBarWidth = widthNoScroll - widthWithScroll;
        return scrollBarWidth;
      };
      function scrollIntoView(container, selected) {
        if (!isClient$1)
          return;
        if (!selected) {
          container.scrollTop = 0;
          return;
        }
        const offsetParents = [];
        let pointer = selected.offsetParent;
        while (pointer !== null && container !== pointer && container.contains(pointer)) {
          offsetParents.push(pointer);
          pointer = pointer.offsetParent;
        }
        const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
        const bottom = top + selected.offsetHeight;
        const viewRectTop = container.scrollTop;
        const viewRectBottom = viewRectTop + container.clientHeight;
        if (top < viewRectTop) {
          container.scrollTop = top;
        } else if (bottom > viewRectBottom) {
          container.scrollTop = bottom - container.clientHeight;
        }
      }
      /*! Element Plus Icons Vue v2.1.0 */
      var export_helper_default = (sfc, props) => {
        let target = sfc.__vccOpts || sfc;
        for (let [key, val] of props)
          target[key] = val;
        return target;
      };
      var arrow_down_vue_vue_type_script_lang_default = {
        name: "ArrowDown"
      };
      var _hoisted_16$1 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_26$1 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_36 = [
        _hoisted_26$1
      ];
      function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_16$1, _hoisted_36);
      }
      var arrow_down_default = /* @__PURE__ */ export_helper_default(arrow_down_vue_vue_type_script_lang_default, [["render", _sfc_render6], ["__file", "arrow-down.vue"]]);
      var arrow_left_vue_vue_type_script_lang_default = {
        name: "ArrowLeft"
      };
      var _hoisted_18$1 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_28$1 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_38 = [
        _hoisted_28$1
      ];
      function _sfc_render8(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_18$1, _hoisted_38);
      }
      var arrow_left_default = /* @__PURE__ */ export_helper_default(arrow_left_vue_vue_type_script_lang_default, [["render", _sfc_render8], ["__file", "arrow-left.vue"]]);
      var arrow_right_vue_vue_type_script_lang_default = {
        name: "ArrowRight"
      };
      var _hoisted_110 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_210 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_310 = [
        _hoisted_210
      ];
      function _sfc_render10(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_110, _hoisted_310);
      }
      var arrow_right_default = /* @__PURE__ */ export_helper_default(arrow_right_vue_vue_type_script_lang_default, [["render", _sfc_render10], ["__file", "arrow-right.vue"]]);
      var arrow_up_vue_vue_type_script_lang_default = {
        name: "ArrowUp"
      };
      var _hoisted_112 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_212 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_312 = [
        _hoisted_212
      ];
      function _sfc_render12(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_112, _hoisted_312);
      }
      var arrow_up_default = /* @__PURE__ */ export_helper_default(arrow_up_vue_vue_type_script_lang_default, [["render", _sfc_render12], ["__file", "arrow-up.vue"]]);
      var caret_right_vue_vue_type_script_lang_default = {
        name: "CaretRight"
      };
      var _hoisted_134 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_234 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M384 192v640l384-320.064z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_333 = [
        _hoisted_234
      ];
      function _sfc_render34(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_134, _hoisted_333);
      }
      var caret_right_default = /* @__PURE__ */ export_helper_default(caret_right_vue_vue_type_script_lang_default, [["render", _sfc_render34], ["__file", "caret-right.vue"]]);
      var check_vue_vue_type_script_lang_default = {
        name: "Check"
      };
      var _hoisted_143 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_243 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_342 = [
        _hoisted_243
      ];
      function _sfc_render43(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_143, _hoisted_342);
      }
      var check_default = /* @__PURE__ */ export_helper_default(check_vue_vue_type_script_lang_default, [["render", _sfc_render43], ["__file", "check.vue"]]);
      var circle_check_vue_vue_type_script_lang_default = {
        name: "CircleCheck"
      };
      var _hoisted_149 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_249 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_348 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_415 = [
        _hoisted_249,
        _hoisted_348
      ];
      function _sfc_render49(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_149, _hoisted_415);
      }
      var circle_check_default = /* @__PURE__ */ export_helper_default(circle_check_vue_vue_type_script_lang_default, [["render", _sfc_render49], ["__file", "circle-check.vue"]]);
      var circle_close_filled_vue_vue_type_script_lang_default = {
        name: "CircleCloseFilled"
      };
      var _hoisted_150 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_250 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_349 = [
        _hoisted_250
      ];
      function _sfc_render50(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_150, _hoisted_349);
      }
      var circle_close_filled_default = /* @__PURE__ */ export_helper_default(circle_close_filled_vue_vue_type_script_lang_default, [["render", _sfc_render50], ["__file", "circle-close-filled.vue"]]);
      var circle_close_vue_vue_type_script_lang_default = {
        name: "CircleClose"
      };
      var _hoisted_151 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_251 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_350 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_416 = [
        _hoisted_251,
        _hoisted_350
      ];
      function _sfc_render51(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_151, _hoisted_416);
      }
      var circle_close_default = /* @__PURE__ */ export_helper_default(circle_close_vue_vue_type_script_lang_default, [["render", _sfc_render51], ["__file", "circle-close.vue"]]);
      var close_vue_vue_type_script_lang_default = {
        name: "Close"
      };
      var _hoisted_156 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_256 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_355 = [
        _hoisted_256
      ];
      function _sfc_render56(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_156, _hoisted_355);
      }
      var close_default = /* @__PURE__ */ export_helper_default(close_vue_vue_type_script_lang_default, [["render", _sfc_render56], ["__file", "close.vue"]]);
      var hide_vue_vue_type_script_lang_default = {
        name: "Hide"
      };
      var _hoisted_1133 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2133 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3132 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_438 = [
        _hoisted_2133,
        _hoisted_3132
      ];
      function _sfc_render133(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1133, _hoisted_438);
      }
      var hide_default = /* @__PURE__ */ export_helper_default(hide_vue_vue_type_script_lang_default, [["render", _sfc_render133], ["__file", "hide.vue"]]);
      var info_filled_vue_vue_type_script_lang_default = {
        name: "InfoFilled"
      };
      var _hoisted_1143 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2143 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3142 = [
        _hoisted_2143
      ];
      function _sfc_render143(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1143, _hoisted_3142);
      }
      var info_filled_default = /* @__PURE__ */ export_helper_default(info_filled_vue_vue_type_script_lang_default, [["render", _sfc_render143], ["__file", "info-filled.vue"]]);
      var loading_vue_vue_type_script_lang_default = {
        name: "Loading"
      };
      var _hoisted_1150 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2150 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3149 = [
        _hoisted_2150
      ];
      function _sfc_render150(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1150, _hoisted_3149);
      }
      var loading_default = /* @__PURE__ */ export_helper_default(loading_vue_vue_type_script_lang_default, [["render", _sfc_render150], ["__file", "loading.vue"]]);
      var minus_vue_vue_type_script_lang_default = {
        name: "Minus"
      };
      var _hoisted_1169 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2169 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3168 = [
        _hoisted_2169
      ];
      function _sfc_render169(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1169, _hoisted_3168);
      }
      var minus_default = /* @__PURE__ */ export_helper_default(minus_vue_vue_type_script_lang_default, [["render", _sfc_render169], ["__file", "minus.vue"]]);
      var plus_vue_vue_type_script_lang_default = {
        name: "Plus"
      };
      var _hoisted_1201 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2201 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64h352z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3200 = [
        _hoisted_2201
      ];
      function _sfc_render201(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1201, _hoisted_3200);
      }
      var plus_default = /* @__PURE__ */ export_helper_default(plus_vue_vue_type_script_lang_default, [["render", _sfc_render201], ["__file", "plus.vue"]]);
      var success_filled_vue_vue_type_script_lang_default = {
        name: "SuccessFilled"
      };
      var _hoisted_1249 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2249 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3248 = [
        _hoisted_2249
      ];
      function _sfc_render249(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1249, _hoisted_3248);
      }
      var success_filled_default = /* @__PURE__ */ export_helper_default(success_filled_vue_vue_type_script_lang_default, [["render", _sfc_render249], ["__file", "success-filled.vue"]]);
      var view_vue_vue_type_script_lang_default = {
        name: "View"
      };
      var _hoisted_1283 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2283 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3282 = [
        _hoisted_2283
      ];
      function _sfc_render283(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1283, _hoisted_3282);
      }
      var view_default = /* @__PURE__ */ export_helper_default(view_vue_vue_type_script_lang_default, [["render", _sfc_render283], ["__file", "view.vue"]]);
      var warning_filled_vue_vue_type_script_lang_default = {
        name: "WarningFilled"
      };
      var _hoisted_1287 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, _hoisted_2287 = /* @__PURE__ */ createBaseVNode(
        "path",
        {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"
        },
        null,
        -1
        /* HOISTED */
      ), _hoisted_3286 = [
        _hoisted_2287
      ];
      function _sfc_render287(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("svg", _hoisted_1287, _hoisted_3286);
      }
      var warning_filled_default = /* @__PURE__ */ export_helper_default(warning_filled_vue_vue_type_script_lang_default, [["render", _sfc_render287], ["__file", "warning-filled.vue"]]);
      const epPropKey = "__epPropKey";
      const definePropType = (val) => val;
      const isEpProp = (val) => isObject$1(val) && !!val[epPropKey];
      const buildProp = (prop, key) => {
        if (!isObject$1(prop) || isEpProp(prop))
          return prop;
        const { values, required: required2, default: defaultValue, type: type2, validator } = prop;
        const _validator = values || validator ? (val) => {
          let valid = false;
          let allowedValues = [];
          if (values) {
            allowedValues = Array.from(values);
            if (hasOwn(prop, "default")) {
              allowedValues.push(defaultValue);
            }
            valid || (valid = allowedValues.includes(val));
          }
          if (validator)
            valid || (valid = validator(val));
          if (!valid && allowedValues.length > 0) {
            const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
            warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
          }
          return valid;
        } : void 0;
        const epProp = {
          type: type2,
          required: !!required2,
          validator: _validator,
          [epPropKey]: true
        };
        if (hasOwn(prop, "default"))
          epProp.default = defaultValue;
        return epProp;
      };
      const buildProps = (props) => fromPairs(Object.entries(props).map(([key, option]) => [
        key,
        buildProp(option, key)
      ]));
      const iconPropType = definePropType([
        String,
        Object,
        Function
      ]);
      const CloseComponents = {
        Close: close_default
      };
      const TypeComponents = {
        Close: close_default,
        SuccessFilled: success_filled_default,
        InfoFilled: info_filled_default,
        WarningFilled: warning_filled_default,
        CircleCloseFilled: circle_close_filled_default
      };
      const TypeComponentsMap = {
        success: success_filled_default,
        warning: warning_filled_default,
        error: circle_close_filled_default,
        info: info_filled_default
      };
      const ValidateComponentsMap = {
        validating: loading_default,
        success: circle_check_default,
        error: circle_close_default
      };
      const withInstall = (main, extra) => {
        main.install = (app2) => {
          for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
            app2.component(comp.name, comp);
          }
        };
        if (extra) {
          for (const [key, comp] of Object.entries(extra)) {
            main[key] = comp;
          }
        }
        return main;
      };
      const withInstallFunction = (fn2, name) => {
        fn2.install = (app2) => {
          fn2._context = app2._context;
          app2.config.globalProperties[name] = fn2;
        };
        return fn2;
      };
      const withInstallDirective = (directive, name) => {
        directive.install = (app2) => {
          app2.directive(name, directive);
        };
        return directive;
      };
      const withNoopInstall = (component) => {
        component.install = NOOP;
        return component;
      };
      const composeRefs = (...refs) => {
        return (el) => {
          refs.forEach((ref2) => {
            if (isFunction$1(ref2)) {
              ref2(el);
            } else {
              ref2.value = el;
            }
          });
        };
      };
      const EVENT_CODE = {
        tab: "Tab",
        enter: "Enter",
        space: "Space",
        left: "ArrowLeft",
        up: "ArrowUp",
        right: "ArrowRight",
        down: "ArrowDown",
        esc: "Escape",
        delete: "Delete",
        backspace: "Backspace",
        numpadEnter: "NumpadEnter",
        pageUp: "PageUp",
        pageDown: "PageDown",
        home: "Home",
        end: "End"
      };
      const UPDATE_MODEL_EVENT = "update:modelValue";
      const CHANGE_EVENT = "change";
      const INPUT_EVENT = "input";
      const componentSizes = ["", "default", "small", "large"];
      const componentSizeMap = {
        large: 40,
        default: 32,
        small: 24
      };
      const getComponentSize = (size2) => {
        return componentSizeMap[size2 || "default"];
      };
      const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
      var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
        PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
        PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
        PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
        PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
        PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
        PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
        PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
        PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
        PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
        PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
        PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
        return PatchFlags2;
      })(PatchFlags || {});
      const flattedChildren = (children) => {
        const vNodes = isArray$2(children) ? children : [children];
        const result = [];
        vNodes.forEach((child) => {
          var _a2;
          if (isArray$2(child)) {
            result.push(...flattedChildren(child));
          } else if (isVNode(child) && isArray$2(child.children)) {
            result.push(...flattedChildren(child.children));
          } else {
            result.push(child);
            if (isVNode(child) && ((_a2 = child.component) == null ? void 0 : _a2.subTree)) {
              result.push(...flattedChildren(child.component.subTree));
            }
          }
        });
        return result;
      };
      const isKorean = (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text);
      const rAF = (fn2) => isClient$1 ? window.requestAnimationFrame(fn2) : setTimeout(fn2, 16);
      const cAF = (handle) => isClient$1 ? window.cancelAnimationFrame(handle) : clearTimeout(handle);
      const mutable = (val) => val;
      const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
      const LISTENER_PREFIX = /^on[A-Z]/;
      const useAttrs = (params = {}) => {
        const { excludeListeners = false, excludeKeys } = params;
        const allExcludeKeys = computed(() => {
          return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
        });
        const instance = getCurrentInstance();
        if (!instance) {
          return computed(() => ({}));
        }
        return computed(() => {
          var _a2;
          return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
        });
      };
      const useDeprecated = ({ from, replacement, scope, version: version2, ref: ref2, type: type2 = "API" }, condition) => {
        watch(() => unref(condition), (val) => {
        }, {
          immediate: true
        });
      };
      const useDraggable = (targetRef, dragRef, draggable) => {
        let transform = {
          offsetX: 0,
          offsetY: 0
        };
        const onMousedown = (e) => {
          const downX = e.clientX;
          const downY = e.clientY;
          const { offsetX, offsetY } = transform;
          const targetRect = targetRef.value.getBoundingClientRect();
          const targetLeft = targetRect.left;
          const targetTop = targetRect.top;
          const targetWidth = targetRect.width;
          const targetHeight = targetRect.height;
          const clientWidth = document.documentElement.clientWidth;
          const clientHeight = document.documentElement.clientHeight;
          const minLeft = -targetLeft + offsetX;
          const minTop = -targetTop + offsetY;
          const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
          const maxTop = clientHeight - targetTop - targetHeight + offsetY;
          const onMousemove = (e2) => {
            const moveX = Math.min(Math.max(offsetX + e2.clientX - downX, minLeft), maxLeft);
            const moveY = Math.min(Math.max(offsetY + e2.clientY - downY, minTop), maxTop);
            transform = {
              offsetX: moveX,
              offsetY: moveY
            };
            targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
          };
          const onMouseup = () => {
            document.removeEventListener("mousemove", onMousemove);
            document.removeEventListener("mouseup", onMouseup);
          };
          document.addEventListener("mousemove", onMousemove);
          document.addEventListener("mouseup", onMouseup);
        };
        const onDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.addEventListener("mousedown", onMousedown);
          }
        };
        const offDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.removeEventListener("mousedown", onMousedown);
          }
        };
        onMounted(() => {
          watchEffect(() => {
            if (draggable.value) {
              onDraggable();
            } else {
              offDraggable();
            }
          });
        });
        onBeforeUnmount(() => {
          offDraggable();
        });
      };
      const useFocus = (el) => {
        return {
          focus: () => {
            var _a2, _b;
            (_b = (_a2 = el.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          }
        };
      };
      var English = {
        name: "en",
        el: {
          colorpicker: {
            confirm: "OK",
            clear: "Clear",
            defaultLabel: "color picker",
            description: "current color is {color}. press enter to select a new color."
          },
          datepicker: {
            now: "Now",
            today: "Today",
            cancel: "Cancel",
            clear: "Clear",
            confirm: "OK",
            dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
            monthTablePrompt: "Use the arrow keys and enter to select the month",
            yearTablePrompt: "Use the arrow keys and enter to select the year",
            selectedDate: "Selected date",
            selectDate: "Select date",
            selectTime: "Select time",
            startDate: "Start Date",
            startTime: "Start Time",
            endDate: "End Date",
            endTime: "End Time",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            year: "",
            month1: "January",
            month2: "February",
            month3: "March",
            month4: "April",
            month5: "May",
            month6: "June",
            month7: "July",
            month8: "August",
            month9: "September",
            month10: "October",
            month11: "November",
            month12: "December",
            week: "week",
            weeks: {
              sun: "Sun",
              mon: "Mon",
              tue: "Tue",
              wed: "Wed",
              thu: "Thu",
              fri: "Fri",
              sat: "Sat"
            },
            weeksFull: {
              sun: "Sunday",
              mon: "Monday",
              tue: "Tuesday",
              wed: "Wednesday",
              thu: "Thursday",
              fri: "Friday",
              sat: "Saturday"
            },
            months: {
              jan: "Jan",
              feb: "Feb",
              mar: "Mar",
              apr: "Apr",
              may: "May",
              jun: "Jun",
              jul: "Jul",
              aug: "Aug",
              sep: "Sep",
              oct: "Oct",
              nov: "Nov",
              dec: "Dec"
            }
          },
          inputNumber: {
            decrease: "decrease number",
            increase: "increase number"
          },
          select: {
            loading: "Loading",
            noMatch: "No matching data",
            noData: "No data",
            placeholder: "Select"
          },
          dropdown: {
            toggleDropdown: "Toggle Dropdown"
          },
          cascader: {
            noMatch: "No matching data",
            loading: "Loading",
            placeholder: "Select",
            noData: "No data"
          },
          pagination: {
            goto: "Go to",
            pagesize: "/page",
            total: "Total {total}",
            pageClassifier: "",
            page: "Page",
            prev: "Go to previous page",
            next: "Go to next page",
            currentPage: "page {pager}",
            prevPages: "Previous {pager} pages",
            nextPages: "Next {pager} pages",
            deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
          },
          dialog: {
            close: "Close this dialog"
          },
          drawer: {
            close: "Close this dialog"
          },
          messagebox: {
            title: "Message",
            confirm: "OK",
            cancel: "Cancel",
            error: "Illegal input",
            close: "Close this dialog"
          },
          upload: {
            deleteTip: "press delete to remove",
            delete: "Delete",
            preview: "Preview",
            continue: "Continue"
          },
          slider: {
            defaultLabel: "slider between {min} and {max}",
            defaultRangeStartLabel: "pick start value",
            defaultRangeEndLabel: "pick end value"
          },
          table: {
            emptyText: "No Data",
            confirmFilter: "Confirm",
            resetFilter: "Reset",
            clearFilter: "All",
            sumText: "Sum"
          },
          tree: {
            emptyText: "No Data"
          },
          transfer: {
            noMatch: "No matching data",
            noData: "No data",
            titles: ["List 1", "List 2"],
            filterPlaceholder: "Enter keyword",
            noCheckedFormat: "{total} items",
            hasCheckedFormat: "{checked}/{total} checked"
          },
          image: {
            error: "FAILED"
          },
          pageHeader: {
            title: "Back"
          },
          popconfirm: {
            confirmButtonText: "Yes",
            cancelButtonText: "No"
          }
        }
      };
      const buildTranslator = (locale) => (path, option) => translate(path, option, unref(locale));
      const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_, key) => {
        var _a2;
        return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
      });
      const buildLocaleContext = (locale) => {
        const lang = computed(() => unref(locale).name);
        const localeRef = isRef(locale) ? locale : ref(locale);
        return {
          lang,
          locale: localeRef,
          t: buildTranslator(locale)
        };
      };
      const localeContextKey = Symbol("localeContextKey");
      const useLocale = (localeOverrides) => {
        const locale = localeOverrides || inject(localeContextKey, ref());
        return buildLocaleContext(computed(() => locale.value || English));
      };
      const defaultNamespace = "el";
      const statePrefix = "is-";
      const _bem = (namespace, block, blockSuffix, element, modifier) => {
        let cls = `${namespace}-${block}`;
        if (blockSuffix) {
          cls += `-${blockSuffix}`;
        }
        if (element) {
          cls += `__${element}`;
        }
        if (modifier) {
          cls += `--${modifier}`;
        }
        return cls;
      };
      const namespaceContextKey = Symbol("namespaceContextKey");
      const useGetDerivedNamespace = (namespaceOverrides) => {
        const derivedNamespace = namespaceOverrides || inject(namespaceContextKey, ref(defaultNamespace));
        const namespace = computed(() => {
          return unref(derivedNamespace) || defaultNamespace;
        });
        return namespace;
      };
      const useNamespace = (block, namespaceOverrides) => {
        const namespace = useGetDerivedNamespace(namespaceOverrides);
        const b = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
        const e = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
        const m = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
        const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
        const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
        const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
        const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
        const is = (name, ...args) => {
          const state = args.length >= 1 ? args[0] : true;
          return name && state ? `${statePrefix}${name}` : "";
        };
        const cssVar = (object2) => {
          const styles = {};
          for (const key in object2) {
            if (object2[key]) {
              styles[`--${namespace.value}-${key}`] = object2[key];
            }
          }
          return styles;
        };
        const cssVarBlock = (object2) => {
          const styles = {};
          for (const key in object2) {
            if (object2[key]) {
              styles[`--${namespace.value}-${block}-${key}`] = object2[key];
            }
          }
          return styles;
        };
        const cssVarName = (name) => `--${namespace.value}-${name}`;
        const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
        return {
          namespace,
          b,
          e,
          m,
          be: be2,
          em,
          bm,
          bem,
          is,
          cssVar,
          cssVarName,
          cssVarBlock,
          cssVarBlockName
        };
      };
      const useLockscreen = (trigger2, options = {}) => {
        if (!isRef(trigger2)) {
          throwError("[useLockscreen]", "You need to pass a ref param to this function");
        }
        const ns = options.ns || useNamespace("popup");
        const hiddenCls = computed$1(() => ns.bm("parent", "hidden"));
        if (!isClient$1 || hasClass(document.body, hiddenCls.value)) {
          return;
        }
        let scrollBarWidth2 = 0;
        let withoutHiddenClass = false;
        let bodyWidth = "0";
        const cleanup = () => {
          setTimeout(() => {
            removeClass(document == null ? void 0 : document.body, hiddenCls.value);
            if (withoutHiddenClass && document) {
              document.body.style.width = bodyWidth;
            }
          }, 200);
        };
        watch(trigger2, (val) => {
          if (!val) {
            cleanup();
            return;
          }
          withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
          if (withoutHiddenClass) {
            bodyWidth = document.body.style.width;
          }
          scrollBarWidth2 = getScrollBarWidth(ns.namespace.value);
          const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          const bodyOverflowY = getStyle(document.body, "overflowY");
          if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
            document.body.style.width = `calc(100% - ${scrollBarWidth2}px)`;
          }
          addClass(document.body, hiddenCls.value);
        });
        onScopeDispose(() => cleanup());
      };
      const _prop = buildProp({
        type: definePropType(Boolean),
        default: null
      });
      const _event = buildProp({
        type: definePropType(Function)
      });
      const createModelToggleComposable = (name) => {
        const updateEventKey = `update:${name}`;
        const updateEventKeyRaw2 = `onUpdate:${name}`;
        const useModelToggleEmits2 = [updateEventKey];
        const useModelToggleProps2 = {
          [name]: _prop,
          [updateEventKeyRaw2]: _event
        };
        const useModelToggle2 = ({
          indicator,
          toggleReason,
          shouldHideWhenRouteChanges,
          shouldProceed,
          onShow,
          onHide
        }) => {
          const instance = getCurrentInstance();
          const { emit: emit2 } = instance;
          const props = instance.props;
          const hasUpdateHandler = computed(() => isFunction$1(props[updateEventKeyRaw2]));
          const isModelBindingAbsent = computed(() => props[name] === null);
          const doShow = (event) => {
            if (indicator.value === true) {
              return;
            }
            indicator.value = true;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$1(onShow)) {
              onShow(event);
            }
          };
          const doHide = (event) => {
            if (indicator.value === false) {
              return;
            }
            indicator.value = false;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$1(onHide)) {
              onHide(event);
            }
          };
          const show = (event) => {
            if (props.disabled === true || isFunction$1(shouldProceed) && !shouldProceed())
              return;
            const shouldEmit = hasUpdateHandler.value && isClient$1;
            if (shouldEmit) {
              emit2(updateEventKey, true);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doShow(event);
            }
          };
          const hide = (event) => {
            if (props.disabled === true || !isClient$1)
              return;
            const shouldEmit = hasUpdateHandler.value && isClient$1;
            if (shouldEmit) {
              emit2(updateEventKey, false);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doHide(event);
            }
          };
          const onChange = (val) => {
            if (!isBoolean(val))
              return;
            if (props.disabled && val) {
              if (hasUpdateHandler.value) {
                emit2(updateEventKey, false);
              }
            } else if (indicator.value !== val) {
              if (val) {
                doShow();
              } else {
                doHide();
              }
            }
          };
          const toggle = () => {
            if (indicator.value) {
              hide();
            } else {
              show();
            }
          };
          watch(() => props[name], onChange);
          if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
            watch(() => ({
              ...instance.proxy.$route
            }), () => {
              if (shouldHideWhenRouteChanges.value && indicator.value) {
                hide();
              }
            });
          }
          onMounted(() => {
            onChange(props[name]);
          });
          return {
            hide,
            show,
            toggle,
            hasUpdateHandler
          };
        };
        return {
          useModelToggle: useModelToggle2,
          useModelToggleProps: useModelToggleProps2,
          useModelToggleEmits: useModelToggleEmits2
        };
      };
      const useProp = (name) => {
        const vm = getCurrentInstance();
        return computed(() => {
          var _a2, _b;
          return (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$props) == null ? void 0 : _b[name];
        });
      };
      var E = "top", R = "bottom", W = "right", P = "left", me = "auto", G = [E, R, W, P], U = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t, e) {
        return t.concat([e + "-" + U, e + "-" + J]);
      }, []), Ee = [].concat(G, [me]).reduce(function(t, e) {
        return t.concat([e, e + "-" + U, e + "-" + J]);
      }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
      function C(t) {
        return t ? (t.nodeName || "").toLowerCase() : null;
      }
      function H(t) {
        if (t == null)
          return window;
        if (t.toString() !== "[object Window]") {
          var e = t.ownerDocument;
          return e && e.defaultView || window;
        }
        return t;
      }
      function Q(t) {
        var e = H(t).Element;
        return t instanceof e || t instanceof Element;
      }
      function B(t) {
        var e = H(t).HTMLElement;
        return t instanceof e || t instanceof HTMLElement;
      }
      function Pe(t) {
        if (typeof ShadowRoot == "undefined")
          return false;
        var e = H(t).ShadowRoot;
        return t instanceof e || t instanceof ShadowRoot;
      }
      function Mt(t) {
        var e = t.state;
        Object.keys(e.elements).forEach(function(n) {
          var r = e.styles[n] || {}, o = e.attributes[n] || {}, i = e.elements[n];
          !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o).forEach(function(a) {
            var s = o[a];
            s === false ? i.removeAttribute(a) : i.setAttribute(a, s === true ? "" : s);
          }));
        });
      }
      function Rt(t) {
        var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
        return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
          Object.keys(e.elements).forEach(function(r) {
            var o = e.elements[r], i = e.attributes[r] || {}, a = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), s = a.reduce(function(f, c) {
              return f[c] = "", f;
            }, {});
            !B(o) || !C(o) || (Object.assign(o.style, s), Object.keys(i).forEach(function(f) {
              o.removeAttribute(f);
            }));
          });
        };
      }
      var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
      function q(t) {
        return t.split("-")[0];
      }
      var X = Math.max, ve = Math.min, Z = Math.round;
      function ee(t, e) {
        e === void 0 && (e = false);
        var n = t.getBoundingClientRect(), r = 1, o = 1;
        if (B(t) && e) {
          var i = t.offsetHeight, a = t.offsetWidth;
          a > 0 && (r = Z(n.width) / a || 1), i > 0 && (o = Z(n.height) / i || 1);
        }
        return { width: n.width / r, height: n.height / o, top: n.top / o, right: n.right / r, bottom: n.bottom / o, left: n.left / r, x: n.left / r, y: n.top / o };
      }
      function ke(t) {
        var e = ee(t), n = t.offsetWidth, r = t.offsetHeight;
        return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
      }
      function it(t, e) {
        var n = e.getRootNode && e.getRootNode();
        if (t.contains(e))
          return true;
        if (n && Pe(n)) {
          var r = e;
          do {
            if (r && t.isSameNode(r))
              return true;
            r = r.parentNode || r.host;
          } while (r);
        }
        return false;
      }
      function N(t) {
        return H(t).getComputedStyle(t);
      }
      function Wt(t) {
        return ["table", "td", "th"].indexOf(C(t)) >= 0;
      }
      function I(t) {
        return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
      }
      function ge(t) {
        return C(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I(t);
      }
      function at(t) {
        return !B(t) || N(t).position === "fixed" ? null : t.offsetParent;
      }
      function Bt(t) {
        var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
        if (n && B(t)) {
          var r = N(t);
          if (r.position === "fixed")
            return null;
        }
        var o = ge(t);
        for (Pe(o) && (o = o.host); B(o) && ["html", "body"].indexOf(C(o)) < 0; ) {
          var i = N(o);
          if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none")
            return o;
          o = o.parentNode;
        }
        return null;
      }
      function se(t) {
        for (var e = H(t), n = at(t); n && Wt(n) && N(n).position === "static"; )
          n = at(n);
        return n && (C(n) === "html" || C(n) === "body" && N(n).position === "static") ? e : n || Bt(t) || e;
      }
      function Le(t) {
        return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
      }
      function fe(t, e, n) {
        return X(t, ve(e, n));
      }
      function St(t, e, n) {
        var r = fe(t, e, n);
        return r > n ? n : r;
      }
      function st() {
        return { top: 0, right: 0, bottom: 0, left: 0 };
      }
      function ft(t) {
        return Object.assign({}, st(), t);
      }
      function ct(t, e) {
        return e.reduce(function(n, r) {
          return n[r] = t, n;
        }, {});
      }
      var Tt = function(t, e) {
        return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, ft(typeof t != "number" ? t : ct(t, G));
      };
      function Ht(t) {
        var e, n = t.state, r = t.name, o = t.options, i = n.elements.arrow, a = n.modifiersData.popperOffsets, s = q(n.placement), f = Le(s), c = [P, W].indexOf(s) >= 0, u = c ? "height" : "width";
        if (!(!i || !a)) {
          var m = Tt(o.padding, n), v = ke(i), l = f === "y" ? E : P, h2 = f === "y" ? R : W, p2 = n.rects.reference[u] + n.rects.reference[f] - a[f] - n.rects.popper[u], g = a[f] - n.rects.reference[f], x = se(i), y = x ? f === "y" ? x.clientHeight || 0 : x.clientWidth || 0 : 0, $ = p2 / 2 - g / 2, d = m[l], b = y - v[u] - m[h2], w = y / 2 - v[u] / 2 + $, O = fe(d, w, b), j = f;
          n.modifiersData[r] = (e = {}, e[j] = O, e.centerOffset = O - w, e);
        }
      }
      function Ct(t) {
        var e = t.state, n = t.options, r = n.element, o = r === void 0 ? "[data-popper-arrow]" : r;
        o != null && (typeof o == "string" && (o = e.elements.popper.querySelector(o), !o) || !it(e.elements.popper, o) || (e.elements.arrow = o));
      }
      var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
      function te(t) {
        return t.split("-")[1];
      }
      var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
      function Vt(t) {
        var e = t.x, n = t.y, r = window, o = r.devicePixelRatio || 1;
        return { x: Z(e * o) / o || 0, y: Z(n * o) / o || 0 };
      }
      function ut(t) {
        var e, n = t.popper, r = t.popperRect, o = t.placement, i = t.variation, a = t.offsets, s = t.position, f = t.gpuAcceleration, c = t.adaptive, u = t.roundOffsets, m = t.isFixed, v = a.x, l = v === void 0 ? 0 : v, h2 = a.y, p2 = h2 === void 0 ? 0 : h2, g = typeof u == "function" ? u({ x: l, y: p2 }) : { x: l, y: p2 };
        l = g.x, p2 = g.y;
        var x = a.hasOwnProperty("x"), y = a.hasOwnProperty("y"), $ = P, d = E, b = window;
        if (c) {
          var w = se(n), O = "clientHeight", j = "clientWidth";
          if (w === H(n) && (w = I(n), N(w).position !== "static" && s === "absolute" && (O = "scrollHeight", j = "scrollWidth")), w = w, o === E || (o === P || o === W) && i === J) {
            d = R;
            var A = m && w === b && b.visualViewport ? b.visualViewport.height : w[O];
            p2 -= A - r.height, p2 *= f ? 1 : -1;
          }
          if (o === P || (o === E || o === R) && i === J) {
            $ = W;
            var k = m && w === b && b.visualViewport ? b.visualViewport.width : w[j];
            l -= k - r.width, l *= f ? 1 : -1;
          }
        }
        var D = Object.assign({ position: s }, c && qt), S = u === true ? Vt({ x: l, y: p2 }) : { x: l, y: p2 };
        if (l = S.x, p2 = S.y, f) {
          var L;
          return Object.assign({}, D, (L = {}, L[d] = y ? "0" : "", L[$] = x ? "0" : "", L.transform = (b.devicePixelRatio || 1) <= 1 ? "translate(" + l + "px, " + p2 + "px)" : "translate3d(" + l + "px, " + p2 + "px, 0)", L));
        }
        return Object.assign({}, D, (e = {}, e[d] = y ? p2 + "px" : "", e[$] = x ? l + "px" : "", e.transform = "", e));
      }
      function Nt(t) {
        var e = t.state, n = t.options, r = n.gpuAcceleration, o = r === void 0 ? true : r, i = n.adaptive, a = i === void 0 ? true : i, s = n.roundOffsets, f = s === void 0 ? true : s, c = { placement: q(e.placement), variation: te(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o, isFixed: e.options.strategy === "fixed" };
        e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a, roundOffsets: f })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
      }
      var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
      function It(t) {
        var e = t.state, n = t.instance, r = t.options, o = r.scroll, i = o === void 0 ? true : o, a = r.resize, s = a === void 0 ? true : a, f = H(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
        return i && c.forEach(function(u) {
          u.addEventListener("scroll", n.update, ye);
        }), s && f.addEventListener("resize", n.update, ye), function() {
          i && c.forEach(function(u) {
            u.removeEventListener("scroll", n.update, ye);
          }), s && f.removeEventListener("resize", n.update, ye);
        };
      }
      var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
      }, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
      function be(t) {
        return t.replace(/left|right|bottom|top/g, function(e) {
          return _t[e];
        });
      }
      var zt = { start: "end", end: "start" };
      function lt(t) {
        return t.replace(/start|end/g, function(e) {
          return zt[e];
        });
      }
      function We(t) {
        var e = H(t), n = e.pageXOffset, r = e.pageYOffset;
        return { scrollLeft: n, scrollTop: r };
      }
      function Be(t) {
        return ee(I(t)).left + We(t).scrollLeft;
      }
      function Ft(t) {
        var e = H(t), n = I(t), r = e.visualViewport, o = n.clientWidth, i = n.clientHeight, a = 0, s = 0;
        return r && (o = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = r.offsetLeft, s = r.offsetTop)), { width: o, height: i, x: a + Be(t), y: s };
      }
      function Ut(t) {
        var e, n = I(t), r = We(t), o = (e = t.ownerDocument) == null ? void 0 : e.body, i = X(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), a = X(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), s = -r.scrollLeft + Be(t), f = -r.scrollTop;
        return N(o || n).direction === "rtl" && (s += X(n.clientWidth, o ? o.clientWidth : 0) - i), { width: i, height: a, x: s, y: f };
      }
      function Se(t) {
        var e = N(t), n = e.overflow, r = e.overflowX, o = e.overflowY;
        return /auto|scroll|overlay|hidden/.test(n + o + r);
      }
      function dt(t) {
        return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : B(t) && Se(t) ? t : dt(ge(t));
      }
      function ce(t, e) {
        var n;
        e === void 0 && (e = []);
        var r = dt(t), o = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i = H(r), a = o ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r, s = e.concat(a);
        return o ? s : s.concat(ce(ge(a)));
      }
      function Te(t) {
        return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
      }
      function Xt(t) {
        var e = ee(t);
        return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
      }
      function ht(t, e) {
        return e === je ? Te(Ft(t)) : Q(e) ? Xt(e) : Te(Ut(I(t)));
      }
      function Yt(t) {
        var e = ce(ge(t)), n = ["absolute", "fixed"].indexOf(N(t).position) >= 0, r = n && B(t) ? se(t) : t;
        return Q(r) ? e.filter(function(o) {
          return Q(o) && it(o, r) && C(o) !== "body";
        }) : [];
      }
      function Gt(t, e, n) {
        var r = e === "clippingParents" ? Yt(t) : [].concat(e), o = [].concat(r, [n]), i = o[0], a = o.reduce(function(s, f) {
          var c = ht(t, f);
          return s.top = X(c.top, s.top), s.right = ve(c.right, s.right), s.bottom = ve(c.bottom, s.bottom), s.left = X(c.left, s.left), s;
        }, ht(t, i));
        return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
      }
      function mt(t) {
        var e = t.reference, n = t.element, r = t.placement, o = r ? q(r) : null, i = r ? te(r) : null, a = e.x + e.width / 2 - n.width / 2, s = e.y + e.height / 2 - n.height / 2, f;
        switch (o) {
          case E:
            f = { x: a, y: e.y - n.height };
            break;
          case R:
            f = { x: a, y: e.y + e.height };
            break;
          case W:
            f = { x: e.x + e.width, y: s };
            break;
          case P:
            f = { x: e.x - n.width, y: s };
            break;
          default:
            f = { x: e.x, y: e.y };
        }
        var c = o ? Le(o) : null;
        if (c != null) {
          var u = c === "y" ? "height" : "width";
          switch (i) {
            case U:
              f[c] = f[c] - (e[u] / 2 - n[u] / 2);
              break;
            case J:
              f[c] = f[c] + (e[u] / 2 - n[u] / 2);
              break;
          }
        }
        return f;
      }
      function ne(t, e) {
        e === void 0 && (e = {});
        var n = e, r = n.placement, o = r === void 0 ? t.placement : r, i = n.boundary, a = i === void 0 ? Xe : i, s = n.rootBoundary, f = s === void 0 ? je : s, c = n.elementContext, u = c === void 0 ? K : c, m = n.altBoundary, v = m === void 0 ? false : m, l = n.padding, h2 = l === void 0 ? 0 : l, p2 = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u === K ? Ye : K, x = t.rects.popper, y = t.elements[v ? g : u], $ = Gt(Q(y) ? y : y.contextElement || I(t.elements.popper), a, f), d = ee(t.elements.reference), b = mt({ reference: d, element: x, strategy: "absolute", placement: o }), w = Te(Object.assign({}, x, b)), O = u === K ? w : d, j = { top: $.top - O.top + p2.top, bottom: O.bottom - $.bottom + p2.bottom, left: $.left - O.left + p2.left, right: O.right - $.right + p2.right }, A = t.modifiersData.offset;
        if (u === K && A) {
          var k = A[o];
          Object.keys(j).forEach(function(D) {
            var S = [W, R].indexOf(D) >= 0 ? 1 : -1, L = [E, R].indexOf(D) >= 0 ? "y" : "x";
            j[D] += k[L] * S;
          });
        }
        return j;
      }
      function Jt(t, e) {
        e === void 0 && (e = {});
        var n = e, r = n.placement, o = n.boundary, i = n.rootBoundary, a = n.padding, s = n.flipVariations, f = n.allowedAutoPlacements, c = f === void 0 ? Ee : f, u = te(r), m = u ? s ? De : De.filter(function(h2) {
          return te(h2) === u;
        }) : G, v = m.filter(function(h2) {
          return c.indexOf(h2) >= 0;
        });
        v.length === 0 && (v = m);
        var l = v.reduce(function(h2, p2) {
          return h2[p2] = ne(t, { placement: p2, boundary: o, rootBoundary: i, padding: a })[q(p2)], h2;
        }, {});
        return Object.keys(l).sort(function(h2, p2) {
          return l[h2] - l[p2];
        });
      }
      function Kt(t) {
        if (q(t) === me)
          return [];
        var e = be(t);
        return [lt(t), e, lt(e)];
      }
      function Qt(t) {
        var e = t.state, n = t.options, r = t.name;
        if (!e.modifiersData[r]._skip) {
          for (var o = n.mainAxis, i = o === void 0 ? true : o, a = n.altAxis, s = a === void 0 ? true : a, f = n.fallbackPlacements, c = n.padding, u = n.boundary, m = n.rootBoundary, v = n.altBoundary, l = n.flipVariations, h2 = l === void 0 ? true : l, p2 = n.allowedAutoPlacements, g = e.options.placement, x = q(g), y = x === g, $ = f || (y || !h2 ? [be(g)] : Kt(g)), d = [g].concat($).reduce(function(z, V) {
            return z.concat(q(V) === me ? Jt(e, { placement: V, boundary: u, rootBoundary: m, padding: c, flipVariations: h2, allowedAutoPlacements: p2 }) : V);
          }, []), b = e.rects.reference, w = e.rects.popper, O = /* @__PURE__ */ new Map(), j = true, A = d[0], k = 0; k < d.length; k++) {
            var D = d[k], S = q(D), L = te(D) === U, re = [E, R].indexOf(S) >= 0, oe = re ? "width" : "height", M = ne(e, { placement: D, boundary: u, rootBoundary: m, altBoundary: v, padding: c }), T = re ? L ? W : P : L ? R : E;
            b[oe] > w[oe] && (T = be(T));
            var pe = be(T), _ = [];
            if (i && _.push(M[S] <= 0), s && _.push(M[T] <= 0, M[pe] <= 0), _.every(function(z) {
              return z;
            })) {
              A = D, j = false;
              break;
            }
            O.set(D, _);
          }
          if (j)
            for (var ue = h2 ? 3 : 1, xe = function(z) {
              var V = d.find(function(de) {
                var ae = O.get(de);
                if (ae)
                  return ae.slice(0, z).every(function(Y) {
                    return Y;
                  });
              });
              if (V)
                return A = V, "break";
            }, ie = ue; ie > 0; ie--) {
              var le = xe(ie);
              if (le === "break")
                break;
            }
          e.placement !== A && (e.modifiersData[r]._skip = true, e.placement = A, e.reset = true);
        }
      }
      var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
      function gt(t, e, n) {
        return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
      }
      function yt(t) {
        return [E, W, R, P].some(function(e) {
          return t[e] >= 0;
        });
      }
      function Zt(t) {
        var e = t.state, n = t.name, r = e.rects.reference, o = e.rects.popper, i = e.modifiersData.preventOverflow, a = ne(e, { elementContext: "reference" }), s = ne(e, { altBoundary: true }), f = gt(a, r), c = gt(s, o, i), u = yt(f), m = yt(c);
        e.modifiersData[n] = { referenceClippingOffsets: f, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: m }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": m });
      }
      var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
      function en(t, e, n) {
        var r = q(t), o = [P, E].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, a = i[0], s = i[1];
        return a = a || 0, s = (s || 0) * o, [P, W].indexOf(r) >= 0 ? { x: s, y: a } : { x: a, y: s };
      }
      function tn(t) {
        var e = t.state, n = t.options, r = t.name, o = n.offset, i = o === void 0 ? [0, 0] : o, a = Ee.reduce(function(u, m) {
          return u[m] = en(m, e.rects, i), u;
        }, {}), s = a[e.placement], f = s.x, c = s.y;
        e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = a;
      }
      var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
      function nn(t) {
        var e = t.state, n = t.name;
        e.modifiersData[n] = mt({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
      }
      var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
      function rn(t) {
        return t === "x" ? "y" : "x";
      }
      function on(t) {
        var e = t.state, n = t.options, r = t.name, o = n.mainAxis, i = o === void 0 ? true : o, a = n.altAxis, s = a === void 0 ? false : a, f = n.boundary, c = n.rootBoundary, u = n.altBoundary, m = n.padding, v = n.tether, l = v === void 0 ? true : v, h2 = n.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g = ne(e, { boundary: f, rootBoundary: c, padding: m, altBoundary: u }), x = q(e.placement), y = te(e.placement), $ = !y, d = Le(x), b = rn(d), w = e.modifiersData.popperOffsets, O = e.rects.reference, j = e.rects.popper, A = typeof p2 == "function" ? p2(Object.assign({}, e.rects, { placement: e.placement })) : p2, k = typeof A == "number" ? { mainAxis: A, altAxis: A } : Object.assign({ mainAxis: 0, altAxis: 0 }, A), D = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S = { x: 0, y: 0 };
        if (w) {
          if (i) {
            var L, re = d === "y" ? E : P, oe = d === "y" ? R : W, M = d === "y" ? "height" : "width", T = w[d], pe = T + g[re], _ = T - g[oe], ue = l ? -j[M] / 2 : 0, xe = y === U ? O[M] : j[M], ie = y === U ? -j[M] : -O[M], le = e.elements.arrow, z = l && le ? ke(le) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y = fe(0, O[M], z[M]), jt = $ ? O[M] / 2 - ue - Y - de - k.mainAxis : xe - Y - de - k.mainAxis, Dt = $ ? -O[M] / 2 + ue + Y + ae + k.mainAxis : ie + Y + ae + k.mainAxis, Oe = e.elements.arrow && se(e.elements.arrow), Et = Oe ? d === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L = D == null ? void 0 : D[d]) != null ? L : 0, Pt = T + jt - Ce - Et, At = T + Dt - Ce, qe = fe(l ? ve(pe, Pt) : pe, T, l ? X(_, At) : _);
            w[d] = qe, S[d] = qe - T;
          }
          if (s) {
            var Ve, kt = d === "x" ? E : P, Lt = d === "x" ? R : W, F = w[b], he = b === "y" ? "height" : "width", Ne = F + g[kt], Ie = F - g[Lt], $e = [E, P].indexOf(x) !== -1, _e = (Ve = D == null ? void 0 : D[b]) != null ? Ve : 0, ze = $e ? Ne : F - O[he] - j[he] - _e + k.altAxis, Fe = $e ? F + O[he] + j[he] - _e - k.altAxis : Ie, Ue = l && $e ? St(ze, F, Fe) : fe(l ? ze : Ne, F, l ? Fe : Ie);
            w[b] = Ue, S[b] = Ue - F;
          }
          e.modifiersData[r] = S;
        }
      }
      var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
      function an(t) {
        return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
      }
      function sn(t) {
        return t === H(t) || !B(t) ? We(t) : an(t);
      }
      function fn(t) {
        var e = t.getBoundingClientRect(), n = Z(e.width) / t.offsetWidth || 1, r = Z(e.height) / t.offsetHeight || 1;
        return n !== 1 || r !== 1;
      }
      function cn(t, e, n) {
        n === void 0 && (n = false);
        var r = B(e), o = B(e) && fn(e), i = I(e), a = ee(t, o), s = { scrollLeft: 0, scrollTop: 0 }, f = { x: 0, y: 0 };
        return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s = sn(e)), B(e) ? (f = ee(e, true), f.x += e.clientLeft, f.y += e.clientTop) : i && (f.x = Be(i))), { x: a.left + s.scrollLeft - f.x, y: a.top + s.scrollTop - f.y, width: a.width, height: a.height };
      }
      function pn(t) {
        var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
        t.forEach(function(i) {
          e.set(i.name, i);
        });
        function o(i) {
          n.add(i.name);
          var a = [].concat(i.requires || [], i.requiresIfExists || []);
          a.forEach(function(s) {
            if (!n.has(s)) {
              var f = e.get(s);
              f && o(f);
            }
          }), r.push(i);
        }
        return t.forEach(function(i) {
          n.has(i.name) || o(i);
        }), r;
      }
      function un(t) {
        var e = pn(t);
        return ot.reduce(function(n, r) {
          return n.concat(e.filter(function(o) {
            return o.phase === r;
          }));
        }, []);
      }
      function ln(t) {
        var e;
        return function() {
          return e || (e = new Promise(function(n) {
            Promise.resolve().then(function() {
              e = void 0, n(t());
            });
          })), e;
        };
      }
      function dn(t) {
        var e = t.reduce(function(n, r) {
          var o = n[r.name];
          return n[r.name] = o ? Object.assign({}, o, r, { options: Object.assign({}, o.options, r.options), data: Object.assign({}, o.data, r.data) }) : r, n;
        }, {});
        return Object.keys(e).map(function(n) {
          return e[n];
        });
      }
      var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
      function $t() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        return !e.some(function(r) {
          return !(r && typeof r.getBoundingClientRect == "function");
        });
      }
      function we(t) {
        t === void 0 && (t = {});
        var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o = e.defaultOptions, i = o === void 0 ? Ot : o;
        return function(a, s, f) {
          f === void 0 && (f = i);
          var c = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a, popper: s }, attributes: {}, styles: {} }, u = [], m = false, v = { state: c, setOptions: function(p2) {
            var g = typeof p2 == "function" ? p2(c.options) : p2;
            h2(), c.options = Object.assign({}, i, c.options, g), c.scrollParents = { reference: Q(a) ? ce(a) : a.contextElement ? ce(a.contextElement) : [], popper: ce(s) };
            var x = un(dn([].concat(r, c.options.modifiers)));
            return c.orderedModifiers = x.filter(function(y) {
              return y.enabled;
            }), l(), v.update();
          }, forceUpdate: function() {
            if (!m) {
              var p2 = c.elements, g = p2.reference, x = p2.popper;
              if ($t(g, x)) {
                c.rects = { reference: cn(g, se(x), c.options.strategy === "fixed"), popper: ke(x) }, c.reset = false, c.placement = c.options.placement, c.orderedModifiers.forEach(function(j) {
                  return c.modifiersData[j.name] = Object.assign({}, j.data);
                });
                for (var y = 0; y < c.orderedModifiers.length; y++) {
                  if (c.reset === true) {
                    c.reset = false, y = -1;
                    continue;
                  }
                  var $ = c.orderedModifiers[y], d = $.fn, b = $.options, w = b === void 0 ? {} : b, O = $.name;
                  typeof d == "function" && (c = d({ state: c, options: w, name: O, instance: v }) || c);
                }
              }
            }
          }, update: ln(function() {
            return new Promise(function(p2) {
              v.forceUpdate(), p2(c);
            });
          }), destroy: function() {
            h2(), m = true;
          } };
          if (!$t(a, s))
            return v;
          v.setOptions(f).then(function(p2) {
            !m && f.onFirstUpdate && f.onFirstUpdate(p2);
          });
          function l() {
            c.orderedModifiers.forEach(function(p2) {
              var g = p2.name, x = p2.options, y = x === void 0 ? {} : x, $ = p2.effect;
              if (typeof $ == "function") {
                var d = $({ state: c, name: g, instance: v, options: y }), b = function() {
                };
                u.push(d || b);
              }
            });
          }
          function h2() {
            u.forEach(function(p2) {
              return p2();
            }), u = [];
          }
          return v;
        };
      }
      we();
      var mn = [Re, He, Me, Ae];
      we({ defaultModifiers: mn });
      var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
      const usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
        const stateUpdater = {
          name: "updateState",
          enabled: true,
          phase: "write",
          fn: ({ state }) => {
            const derivedState = deriveState(state);
            Object.assign(states.value, derivedState);
          },
          requires: ["computeStyles"]
        };
        const options = computed(() => {
          const { onFirstUpdate, placement, strategy, modifiers } = unref(opts);
          return {
            onFirstUpdate,
            placement: placement || "bottom",
            strategy: strategy || "absolute",
            modifiers: [
              ...modifiers || [],
              stateUpdater,
              { name: "applyStyles", enabled: false }
            ]
          };
        });
        const instanceRef = shallowRef();
        const states = ref({
          styles: {
            popper: {
              position: unref(options).strategy,
              left: "0",
              top: "0"
            },
            arrow: {
              position: "absolute"
            }
          },
          attributes: {}
        });
        const destroy = () => {
          if (!instanceRef.value)
            return;
          instanceRef.value.destroy();
          instanceRef.value = void 0;
        };
        watch(options, (newOptions) => {
          const instance = unref(instanceRef);
          if (instance) {
            instance.setOptions(newOptions);
          }
        }, {
          deep: true
        });
        watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
          destroy();
          if (!referenceElement || !popperElement)
            return;
          instanceRef.value = yn(referenceElement, popperElement, unref(options));
        });
        onBeforeUnmount(() => {
          destroy();
        });
        return {
          state: computed(() => {
            var _a2;
            return { ...((_a2 = unref(instanceRef)) == null ? void 0 : _a2.state) || {} };
          }),
          styles: computed(() => unref(states).styles),
          attributes: computed(() => unref(states).attributes),
          update: () => {
            var _a2;
            return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.update();
          },
          forceUpdate: () => {
            var _a2;
            return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.forceUpdate();
          },
          instanceRef: computed(() => unref(instanceRef))
        };
      };
      function deriveState(state) {
        const elements = Object.keys(state.elements);
        const styles = fromPairs(elements.map((element) => [element, state.styles[element] || {}]));
        const attributes = fromPairs(elements.map((element) => [element, state.attributes[element]]));
        return {
          styles,
          attributes
        };
      }
      const useSameTarget = (handleClick) => {
        if (!handleClick) {
          return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
        }
        let mousedownTarget = false;
        let mouseupTarget = false;
        const onClick = (e) => {
          if (mousedownTarget && mouseupTarget) {
            handleClick(e);
          }
          mousedownTarget = mouseupTarget = false;
        };
        const onMousedown = (e) => {
          mousedownTarget = e.target === e.currentTarget;
        };
        const onMouseup = (e) => {
          mouseupTarget = e.target === e.currentTarget;
        };
        return { onClick, onMousedown, onMouseup };
      };
      function useTimeout() {
        let timeoutHandle;
        const registerTimeout = (fn2, delay) => {
          cancelTimeout();
          timeoutHandle = window.setTimeout(fn2, delay);
        };
        const cancelTimeout = () => window.clearTimeout(timeoutHandle);
        tryOnScopeDispose$1(() => cancelTimeout());
        return {
          registerTimeout,
          cancelTimeout
        };
      }
      const defaultIdInjection = {
        prefix: Math.floor(Math.random() * 1e4),
        current: 0
      };
      const ID_INJECTION_KEY = Symbol("elIdInjection");
      const useIdInjection = () => {
        return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
      };
      const useId = (deterministicId) => {
        const idInjection = useIdInjection();
        const namespace = useGetDerivedNamespace();
        const idRef = computed(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
        return idRef;
      };
      let registeredEscapeHandlers = [];
      const cachedHandler = (e) => {
        const event = e;
        if (event.key === EVENT_CODE.esc) {
          registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
        }
      };
      const useEscapeKeydown = (handler) => {
        onMounted(() => {
          if (registeredEscapeHandlers.length === 0) {
            document.addEventListener("keydown", cachedHandler);
          }
          if (isClient$1)
            registeredEscapeHandlers.push(handler);
        });
        onBeforeUnmount(() => {
          registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
          if (registeredEscapeHandlers.length === 0) {
            if (isClient$1)
              document.removeEventListener("keydown", cachedHandler);
          }
        });
      };
      let cachedContainer;
      const usePopperContainerId = () => {
        const namespace = useGetDerivedNamespace();
        const idInjection = useIdInjection();
        const id2 = computed(() => {
          return `${namespace.value}-popper-container-${idInjection.prefix}`;
        });
        const selector = computed(() => `#${id2.value}`);
        return {
          id: id2,
          selector
        };
      };
      const createContainer = (id2) => {
        const container = document.createElement("div");
        container.id = id2;
        document.body.appendChild(container);
        return container;
      };
      const usePopperContainer = () => {
        const { id: id2, selector } = usePopperContainerId();
        onBeforeMount(() => {
          if (!isClient$1)
            return;
          if (!cachedContainer && !document.body.querySelector(selector.value)) {
            cachedContainer = createContainer(id2.value);
          }
        });
        return {
          id: id2,
          selector
        };
      };
      const useDelayedToggleProps = buildProps({
        showAfter: {
          type: Number,
          default: 0
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        autoClose: {
          type: Number,
          default: 0
        }
      });
      const useDelayedToggle = ({
        showAfter,
        hideAfter,
        autoClose,
        open: open2,
        close: close2
      }) => {
        const { registerTimeout } = useTimeout();
        const {
          registerTimeout: registerTimeoutForAutoClose,
          cancelTimeout: cancelTimeoutForAutoClose
        } = useTimeout();
        const onOpen = (event) => {
          registerTimeout(() => {
            open2(event);
            const _autoClose = unref(autoClose);
            if (isNumber(_autoClose) && _autoClose > 0) {
              registerTimeoutForAutoClose(() => {
                close2(event);
              }, _autoClose);
            }
          }, unref(showAfter));
        };
        const onClose = (event) => {
          cancelTimeoutForAutoClose();
          registerTimeout(() => {
            close2(event);
          }, unref(hideAfter));
        };
        return {
          onOpen,
          onClose
        };
      };
      const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
      const useForwardRef = (forwardRef) => {
        const setForwardRef = (el) => {
          forwardRef.value = el;
        };
        provide(FORWARD_REF_INJECTION_KEY, {
          setForwardRef
        });
      };
      const useForwardRefDirective = (setForwardRef) => {
        return {
          mounted(el) {
            setForwardRef(el);
          },
          updated(el) {
            setForwardRef(el);
          },
          unmounted() {
            setForwardRef(null);
          }
        };
      };
      const zIndex = ref(0);
      const defaultInitialZIndex = 2e3;
      const zIndexContextKey = Symbol("zIndexContextKey");
      const useZIndex = (zIndexOverrides) => {
        const zIndexInjection = zIndexOverrides || inject(zIndexContextKey, void 0);
        const initialZIndex = computed(() => {
          const zIndexFromInjection = unref(zIndexInjection);
          return isNumber(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
        });
        const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
        const nextZIndex = () => {
          zIndex.value++;
          return currentZIndex.value;
        };
        return {
          initialZIndex,
          currentZIndex,
          nextZIndex
        };
      };
      function useCursor(input) {
        const selectionRef = ref();
        function recordCursor() {
          if (input.value == void 0)
            return;
          const { selectionStart, selectionEnd, value } = input.value;
          if (selectionStart == null || selectionEnd == null)
            return;
          const beforeTxt = value.slice(0, Math.max(0, selectionStart));
          const afterTxt = value.slice(Math.max(0, selectionEnd));
          selectionRef.value = {
            selectionStart,
            selectionEnd,
            value,
            beforeTxt,
            afterTxt
          };
        }
        function setCursor() {
          if (input.value == void 0 || selectionRef.value == void 0)
            return;
          const { value } = input.value;
          const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
          if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
            return;
          let startPos = value.length;
          if (value.endsWith(afterTxt)) {
            startPos = value.length - afterTxt.length;
          } else if (value.startsWith(beforeTxt)) {
            startPos = beforeTxt.length;
          } else {
            const beforeLastChar = beforeTxt[selectionStart - 1];
            const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
            if (newIndex !== -1) {
              startPos = newIndex + 1;
            }
          }
          input.value.setSelectionRange(startPos, startPos);
        }
        return [recordCursor, setCursor];
      }
      const getOrderedChildren = (vm, childComponentName, children) => {
        const nodes = flattedChildren(vm.subTree).filter((n) => {
          var _a2;
          return isVNode(n) && ((_a2 = n.type) == null ? void 0 : _a2.name) === childComponentName && !!n.component;
        });
        const uids = nodes.map((n) => n.component.uid);
        return uids.map((uid2) => children[uid2]).filter((p2) => !!p2);
      };
      const useOrderedChildren = (vm, childComponentName) => {
        const children = {};
        const orderedChildren = shallowRef([]);
        const addChild = (child) => {
          children[child.uid] = child;
          orderedChildren.value = getOrderedChildren(vm, childComponentName, children);
        };
        const removeChild = (uid2) => {
          delete children[uid2];
          orderedChildren.value = orderedChildren.value.filter((children2) => children2.uid !== uid2);
        };
        return {
          children: orderedChildren,
          addChild,
          removeChild
        };
      };
      const useSizeProp = buildProp({
        type: String,
        values: componentSizes,
        required: false
      });
      const SIZE_INJECTION_KEY = Symbol("size");
      const useGlobalSize = () => {
        const injectedSize = inject(SIZE_INJECTION_KEY, {});
        return computed(() => {
          return unref(injectedSize.size) || "";
        });
      };
      function useFocusController(target, { afterFocus, afterBlur } = {}) {
        const instance = getCurrentInstance();
        const { emit: emit2 } = instance;
        const wrapperRef = shallowRef();
        const isFocused = ref(false);
        const handleFocus = (event) => {
          if (isFocused.value)
            return;
          isFocused.value = true;
          emit2("focus", event);
          afterFocus == null ? void 0 : afterFocus();
        };
        const handleBlur = (event) => {
          var _a2;
          if (event.relatedTarget && ((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(event.relatedTarget)))
            return;
          isFocused.value = false;
          emit2("blur", event);
          afterBlur == null ? void 0 : afterBlur();
        };
        const handleClick = () => {
          var _a2;
          (_a2 = target.value) == null ? void 0 : _a2.focus();
        };
        watch(wrapperRef, (el) => {
          if (el) {
            el.setAttribute("role", "button");
            el.setAttribute("tabindex", "-1");
          }
        });
        useEventListener$1(wrapperRef, "click", handleClick);
        return {
          wrapperRef,
          isFocused,
          handleFocus,
          handleBlur
        };
      }
      const configProviderContextKey = Symbol();
      const globalConfig = ref();
      function useGlobalConfig(key, defaultValue = void 0) {
        const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
        if (key) {
          return computed(() => {
            var _a2, _b;
            return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
          });
        } else {
          return config;
        }
      }
      function useGlobalComponentSettings(block, sizeFallback) {
        const config = useGlobalConfig();
        const ns = useNamespace(block, computed(() => {
          var _a2;
          return ((_a2 = config.value) == null ? void 0 : _a2.namespace) || defaultNamespace;
        }));
        const locale = useLocale(computed(() => {
          var _a2;
          return (_a2 = config.value) == null ? void 0 : _a2.locale;
        }));
        const zIndex2 = useZIndex(computed(() => {
          var _a2;
          return ((_a2 = config.value) == null ? void 0 : _a2.zIndex) || defaultInitialZIndex;
        }));
        const size2 = computed(() => {
          var _a2;
          return unref(sizeFallback) || ((_a2 = config.value) == null ? void 0 : _a2.size) || "";
        });
        provideGlobalConfig(computed(() => unref(config) || {}));
        return {
          ns,
          locale,
          zIndex: zIndex2,
          size: size2
        };
      }
      const provideGlobalConfig = (config, app2, global2 = false) => {
        var _a2;
        const inSetup = !!getCurrentInstance();
        const oldConfig = inSetup ? useGlobalConfig() : void 0;
        const provideFn = (_a2 = app2 == null ? void 0 : app2.provide) != null ? _a2 : inSetup ? provide : void 0;
        if (!provideFn) {
          return;
        }
        const context = computed(() => {
          const cfg = unref(config);
          if (!(oldConfig == null ? void 0 : oldConfig.value))
            return cfg;
          return mergeConfig(oldConfig.value, cfg);
        });
        provideFn(configProviderContextKey, context);
        provideFn(localeContextKey, computed(() => context.value.locale));
        provideFn(namespaceContextKey, computed(() => context.value.namespace));
        provideFn(zIndexContextKey, computed(() => context.value.zIndex));
        provideFn(SIZE_INJECTION_KEY, {
          size: computed(() => context.value.size || "")
        });
        if (global2 || !globalConfig.value) {
          globalConfig.value = context.value;
        }
        return context;
      };
      const mergeConfig = (a, b) => {
        var _a2;
        const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a), ...keysOf(b)])];
        const obj = {};
        for (const key of keys2) {
          obj[key] = (_a2 = b[key]) != null ? _a2 : a[key];
        }
        return obj;
      };
      const messageConfig = {};
      var _export_sfc$1 = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };
      const iconProps = buildProps({
        size: {
          type: definePropType([Number, String])
        },
        color: {
          type: String
        }
      });
      const __default__$B = defineComponent({
        name: "ElIcon",
        inheritAttrs: false
      });
      const _sfc_main$12 = /* @__PURE__ */ defineComponent({
        ...__default__$B,
        props: iconProps,
        setup(__props) {
          const props = __props;
          const ns = useNamespace("icon");
          const style = computed(() => {
            const { size: size2, color } = props;
            if (!size2 && !color)
              return {};
            return {
              fontSize: isUndefined(size2) ? void 0 : addUnit(size2),
              "--color": color
            };
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("i", mergeProps({
              class: unref(ns).b(),
              style: unref(style)
            }, _ctx.$attrs), [
              renderSlot(_ctx.$slots, "default")
            ], 16);
          };
        }
      });
      var Icon = /* @__PURE__ */ _export_sfc$1(_sfc_main$12, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
      const ElIcon = withInstall(Icon);
      const formContextKey = Symbol("formContextKey");
      const formItemContextKey = Symbol("formItemContextKey");
      const useFormSize = (fallback, ignore = {}) => {
        const emptyRef = ref(void 0);
        const size2 = ignore.prop ? emptyRef : useProp("size");
        const globalConfig2 = ignore.global ? emptyRef : useGlobalSize();
        const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
        const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
        return computed(() => size2.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
      };
      const useFormDisabled = (fallback) => {
        const disabled = useProp("disabled");
        const form = inject(formContextKey, void 0);
        return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
      };
      const useFormItem = () => {
        const form = inject(formContextKey, void 0);
        const formItem = inject(formItemContextKey, void 0);
        return {
          form,
          formItem
        };
      };
      const useFormItemInputId = (props, {
        formItemContext,
        disableIdGeneration,
        disableIdManagement
      }) => {
        if (!disableIdGeneration) {
          disableIdGeneration = ref(false);
        }
        if (!disableIdManagement) {
          disableIdManagement = ref(false);
        }
        const inputId = ref();
        let idUnwatch = void 0;
        const isLabeledByFormItem = computed(() => {
          var _a2;
          return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
        });
        onMounted(() => {
          idUnwatch = watch([toRef$1(props, "id"), disableIdGeneration], ([id2, disableIdGeneration2]) => {
            const newId = id2 != null ? id2 : !disableIdGeneration2 ? useId().value : void 0;
            if (newId !== inputId.value) {
              if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
                inputId.value && formItemContext.removeInputId(inputId.value);
                if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                  formItemContext.addInputId(newId);
                }
              }
              inputId.value = newId;
            }
          }, { immediate: true });
        });
        onUnmounted(() => {
          idUnwatch && idUnwatch();
          if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
            inputId.value && formItemContext.removeInputId(inputId.value);
          }
        });
        return {
          isLabeledByFormItem,
          inputId
        };
      };
      const formMetaProps = buildProps({
        size: {
          type: String,
          values: componentSizes
        },
        disabled: Boolean
      });
      const formProps = buildProps({
        ...formMetaProps,
        model: Object,
        rules: {
          type: definePropType(Object)
        },
        labelPosition: {
          type: String,
          values: ["left", "right", "top"],
          default: "right"
        },
        requireAsteriskPosition: {
          type: String,
          values: ["left", "right"],
          default: "left"
        },
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        labelSuffix: {
          type: String,
          default: ""
        },
        inline: Boolean,
        inlineMessage: Boolean,
        statusIcon: Boolean,
        showMessage: {
          type: Boolean,
          default: true
        },
        validateOnRuleChange: {
          type: Boolean,
          default: true
        },
        hideRequiredAsterisk: Boolean,
        scrollToError: Boolean,
        scrollIntoViewOptions: {
          type: [Object, Boolean]
        }
      });
      const formEmits = {
        validate: (prop, isValid, message2) => (isArray$2(prop) || isString$1(prop)) && isBoolean(isValid) && isString$1(message2)
      };
      function useFormLabelWidth() {
        const potentialLabelWidthArr = ref([]);
        const autoLabelWidth = computed(() => {
          if (!potentialLabelWidthArr.value.length)
            return "0";
          const max = Math.max(...potentialLabelWidthArr.value);
          return max ? `${max}px` : "";
        });
        function getLabelWidthIndex(width) {
          const index = potentialLabelWidthArr.value.indexOf(width);
          if (index === -1 && autoLabelWidth.value === "0")
            ;
          return index;
        }
        function registerLabelWidth(val, oldVal) {
          if (val && oldVal) {
            const index = getLabelWidthIndex(oldVal);
            potentialLabelWidthArr.value.splice(index, 1, val);
          } else if (val) {
            potentialLabelWidthArr.value.push(val);
          }
        }
        function deregisterLabelWidth(val) {
          const index = getLabelWidthIndex(val);
          if (index > -1) {
            potentialLabelWidthArr.value.splice(index, 1);
          }
        }
        return {
          autoLabelWidth,
          registerLabelWidth,
          deregisterLabelWidth
        };
      }
      const filterFields = (fields, props) => {
        const normalized = castArray(props);
        return normalized.length > 0 ? fields.filter((field) => field.prop && normalized.includes(field.prop)) : fields;
      };
      const COMPONENT_NAME$7 = "ElForm";
      const __default__$A = defineComponent({
        name: COMPONENT_NAME$7
      });
      const _sfc_main$11 = /* @__PURE__ */ defineComponent({
        ...__default__$A,
        props: formProps,
        emits: formEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const fields = [];
          const formSize = useFormSize();
          const ns = useNamespace("form");
          const formClasses = computed(() => {
            const { labelPosition, inline } = props;
            return [
              ns.b(),
              ns.m(formSize.value || "default"),
              {
                [ns.m(`label-${labelPosition}`)]: labelPosition,
                [ns.m("inline")]: inline
              }
            ];
          });
          const addField = (field) => {
            fields.push(field);
          };
          const removeField = (field) => {
            if (field.prop) {
              fields.splice(fields.indexOf(field), 1);
            }
          };
          const resetFields = (properties = []) => {
            if (!props.model) {
              return;
            }
            filterFields(fields, properties).forEach((field) => field.resetField());
          };
          const clearValidate = (props2 = []) => {
            filterFields(fields, props2).forEach((field) => field.clearValidate());
          };
          const isValidatable = computed(() => {
            const hasModel = !!props.model;
            return hasModel;
          });
          const obtainValidateFields = (props2) => {
            if (fields.length === 0)
              return [];
            const filteredFields = filterFields(fields, props2);
            if (!filteredFields.length) {
              return [];
            }
            return filteredFields;
          };
          const validate = async (callback) => validateField(void 0, callback);
          const doValidateField = async (props2 = []) => {
            if (!isValidatable.value)
              return false;
            const fields2 = obtainValidateFields(props2);
            if (fields2.length === 0)
              return true;
            let validationErrors = {};
            for (const field of fields2) {
              try {
                await field.validate("");
              } catch (fields3) {
                validationErrors = {
                  ...validationErrors,
                  ...fields3
                };
              }
            }
            if (Object.keys(validationErrors).length === 0)
              return true;
            return Promise.reject(validationErrors);
          };
          const validateField = async (modelProps = [], callback) => {
            const shouldThrow = !isFunction$1(callback);
            try {
              const result = await doValidateField(modelProps);
              if (result === true) {
                callback == null ? void 0 : callback(result);
              }
              return result;
            } catch (e) {
              if (e instanceof Error)
                throw e;
              const invalidFields = e;
              if (props.scrollToError) {
                scrollToField(Object.keys(invalidFields)[0]);
              }
              callback == null ? void 0 : callback(false, invalidFields);
              return shouldThrow && Promise.reject(invalidFields);
            }
          };
          const scrollToField = (prop) => {
            var _a2;
            const field = filterFields(fields, prop)[0];
            if (field) {
              (_a2 = field.$el) == null ? void 0 : _a2.scrollIntoView(props.scrollIntoViewOptions);
            }
          };
          watch(() => props.rules, () => {
            if (props.validateOnRuleChange) {
              validate().catch((err) => debugWarn());
            }
          }, { deep: true });
          provide(formContextKey, reactive({
            ...toRefs(props),
            emit: emit2,
            resetFields,
            clearValidate,
            validateField,
            addField,
            removeField,
            ...useFormLabelWidth()
          }));
          expose({
            validate,
            validateField,
            resetFields,
            clearValidate,
            scrollToField
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("form", {
              class: normalizeClass(unref(formClasses))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Form = /* @__PURE__ */ _export_sfc$1(_sfc_main$11, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form.vue"]]);
      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      function _setPrototypeOf(o, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
          o2.__proto__ = p3;
          return o2;
        };
        return _setPrototypeOf(o, p2);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a = [null];
            a.push.apply(a, args2);
            var Constructor = Function.bind.apply(Parent2, a);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn2) {
        return Function.toString.call(fn2).indexOf("[native code]") !== -1;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2))
            return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2))
              return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      var formatRegExp = /%[sdj%]/g;
      var warning = function warning2() {
      };
      if (typeof process !== "undefined" && process.env && false) {
        warning = function warning2(type2, errors) {
          if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
            if (errors.every(function(e) {
              return typeof e === "string";
            })) {
              console.warn(type2, errors);
            }
          }
        };
      }
      function convertFieldsError(errors) {
        if (!errors || !errors.length)
          return null;
        var fields = {};
        errors.forEach(function(error) {
          var field = error.field;
          fields[field] = fields[field] || [];
          fields[field].push(error);
        });
        return fields;
      }
      function format(template) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var i = 0;
        var len = args.length;
        if (typeof template === "function") {
          return template.apply(null, args);
        }
        if (typeof template === "string") {
          var str = template.replace(formatRegExp, function(x) {
            if (x === "%%") {
              return "%";
            }
            if (i >= len) {
              return x;
            }
            switch (x) {
              case "%s":
                return String(args[i++]);
              case "%d":
                return Number(args[i++]);
              case "%j":
                try {
                  return JSON.stringify(args[i++]);
                } catch (_) {
                  return "[Circular]";
                }
                break;
              default:
                return x;
            }
          });
          return str;
        }
        return template;
      }
      function isNativeStringType(type2) {
        return type2 === "string" || type2 === "url" || type2 === "hex" || type2 === "email" || type2 === "date" || type2 === "pattern";
      }
      function isEmptyValue(value, type2) {
        if (value === void 0 || value === null) {
          return true;
        }
        if (type2 === "array" && Array.isArray(value) && !value.length) {
          return true;
        }
        if (isNativeStringType(type2) && typeof value === "string" && !value) {
          return true;
        }
        return false;
      }
      function asyncParallelArray(arr, func, callback) {
        var results = [];
        var total2 = 0;
        var arrLength = arr.length;
        function count(errors) {
          results.push.apply(results, errors || []);
          total2++;
          if (total2 === arrLength) {
            callback(results);
          }
        }
        arr.forEach(function(a) {
          func(a, count);
        });
      }
      function asyncSerialArray(arr, func, callback) {
        var index = 0;
        var arrLength = arr.length;
        function next(errors) {
          if (errors && errors.length) {
            callback(errors);
            return;
          }
          var original = index;
          index = index + 1;
          if (original < arrLength) {
            func(arr[original], next);
          } else {
            callback([]);
          }
        }
        next([]);
      }
      function flattenObjArr(objArr) {
        var ret = [];
        Object.keys(objArr).forEach(function(k) {
          ret.push.apply(ret, objArr[k] || []);
        });
        return ret;
      }
      var AsyncValidationError = /* @__PURE__ */ function(_Error) {
        _inheritsLoose(AsyncValidationError2, _Error);
        function AsyncValidationError2(errors, fields) {
          var _this;
          _this = _Error.call(this, "Async Validation Error") || this;
          _this.errors = errors;
          _this.fields = fields;
          return _this;
        }
        return AsyncValidationError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      function asyncMap(objArr, option, func, callback, source) {
        if (option.first) {
          var _pending = new Promise(function(resolve2, reject) {
            var next = function next2(errors) {
              callback(errors);
              return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source);
            };
            var flattenArr = flattenObjArr(objArr);
            asyncSerialArray(flattenArr, func, next);
          });
          _pending["catch"](function(e) {
            return e;
          });
          return _pending;
        }
        var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
        var objArrKeys = Object.keys(objArr);
        var objArrLength = objArrKeys.length;
        var total2 = 0;
        var results = [];
        var pending = new Promise(function(resolve2, reject) {
          var next = function next2(errors) {
            results.push.apply(results, errors);
            total2++;
            if (total2 === objArrLength) {
              callback(results);
              return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source);
            }
          };
          if (!objArrKeys.length) {
            callback(results);
            resolve2(source);
          }
          objArrKeys.forEach(function(key) {
            var arr = objArr[key];
            if (firstFields.indexOf(key) !== -1) {
              asyncSerialArray(arr, func, next);
            } else {
              asyncParallelArray(arr, func, next);
            }
          });
        });
        pending["catch"](function(e) {
          return e;
        });
        return pending;
      }
      function isErrorObj(obj) {
        return !!(obj && obj.message !== void 0);
      }
      function getValue(value, path) {
        var v = value;
        for (var i = 0; i < path.length; i++) {
          if (v == void 0) {
            return v;
          }
          v = v[path[i]];
        }
        return v;
      }
      function complementError(rule, source) {
        return function(oe) {
          var fieldValue;
          if (rule.fullFields) {
            fieldValue = getValue(source, rule.fullFields);
          } else {
            fieldValue = source[oe.field || rule.fullField];
          }
          if (isErrorObj(oe)) {
            oe.field = oe.field || rule.fullField;
            oe.fieldValue = fieldValue;
            return oe;
          }
          return {
            message: typeof oe === "function" ? oe() : oe,
            fieldValue,
            field: oe.field || rule.fullField
          };
        };
      }
      function deepMerge(target, source) {
        if (source) {
          for (var s in source) {
            if (source.hasOwnProperty(s)) {
              var value = source[s];
              if (typeof value === "object" && typeof target[s] === "object") {
                target[s] = _extends({}, target[s], value);
              } else {
                target[s] = value;
              }
            }
          }
        }
        return target;
      }
      var required$1 = function required2(rule, value, source, errors, options, type2) {
        if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type2 || rule.type))) {
          errors.push(format(options.messages.required, rule.fullField));
        }
      };
      var whitespace = function whitespace2(rule, value, source, errors, options) {
        if (/^\s+$/.test(value) || value === "") {
          errors.push(format(options.messages.whitespace, rule.fullField));
        }
      };
      var urlReg;
      var getUrlRegex = function() {
        if (urlReg) {
          return urlReg;
        }
        var word = "[a-fA-F\\d:]";
        var b = function b2(options) {
          return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
        };
        var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
        var v6seg = "[a-fA-F\\d]{1,4}";
        var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
        var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
        var v4exact = new RegExp("^" + v4 + "$");
        var v6exact = new RegExp("^" + v6 + "$");
        var ip = function ip2(options) {
          return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", "g");
        };
        ip.v4 = function(options) {
          return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), "g");
        };
        ip.v6 = function(options) {
          return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), "g");
        };
        var protocol = "(?:(?:[a-z]+:)?//)";
        var auth = "(?:\\S+(?::\\S*)?@)?";
        var ipv4 = ip.v4().source;
        var ipv6 = ip.v6().source;
        var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
        var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
        var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
        var port = "(?::\\d{2,5})?";
        var path = '(?:[/?#][^\\s"]*)?';
        var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
        urlReg = new RegExp("(?:^" + regex + "$)", "i");
        return urlReg;
      };
      var pattern$2 = {
        // http://emailregex.com/
        email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
        // url: new RegExp(
        //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
        //   'i',
        // ),
        hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
      };
      var types = {
        integer: function integer2(value) {
          return types.number(value) && parseInt(value, 10) === value;
        },
        "float": function float(value) {
          return types.number(value) && !types.integer(value);
        },
        array: function array2(value) {
          return Array.isArray(value);
        },
        regexp: function regexp2(value) {
          if (value instanceof RegExp) {
            return true;
          }
          try {
            return !!new RegExp(value);
          } catch (e) {
            return false;
          }
        },
        date: function date2(value) {
          return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
        },
        number: function number2(value) {
          if (isNaN(value)) {
            return false;
          }
          return typeof value === "number";
        },
        object: function object2(value) {
          return typeof value === "object" && !types.array(value);
        },
        method: function method2(value) {
          return typeof value === "function";
        },
        email: function email(value) {
          return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
        },
        url: function url(value) {
          return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
        },
        hex: function hex(value) {
          return typeof value === "string" && !!value.match(pattern$2.hex);
        }
      };
      var type$1 = function type2(rule, value, source, errors, options) {
        if (rule.required && value === void 0) {
          required$1(rule, value, source, errors, options);
          return;
        }
        var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
        var ruleType = rule.type;
        if (custom.indexOf(ruleType) > -1) {
          if (!types[ruleType](value)) {
            errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
          }
        } else if (ruleType && typeof value !== rule.type) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      };
      var range = function range2(rule, value, source, errors, options) {
        var len = typeof rule.len === "number";
        var min = typeof rule.min === "number";
        var max = typeof rule.max === "number";
        var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var val = value;
        var key = null;
        var num = typeof value === "number";
        var str = typeof value === "string";
        var arr = Array.isArray(value);
        if (num) {
          key = "number";
        } else if (str) {
          key = "string";
        } else if (arr) {
          key = "array";
        }
        if (!key) {
          return false;
        }
        if (arr) {
          val = value.length;
        }
        if (str) {
          val = value.replace(spRegexp, "_").length;
        }
        if (len) {
          if (val !== rule.len) {
            errors.push(format(options.messages[key].len, rule.fullField, rule.len));
          }
        } else if (min && !max && val < rule.min) {
          errors.push(format(options.messages[key].min, rule.fullField, rule.min));
        } else if (max && !min && val > rule.max) {
          errors.push(format(options.messages[key].max, rule.fullField, rule.max));
        } else if (min && max && (val < rule.min || val > rule.max)) {
          errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
        }
      };
      var ENUM$1 = "enum";
      var enumerable$1 = function enumerable2(rule, value, source, errors, options) {
        rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
        if (rule[ENUM$1].indexOf(value) === -1) {
          errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
        }
      };
      var pattern$1 = function pattern2(rule, value, source, errors, options) {
        if (rule.pattern) {
          if (rule.pattern instanceof RegExp) {
            rule.pattern.lastIndex = 0;
            if (!rule.pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          } else if (typeof rule.pattern === "string") {
            var _pattern = new RegExp(rule.pattern);
            if (!_pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          }
        }
      };
      var rules = {
        required: required$1,
        whitespace,
        type: type$1,
        range,
        "enum": enumerable$1,
        pattern: pattern$1
      };
      var string = function string2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "string");
          if (!isEmptyValue(value, "string")) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
            rules.pattern(rule, value, source, errors, options);
            if (rule.whitespace === true) {
              rules.whitespace(rule, value, source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var method = function method2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var number = function number2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (value === "") {
            value = void 0;
          }
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var _boolean = function _boolean2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var regexp = function regexp2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var integer = function integer2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var floatFn = function floatFn2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var array = function array2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if ((value === void 0 || value === null) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "array");
          if (value !== void 0 && value !== null) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var object = function object2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var ENUM = "enum";
      var enumerable = function enumerable2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules[ENUM](rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var pattern = function pattern2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "string")) {
            rules.pattern(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var date = function date2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "date") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "date")) {
            var dateObject;
            if (value instanceof Date) {
              dateObject = value;
            } else {
              dateObject = new Date(value);
            }
            rules.type(rule, dateObject, source, errors, options);
            if (dateObject) {
              rules.range(rule, dateObject.getTime(), source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var required = function required2(rule, value, callback, source, options) {
        var errors = [];
        var type2 = Array.isArray(value) ? "array" : typeof value;
        rules.required(rule, value, source, errors, options, type2);
        callback(errors);
      };
      var type = function type2(rule, value, callback, source, options) {
        var ruleType = rule.type;
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, ruleType) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, ruleType);
          if (!isEmptyValue(value, ruleType)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var any = function any2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
        }
        callback(errors);
      };
      var validators = {
        string,
        method,
        number,
        "boolean": _boolean,
        regexp,
        integer,
        "float": floatFn,
        array,
        object,
        "enum": enumerable,
        pattern,
        date,
        url: type,
        hex: type,
        email: type,
        required,
        any
      };
      function newMessages() {
        return {
          "default": "Validation error on field %s",
          required: "%s is required",
          "enum": "%s must be one of %s",
          whitespace: "%s cannot be empty",
          date: {
            format: "%s date %s is invalid for format %s",
            parse: "%s date could not be parsed, %s is invalid ",
            invalid: "%s date %s is invalid"
          },
          types: {
            string: "%s is not a %s",
            method: "%s is not a %s (function)",
            array: "%s is not an %s",
            object: "%s is not an %s",
            number: "%s is not a %s",
            date: "%s is not a %s",
            "boolean": "%s is not a %s",
            integer: "%s is not an %s",
            "float": "%s is not a %s",
            regexp: "%s is not a valid %s",
            email: "%s is not a valid %s",
            url: "%s is not a valid %s",
            hex: "%s is not a valid %s"
          },
          string: {
            len: "%s must be exactly %s characters",
            min: "%s must be at least %s characters",
            max: "%s cannot be longer than %s characters",
            range: "%s must be between %s and %s characters"
          },
          number: {
            len: "%s must equal %s",
            min: "%s cannot be less than %s",
            max: "%s cannot be greater than %s",
            range: "%s must be between %s and %s"
          },
          array: {
            len: "%s must be exactly %s in length",
            min: "%s cannot be less than %s in length",
            max: "%s cannot be greater than %s in length",
            range: "%s must be between %s and %s in length"
          },
          pattern: {
            mismatch: "%s value %s does not match pattern %s"
          },
          clone: function clone2() {
            var cloned = JSON.parse(JSON.stringify(this));
            cloned.clone = this.clone;
            return cloned;
          }
        };
      }
      var messages = newMessages();
      var Schema = /* @__PURE__ */ function() {
        function Schema2(descriptor) {
          this.rules = null;
          this._messages = messages;
          this.define(descriptor);
        }
        var _proto = Schema2.prototype;
        _proto.define = function define(rules2) {
          var _this = this;
          if (!rules2) {
            throw new Error("Cannot configure a schema with no rules");
          }
          if (typeof rules2 !== "object" || Array.isArray(rules2)) {
            throw new Error("Rules must be an object");
          }
          this.rules = {};
          Object.keys(rules2).forEach(function(name) {
            var item = rules2[name];
            _this.rules[name] = Array.isArray(item) ? item : [item];
          });
        };
        _proto.messages = function messages2(_messages) {
          if (_messages) {
            this._messages = deepMerge(newMessages(), _messages);
          }
          return this._messages;
        };
        _proto.validate = function validate(source_, o, oc) {
          var _this2 = this;
          if (o === void 0) {
            o = {};
          }
          if (oc === void 0) {
            oc = function oc2() {
            };
          }
          var source = source_;
          var options = o;
          var callback = oc;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          if (!this.rules || Object.keys(this.rules).length === 0) {
            if (callback) {
              callback(null, source);
            }
            return Promise.resolve(source);
          }
          function complete(results) {
            var errors = [];
            var fields = {};
            function add2(e) {
              if (Array.isArray(e)) {
                var _errors;
                errors = (_errors = errors).concat.apply(_errors, e);
              } else {
                errors.push(e);
              }
            }
            for (var i = 0; i < results.length; i++) {
              add2(results[i]);
            }
            if (!errors.length) {
              callback(null, source);
            } else {
              fields = convertFieldsError(errors);
              callback(errors, fields);
            }
          }
          if (options.messages) {
            var messages$1 = this.messages();
            if (messages$1 === messages) {
              messages$1 = newMessages();
            }
            deepMerge(messages$1, options.messages);
            options.messages = messages$1;
          } else {
            options.messages = this.messages();
          }
          var series = {};
          var keys2 = options.keys || Object.keys(this.rules);
          keys2.forEach(function(z) {
            var arr = _this2.rules[z];
            var value = source[z];
            arr.forEach(function(r) {
              var rule = r;
              if (typeof rule.transform === "function") {
                if (source === source_) {
                  source = _extends({}, source);
                }
                value = source[z] = rule.transform(value);
              }
              if (typeof rule === "function") {
                rule = {
                  validator: rule
                };
              } else {
                rule = _extends({}, rule);
              }
              rule.validator = _this2.getValidationMethod(rule);
              if (!rule.validator) {
                return;
              }
              rule.field = z;
              rule.fullField = rule.fullField || z;
              rule.type = _this2.getType(rule);
              series[z] = series[z] || [];
              series[z].push({
                rule,
                value,
                source,
                field: z
              });
            });
          });
          var errorFields = {};
          return asyncMap(series, options, function(data, doIt) {
            var rule = data.rule;
            var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
            deep = deep && (rule.required || !rule.required && data.value);
            rule.field = data.field;
            function addFullField(key, schema) {
              return _extends({}, schema, {
                fullField: rule.fullField + "." + key,
                fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
              });
            }
            function cb(e) {
              if (e === void 0) {
                e = [];
              }
              var errorList = Array.isArray(e) ? e : [e];
              if (!options.suppressWarning && errorList.length) {
                Schema2.warning("async-validator:", errorList);
              }
              if (errorList.length && rule.message !== void 0) {
                errorList = [].concat(rule.message);
              }
              var filledErrors = errorList.map(complementError(rule, source));
              if (options.first && filledErrors.length) {
                errorFields[rule.field] = 1;
                return doIt(filledErrors);
              }
              if (!deep) {
                doIt(filledErrors);
              } else {
                if (rule.required && !data.value) {
                  if (rule.message !== void 0) {
                    filledErrors = [].concat(rule.message).map(complementError(rule, source));
                  } else if (options.error) {
                    filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                  }
                  return doIt(filledErrors);
                }
                var fieldsSchema = {};
                if (rule.defaultField) {
                  Object.keys(data.value).map(function(key) {
                    fieldsSchema[key] = rule.defaultField;
                  });
                }
                fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
                var paredFieldsSchema = {};
                Object.keys(fieldsSchema).forEach(function(field) {
                  var fieldSchema = fieldsSchema[field];
                  var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                  paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                });
                var schema = new Schema2(paredFieldsSchema);
                schema.messages(options.messages);
                if (data.rule.options) {
                  data.rule.options.messages = options.messages;
                  data.rule.options.error = options.error;
                }
                schema.validate(data.value, data.rule.options || options, function(errs) {
                  var finalErrors = [];
                  if (filledErrors && filledErrors.length) {
                    finalErrors.push.apply(finalErrors, filledErrors);
                  }
                  if (errs && errs.length) {
                    finalErrors.push.apply(finalErrors, errs);
                  }
                  doIt(finalErrors.length ? finalErrors : null);
                });
              }
            }
            var res;
            if (rule.asyncValidator) {
              res = rule.asyncValidator(rule, data.value, cb, data.source, options);
            } else if (rule.validator) {
              try {
                res = rule.validator(rule, data.value, cb, data.source, options);
              } catch (error) {
                console.error == null ? void 0 : console.error(error);
                if (!options.suppressValidatorError) {
                  setTimeout(function() {
                    throw error;
                  }, 0);
                }
                cb(error.message);
              }
              if (res === true) {
                cb();
              } else if (res === false) {
                cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
              } else if (res instanceof Array) {
                cb(res);
              } else if (res instanceof Error) {
                cb(res.message);
              }
            }
            if (res && res.then) {
              res.then(function() {
                return cb();
              }, function(e) {
                return cb(e);
              });
            }
          }, function(results) {
            complete(results);
          }, source);
        };
        _proto.getType = function getType2(rule) {
          if (rule.type === void 0 && rule.pattern instanceof RegExp) {
            rule.type = "pattern";
          }
          if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
            throw new Error(format("Unknown rule type %s", rule.type));
          }
          return rule.type || "string";
        };
        _proto.getValidationMethod = function getValidationMethod(rule) {
          if (typeof rule.validator === "function") {
            return rule.validator;
          }
          var keys2 = Object.keys(rule);
          var messageIndex = keys2.indexOf("message");
          if (messageIndex !== -1) {
            keys2.splice(messageIndex, 1);
          }
          if (keys2.length === 1 && keys2[0] === "required") {
            return validators.required;
          }
          return validators[this.getType(rule)] || void 0;
        };
        return Schema2;
      }();
      Schema.register = function register(type2, validator) {
        if (typeof validator !== "function") {
          throw new Error("Cannot register a validator by type, validator is not a function");
        }
        validators[type2] = validator;
      };
      Schema.warning = warning;
      Schema.messages = messages;
      Schema.validators = validators;
      const formItemValidateStates = [
        "",
        "error",
        "validating",
        "success"
      ];
      const formItemProps = buildProps({
        label: String,
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        prop: {
          type: definePropType([String, Array])
        },
        required: {
          type: Boolean,
          default: void 0
        },
        rules: {
          type: definePropType([Object, Array])
        },
        error: String,
        validateStatus: {
          type: String,
          values: formItemValidateStates
        },
        for: String,
        inlineMessage: {
          type: [String, Boolean],
          default: ""
        },
        showMessage: {
          type: Boolean,
          default: true
        },
        size: {
          type: String,
          values: componentSizes
        }
      });
      const COMPONENT_NAME$6 = "ElLabelWrap";
      var FormLabelWrap = defineComponent({
        name: COMPONENT_NAME$6,
        props: {
          isAutoWidth: Boolean,
          updateAll: Boolean
        },
        setup(props, {
          slots
        }) {
          const formContext = inject(formContextKey, void 0);
          const formItemContext = inject(formItemContextKey);
          if (!formItemContext)
            throwError(COMPONENT_NAME$6, "usage: <el-form-item><label-wrap /></el-form-item>");
          const ns = useNamespace("form");
          const el = ref();
          const computedWidth = ref(0);
          const getLabelWidth = () => {
            var _a2;
            if ((_a2 = el.value) == null ? void 0 : _a2.firstElementChild) {
              const width = window.getComputedStyle(el.value.firstElementChild).width;
              return Math.ceil(Number.parseFloat(width));
            } else {
              return 0;
            }
          };
          const updateLabelWidth = (action = "update") => {
            nextTick(() => {
              if (slots.default && props.isAutoWidth) {
                if (action === "update") {
                  computedWidth.value = getLabelWidth();
                } else if (action === "remove") {
                  formContext == null ? void 0 : formContext.deregisterLabelWidth(computedWidth.value);
                }
              }
            });
          };
          const updateLabelWidthFn = () => updateLabelWidth("update");
          onMounted(() => {
            updateLabelWidthFn();
          });
          onBeforeUnmount(() => {
            updateLabelWidth("remove");
          });
          onUpdated(() => updateLabelWidthFn());
          watch(computedWidth, (val, oldVal) => {
            if (props.updateAll) {
              formContext == null ? void 0 : formContext.registerLabelWidth(val, oldVal);
            }
          });
          useResizeObserver(computed(() => {
            var _a2, _b;
            return (_b = (_a2 = el.value) == null ? void 0 : _a2.firstElementChild) != null ? _b : null;
          }), updateLabelWidthFn);
          return () => {
            var _a2, _b;
            if (!slots)
              return null;
            const {
              isAutoWidth
            } = props;
            if (isAutoWidth) {
              const autoLabelWidth = formContext == null ? void 0 : formContext.autoLabelWidth;
              const hasLabel = formItemContext == null ? void 0 : formItemContext.hasLabel;
              const style = {};
              if (hasLabel && autoLabelWidth && autoLabelWidth !== "auto") {
                const marginWidth = Math.max(0, Number.parseInt(autoLabelWidth, 10) - computedWidth.value);
                const marginPosition = formContext.labelPosition === "left" ? "marginRight" : "marginLeft";
                if (marginWidth) {
                  style[marginPosition] = `${marginWidth}px`;
                }
              }
              return createVNode("div", {
                "ref": el,
                "class": [ns.be("item", "label-wrap")],
                "style": style
              }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
            } else {
              return createVNode(Fragment, {
                "ref": el
              }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
            }
          };
        }
      });
      const _hoisted_1$K = ["role", "aria-labelledby"];
      const __default__$z = defineComponent({
        name: "ElFormItem"
      });
      const _sfc_main$10 = /* @__PURE__ */ defineComponent({
        ...__default__$z,
        props: formItemProps,
        setup(__props, { expose }) {
          const props = __props;
          const slots = useSlots();
          const formContext = inject(formContextKey, void 0);
          const parentFormItemContext = inject(formItemContextKey, void 0);
          const _size = useFormSize(void 0, { formItem: false });
          const ns = useNamespace("form-item");
          const labelId = useId().value;
          const inputIds = ref([]);
          const validateState = ref("");
          const validateStateDebounced = refDebounced(validateState, 100);
          const validateMessage = ref("");
          const formItemRef = ref();
          let initialValue = void 0;
          let isResettingField = false;
          const labelStyle = computed(() => {
            if ((formContext == null ? void 0 : formContext.labelPosition) === "top") {
              return {};
            }
            const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (labelWidth)
              return { width: labelWidth };
            return {};
          });
          const contentStyle = computed(() => {
            if ((formContext == null ? void 0 : formContext.labelPosition) === "top" || (formContext == null ? void 0 : formContext.inline)) {
              return {};
            }
            if (!props.label && !props.labelWidth && isNested) {
              return {};
            }
            const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (!props.label && !slots.label) {
              return { marginLeft: labelWidth };
            }
            return {};
          });
          const formItemClasses = computed(() => [
            ns.b(),
            ns.m(_size.value),
            ns.is("error", validateState.value === "error"),
            ns.is("validating", validateState.value === "validating"),
            ns.is("success", validateState.value === "success"),
            ns.is("required", isRequired.value || props.required),
            ns.is("no-asterisk", formContext == null ? void 0 : formContext.hideRequiredAsterisk),
            (formContext == null ? void 0 : formContext.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
            { [ns.m("feedback")]: formContext == null ? void 0 : formContext.statusIcon }
          ]);
          const _inlineMessage = computed(() => isBoolean(props.inlineMessage) ? props.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);
          const validateClasses = computed(() => [
            ns.e("error"),
            { [ns.em("error", "inline")]: _inlineMessage.value }
          ]);
          const propString = computed(() => {
            if (!props.prop)
              return "";
            return isString$1(props.prop) ? props.prop : props.prop.join(".");
          });
          const hasLabel = computed(() => {
            return !!(props.label || slots.label);
          });
          const labelFor = computed(() => {
            return props.for || inputIds.value.length === 1 ? inputIds.value[0] : void 0;
          });
          const isGroup = computed(() => {
            return !labelFor.value && hasLabel.value;
          });
          const isNested = !!parentFormItemContext;
          const fieldValue = computed(() => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props.prop) {
              return;
            }
            return getProp(model, props.prop).value;
          });
          const normalizedRules = computed(() => {
            const { required: required2 } = props;
            const rules2 = [];
            if (props.rules) {
              rules2.push(...castArray(props.rules));
            }
            const formRules = formContext == null ? void 0 : formContext.rules;
            if (formRules && props.prop) {
              const _rules = getProp(formRules, props.prop).value;
              if (_rules) {
                rules2.push(...castArray(_rules));
              }
            }
            if (required2 !== void 0) {
              const requiredRules = rules2.map((rule, i) => [rule, i]).filter(([rule]) => Object.keys(rule).includes("required"));
              if (requiredRules.length > 0) {
                for (const [rule, i] of requiredRules) {
                  if (rule.required === required2)
                    continue;
                  rules2[i] = { ...rule, required: required2 };
                }
              } else {
                rules2.push({ required: required2 });
              }
            }
            return rules2;
          });
          const validateEnabled = computed(() => normalizedRules.value.length > 0);
          const getFilteredRule = (trigger2) => {
            const rules2 = normalizedRules.value;
            return rules2.filter((rule) => {
              if (!rule.trigger || !trigger2)
                return true;
              if (Array.isArray(rule.trigger)) {
                return rule.trigger.includes(trigger2);
              } else {
                return rule.trigger === trigger2;
              }
            }).map(({ trigger: trigger22, ...rule }) => rule);
          };
          const isRequired = computed(() => normalizedRules.value.some((rule) => rule.required));
          const shouldShowError = computed(() => {
            var _a2;
            return validateStateDebounced.value === "error" && props.showMessage && ((_a2 = formContext == null ? void 0 : formContext.showMessage) != null ? _a2 : true);
          });
          const currentLabel = computed(() => `${props.label || ""}${(formContext == null ? void 0 : formContext.labelSuffix) || ""}`);
          const setValidationState = (state) => {
            validateState.value = state;
          };
          const onValidationFailed = (error) => {
            var _a2, _b;
            const { errors, fields } = error;
            if (!errors || !fields) {
              console.error(error);
            }
            setValidationState("error");
            validateMessage.value = errors ? (_b = (_a2 = errors == null ? void 0 : errors[0]) == null ? void 0 : _a2.message) != null ? _b : `${props.prop} is required` : "";
            formContext == null ? void 0 : formContext.emit("validate", props.prop, false, validateMessage.value);
          };
          const onValidationSucceeded = () => {
            setValidationState("success");
            formContext == null ? void 0 : formContext.emit("validate", props.prop, true, "");
          };
          const doValidate = async (rules2) => {
            const modelName = propString.value;
            const validator = new Schema({
              [modelName]: rules2
            });
            return validator.validate({ [modelName]: fieldValue.value }, { firstFields: true }).then(() => {
              onValidationSucceeded();
              return true;
            }).catch((err) => {
              onValidationFailed(err);
              return Promise.reject(err);
            });
          };
          const validate = async (trigger2, callback) => {
            if (isResettingField || !props.prop) {
              return false;
            }
            const hasCallback = isFunction$1(callback);
            if (!validateEnabled.value) {
              callback == null ? void 0 : callback(false);
              return false;
            }
            const rules2 = getFilteredRule(trigger2);
            if (rules2.length === 0) {
              callback == null ? void 0 : callback(true);
              return true;
            }
            setValidationState("validating");
            return doValidate(rules2).then(() => {
              callback == null ? void 0 : callback(true);
              return true;
            }).catch((err) => {
              const { fields } = err;
              callback == null ? void 0 : callback(false, fields);
              return hasCallback ? false : Promise.reject(fields);
            });
          };
          const clearValidate = () => {
            setValidationState("");
            validateMessage.value = "";
            isResettingField = false;
          };
          const resetField = async () => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props.prop)
              return;
            const computedValue = getProp(model, props.prop);
            isResettingField = true;
            computedValue.value = clone(initialValue);
            await nextTick();
            clearValidate();
            isResettingField = false;
          };
          const addInputId = (id2) => {
            if (!inputIds.value.includes(id2)) {
              inputIds.value.push(id2);
            }
          };
          const removeInputId = (id2) => {
            inputIds.value = inputIds.value.filter((listId) => listId !== id2);
          };
          watch(() => props.error, (val) => {
            validateMessage.value = val || "";
            setValidationState(val ? "error" : "");
          }, { immediate: true });
          watch(() => props.validateStatus, (val) => setValidationState(val || ""));
          const context = reactive({
            ...toRefs(props),
            $el: formItemRef,
            size: _size,
            validateState,
            labelId,
            inputIds,
            isGroup,
            hasLabel,
            addInputId,
            removeInputId,
            resetField,
            clearValidate,
            validate
          });
          provide(formItemContextKey, context);
          onMounted(() => {
            if (props.prop) {
              formContext == null ? void 0 : formContext.addField(context);
              initialValue = clone(fieldValue.value);
            }
          });
          onBeforeUnmount(() => {
            formContext == null ? void 0 : formContext.removeField(context);
          });
          expose({
            size: _size,
            validateMessage,
            validateState,
            validate,
            clearValidate,
            resetField
          });
          return (_ctx, _cache) => {
            var _a2;
            return openBlock(), createElementBlock("div", {
              ref_key: "formItemRef",
              ref: formItemRef,
              class: normalizeClass(unref(formItemClasses)),
              role: unref(isGroup) ? "group" : void 0,
              "aria-labelledby": unref(isGroup) ? unref(labelId) : void 0
            }, [
              createVNode(unref(FormLabelWrap), {
                "is-auto-width": unref(labelStyle).width === "auto",
                "update-all": ((_a2 = unref(formContext)) == null ? void 0 : _a2.labelWidth) === "auto"
              }, {
                default: withCtx(() => [
                  unref(hasLabel) ? (openBlock(), createBlock(resolveDynamicComponent(unref(labelFor) ? "label" : "div"), {
                    key: 0,
                    id: unref(labelId),
                    for: unref(labelFor),
                    class: normalizeClass(unref(ns).e("label")),
                    style: normalizeStyle(unref(labelStyle))
                  }, {
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "label", { label: unref(currentLabel) }, () => [
                        createTextVNode(toDisplayString(unref(currentLabel)), 1)
                      ])
                    ]),
                    _: 3
                  }, 8, ["id", "for", "class", "style"])) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["is-auto-width", "update-all"]),
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).e("content")),
                style: normalizeStyle(unref(contentStyle))
              }, [
                renderSlot(_ctx.$slots, "default"),
                createVNode(TransitionGroup, {
                  name: `${unref(ns).namespace.value}-zoom-in-top`
                }, {
                  default: withCtx(() => [
                    unref(shouldShowError) ? renderSlot(_ctx.$slots, "error", {
                      key: 0,
                      error: validateMessage.value
                    }, () => [
                      createBaseVNode("div", {
                        class: normalizeClass(unref(validateClasses))
                      }, toDisplayString(validateMessage.value), 3)
                    ]) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["name"])
              ], 6)
            ], 10, _hoisted_1$K);
          };
        }
      });
      var FormItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$10, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form-item.vue"]]);
      const ElForm = withInstall(Form, {
        FormItem
      });
      const ElFormItem = withNoopInstall(FormItem);
      let hiddenTextarea = void 0;
      const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  ${isFirefox() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
      const CONTEXT_STYLE = [
        "letter-spacing",
        "line-height",
        "padding-top",
        "padding-bottom",
        "font-family",
        "font-weight",
        "font-size",
        "text-rendering",
        "text-transform",
        "width",
        "text-indent",
        "padding-left",
        "padding-right",
        "border-width",
        "box-sizing"
      ];
      function calculateNodeStyling(targetElement) {
        const style = window.getComputedStyle(targetElement);
        const boxSizing = style.getPropertyValue("box-sizing");
        const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
        const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
        const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
        return { contextStyle, paddingSize, borderSize, boxSizing };
      }
      function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
        var _a2;
        if (!hiddenTextarea) {
          hiddenTextarea = document.createElement("textarea");
          document.body.appendChild(hiddenTextarea);
        }
        const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
        hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
        hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
        let height = hiddenTextarea.scrollHeight;
        const result = {};
        if (boxSizing === "border-box") {
          height = height + borderSize;
        } else if (boxSizing === "content-box") {
          height = height - paddingSize;
        }
        hiddenTextarea.value = "";
        const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (isNumber(minRows)) {
          let minHeight = singleRowHeight * minRows;
          if (boxSizing === "border-box") {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
          result.minHeight = `${minHeight}px`;
        }
        if (isNumber(maxRows)) {
          let maxHeight = singleRowHeight * maxRows;
          if (boxSizing === "border-box") {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          height = Math.min(maxHeight, height);
        }
        result.height = `${height}px`;
        (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
        hiddenTextarea = void 0;
        return result;
      }
      const inputProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        size: useSizeProp,
        disabled: Boolean,
        modelValue: {
          type: definePropType([
            String,
            Number,
            Object
          ]),
          default: ""
        },
        type: {
          type: String,
          default: "text"
        },
        resize: {
          type: String,
          values: ["none", "both", "horizontal", "vertical"]
        },
        autosize: {
          type: definePropType([Boolean, Object]),
          default: false
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        formatter: {
          type: Function
        },
        parser: {
          type: Function
        },
        placeholder: {
          type: String
        },
        form: {
          type: String
        },
        readonly: {
          type: Boolean,
          default: false
        },
        clearable: {
          type: Boolean,
          default: false
        },
        showPassword: {
          type: Boolean,
          default: false
        },
        showWordLimit: {
          type: Boolean,
          default: false
        },
        suffixIcon: {
          type: iconPropType
        },
        prefixIcon: {
          type: iconPropType
        },
        containerRole: {
          type: String,
          default: void 0
        },
        label: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        inputStyle: {
          type: definePropType([Object, Array, String]),
          default: () => mutable({})
        }
      });
      const inputEmits = {
        [UPDATE_MODEL_EVENT]: (value) => isString$1(value),
        input: (value) => isString$1(value),
        change: (value) => isString$1(value),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true,
        mouseleave: (evt) => evt instanceof MouseEvent,
        mouseenter: (evt) => evt instanceof MouseEvent,
        keydown: (evt) => evt instanceof Event,
        compositionstart: (evt) => evt instanceof CompositionEvent,
        compositionupdate: (evt) => evt instanceof CompositionEvent,
        compositionend: (evt) => evt instanceof CompositionEvent
      };
      const _hoisted_1$J = ["role"];
      const _hoisted_2$z = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form"];
      const _hoisted_3$q = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form"];
      const __default__$y = defineComponent({
        name: "ElInput",
        inheritAttrs: false
      });
      const _sfc_main$$ = /* @__PURE__ */ defineComponent({
        ...__default__$y,
        props: inputProps,
        emits: inputEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const rawAttrs = useAttrs$1();
          const slots = useSlots();
          const containerAttrs = computed(() => {
            const comboBoxAttrs = {};
            if (props.containerRole === "combobox") {
              comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
              comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
              comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
            }
            return comboBoxAttrs;
          });
          const containerKls = computed(() => [
            props.type === "textarea" ? nsTextarea.b() : nsInput.b(),
            nsInput.m(inputSize.value),
            nsInput.is("disabled", inputDisabled.value),
            nsInput.is("exceed", inputExceed.value),
            {
              [nsInput.b("group")]: slots.prepend || slots.append,
              [nsInput.bm("group", "append")]: slots.append,
              [nsInput.bm("group", "prepend")]: slots.prepend,
              [nsInput.m("prefix")]: slots.prefix || props.prefixIcon,
              [nsInput.m("suffix")]: slots.suffix || props.suffixIcon || props.clearable || props.showPassword,
              [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value
            },
            rawAttrs.class
          ]);
          const wrapperKls = computed(() => [
            nsInput.e("wrapper"),
            nsInput.is("focus", isFocused.value)
          ]);
          const attrs = useAttrs({
            excludeKeys: computed(() => {
              return Object.keys(containerAttrs.value);
            })
          });
          const { form, formItem } = useFormItem();
          const { inputId } = useFormItemInputId(props, {
            formItemContext: formItem
          });
          const inputSize = useFormSize();
          const inputDisabled = useFormDisabled();
          const nsInput = useNamespace("input");
          const nsTextarea = useNamespace("textarea");
          const input = shallowRef();
          const textarea = shallowRef();
          const hovering = ref(false);
          const isComposing = ref(false);
          const passwordVisible = ref(false);
          const countStyle = ref();
          const textareaCalcStyle = shallowRef(props.inputStyle);
          const _ref = computed(() => input.value || textarea.value);
          const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
            afterBlur() {
              var _a2;
              if (props.validateEvent) {
                (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn());
              }
            }
          });
          const needStatusIcon = computed(() => {
            var _a2;
            return (_a2 = form == null ? void 0 : form.statusIcon) != null ? _a2 : false;
          });
          const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
          const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
          const passwordIcon = computed(() => passwordVisible.value ? view_default : hide_default);
          const containerStyle = computed(() => [
            rawAttrs.style,
            props.inputStyle
          ]);
          const textareaStyle = computed(() => [
            props.inputStyle,
            textareaCalcStyle.value,
            { resize: props.resize }
          ]);
          const nativeInputValue = computed(() => isNil(props.modelValue) ? "" : String(props.modelValue));
          const showClear = computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
          const showPwdVisible = computed(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || isFocused.value));
          const isWordLimitVisible = computed(() => props.showWordLimit && !!attrs.value.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
          const textLength = computed(() => nativeInputValue.value.length);
          const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(attrs.value.maxlength));
          const suffixVisible = computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
          const [recordCursor, setCursor] = useCursor(input);
          useResizeObserver(textarea, (entries) => {
            onceInitSizeTextarea();
            if (!isWordLimitVisible.value || props.resize !== "both")
              return;
            const entry = entries[0];
            const { width } = entry.contentRect;
            countStyle.value = {
              right: `calc(100% - ${width + 15 + 6}px)`
            };
          });
          const resizeTextarea = () => {
            const { type: type2, autosize } = props;
            if (!isClient$1 || type2 !== "textarea" || !textarea.value)
              return;
            if (autosize) {
              const minRows = isObject$1(autosize) ? autosize.minRows : void 0;
              const maxRows = isObject$1(autosize) ? autosize.maxRows : void 0;
              const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
              textareaCalcStyle.value = {
                overflowY: "hidden",
                ...textareaStyle2
              };
              nextTick(() => {
                textarea.value.offsetHeight;
                textareaCalcStyle.value = textareaStyle2;
              });
            } else {
              textareaCalcStyle.value = {
                minHeight: calcTextareaHeight(textarea.value).minHeight
              };
            }
          };
          const createOnceInitResize = (resizeTextarea2) => {
            let isInit = false;
            return () => {
              var _a2;
              if (isInit || !props.autosize)
                return;
              const isElHidden = ((_a2 = textarea.value) == null ? void 0 : _a2.offsetParent) === null;
              if (!isElHidden) {
                resizeTextarea2();
                isInit = true;
              }
            };
          };
          const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
          const setNativeInputValue = () => {
            const input2 = _ref.value;
            const formatterValue = props.formatter ? props.formatter(nativeInputValue.value) : nativeInputValue.value;
            if (!input2 || input2.value === formatterValue)
              return;
            input2.value = formatterValue;
          };
          const handleInput = async (event) => {
            recordCursor();
            let { value } = event.target;
            if (props.formatter) {
              value = props.parser ? props.parser(value) : value;
            }
            if (isComposing.value)
              return;
            if (value === nativeInputValue.value) {
              setNativeInputValue();
              return;
            }
            emit2(UPDATE_MODEL_EVENT, value);
            emit2("input", value);
            await nextTick();
            setNativeInputValue();
            setCursor();
          };
          const handleChange = (event) => {
            emit2("change", event.target.value);
          };
          const handleCompositionStart = (event) => {
            emit2("compositionstart", event);
            isComposing.value = true;
          };
          const handleCompositionUpdate = (event) => {
            var _a2;
            emit2("compositionupdate", event);
            const text = (_a2 = event.target) == null ? void 0 : _a2.value;
            const lastCharacter = text[text.length - 1] || "";
            isComposing.value = !isKorean(lastCharacter);
          };
          const handleCompositionEnd = (event) => {
            emit2("compositionend", event);
            if (isComposing.value) {
              isComposing.value = false;
              handleInput(event);
            }
          };
          const handlePasswordVisible = () => {
            passwordVisible.value = !passwordVisible.value;
            focus();
          };
          const focus = async () => {
            var _a2;
            await nextTick();
            (_a2 = _ref.value) == null ? void 0 : _a2.focus();
          };
          const blur = () => {
            var _a2;
            return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
          };
          const handleMouseLeave = (evt) => {
            hovering.value = false;
            emit2("mouseleave", evt);
          };
          const handleMouseEnter = (evt) => {
            hovering.value = true;
            emit2("mouseenter", evt);
          };
          const handleKeydown = (evt) => {
            emit2("keydown", evt);
          };
          const select = () => {
            var _a2;
            (_a2 = _ref.value) == null ? void 0 : _a2.select();
          };
          const clear2 = () => {
            emit2(UPDATE_MODEL_EVENT, "");
            emit2("change", "");
            emit2("clear");
            emit2("input", "");
          };
          watch(() => props.modelValue, () => {
            var _a2;
            nextTick(() => resizeTextarea());
            if (props.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
            }
          });
          watch(nativeInputValue, () => setNativeInputValue());
          watch(() => props.type, async () => {
            await nextTick();
            setNativeInputValue();
            resizeTextarea();
          });
          onMounted(() => {
            if (!props.formatter && props.parser)
              ;
            setNativeInputValue();
            nextTick(resizeTextarea);
          });
          expose({
            input,
            textarea,
            ref: _ref,
            textareaStyle,
            autosize: toRef$1(props, "autosize"),
            focus,
            blur,
            select,
            clear: clear2,
            resizeTextarea
          });
          return (_ctx, _cache) => {
            return withDirectives((openBlock(), createElementBlock("div", mergeProps(unref(containerAttrs), {
              class: unref(containerKls),
              style: unref(containerStyle),
              role: _ctx.containerRole,
              onMouseenter: handleMouseEnter,
              onMouseleave: handleMouseLeave
            }), [
              createCommentVNode(" input "),
              _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createCommentVNode(" prepend slot "),
                _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(nsInput).be("group", "prepend"))
                }, [
                  renderSlot(_ctx.$slots, "prepend")
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  ref_key: "wrapperRef",
                  ref: wrapperRef,
                  class: normalizeClass(unref(wrapperKls))
                }, [
                  createCommentVNode(" prefix slot "),
                  _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(nsInput).e("prefix"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(nsInput).e("prefix-inner"))
                    }, [
                      renderSlot(_ctx.$slots, "prefix"),
                      _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass(unref(nsInput).e("icon"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true),
                  createBaseVNode("input", mergeProps({
                    id: unref(inputId),
                    ref_key: "input",
                    ref: input,
                    class: unref(nsInput).e("inner")
                  }, unref(attrs), {
                    type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                    disabled: unref(inputDisabled),
                    formatter: _ctx.formatter,
                    parser: _ctx.parser,
                    readonly: _ctx.readonly,
                    autocomplete: _ctx.autocomplete,
                    tabindex: _ctx.tabindex,
                    "aria-label": _ctx.label,
                    placeholder: _ctx.placeholder,
                    style: _ctx.inputStyle,
                    form: props.form,
                    onCompositionstart: handleCompositionStart,
                    onCompositionupdate: handleCompositionUpdate,
                    onCompositionend: handleCompositionEnd,
                    onInput: handleInput,
                    onFocus: _cache[0] || (_cache[0] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                    onBlur: _cache[1] || (_cache[1] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                    onChange: handleChange,
                    onKeydown: handleKeydown
                  }), null, 16, _hoisted_2$z),
                  createCommentVNode(" suffix slot "),
                  unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(unref(nsInput).e("suffix"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(nsInput).e("suffix-inner"))
                    }, [
                      !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        renderSlot(_ctx.$slots, "suffix"),
                        _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                          key: 0,
                          class: normalizeClass(unref(nsInput).e("icon"))
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : createCommentVNode("v-if", true)
                      ], 64)) : createCommentVNode("v-if", true),
                      unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 1,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                        onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                        onClick: clear2
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(circle_close_default))
                        ]),
                        _: 1
                      }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                      unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 2,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                        onClick: handlePasswordVisible
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true),
                      unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                        key: 3,
                        class: normalizeClass(unref(nsInput).e("count"))
                      }, [
                        createBaseVNode("span", {
                          class: normalizeClass(unref(nsInput).e("count-inner"))
                        }, toDisplayString(unref(textLength)) + " / " + toDisplayString(unref(attrs).maxlength), 3)
                      ], 2)) : createCommentVNode("v-if", true),
                      unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 4,
                        class: normalizeClass([
                          unref(nsInput).e("icon"),
                          unref(nsInput).e("validateIcon"),
                          unref(nsInput).is("loading", unref(validateState) === "validating")
                        ])
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true)
                ], 2),
                createCommentVNode(" append slot "),
                _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(nsInput).be("group", "append"))
                }, [
                  renderSlot(_ctx.$slots, "append")
                ], 2)) : createCommentVNode("v-if", true)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createCommentVNode(" textarea "),
                createBaseVNode("textarea", mergeProps({
                  id: unref(inputId),
                  ref_key: "textarea",
                  ref: textarea,
                  class: unref(nsTextarea).e("inner")
                }, unref(attrs), {
                  tabindex: _ctx.tabindex,
                  disabled: unref(inputDisabled),
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  style: unref(textareaStyle),
                  "aria-label": _ctx.label,
                  placeholder: _ctx.placeholder,
                  form: props.form,
                  onCompositionstart: handleCompositionStart,
                  onCompositionupdate: handleCompositionUpdate,
                  onCompositionend: handleCompositionEnd,
                  onInput: handleInput,
                  onFocus: _cache[2] || (_cache[2] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                  onBlur: _cache[3] || (_cache[3] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, _hoisted_3$q),
                unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  style: normalizeStyle(countStyle.value),
                  class: normalizeClass(unref(nsInput).e("count"))
                }, toDisplayString(unref(textLength)) + " / " + toDisplayString(unref(attrs).maxlength), 7)) : createCommentVNode("v-if", true)
              ], 64))
            ], 16, _hoisted_1$J)), [
              [vShow, _ctx.type !== "hidden"]
            ]);
          };
        }
      });
      var Input = /* @__PURE__ */ _export_sfc$1(_sfc_main$$, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
      const ElInput = withInstall(Input);
      const GAP = 4;
      const BAR_MAP = {
        vertical: {
          offset: "offsetHeight",
          scroll: "scrollTop",
          scrollSize: "scrollHeight",
          size: "height",
          key: "vertical",
          axis: "Y",
          client: "clientY",
          direction: "top"
        },
        horizontal: {
          offset: "offsetWidth",
          scroll: "scrollLeft",
          scrollSize: "scrollWidth",
          size: "width",
          key: "horizontal",
          axis: "X",
          client: "clientX",
          direction: "left"
        }
      };
      const renderThumbStyle$1 = ({
        move,
        size: size2,
        bar
      }) => ({
        [bar.size]: size2,
        transform: `translate${bar.axis}(${move}%)`
      });
      const scrollbarContextKey = Symbol("scrollbarContextKey");
      const thumbProps = buildProps({
        vertical: Boolean,
        size: String,
        move: Number,
        ratio: {
          type: Number,
          required: true
        },
        always: Boolean
      });
      const COMPONENT_NAME$5 = "Thumb";
      const _sfc_main$_ = /* @__PURE__ */ defineComponent({
        __name: "thumb",
        props: thumbProps,
        setup(__props) {
          const props = __props;
          const scrollbar = inject(scrollbarContextKey);
          const ns = useNamespace("scrollbar");
          if (!scrollbar)
            throwError(COMPONENT_NAME$5, "can not inject scrollbar context");
          const instance = ref();
          const thumb = ref();
          const thumbState = ref({});
          const visible = ref(false);
          let cursorDown = false;
          let cursorLeave = false;
          let originalOnSelectStart = isClient$1 ? document.onselectstart : null;
          const bar = computed(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
          const thumbStyle = computed(() => renderThumbStyle$1({
            size: props.size,
            move: props.move,
            bar: bar.value
          }));
          const offsetRatio = computed(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
          const clickThumbHandler = (e) => {
            var _a2;
            e.stopPropagation();
            if (e.ctrlKey || [1, 2].includes(e.button))
              return;
            (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
            startDrag(e);
            const el = e.currentTarget;
            if (!el)
              return;
            thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
          };
          const clickTrackHandler = (e) => {
            if (!thumb.value || !instance.value || !scrollbar.wrapElement)
              return;
            const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
            const thumbHalf = thumb.value[bar.value.offset] / 2;
            const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const startDrag = (e) => {
            e.stopImmediatePropagation();
            cursorDown = true;
            document.addEventListener("mousemove", mouseMoveDocumentHandler);
            document.addEventListener("mouseup", mouseUpDocumentHandler);
            originalOnSelectStart = document.onselectstart;
            document.onselectstart = () => false;
          };
          const mouseMoveDocumentHandler = (e) => {
            if (!instance.value || !thumb.value)
              return;
            if (cursorDown === false)
              return;
            const prevPage = thumbState.value[bar.value.axis];
            if (!prevPage)
              return;
            const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
            const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
            const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const mouseUpDocumentHandler = () => {
            cursorDown = false;
            thumbState.value[bar.value.axis] = 0;
            document.removeEventListener("mousemove", mouseMoveDocumentHandler);
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
            restoreOnselectstart();
            if (cursorLeave)
              visible.value = false;
          };
          const mouseMoveScrollbarHandler = () => {
            cursorLeave = false;
            visible.value = !!props.size;
          };
          const mouseLeaveScrollbarHandler = () => {
            cursorLeave = true;
            visible.value = cursorDown;
          };
          onBeforeUnmount(() => {
            restoreOnselectstart();
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
          });
          const restoreOnselectstart = () => {
            if (document.onselectstart !== originalOnSelectStart)
              document.onselectstart = originalOnSelectStart;
          };
          useEventListener$1(toRef$1(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
          useEventListener$1(toRef$1(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  ref_key: "instance",
                  ref: instance,
                  class: normalizeClass([unref(ns).e("bar"), unref(ns).is(unref(bar).key)]),
                  onMousedown: clickTrackHandler
                }, [
                  createBaseVNode("div", {
                    ref_key: "thumb",
                    ref: thumb,
                    class: normalizeClass(unref(ns).e("thumb")),
                    style: normalizeStyle(unref(thumbStyle)),
                    onMousedown: clickThumbHandler
                  }, null, 38)
                ], 34), [
                  [vShow, _ctx.always || visible.value]
                ])
              ]),
              _: 1
            }, 8, ["name"]);
          };
        }
      });
      var Thumb = /* @__PURE__ */ _export_sfc$1(_sfc_main$_, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
      const barProps = buildProps({
        always: {
          type: Boolean,
          default: true
        },
        width: String,
        height: String,
        ratioX: {
          type: Number,
          default: 1
        },
        ratioY: {
          type: Number,
          default: 1
        }
      });
      const _sfc_main$Z = /* @__PURE__ */ defineComponent({
        __name: "bar",
        props: barProps,
        setup(__props, { expose }) {
          const props = __props;
          const moveX = ref(0);
          const moveY = ref(0);
          const handleScroll = (wrap) => {
            if (wrap) {
              const offsetHeight = wrap.offsetHeight - GAP;
              const offsetWidth = wrap.offsetWidth - GAP;
              moveY.value = wrap.scrollTop * 100 / offsetHeight * props.ratioY;
              moveX.value = wrap.scrollLeft * 100 / offsetWidth * props.ratioX;
            }
          };
          expose({
            handleScroll
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(Thumb, {
                move: moveX.value,
                ratio: _ctx.ratioX,
                size: _ctx.width,
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"]),
              createVNode(Thumb, {
                move: moveY.value,
                ratio: _ctx.ratioY,
                size: _ctx.height,
                vertical: "",
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"])
            ], 64);
          };
        }
      });
      var Bar = /* @__PURE__ */ _export_sfc$1(_sfc_main$Z, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
      const scrollbarProps = buildProps({
        height: {
          type: [String, Number],
          default: ""
        },
        maxHeight: {
          type: [String, Number],
          default: ""
        },
        native: {
          type: Boolean,
          default: false
        },
        wrapStyle: {
          type: definePropType([String, Object, Array]),
          default: ""
        },
        wrapClass: {
          type: [String, Array],
          default: ""
        },
        viewClass: {
          type: [String, Array],
          default: ""
        },
        viewStyle: {
          type: [String, Array, Object],
          default: ""
        },
        noresize: Boolean,
        tag: {
          type: String,
          default: "div"
        },
        always: Boolean,
        minSize: {
          type: Number,
          default: 20
        }
      });
      const scrollbarEmits = {
        scroll: ({
          scrollTop,
          scrollLeft
        }) => [scrollTop, scrollLeft].every(isNumber)
      };
      const COMPONENT_NAME$4 = "ElScrollbar";
      const __default__$x = defineComponent({
        name: COMPONENT_NAME$4
      });
      const _sfc_main$Y = /* @__PURE__ */ defineComponent({
        ...__default__$x,
        props: scrollbarProps,
        emits: scrollbarEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const ns = useNamespace("scrollbar");
          let stopResizeObserver = void 0;
          let stopResizeListener = void 0;
          const scrollbarRef = ref();
          const wrapRef = ref();
          const resizeRef = ref();
          const sizeWidth = ref("0");
          const sizeHeight = ref("0");
          const barRef = ref();
          const ratioY = ref(1);
          const ratioX = ref(1);
          const style = computed(() => {
            const style2 = {};
            if (props.height)
              style2.height = addUnit(props.height);
            if (props.maxHeight)
              style2.maxHeight = addUnit(props.maxHeight);
            return [props.wrapStyle, style2];
          });
          const wrapKls = computed(() => {
            return [
              props.wrapClass,
              ns.e("wrap"),
              { [ns.em("wrap", "hidden-default")]: !props.native }
            ];
          });
          const resizeKls = computed(() => {
            return [ns.e("view"), props.viewClass];
          });
          const handleScroll = () => {
            var _a2;
            if (wrapRef.value) {
              (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
              emit2("scroll", {
                scrollTop: wrapRef.value.scrollTop,
                scrollLeft: wrapRef.value.scrollLeft
              });
            }
          };
          function scrollTo(arg1, arg2) {
            if (isObject$1(arg1)) {
              wrapRef.value.scrollTo(arg1);
            } else if (isNumber(arg1) && isNumber(arg2)) {
              wrapRef.value.scrollTo(arg1, arg2);
            }
          }
          const setScrollTop = (value) => {
            if (!isNumber(value)) {
              return;
            }
            wrapRef.value.scrollTop = value;
          };
          const setScrollLeft = (value) => {
            if (!isNumber(value)) {
              return;
            }
            wrapRef.value.scrollLeft = value;
          };
          const update = () => {
            if (!wrapRef.value)
              return;
            const offsetHeight = wrapRef.value.offsetHeight - GAP;
            const offsetWidth = wrapRef.value.offsetWidth - GAP;
            const originalHeight = offsetHeight ** 2 / wrapRef.value.scrollHeight;
            const originalWidth = offsetWidth ** 2 / wrapRef.value.scrollWidth;
            const height = Math.max(originalHeight, props.minSize);
            const width = Math.max(originalWidth, props.minSize);
            ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
            ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
            sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
            sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
          };
          watch(() => props.noresize, (noresize) => {
            if (noresize) {
              stopResizeObserver == null ? void 0 : stopResizeObserver();
              stopResizeListener == null ? void 0 : stopResizeListener();
            } else {
              ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update));
              stopResizeListener = useEventListener$1("resize", update);
            }
          }, { immediate: true });
          watch(() => [props.maxHeight, props.height], () => {
            if (!props.native)
              nextTick(() => {
                var _a2;
                update();
                if (wrapRef.value) {
                  (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
                }
              });
          });
          provide(scrollbarContextKey, reactive({
            scrollbarElement: scrollbarRef,
            wrapElement: wrapRef
          }));
          onMounted(() => {
            if (!props.native)
              nextTick(() => {
                update();
              });
          });
          onUpdated(() => update());
          expose({
            wrapRef,
            update,
            scrollTo,
            setScrollTop,
            setScrollLeft,
            handleScroll
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "scrollbarRef",
              ref: scrollbarRef,
              class: normalizeClass(unref(ns).b())
            }, [
              createBaseVNode("div", {
                ref_key: "wrapRef",
                ref: wrapRef,
                class: normalizeClass(unref(wrapKls)),
                style: normalizeStyle(unref(style)),
                onScroll: handleScroll
              }, [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
                  ref_key: "resizeRef",
                  ref: resizeRef,
                  class: normalizeClass(unref(resizeKls)),
                  style: normalizeStyle(_ctx.viewStyle)
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["class", "style"]))
              ], 38),
              !_ctx.native ? (openBlock(), createBlock(Bar, {
                key: 0,
                ref_key: "barRef",
                ref: barRef,
                height: sizeHeight.value,
                width: sizeWidth.value,
                always: _ctx.always,
                "ratio-x": ratioX.value,
                "ratio-y": ratioY.value
              }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"])) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Scrollbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$Y, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);
      const ElScrollbar = withInstall(Scrollbar);
      const POPPER_INJECTION_KEY = Symbol("popper");
      const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
      const roleTypes = [
        "dialog",
        "grid",
        "group",
        "listbox",
        "menu",
        "navigation",
        "tooltip",
        "tree"
      ];
      const popperProps = buildProps({
        role: {
          type: String,
          values: roleTypes,
          default: "tooltip"
        }
      });
      const __default__$w = defineComponent({
        name: "ElPopper",
        inheritAttrs: false
      });
      const _sfc_main$X = /* @__PURE__ */ defineComponent({
        ...__default__$w,
        props: popperProps,
        setup(__props, { expose }) {
          const props = __props;
          const triggerRef2 = ref();
          const popperInstanceRef = ref();
          const contentRef = ref();
          const referenceRef = ref();
          const role = computed(() => props.role);
          const popperProvides = {
            triggerRef: triggerRef2,
            popperInstanceRef,
            contentRef,
            referenceRef,
            role
          };
          expose(popperProvides);
          provide(POPPER_INJECTION_KEY, popperProvides);
          return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
          };
        }
      });
      var Popper = /* @__PURE__ */ _export_sfc$1(_sfc_main$X, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
      const popperArrowProps = buildProps({
        arrowOffset: {
          type: Number,
          default: 5
        }
      });
      const __default__$v = defineComponent({
        name: "ElPopperArrow",
        inheritAttrs: false
      });
      const _sfc_main$W = /* @__PURE__ */ defineComponent({
        ...__default__$v,
        props: popperArrowProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("popper");
          const { arrowOffset, arrowRef, arrowStyle } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
          watch(() => props.arrowOffset, (val) => {
            arrowOffset.value = val;
          });
          onBeforeUnmount(() => {
            arrowRef.value = void 0;
          });
          expose({
            arrowRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              ref_key: "arrowRef",
              ref: arrowRef,
              class: normalizeClass(unref(ns).e("arrow")),
              style: normalizeStyle(unref(arrowStyle)),
              "data-popper-arrow": ""
            }, null, 6);
          };
        }
      });
      var ElPopperArrow = /* @__PURE__ */ _export_sfc$1(_sfc_main$W, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
      const NAME = "ElOnlyChild";
      const OnlyChild = defineComponent({
        name: NAME,
        setup(_, {
          slots,
          attrs
        }) {
          var _a2;
          const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
          const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
          return () => {
            var _a22;
            const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
            if (!defaultSlot)
              return null;
            if (defaultSlot.length > 1) {
              return null;
            }
            const firstLegitNode = findFirstLegitChild(defaultSlot);
            if (!firstLegitNode) {
              return null;
            }
            return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
          };
        }
      });
      function findFirstLegitChild(node) {
        if (!node)
          return null;
        const children = node;
        for (const child of children) {
          if (isObject$1(child)) {
            switch (child.type) {
              case Comment:
                continue;
              case Text:
              case "svg":
                return wrapTextContent(child);
              case Fragment:
                return findFirstLegitChild(child.children);
              default:
                return child;
            }
          }
          return wrapTextContent(child);
        }
        return null;
      }
      function wrapTextContent(s) {
        const ns = useNamespace("only-child");
        return createVNode("span", {
          "class": ns.e("content")
        }, [s]);
      }
      const popperTriggerProps = buildProps({
        virtualRef: {
          type: definePropType(Object)
        },
        virtualTriggering: Boolean,
        onMouseenter: {
          type: definePropType(Function)
        },
        onMouseleave: {
          type: definePropType(Function)
        },
        onClick: {
          type: definePropType(Function)
        },
        onKeydown: {
          type: definePropType(Function)
        },
        onFocus: {
          type: definePropType(Function)
        },
        onBlur: {
          type: definePropType(Function)
        },
        onContextmenu: {
          type: definePropType(Function)
        },
        id: String,
        open: Boolean
      });
      const __default__$u = defineComponent({
        name: "ElPopperTrigger",
        inheritAttrs: false
      });
      const _sfc_main$V = /* @__PURE__ */ defineComponent({
        ...__default__$u,
        props: popperTriggerProps,
        setup(__props, { expose }) {
          const props = __props;
          const { role, triggerRef: triggerRef2 } = inject(POPPER_INJECTION_KEY, void 0);
          useForwardRef(triggerRef2);
          const ariaControls = computed(() => {
            return ariaHaspopup.value ? props.id : void 0;
          });
          const ariaDescribedby = computed(() => {
            if (role && role.value === "tooltip") {
              return props.open && props.id ? props.id : void 0;
            }
            return void 0;
          });
          const ariaHaspopup = computed(() => {
            if (role && role.value !== "tooltip") {
              return role.value;
            }
            return void 0;
          });
          const ariaExpanded = computed(() => {
            return ariaHaspopup.value ? `${props.open}` : void 0;
          });
          let virtualTriggerAriaStopWatch = void 0;
          onMounted(() => {
            watch(() => props.virtualRef, (virtualEl) => {
              if (virtualEl) {
                triggerRef2.value = unrefElement$1(virtualEl);
              }
            }, {
              immediate: true
            });
            watch(triggerRef2, (el, prevEl) => {
              virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
              virtualTriggerAriaStopWatch = void 0;
              if (isElement(el)) {
                [
                  "onMouseenter",
                  "onMouseleave",
                  "onClick",
                  "onKeydown",
                  "onFocus",
                  "onBlur",
                  "onContextmenu"
                ].forEach((eventName) => {
                  var _a2;
                  const handler = props[eventName];
                  if (handler) {
                    el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                    (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                  }
                });
                virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                  [
                    "aria-controls",
                    "aria-describedby",
                    "aria-haspopup",
                    "aria-expanded"
                  ].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (isElement(prevEl)) {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key) => prevEl.removeAttribute(key));
              }
            }, {
              immediate: true
            });
          });
          onBeforeUnmount(() => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
          });
          expose({
            triggerRef: triggerRef2
          });
          return (_ctx, _cache) => {
            return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
              "aria-controls": unref(ariaControls),
              "aria-describedby": unref(ariaDescribedby),
              "aria-expanded": unref(ariaExpanded),
              "aria-haspopup": unref(ariaHaspopup)
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
          };
        }
      });
      var ElPopperTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$V, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
      const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
      const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
      const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
      const FOCUS_AFTER_TRAPPED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const FOCUSOUT_PREVENTED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
      const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
      const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
      const focusReason = ref();
      const lastUserFocusTimestamp = ref(0);
      const lastAutomatedFocusTimestamp = ref(0);
      let focusReasonUserCount = 0;
      const obtainAllFocusableElements = (element) => {
        const nodes = [];
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (node) => {
            const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
            if (node.disabled || node.hidden || isHiddenInput)
              return NodeFilter.FILTER_SKIP;
            return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          }
        });
        while (walker.nextNode())
          nodes.push(walker.currentNode);
        return nodes;
      };
      const getVisibleElement = (elements, container) => {
        for (const element of elements) {
          if (!isHidden(element, container))
            return element;
        }
      };
      const isHidden = (element, container) => {
        if (getComputedStyle(element).visibility === "hidden")
          return true;
        while (element) {
          if (container && element === container)
            return false;
          if (getComputedStyle(element).display === "none")
            return true;
          element = element.parentElement;
        }
        return false;
      };
      const getEdges = (container) => {
        const focusable = obtainAllFocusableElements(container);
        const first = getVisibleElement(focusable, container);
        const last = getVisibleElement(focusable.reverse(), container);
        return [first, last];
      };
      const isSelectable = (element) => {
        return element instanceof HTMLInputElement && "select" in element;
      };
      const tryFocus = (element, shouldSelect) => {
        if (element && element.focus) {
          const prevFocusedElement = document.activeElement;
          element.focus({ preventScroll: true });
          lastAutomatedFocusTimestamp.value = window.performance.now();
          if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
            element.select();
          }
        }
      };
      function removeFromStack(list, item) {
        const copy = [...list];
        const idx = list.indexOf(item);
        if (idx !== -1) {
          copy.splice(idx, 1);
        }
        return copy;
      }
      const createFocusableStack = () => {
        let stack = [];
        const push = (layer) => {
          const currentLayer = stack[0];
          if (currentLayer && layer !== currentLayer) {
            currentLayer.pause();
          }
          stack = removeFromStack(stack, layer);
          stack.unshift(layer);
        };
        const remove2 = (layer) => {
          var _a2, _b;
          stack = removeFromStack(stack, layer);
          (_b = (_a2 = stack[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
        };
        return {
          push,
          remove: remove2
        };
      };
      const focusFirstDescendant = (elements, shouldSelect = false) => {
        const prevFocusedElement = document.activeElement;
        for (const element of elements) {
          tryFocus(element, shouldSelect);
          if (document.activeElement !== prevFocusedElement)
            return;
        }
      };
      const focusableStack = createFocusableStack();
      const isFocusCausedByUserEvent = () => {
        return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
      };
      const notifyFocusReasonPointer = () => {
        focusReason.value = "pointer";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const notifyFocusReasonKeydown = () => {
        focusReason.value = "keyboard";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const useFocusReason = () => {
        onMounted(() => {
          if (focusReasonUserCount === 0) {
            document.addEventListener("mousedown", notifyFocusReasonPointer);
            document.addEventListener("touchstart", notifyFocusReasonPointer);
            document.addEventListener("keydown", notifyFocusReasonKeydown);
          }
          focusReasonUserCount++;
        });
        onBeforeUnmount(() => {
          focusReasonUserCount--;
          if (focusReasonUserCount <= 0) {
            document.removeEventListener("mousedown", notifyFocusReasonPointer);
            document.removeEventListener("touchstart", notifyFocusReasonPointer);
            document.removeEventListener("keydown", notifyFocusReasonKeydown);
          }
        });
        return {
          focusReason,
          lastUserFocusTimestamp,
          lastAutomatedFocusTimestamp
        };
      };
      const createFocusOutPreventedEvent = (detail) => {
        return new CustomEvent(FOCUSOUT_PREVENTED, {
          ...FOCUSOUT_PREVENTED_OPTS,
          detail
        });
      };
      const _sfc_main$U = defineComponent({
        name: "ElFocusTrap",
        inheritAttrs: false,
        props: {
          loop: Boolean,
          trapped: Boolean,
          focusTrapEl: Object,
          focusStartEl: {
            type: [Object, String],
            default: "first"
          }
        },
        emits: [
          ON_TRAP_FOCUS_EVT,
          ON_RELEASE_FOCUS_EVT,
          "focusin",
          "focusout",
          "focusout-prevented",
          "release-requested"
        ],
        setup(props, { emit: emit2 }) {
          const forwardRef = ref();
          let lastFocusBeforeTrapped;
          let lastFocusAfterTrapped;
          const { focusReason: focusReason2 } = useFocusReason();
          useEscapeKeydown((event) => {
            if (props.trapped && !focusLayer.paused) {
              emit2("release-requested", event);
            }
          });
          const focusLayer = {
            paused: false,
            pause() {
              this.paused = true;
            },
            resume() {
              this.paused = false;
            }
          };
          const onKeydown = (e) => {
            if (!props.loop && !props.trapped)
              return;
            if (focusLayer.paused)
              return;
            const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
            const { loop } = props;
            const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
            const currentFocusingEl = document.activeElement;
            if (isTabbing && currentFocusingEl) {
              const container = currentTarget;
              const [first, last] = getEdges(container);
              const isTabbable = first && last;
              if (!isTabbable) {
                if (currentFocusingEl === container) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                  }
                }
              } else {
                if (!shiftKey && currentFocusingEl === last) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                    if (loop)
                      tryFocus(first, true);
                  }
                } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                    if (loop)
                      tryFocus(last, true);
                  }
                }
              }
            }
          };
          provide(FOCUS_TRAP_INJECTION_KEY, {
            focusTrapRef: forwardRef,
            onKeydown
          });
          watch(() => props.focusTrapEl, (focusTrapEl) => {
            if (focusTrapEl) {
              forwardRef.value = focusTrapEl;
            }
          }, { immediate: true });
          watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
            if (forwardRef2) {
              forwardRef2.addEventListener("keydown", onKeydown);
              forwardRef2.addEventListener("focusin", onFocusIn);
              forwardRef2.addEventListener("focusout", onFocusOut);
            }
            if (oldForwardRef) {
              oldForwardRef.removeEventListener("keydown", onKeydown);
              oldForwardRef.removeEventListener("focusin", onFocusIn);
              oldForwardRef.removeEventListener("focusout", onFocusOut);
            }
          });
          const trapOnFocus = (e) => {
            emit2(ON_TRAP_FOCUS_EVT, e);
          };
          const releaseOnFocus = (e) => emit2(ON_RELEASE_FOCUS_EVT, e);
          const onFocusIn = (e) => {
            const trapContainer = unref(forwardRef);
            if (!trapContainer)
              return;
            const target = e.target;
            const relatedTarget = e.relatedTarget;
            const isFocusedInTrap = target && trapContainer.contains(target);
            if (!props.trapped) {
              const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
              if (!isPrevFocusedInTrap) {
                lastFocusBeforeTrapped = relatedTarget;
              }
            }
            if (isFocusedInTrap)
              emit2("focusin", e);
            if (focusLayer.paused)
              return;
            if (props.trapped) {
              if (isFocusedInTrap) {
                lastFocusAfterTrapped = target;
              } else {
                tryFocus(lastFocusAfterTrapped, true);
              }
            }
          };
          const onFocusOut = (e) => {
            const trapContainer = unref(forwardRef);
            if (focusLayer.paused || !trapContainer)
              return;
            if (props.trapped) {
              const relatedTarget = e.relatedTarget;
              if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
                setTimeout(() => {
                  if (!focusLayer.paused && props.trapped) {
                    const focusoutPreventedEvent = createFocusOutPreventedEvent({
                      focusReason: focusReason2.value
                    });
                    emit2("focusout-prevented", focusoutPreventedEvent);
                    if (!focusoutPreventedEvent.defaultPrevented) {
                      tryFocus(lastFocusAfterTrapped, true);
                    }
                  }
                }, 0);
              }
            } else {
              const target = e.target;
              const isFocusedInTrap = target && trapContainer.contains(target);
              if (!isFocusedInTrap)
                emit2("focusout", e);
            }
          };
          async function startTrap() {
            await nextTick();
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              focusableStack.push(focusLayer);
              const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
              lastFocusBeforeTrapped = prevFocusedElement;
              const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
              if (!isPrevFocusContained) {
                const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
                trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
                trapContainer.dispatchEvent(focusEvent);
                if (!focusEvent.defaultPrevented) {
                  nextTick(() => {
                    let focusStartEl = props.focusStartEl;
                    if (!isString$1(focusStartEl)) {
                      tryFocus(focusStartEl);
                      if (document.activeElement !== focusStartEl) {
                        focusStartEl = "first";
                      }
                    }
                    if (focusStartEl === "first") {
                      focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                    }
                    if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                      tryFocus(trapContainer);
                    }
                  });
                }
              }
            }
          }
          function stopTrap() {
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
              const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
                ...FOCUS_AFTER_TRAPPED_OPTS,
                detail: {
                  focusReason: focusReason2.value
                }
              });
              trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              trapContainer.dispatchEvent(releasedEvent);
              if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
                tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
              }
              trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus);
              focusableStack.remove(focusLayer);
            }
          }
          onMounted(() => {
            if (props.trapped) {
              startTrap();
            }
            watch(() => props.trapped, (trapped) => {
              if (trapped) {
                startTrap();
              } else {
                stopTrap();
              }
            });
          });
          onBeforeUnmount(() => {
            if (props.trapped) {
              stopTrap();
            }
          });
          return {
            onKeydown
          };
        }
      });
      function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
      }
      var ElFocusTrap = /* @__PURE__ */ _export_sfc$1(_sfc_main$U, [["render", _sfc_render$h], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);
      const POSITIONING_STRATEGIES = ["fixed", "absolute"];
      const popperCoreConfigProps = buildProps({
        boundariesPadding: {
          type: Number,
          default: 0
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: void 0
        },
        gpuAcceleration: {
          type: Boolean,
          default: true
        },
        offset: {
          type: Number,
          default: 12
        },
        placement: {
          type: String,
          values: Ee,
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        strategy: {
          type: String,
          values: POSITIONING_STRATEGIES,
          default: "absolute"
        }
      });
      const popperContentProps = buildProps({
        ...popperCoreConfigProps,
        id: String,
        style: {
          type: definePropType([String, Array, Object])
        },
        className: {
          type: definePropType([String, Array, Object])
        },
        effect: {
          type: String,
          default: "dark"
        },
        visible: Boolean,
        enterable: {
          type: Boolean,
          default: true
        },
        pure: Boolean,
        focusOnShow: {
          type: Boolean,
          default: false
        },
        trapping: {
          type: Boolean,
          default: false
        },
        popperClass: {
          type: definePropType([String, Array, Object])
        },
        popperStyle: {
          type: definePropType([String, Array, Object])
        },
        referenceEl: {
          type: definePropType(Object)
        },
        triggerTargetEl: {
          type: definePropType(Object)
        },
        stopPopperMouseEvent: {
          type: Boolean,
          default: true
        },
        ariaLabel: {
          type: String,
          default: void 0
        },
        virtualTriggering: Boolean,
        zIndex: Number
      });
      const popperContentEmits = {
        mouseenter: (evt) => evt instanceof MouseEvent,
        mouseleave: (evt) => evt instanceof MouseEvent,
        focus: () => true,
        blur: () => true,
        close: () => true
      };
      const buildPopperOptions = (props, modifiers = []) => {
        const { placement, strategy, popperOptions } = props;
        const options = {
          placement,
          strategy,
          ...popperOptions,
          modifiers: [...genModifiers(props), ...modifiers]
        };
        deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
        return options;
      };
      const unwrapMeasurableEl = ($el) => {
        if (!isClient$1)
          return;
        return unrefElement$1($el);
      };
      function genModifiers(options) {
        const { offset, gpuAcceleration, fallbackPlacements } = options;
        return [
          {
            name: "offset",
            options: {
              offset: [0, offset != null ? offset : 12]
            }
          },
          {
            name: "preventOverflow",
            options: {
              padding: {
                top: 2,
                bottom: 2,
                left: 5,
                right: 5
              }
            }
          },
          {
            name: "flip",
            options: {
              padding: 5,
              fallbackPlacements
            }
          },
          {
            name: "computeStyles",
            options: {
              gpuAcceleration
            }
          }
        ];
      }
      function deriveExtraModifiers(options, modifiers) {
        if (modifiers) {
          options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
        }
      }
      const DEFAULT_ARROW_OFFSET = 0;
      const usePopperContent = (props) => {
        const { popperInstanceRef, contentRef, triggerRef: triggerRef2, role } = inject(POPPER_INJECTION_KEY, void 0);
        const arrowRef = ref();
        const arrowOffset = ref();
        const eventListenerModifier = computed(() => {
          return {
            name: "eventListeners",
            enabled: !!props.visible
          };
        });
        const arrowModifier = computed(() => {
          var _a2;
          const arrowEl = unref(arrowRef);
          const offset = (_a2 = unref(arrowOffset)) != null ? _a2 : DEFAULT_ARROW_OFFSET;
          return {
            name: "arrow",
            enabled: !isUndefined$1(arrowEl),
            options: {
              element: arrowEl,
              padding: offset
            }
          };
        });
        const options = computed(() => {
          return {
            onFirstUpdate: () => {
              update();
            },
            ...buildPopperOptions(props, [
              unref(arrowModifier),
              unref(eventListenerModifier)
            ])
          };
        });
        const computedReference = computed(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef2));
        const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options);
        watch(instanceRef, (instance) => popperInstanceRef.value = instance);
        onMounted(() => {
          watch(() => {
            var _a2;
            return (_a2 = unref(computedReference)) == null ? void 0 : _a2.getBoundingClientRect();
          }, () => {
            update();
          });
        });
        return {
          attributes,
          arrowRef,
          contentRef,
          instanceRef,
          state,
          styles,
          role,
          forceUpdate,
          update
        };
      };
      const usePopperContentDOM = (props, {
        attributes,
        styles,
        role
      }) => {
        const { nextZIndex } = useZIndex();
        const ns = useNamespace("popper");
        const contentAttrs = computed(() => unref(attributes).popper);
        const contentZIndex = ref(props.zIndex || nextZIndex());
        const contentClass = computed(() => [
          ns.b(),
          ns.is("pure", props.pure),
          ns.is(props.effect),
          props.popperClass
        ]);
        const contentStyle = computed(() => {
          return [
            { zIndex: unref(contentZIndex) },
            unref(styles).popper,
            props.popperStyle || {}
          ];
        });
        const ariaModal = computed(() => role.value === "dialog" ? "false" : void 0);
        const arrowStyle = computed(() => unref(styles).arrow || {});
        const updateZIndex = () => {
          contentZIndex.value = props.zIndex || nextZIndex();
        };
        return {
          ariaModal,
          arrowStyle,
          contentAttrs,
          contentClass,
          contentStyle,
          contentZIndex,
          updateZIndex
        };
      };
      const usePopperContentFocusTrap = (props, emit2) => {
        const trapped = ref(false);
        const focusStartRef = ref();
        const onFocusAfterTrapped = () => {
          emit2("focus");
        };
        const onFocusAfterReleased = (event) => {
          var _a2;
          if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) !== "pointer") {
            focusStartRef.value = "first";
            emit2("blur");
          }
        };
        const onFocusInTrap = (event) => {
          if (props.visible && !trapped.value) {
            if (event.target) {
              focusStartRef.value = event.target;
            }
            trapped.value = true;
          }
        };
        const onFocusoutPrevented = (event) => {
          if (!props.trapping) {
            if (event.detail.focusReason === "pointer") {
              event.preventDefault();
            }
            trapped.value = false;
          }
        };
        const onReleaseRequested = () => {
          trapped.value = false;
          emit2("close");
        };
        return {
          focusStartRef,
          trapped,
          onFocusAfterReleased,
          onFocusAfterTrapped,
          onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        };
      };
      const __default__$t = defineComponent({
        name: "ElPopperContent"
      });
      const _sfc_main$T = /* @__PURE__ */ defineComponent({
        ...__default__$t,
        props: popperContentProps,
        emits: popperContentEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const {
            focusStartRef,
            trapped,
            onFocusAfterReleased,
            onFocusAfterTrapped,
            onFocusInTrap,
            onFocusoutPrevented,
            onReleaseRequested
          } = usePopperContentFocusTrap(props, emit2);
          const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props);
          const {
            ariaModal,
            arrowStyle,
            contentAttrs,
            contentClass,
            contentStyle,
            updateZIndex
          } = usePopperContentDOM(props, {
            styles,
            attributes,
            role
          });
          const formItemContext = inject(formItemContextKey, void 0);
          const arrowOffset = ref();
          provide(POPPER_CONTENT_INJECTION_KEY, {
            arrowStyle,
            arrowRef,
            arrowOffset
          });
          if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) {
            provide(formItemContextKey, {
              ...formItemContext,
              addInputId: NOOP,
              removeInputId: NOOP
            });
          }
          let triggerTargetAriaStopWatch = void 0;
          const updatePopper = (shouldUpdateZIndex = true) => {
            update();
            shouldUpdateZIndex && updateZIndex();
          };
          const togglePopperAlive = () => {
            updatePopper(false);
            if (props.visible && props.focusOnShow) {
              trapped.value = true;
            } else if (props.visible === false) {
              trapped.value = false;
            }
          };
          onMounted(() => {
            watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
              triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
              triggerTargetAriaStopWatch = void 0;
              const el = unref(triggerTargetEl || contentRef.value);
              const prevEl = unref(prevTriggerTargetEl || contentRef.value);
              if (isElement(el)) {
                triggerTargetAriaStopWatch = watch([role, () => props.ariaLabel, ariaModal, () => props.id], (watches) => {
                  ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (prevEl !== el && isElement(prevEl)) {
                ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                  prevEl.removeAttribute(key);
                });
              }
            }, { immediate: true });
            watch(() => props.visible, togglePopperAlive, { immediate: true });
          });
          onBeforeUnmount(() => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
          });
          expose({
            popperContentRef: contentRef,
            popperInstanceRef: instanceRef,
            updatePopper,
            contentStyle
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", mergeProps({
              ref_key: "contentRef",
              ref: contentRef
            }, unref(contentAttrs), {
              style: unref(contentStyle),
              class: unref(contentClass),
              tabindex: "-1",
              onMouseenter: _cache[0] || (_cache[0] = (e) => _ctx.$emit("mouseenter", e)),
              onMouseleave: _cache[1] || (_cache[1] = (e) => _ctx.$emit("mouseleave", e))
            }), [
              createVNode(unref(ElFocusTrap), {
                trapped: unref(trapped),
                "trap-on-focus-in": true,
                "focus-trap-el": unref(contentRef),
                "focus-start-el": unref(focusStartRef),
                onFocusAfterTrapped: unref(onFocusAfterTrapped),
                onFocusAfterReleased: unref(onFocusAfterReleased),
                onFocusin: unref(onFocusInTrap),
                onFocusoutPrevented: unref(onFocusoutPrevented),
                onReleaseRequested: unref(onReleaseRequested)
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
            ], 16);
          };
        }
      });
      var ElPopperContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$T, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
      const ElPopper = withInstall(Popper);
      const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
      const useTooltipContentProps = buildProps({
        ...useDelayedToggleProps,
        ...popperContentProps,
        appendTo: {
          type: definePropType([String, Object])
        },
        content: {
          type: String,
          default: ""
        },
        rawContent: {
          type: Boolean,
          default: false
        },
        persistent: Boolean,
        ariaLabel: String,
        visible: {
          type: definePropType(Boolean),
          default: null
        },
        transition: String,
        teleported: {
          type: Boolean,
          default: true
        },
        disabled: Boolean
      });
      const useTooltipTriggerProps = buildProps({
        ...popperTriggerProps,
        disabled: Boolean,
        trigger: {
          type: definePropType([String, Array]),
          default: "hover"
        },
        triggerKeys: {
          type: definePropType(Array),
          default: () => [EVENT_CODE.enter, EVENT_CODE.space]
        }
      });
      const {
        useModelToggleProps: useTooltipModelToggleProps,
        useModelToggleEmits: useTooltipModelToggleEmits,
        useModelToggle: useTooltipModelToggle
      } = createModelToggleComposable("visible");
      const useTooltipProps = buildProps({
        ...popperProps,
        ...useTooltipModelToggleProps,
        ...useTooltipContentProps,
        ...useTooltipTriggerProps,
        ...popperArrowProps,
        showArrow: {
          type: Boolean,
          default: true
        }
      });
      const tooltipEmits = [
        ...useTooltipModelToggleEmits,
        "before-show",
        "before-hide",
        "show",
        "hide",
        "open",
        "close"
      ];
      const isTriggerType = (trigger2, type2) => {
        if (isArray$2(trigger2)) {
          return trigger2.includes(type2);
        }
        return trigger2 === type2;
      };
      const whenTrigger = (trigger2, type2, handler) => {
        return (e) => {
          isTriggerType(unref(trigger2), type2) && handler(e);
        };
      };
      const __default__$s = defineComponent({
        name: "ElTooltipTrigger"
      });
      const _sfc_main$S = /* @__PURE__ */ defineComponent({
        ...__default__$s,
        props: useTooltipTriggerProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("tooltip");
          const { controlled, id: id2, open: open2, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const triggerRef2 = ref(null);
          const stopWhenControlledOrDisabled = () => {
            if (unref(controlled) || props.disabled) {
              return true;
            }
          };
          const trigger2 = toRef$1(props, "trigger");
          const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onOpen));
          const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onClose));
          const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "click", (e) => {
            if (e.button === 0) {
              onToggle(e);
            }
          }));
          const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onOpen));
          const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onClose));
          const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "contextmenu", (e) => {
            e.preventDefault();
            onToggle(e);
          }));
          const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
            const { code } = e;
            if (props.triggerKeys.includes(code)) {
              e.preventDefault();
              onToggle(e);
            }
          });
          expose({
            triggerRef: triggerRef2
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopperTrigger), {
              id: unref(id2),
              "virtual-ref": _ctx.virtualRef,
              open: unref(open2),
              "virtual-triggering": _ctx.virtualTriggering,
              class: normalizeClass(unref(ns).e("trigger")),
              onBlur: unref(onBlur),
              onClick: unref(onClick),
              onContextmenu: unref(onContextMenu),
              onFocus: unref(onFocus),
              onMouseenter: unref(onMouseenter),
              onMouseleave: unref(onMouseleave),
              onKeydown: unref(onKeydown)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
          };
        }
      });
      var ElTooltipTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$S, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
      const __default__$r = defineComponent({
        name: "ElTooltipContent",
        inheritAttrs: false
      });
      const _sfc_main$R = /* @__PURE__ */ defineComponent({
        ...__default__$r,
        props: useTooltipContentProps,
        setup(__props, { expose }) {
          const props = __props;
          const { selector } = usePopperContainerId();
          const ns = useNamespace("tooltip");
          const contentRef = ref(null);
          const destroyed = ref(false);
          const {
            controlled,
            id: id2,
            open: open2,
            trigger: trigger2,
            onClose,
            onOpen,
            onShow,
            onHide,
            onBeforeShow,
            onBeforeHide
          } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const transitionClass = computed(() => {
            return props.transition || `${ns.namespace.value}-fade-in-linear`;
          });
          const persistentRef = computed(() => {
            return props.persistent;
          });
          onBeforeUnmount(() => {
            destroyed.value = true;
          });
          const shouldRender = computed(() => {
            return unref(persistentRef) ? true : unref(open2);
          });
          const shouldShow = computed(() => {
            return props.disabled ? false : unref(open2);
          });
          const appendTo = computed(() => {
            return props.appendTo || selector.value;
          });
          const contentStyle = computed(() => {
            var _a2;
            return (_a2 = props.style) != null ? _a2 : {};
          });
          const ariaHidden = computed(() => !unref(open2));
          const onTransitionLeave = () => {
            onHide();
          };
          const stopWhenControlled = () => {
            if (unref(controlled))
              return true;
          };
          const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
            if (props.enterable && unref(trigger2) === "hover") {
              onOpen();
            }
          });
          const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
            if (unref(trigger2) === "hover") {
              onClose();
            }
          });
          const onBeforeEnter = () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            onBeforeShow == null ? void 0 : onBeforeShow();
          };
          const onBeforeLeave = () => {
            onBeforeHide == null ? void 0 : onBeforeHide();
          };
          const onAfterShow = () => {
            onShow();
            stopHandle = onClickOutside(computed(() => {
              var _a2;
              return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
            }), () => {
              if (unref(controlled))
                return;
              const $trigger = unref(trigger2);
              if ($trigger !== "hover") {
                onClose();
              }
            });
          };
          const onBlur = () => {
            if (!props.virtualTriggering) {
              onClose();
            }
          };
          let stopHandle;
          watch(() => unref(open2), (val) => {
            if (!val) {
              stopHandle == null ? void 0 : stopHandle();
            }
          }, {
            flush: "post"
          });
          watch(() => props.content, () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          });
          expose({
            contentRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              disabled: !_ctx.teleported,
              to: unref(appendTo)
            }, [
              createVNode(Transition, {
                name: unref(transitionClass),
                onAfterLeave: onTransitionLeave,
                onBeforeEnter,
                onAfterEnter: onAfterShow,
                onBeforeLeave
              }, {
                default: withCtx(() => [
                  unref(shouldRender) ? withDirectives((openBlock(), createBlock(unref(ElPopperContent), mergeProps({
                    key: 0,
                    id: unref(id2),
                    ref_key: "contentRef",
                    ref: contentRef
                  }, _ctx.$attrs, {
                    "aria-label": _ctx.ariaLabel,
                    "aria-hidden": unref(ariaHidden),
                    "boundaries-padding": _ctx.boundariesPadding,
                    "fallback-placements": _ctx.fallbackPlacements,
                    "gpu-acceleration": _ctx.gpuAcceleration,
                    offset: _ctx.offset,
                    placement: _ctx.placement,
                    "popper-options": _ctx.popperOptions,
                    strategy: _ctx.strategy,
                    effect: _ctx.effect,
                    enterable: _ctx.enterable,
                    pure: _ctx.pure,
                    "popper-class": _ctx.popperClass,
                    "popper-style": [_ctx.popperStyle, unref(contentStyle)],
                    "reference-el": _ctx.referenceEl,
                    "trigger-target-el": _ctx.triggerTargetEl,
                    visible: unref(shouldShow),
                    "z-index": _ctx.zIndex,
                    onMouseenter: unref(onContentEnter),
                    onMouseleave: unref(onContentLeave),
                    onBlur,
                    onClose: unref(onClose)
                  }), {
                    default: withCtx(() => [
                      !destroyed.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                    ]),
                    _: 3
                  }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
                    [vShow, unref(shouldShow)]
                  ]) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["name"])
            ], 8, ["disabled", "to"]);
          };
        }
      });
      var ElTooltipContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$R, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
      const _hoisted_1$I = ["innerHTML"];
      const _hoisted_2$y = { key: 1 };
      const __default__$q = defineComponent({
        name: "ElTooltip"
      });
      const _sfc_main$Q = /* @__PURE__ */ defineComponent({
        ...__default__$q,
        props: useTooltipProps,
        emits: tooltipEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          usePopperContainer();
          const id2 = useId();
          const popperRef = ref();
          const contentRef = ref();
          const updatePopper = () => {
            var _a2;
            const popperComponent = unref(popperRef);
            if (popperComponent) {
              (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
            }
          };
          const open2 = ref(false);
          const toggleReason = ref();
          const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
            indicator: open2,
            toggleReason
          });
          const { onOpen, onClose } = useDelayedToggle({
            showAfter: toRef$1(props, "showAfter"),
            hideAfter: toRef$1(props, "hideAfter"),
            autoClose: toRef$1(props, "autoClose"),
            open: show,
            close: hide
          });
          const controlled = computed(() => isBoolean(props.visible) && !hasUpdateHandler.value);
          provide(TOOLTIP_INJECTION_KEY, {
            controlled,
            id: id2,
            open: readonly(open2),
            trigger: toRef$1(props, "trigger"),
            onOpen: (event) => {
              onOpen(event);
            },
            onClose: (event) => {
              onClose(event);
            },
            onToggle: (event) => {
              if (unref(open2)) {
                onClose(event);
              } else {
                onOpen(event);
              }
            },
            onShow: () => {
              emit2("show", toggleReason.value);
            },
            onHide: () => {
              emit2("hide", toggleReason.value);
            },
            onBeforeShow: () => {
              emit2("before-show", toggleReason.value);
            },
            onBeforeHide: () => {
              emit2("before-hide", toggleReason.value);
            },
            updatePopper
          });
          watch(() => props.disabled, (disabled) => {
            if (disabled && open2.value) {
              open2.value = false;
            }
          });
          const isFocusInsideContent = () => {
            var _a2, _b;
            const popperContent = (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.contentRef) == null ? void 0 : _b.popperContentRef;
            return popperContent && popperContent.contains(document.activeElement);
          };
          onDeactivated(() => open2.value && hide());
          expose({
            popperRef,
            contentRef,
            isFocusInsideContent,
            updatePopper,
            onOpen,
            onClose,
            hide
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopper), {
              ref_key: "popperRef",
              ref: popperRef,
              role: _ctx.role
            }, {
              default: withCtx(() => [
                createVNode(ElTooltipTrigger, {
                  disabled: _ctx.disabled,
                  trigger: _ctx.trigger,
                  "trigger-keys": _ctx.triggerKeys,
                  "virtual-ref": _ctx.virtualRef,
                  "virtual-triggering": _ctx.virtualTriggering
                }, {
                  default: withCtx(() => [
                    _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
                createVNode(ElTooltipContent, {
                  ref_key: "contentRef",
                  ref: contentRef,
                  "aria-label": _ctx.ariaLabel,
                  "boundaries-padding": _ctx.boundariesPadding,
                  content: _ctx.content,
                  disabled: _ctx.disabled,
                  effect: _ctx.effect,
                  enterable: _ctx.enterable,
                  "fallback-placements": _ctx.fallbackPlacements,
                  "hide-after": _ctx.hideAfter,
                  "gpu-acceleration": _ctx.gpuAcceleration,
                  offset: _ctx.offset,
                  persistent: _ctx.persistent,
                  "popper-class": _ctx.popperClass,
                  "popper-style": _ctx.popperStyle,
                  placement: _ctx.placement,
                  "popper-options": _ctx.popperOptions,
                  pure: _ctx.pure,
                  "raw-content": _ctx.rawContent,
                  "reference-el": _ctx.referenceEl,
                  "trigger-target-el": _ctx.triggerTargetEl,
                  "show-after": _ctx.showAfter,
                  strategy: _ctx.strategy,
                  teleported: _ctx.teleported,
                  transition: _ctx.transition,
                  "virtual-triggering": _ctx.virtualTriggering,
                  "z-index": _ctx.zIndex,
                  "append-to": _ctx.appendTo
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "content", {}, () => [
                      _ctx.rawContent ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        innerHTML: _ctx.content
                      }, null, 8, _hoisted_1$I)) : (openBlock(), createElementBlock("span", _hoisted_2$y, toDisplayString(_ctx.content), 1))
                    ]),
                    _ctx.showArrow ? (openBlock(), createBlock(unref(ElPopperArrow), {
                      key: 0,
                      "arrow-offset": _ctx.arrowOffset
                    }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
              ]),
              _: 3
            }, 8, ["role"]);
          };
        }
      });
      var Tooltip = /* @__PURE__ */ _export_sfc$1(_sfc_main$Q, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
      const ElTooltip = withInstall(Tooltip);
      const badgeProps = buildProps({
        value: {
          type: [String, Number],
          default: ""
        },
        max: {
          type: Number,
          default: 99
        },
        isDot: Boolean,
        hidden: Boolean,
        type: {
          type: String,
          values: ["primary", "success", "warning", "info", "danger"],
          default: "danger"
        }
      });
      const _hoisted_1$H = ["textContent"];
      const __default__$p = defineComponent({
        name: "ElBadge"
      });
      const _sfc_main$P = /* @__PURE__ */ defineComponent({
        ...__default__$p,
        props: badgeProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("badge");
          const content = computed(() => {
            if (props.isDot)
              return "";
            if (isNumber(props.value) && isNumber(props.max)) {
              return props.max < props.value ? `${props.max}+` : `${props.value}`;
            }
            return `${props.value}`;
          });
          expose({
            content
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b())
            }, [
              renderSlot(_ctx.$slots, "default"),
              createVNode(Transition, {
                name: `${unref(ns).namespace.value}-zoom-in-center`,
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createBaseVNode("sup", {
                    class: normalizeClass([
                      unref(ns).e("content"),
                      unref(ns).em("content", _ctx.type),
                      unref(ns).is("fixed", !!_ctx.$slots.default),
                      unref(ns).is("dot", _ctx.isDot)
                    ]),
                    textContent: toDisplayString(unref(content))
                  }, null, 10, _hoisted_1$H), [
                    [vShow, !_ctx.hidden && (unref(content) || _ctx.isDot)]
                  ])
                ]),
                _: 1
              }, 8, ["name"])
            ], 2);
          };
        }
      });
      var Badge = /* @__PURE__ */ _export_sfc$1(_sfc_main$P, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]);
      const ElBadge = withInstall(Badge);
      const buttonGroupContextKey = Symbol("buttonGroupContextKey");
      const useButton = (props, emit2) => {
        useDeprecated({
          from: "type.text",
          replacement: "link",
          version: "3.0.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
        }, computed(() => props.type === "text"));
        const buttonGroupContext = inject(buttonGroupContextKey, void 0);
        const globalConfig2 = useGlobalConfig("button");
        const { form } = useFormItem();
        const _size = useFormSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
        const _disabled = useFormDisabled();
        const _ref = ref();
        const slots = useSlots();
        const _type = computed(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
        const autoInsertSpace = computed(() => {
          var _a2, _b, _c;
          return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
        });
        const _props = computed(() => {
          if (props.tag === "button") {
            return {
              ariaDisabled: _disabled.value || props.loading,
              disabled: _disabled.value || props.loading,
              autofocus: props.autofocus,
              type: props.nativeType
            };
          }
          return {};
        });
        const shouldAddSpace = computed(() => {
          var _a2;
          const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
          if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
            const slot = defaultSlot[0];
            if ((slot == null ? void 0 : slot.type) === Text) {
              const text = slot.children;
              return /^\p{Unified_Ideograph}{2}$/u.test(text.trim());
            }
          }
          return false;
        });
        const handleClick = (evt) => {
          if (props.nativeType === "reset") {
            form == null ? void 0 : form.resetFields();
          }
          emit2("click", evt);
        };
        return {
          _disabled,
          _size,
          _type,
          _ref,
          _props,
          shouldAddSpace,
          handleClick
        };
      };
      const buttonTypes = [
        "default",
        "primary",
        "success",
        "warning",
        "info",
        "danger",
        "text",
        ""
      ];
      const buttonNativeTypes = ["button", "submit", "reset"];
      const buttonProps = buildProps({
        size: useSizeProp,
        disabled: Boolean,
        type: {
          type: String,
          values: buttonTypes,
          default: ""
        },
        icon: {
          type: iconPropType
        },
        nativeType: {
          type: String,
          values: buttonNativeTypes,
          default: "button"
        },
        loading: Boolean,
        loadingIcon: {
          type: iconPropType,
          default: () => loading_default
        },
        plain: Boolean,
        text: Boolean,
        link: Boolean,
        bg: Boolean,
        autofocus: Boolean,
        round: Boolean,
        circle: Boolean,
        color: String,
        dark: Boolean,
        autoInsertSpace: {
          type: Boolean,
          default: void 0
        },
        tag: {
          type: definePropType([String, Object]),
          default: "button"
        }
      });
      const buttonEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      function bound01(n, max) {
        if (isOnePointZero(n)) {
          n = "100%";
        }
        var isPercent = isPercentage(n);
        n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
        if (isPercent) {
          n = parseInt(String(n * max), 10) / 100;
        }
        if (Math.abs(n - max) < 1e-6) {
          return 1;
        }
        if (max === 360) {
          n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
        } else {
          n = n % max / parseFloat(String(max));
        }
        return n;
      }
      function clamp01(val) {
        return Math.min(1, Math.max(0, val));
      }
      function isOnePointZero(n) {
        return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
      }
      function isPercentage(n) {
        return typeof n === "string" && n.indexOf("%") !== -1;
      }
      function boundAlpha(a) {
        a = parseFloat(a);
        if (isNaN(a) || a < 0 || a > 1) {
          a = 1;
        }
        return a;
      }
      function convertToPercentage(n) {
        if (n <= 1) {
          return "".concat(Number(n) * 100, "%");
        }
        return n;
      }
      function pad2(c) {
        return c.length === 1 ? "0" + c : String(c);
      }
      function rgbToRgb(r, g, b) {
        return {
          r: bound01(r, 255) * 255,
          g: bound01(g, 255) * 255,
          b: bound01(b, 255) * 255
        };
      }
      function rgbToHsl(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var h2 = 0;
        var s = 0;
        var l = (max + min) / 2;
        if (max === min) {
          s = 0;
          h2 = 0;
        } else {
          var d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h2 = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h2 = (b - r) / d + 2;
              break;
            case b:
              h2 = (r - g) / d + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s, l };
      }
      function hue2rgb(p2, q2, t) {
        if (t < 0) {
          t += 1;
        }
        if (t > 1) {
          t -= 1;
        }
        if (t < 1 / 6) {
          return p2 + (q2 - p2) * (6 * t);
        }
        if (t < 1 / 2) {
          return q2;
        }
        if (t < 2 / 3) {
          return p2 + (q2 - p2) * (2 / 3 - t) * 6;
        }
        return p2;
      }
      function hslToRgb(h2, s, l) {
        var r;
        var g;
        var b;
        h2 = bound01(h2, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);
        if (s === 0) {
          g = l;
          b = l;
          r = l;
        } else {
          var q2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p2 = 2 * l - q2;
          r = hue2rgb(p2, q2, h2 + 1 / 3);
          g = hue2rgb(p2, q2, h2);
          b = hue2rgb(p2, q2, h2 - 1 / 3);
        }
        return { r: r * 255, g: g * 255, b: b * 255 };
      }
      function rgbToHsv(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var h2 = 0;
        var v = max;
        var d = max - min;
        var s = max === 0 ? 0 : d / max;
        if (max === min) {
          h2 = 0;
        } else {
          switch (max) {
            case r:
              h2 = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h2 = (b - r) / d + 2;
              break;
            case b:
              h2 = (r - g) / d + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s, v };
      }
      function hsvToRgb(h2, s, v) {
        h2 = bound01(h2, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);
        var i = Math.floor(h2);
        var f = h2 - i;
        var p2 = v * (1 - s);
        var q2 = v * (1 - f * s);
        var t = v * (1 - (1 - f) * s);
        var mod = i % 6;
        var r = [v, q2, p2, p2, t, v][mod];
        var g = [t, v, v, q2, p2, p2][mod];
        var b = [p2, p2, t, v, v, q2][mod];
        return { r: r * 255, g: g * 255, b: b * 255 };
      }
      function rgbToHex(r, g, b, allow3Char) {
        var hex = [
          pad2(Math.round(r).toString(16)),
          pad2(Math.round(g).toString(16)),
          pad2(Math.round(b).toString(16))
        ];
        if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToHex(r, g, b, a, allow4Char) {
        var hex = [
          pad2(Math.round(r).toString(16)),
          pad2(Math.round(g).toString(16)),
          pad2(Math.round(b).toString(16)),
          pad2(convertDecimalToHex(a))
        ];
        if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }
        return hex.join("");
      }
      function convertDecimalToHex(d) {
        return Math.round(parseFloat(d) * 255).toString(16);
      }
      function convertHexToDecimal(h2) {
        return parseIntFromHex(h2) / 255;
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function numberInputToObject(color) {
        return {
          r: color >> 16,
          g: (color & 65280) >> 8,
          b: color & 255
        };
      }
      var names = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        goldenrod: "#daa520",
        gold: "#ffd700",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavenderblush: "#fff0f5",
        lavender: "#e6e6fa",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
      };
      function inputToRGB(color) {
        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var s = null;
        var v = null;
        var l = null;
        var ok = false;
        var format2 = false;
        if (typeof color === "string") {
          color = stringInputToObject(color);
        }
        if (typeof color === "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format2 = "hsv";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format2 = "hsl";
          }
          if (Object.prototype.hasOwnProperty.call(color, "a")) {
            a = color.a;
          }
        }
        a = boundAlpha(a);
        return {
          ok,
          format: color.format || format2,
          r: Math.min(255, Math.max(rgb.r, 0)),
          g: Math.min(255, Math.max(rgb.g, 0)),
          b: Math.min(255, Math.max(rgb.b, 0)),
          a
        };
      }
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var matchers = {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
      function stringInputToObject(color) {
        color = color.trim().toLowerCase();
        if (color.length === 0) {
          return false;
        }
        var named = false;
        if (names[color]) {
          color = names[color];
          named = true;
        } else if (color === "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match = matchers.rgb.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3] };
        }
        match = matchers.rgba.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        match = matchers.hsl.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3] };
        }
        match = matchers.hsla.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        match = matchers.hsv.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3] };
        }
        match = matchers.hsva.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        match = matchers.hex8.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex6.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
          };
        }
        match = matchers.hex4.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            a: convertHexToDecimal(match[4] + match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex3.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            format: named ? "name" : "hex"
          };
        }
        return false;
      }
      function isValidCSSUnit(color) {
        return Boolean(matchers.CSS_UNIT.exec(String(color)));
      }
      var TinyColor = (
        /** @class */
        function() {
          function TinyColor2(color, opts) {
            if (color === void 0) {
              color = "";
            }
            if (opts === void 0) {
              opts = {};
            }
            var _a2;
            if (color instanceof TinyColor2) {
              return color;
            }
            if (typeof color === "number") {
              color = numberInputToObject(color);
            }
            this.originalInput = color;
            var rgb = inputToRGB(color);
            this.originalInput = color;
            this.r = rgb.r;
            this.g = rgb.g;
            this.b = rgb.b;
            this.a = rgb.a;
            this.roundA = Math.round(100 * this.a) / 100;
            this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
            this.gradientType = opts.gradientType;
            if (this.r < 1) {
              this.r = Math.round(this.r);
            }
            if (this.g < 1) {
              this.g = Math.round(this.g);
            }
            if (this.b < 1) {
              this.b = Math.round(this.b);
            }
            this.isValid = rgb.ok;
          }
          TinyColor2.prototype.isDark = function() {
            return this.getBrightness() < 128;
          };
          TinyColor2.prototype.isLight = function() {
            return !this.isDark();
          };
          TinyColor2.prototype.getBrightness = function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
          };
          TinyColor2.prototype.getLuminance = function() {
            var rgb = this.toRgb();
            var R2;
            var G2;
            var B2;
            var RsRGB = rgb.r / 255;
            var GsRGB = rgb.g / 255;
            var BsRGB = rgb.b / 255;
            if (RsRGB <= 0.03928) {
              R2 = RsRGB / 12.92;
            } else {
              R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
            }
            if (GsRGB <= 0.03928) {
              G2 = GsRGB / 12.92;
            } else {
              G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
            }
            if (BsRGB <= 0.03928) {
              B2 = BsRGB / 12.92;
            } else {
              B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
          };
          TinyColor2.prototype.getAlpha = function() {
            return this.a;
          };
          TinyColor2.prototype.setAlpha = function(alpha) {
            this.a = boundAlpha(alpha);
            this.roundA = Math.round(100 * this.a) / 100;
            return this;
          };
          TinyColor2.prototype.isMonochrome = function() {
            var s = this.toHsl().s;
            return s === 0;
          };
          TinyColor2.prototype.toHsv = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
          };
          TinyColor2.prototype.toHsvString = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            var h2 = Math.round(hsv.h * 360);
            var s = Math.round(hsv.s * 100);
            var v = Math.round(hsv.v * 100);
            return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHsl = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
          };
          TinyColor2.prototype.toHslString = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            var h2 = Math.round(hsl.h * 360);
            var s = Math.round(hsl.s * 100);
            var l = Math.round(hsl.l * 100);
            return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHex = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return rgbToHex(this.r, this.g, this.b, allow3Char);
          };
          TinyColor2.prototype.toHexString = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return "#" + this.toHex(allow3Char);
          };
          TinyColor2.prototype.toHex8 = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
          };
          TinyColor2.prototype.toHex8String = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return "#" + this.toHex8(allow4Char);
          };
          TinyColor2.prototype.toHexShortString = function(allowShortChar) {
            if (allowShortChar === void 0) {
              allowShortChar = false;
            }
            return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
          };
          TinyColor2.prototype.toRgb = function() {
            return {
              r: Math.round(this.r),
              g: Math.round(this.g),
              b: Math.round(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toRgbString = function() {
            var r = Math.round(this.r);
            var g = Math.round(this.g);
            var b = Math.round(this.b);
            return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toPercentageRgb = function() {
            var fmt = function(x) {
              return "".concat(Math.round(bound01(x, 255) * 100), "%");
            };
            return {
              r: fmt(this.r),
              g: fmt(this.g),
              b: fmt(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toPercentageRgbString = function() {
            var rnd = function(x) {
              return Math.round(bound01(x, 255) * 100);
            };
            return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toName = function() {
            if (this.a === 0) {
              return "transparent";
            }
            if (this.a < 1) {
              return false;
            }
            var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
            for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
              var _b = _a2[_i], key = _b[0], value = _b[1];
              if (hex === value) {
                return key;
              }
            }
            return false;
          };
          TinyColor2.prototype.toString = function(format2) {
            var formatSet = Boolean(format2);
            format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
            var formattedString = false;
            var hasAlpha = this.a < 1 && this.a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
            if (needsAlphaFormat) {
              if (format2 === "name" && this.a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format2 === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format2 === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format2 === "hex" || format2 === "hex6") {
              formattedString = this.toHexString();
            }
            if (format2 === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format2 === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format2 === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format2 === "name") {
              formattedString = this.toName();
            }
            if (format2 === "hsl") {
              formattedString = this.toHslString();
            }
            if (format2 === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          };
          TinyColor2.prototype.toNumber = function() {
            return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
          };
          TinyColor2.prototype.clone = function() {
            return new TinyColor2(this.toString());
          };
          TinyColor2.prototype.lighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.brighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var rgb = this.toRgb();
            rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
            rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
            rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
            return new TinyColor2(rgb);
          };
          TinyColor2.prototype.darken = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.tint = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("white", amount);
          };
          TinyColor2.prototype.shade = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("black", amount);
          };
          TinyColor2.prototype.desaturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.saturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.greyscale = function() {
            return this.desaturate(100);
          };
          TinyColor2.prototype.spin = function(amount) {
            var hsl = this.toHsl();
            var hue = (hsl.h + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.mix = function(color, amount) {
            if (amount === void 0) {
              amount = 50;
            }
            var rgb1 = this.toRgb();
            var rgb2 = new TinyColor2(color).toRgb();
            var p2 = amount / 100;
            var rgba = {
              r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
              g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
              b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
              a: (rgb2.a - rgb1.a) * p2 + rgb1.a
            };
            return new TinyColor2(rgba);
          };
          TinyColor2.prototype.analogous = function(results, slices) {
            if (results === void 0) {
              results = 6;
            }
            if (slices === void 0) {
              slices = 30;
            }
            var hsl = this.toHsl();
            var part = 360 / slices;
            var ret = [this];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
              hsl.h = (hsl.h + part) % 360;
              ret.push(new TinyColor2(hsl));
            }
            return ret;
          };
          TinyColor2.prototype.complement = function() {
            var hsl = this.toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.monochromatic = function(results) {
            if (results === void 0) {
              results = 6;
            }
            var hsv = this.toHsv();
            var h2 = hsv.h;
            var s = hsv.s;
            var v = hsv.v;
            var res = [];
            var modification = 1 / results;
            while (results--) {
              res.push(new TinyColor2({ h: h2, s, v }));
              v = (v + modification) % 1;
            }
            return res;
          };
          TinyColor2.prototype.splitcomplement = function() {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            return [
              this,
              new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
              new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
            ];
          };
          TinyColor2.prototype.onBackground = function(background) {
            var fg = this.toRgb();
            var bg = new TinyColor2(background).toRgb();
            var alpha = fg.a + bg.a * (1 - fg.a);
            return new TinyColor2({
              r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
              g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
              b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
              a: alpha
            });
          };
          TinyColor2.prototype.triad = function() {
            return this.polyad(3);
          };
          TinyColor2.prototype.tetrad = function() {
            return this.polyad(4);
          };
          TinyColor2.prototype.polyad = function(n) {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            var result = [this];
            var increment = 360 / n;
            for (var i = 1; i < n; i++) {
              result.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
            }
            return result;
          };
          TinyColor2.prototype.equals = function(color) {
            return this.toRgbString() === new TinyColor2(color).toRgbString();
          };
          return TinyColor2;
        }()
      );
      function darken(color, amount = 20) {
        return color.mix("#141414", amount).toString();
      }
      function useButtonCustomStyle(props) {
        const _disabled = useFormDisabled();
        const ns = useNamespace("button");
        return computed(() => {
          let styles = {};
          const buttonColor = props.color;
          if (buttonColor) {
            const color = new TinyColor(buttonColor);
            const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
            if (props.plain) {
              styles = ns.cssVarBlock({
                "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
                "text-color": buttonColor,
                "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
                "hover-text-color": `var(${ns.cssVarName("color-white")})`,
                "hover-bg-color": buttonColor,
                "hover-border-color": buttonColor,
                "active-bg-color": activeBgColor,
                "active-text-color": `var(${ns.cssVarName("color-white")})`,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                styles[ns.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
                styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
              }
            } else {
              const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
              const textColor = color.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
              styles = ns.cssVarBlock({
                "bg-color": buttonColor,
                "text-color": textColor,
                "border-color": buttonColor,
                "hover-bg-color": hoverBgColor,
                "hover-text-color": textColor,
                "hover-border-color": hoverBgColor,
                "active-bg-color": activeBgColor,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
                styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
                styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
              }
            }
          }
          return styles;
        });
      }
      const __default__$o = defineComponent({
        name: "ElButton"
      });
      const _sfc_main$O = /* @__PURE__ */ defineComponent({
        ...__default__$o,
        props: buttonProps,
        emits: buttonEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const buttonStyle = useButtonCustomStyle(props);
          const ns = useNamespace("button");
          const { _ref, _size, _type, _disabled, _props, shouldAddSpace, handleClick } = useButton(props, emit2);
          expose({
            ref: _ref,
            size: _size,
            type: _type,
            disabled: _disabled,
            shouldAddSpace
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({
              ref_key: "_ref",
              ref: _ref
            }, unref(_props), {
              class: [
                unref(ns).b(),
                unref(ns).m(unref(_type)),
                unref(ns).m(unref(_size)),
                unref(ns).is("disabled", unref(_disabled)),
                unref(ns).is("loading", _ctx.loading),
                unref(ns).is("plain", _ctx.plain),
                unref(ns).is("round", _ctx.round),
                unref(ns).is("circle", _ctx.circle),
                unref(ns).is("text", _ctx.text),
                unref(ns).is("link", _ctx.link),
                unref(ns).is("has-bg", _ctx.bg)
              ],
              style: unref(buttonStyle),
              onClick: unref(handleClick)
            }), {
              default: withCtx(() => [
                _ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass(unref(ns).is("loading"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"]))
                ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                  default: withCtx(() => [
                    _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
                  ]),
                  _: 3
                })) : createCommentVNode("v-if", true),
                _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                  key: 2,
                  class: normalizeClass({ [unref(ns).em("text", "expand")]: unref(shouldAddSpace) })
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["class", "style", "onClick"]);
          };
        }
      });
      var Button = /* @__PURE__ */ _export_sfc$1(_sfc_main$O, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
      const buttonGroupProps = {
        size: buttonProps.size,
        type: buttonProps.type
      };
      const __default__$n = defineComponent({
        name: "ElButtonGroup"
      });
      const _sfc_main$N = /* @__PURE__ */ defineComponent({
        ...__default__$n,
        props: buttonGroupProps,
        setup(__props) {
          const props = __props;
          provide(buttonGroupContextKey, reactive({
            size: toRef$1(props, "size"),
            type: toRef$1(props, "type")
          }));
          const ns = useNamespace("button");
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(`${unref(ns).b("group")}`)
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var ButtonGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$N, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
      const ElButton = withInstall(Button, {
        ButtonGroup
      });
      const ElButtonGroup$1 = withNoopInstall(ButtonGroup);
      const nodeList = /* @__PURE__ */ new Map();
      let startClick;
      if (isClient$1) {
        document.addEventListener("mousedown", (e) => startClick = e);
        document.addEventListener("mouseup", (e) => {
          for (const handlers of nodeList.values()) {
            for (const { documentHandler } of handlers) {
              documentHandler(e, startClick);
            }
          }
        });
      }
      function createDocumentHandler(el, binding) {
        let excludes = [];
        if (Array.isArray(binding.arg)) {
          excludes = binding.arg;
        } else if (isElement(binding.arg)) {
          excludes.push(binding.arg);
        }
        return function(mouseup, mousedown) {
          const popperRef = binding.instance.popperRef;
          const mouseUpTarget = mouseup.target;
          const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
          const isBound = !binding || !binding.instance;
          const isTargetExists = !mouseUpTarget || !mouseDownTarget;
          const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
          const isSelf = el === mouseUpTarget;
          const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
          const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
          if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
            return;
          }
          binding.value(mouseup, mousedown);
        };
      }
      const ClickOutside = {
        beforeMount(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          nodeList.get(el).push({
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          });
        },
        updated(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          const handlers = nodeList.get(el);
          const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
          const newHandler = {
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          };
          if (oldHandlerIndex >= 0) {
            handlers.splice(oldHandlerIndex, 1, newHandler);
          } else {
            handlers.push(newHandler);
          }
        },
        unmounted(el) {
          nodeList.delete(el);
        }
      };
      const REPEAT_INTERVAL = 100;
      const REPEAT_DELAY = 600;
      const vRepeatClick = {
        beforeMount(el, binding) {
          const value = binding.value;
          const { interval = REPEAT_INTERVAL, delay = REPEAT_DELAY } = isFunction$1(value) ? {} : value;
          let intervalId;
          let delayId;
          const handler = () => isFunction$1(value) ? value() : value.handler();
          const clear2 = () => {
            if (delayId) {
              clearTimeout(delayId);
              delayId = void 0;
            }
            if (intervalId) {
              clearInterval(intervalId);
              intervalId = void 0;
            }
          };
          el.addEventListener("mousedown", (evt) => {
            if (evt.button !== 0)
              return;
            clear2();
            handler();
            document.addEventListener("mouseup", () => clear2(), {
              once: true
            });
            delayId = setTimeout(() => {
              intervalId = setInterval(() => {
                handler();
              }, interval);
            }, delay);
          });
        }
      };
      const FOCUSABLE_CHILDREN = "_trap-focus-children";
      const FOCUS_STACK = [];
      const FOCUS_HANDLER = (e) => {
        if (FOCUS_STACK.length === 0)
          return;
        const focusableElement = FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN];
        if (focusableElement.length > 0 && e.code === EVENT_CODE.tab) {
          if (focusableElement.length === 1) {
            e.preventDefault();
            if (document.activeElement !== focusableElement[0]) {
              focusableElement[0].focus();
            }
            return;
          }
          const goingBackward = e.shiftKey;
          const isFirst = e.target === focusableElement[0];
          const isLast = e.target === focusableElement[focusableElement.length - 1];
          if (isFirst && goingBackward) {
            e.preventDefault();
            focusableElement[focusableElement.length - 1].focus();
          }
          if (isLast && !goingBackward) {
            e.preventDefault();
            focusableElement[0].focus();
          }
        }
      };
      const TrapFocus = {
        beforeMount(el) {
          el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
          FOCUS_STACK.push(el);
          if (FOCUS_STACK.length <= 1) {
            document.addEventListener("keydown", FOCUS_HANDLER);
          }
        },
        updated(el) {
          nextTick(() => {
            el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
          });
        },
        unmounted() {
          FOCUS_STACK.shift();
          if (FOCUS_STACK.length === 0) {
            document.removeEventListener("keydown", FOCUS_HANDLER);
          }
        }
      };
      const checkboxProps = {
        modelValue: {
          type: [Number, String, Boolean],
          default: void 0
        },
        label: {
          type: [String, Boolean, Number, Object]
        },
        indeterminate: Boolean,
        disabled: Boolean,
        checked: Boolean,
        name: {
          type: String,
          default: void 0
        },
        trueLabel: {
          type: [String, Number],
          default: void 0
        },
        falseLabel: {
          type: [String, Number],
          default: void 0
        },
        id: {
          type: String,
          default: void 0
        },
        controls: {
          type: String,
          default: void 0
        },
        border: Boolean,
        size: useSizeProp,
        tabindex: [String, Number],
        validateEvent: {
          type: Boolean,
          default: true
        }
      };
      const checkboxEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isString$1(val) || isNumber(val) || isBoolean(val),
        change: (val) => isString$1(val) || isNumber(val) || isBoolean(val)
      };
      const checkboxGroupContextKey = Symbol("checkboxGroupContextKey");
      const useCheckboxDisabled = ({
        model,
        isChecked
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isLimitDisabled = computed(() => {
          var _a2, _b;
          const max = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value;
          const min = (_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value;
          return !isUndefined(max) && model.value.length >= max && !isChecked.value || !isUndefined(min) && model.value.length <= min && isChecked.value;
        });
        const isDisabled = useFormDisabled(computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value));
        return {
          isDisabled,
          isLimitDisabled
        };
      };
      const useCheckboxEvent = (props, {
        model,
        isLimitExceeded,
        hasOwnLabel,
        isDisabled,
        isLabeledByFormItem
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const { formItem } = useFormItem();
        const { emit: emit2 } = getCurrentInstance();
        function getLabeledValue(value) {
          var _a2, _b;
          return value === props.trueLabel || value === true ? (_a2 = props.trueLabel) != null ? _a2 : true : (_b = props.falseLabel) != null ? _b : false;
        }
        function emitChangeEvent(checked, e) {
          emit2("change", getLabeledValue(checked), e);
        }
        function handleChange(e) {
          if (isLimitExceeded.value)
            return;
          const target = e.target;
          emit2("change", getLabeledValue(target.checked), e);
        }
        async function onClickRoot(e) {
          if (isLimitExceeded.value)
            return;
          if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
            const eventTargets = e.composedPath();
            const hasLabel = eventTargets.some((item) => item.tagName === "LABEL");
            if (!hasLabel) {
              model.value = getLabeledValue([false, props.falseLabel].includes(model.value));
              await nextTick();
              emitChangeEvent(model.value, e);
            }
          }
        }
        const validateEvent = computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.validateEvent) || props.validateEvent);
        watch(() => props.modelValue, () => {
          if (validateEvent.value) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        });
        return {
          handleChange,
          onClickRoot
        };
      };
      const useCheckboxModel = (props) => {
        const selfModel = ref(false);
        const { emit: emit2 } = getCurrentInstance();
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isGroup = computed(() => isUndefined(checkboxGroup) === false);
        const isLimitExceeded = ref(false);
        const model = computed({
          get() {
            var _a2, _b;
            return isGroup.value ? (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a2.value : (_b = props.modelValue) != null ? _b : selfModel.value;
          },
          set(val) {
            var _a2, _b;
            if (isGroup.value && isArray$2(val)) {
              isLimitExceeded.value = ((_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value);
              isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));
            } else {
              emit2(UPDATE_MODEL_EVENT, val);
              selfModel.value = val;
            }
          }
        });
        return {
          model,
          isGroup,
          isLimitExceeded
        };
      };
      const useCheckboxStatus = (props, slots, { model }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isFocused = ref(false);
        const isChecked = computed(() => {
          const value = model.value;
          if (isBoolean(value)) {
            return value;
          } else if (isArray$2(value)) {
            if (isObject$1(props.label)) {
              return value.map(toRaw).some((o) => isEqual$1(o, props.label));
            } else {
              return value.map(toRaw).includes(props.label);
            }
          } else if (value !== null && value !== void 0) {
            return value === props.trueLabel;
          } else {
            return !!value;
          }
        });
        const checkboxButtonSize = useFormSize(computed(() => {
          var _a2;
          return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
        }), {
          prop: true
        });
        const checkboxSize = useFormSize(computed(() => {
          var _a2;
          return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
        }));
        const hasOwnLabel = computed(() => {
          return !!(slots.default || props.label);
        });
        return {
          checkboxButtonSize,
          isChecked,
          isFocused,
          checkboxSize,
          hasOwnLabel
        };
      };
      const setStoreValue = (props, { model }) => {
        function addToStore() {
          if (isArray$2(model.value) && !model.value.includes(props.label)) {
            model.value.push(props.label);
          } else {
            model.value = props.trueLabel || true;
          }
        }
        props.checked && addToStore();
      };
      const useCheckbox = (props, slots) => {
        const { formItem: elFormItem2 } = useFormItem();
        const { model, isGroup, isLimitExceeded } = useCheckboxModel(props);
        const {
          isFocused,
          isChecked,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel
        } = useCheckboxStatus(props, slots, { model });
        const { isDisabled } = useCheckboxDisabled({ model, isChecked });
        const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
          formItemContext: elFormItem2,
          disableIdGeneration: hasOwnLabel,
          disableIdManagement: isGroup
        });
        const { handleChange, onClickRoot } = useCheckboxEvent(props, {
          model,
          isLimitExceeded,
          hasOwnLabel,
          isDisabled,
          isLabeledByFormItem
        });
        setStoreValue(props, { model });
        return {
          inputId,
          isLabeledByFormItem,
          isChecked,
          isDisabled,
          isFocused,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          model,
          handleChange,
          onClickRoot
        };
      };
      const _hoisted_1$G = ["tabindex", "role", "aria-checked"];
      const _hoisted_2$x = ["id", "aria-hidden", "name", "tabindex", "disabled", "true-value", "false-value"];
      const _hoisted_3$p = ["id", "aria-hidden", "disabled", "value", "name", "tabindex"];
      const __default__$m = defineComponent({
        name: "ElCheckbox"
      });
      const _sfc_main$M = /* @__PURE__ */ defineComponent({
        ...__default__$m,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props = __props;
          const slots = useSlots();
          const {
            inputId,
            isLabeledByFormItem,
            isChecked,
            isDisabled,
            isFocused,
            checkboxSize,
            hasOwnLabel,
            model,
            handleChange,
            onClickRoot
          } = useCheckbox(props, slots);
          const ns = useNamespace("checkbox");
          const compKls = computed(() => {
            return [
              ns.b(),
              ns.m(checkboxSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("bordered", props.border),
              ns.is("checked", isChecked.value)
            ];
          });
          const spanKls = computed(() => {
            return [
              ns.e("input"),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("indeterminate", props.indeterminate),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(!unref(hasOwnLabel) && unref(isLabeledByFormItem) ? "span" : "label"), {
              class: normalizeClass(unref(compKls)),
              "aria-controls": _ctx.indeterminate ? _ctx.controls : null,
              onClick: unref(onClickRoot)
            }, {
              default: withCtx(() => [
                createBaseVNode("span", {
                  class: normalizeClass(unref(spanKls)),
                  tabindex: _ctx.indeterminate ? 0 : void 0,
                  role: _ctx.indeterminate ? "checkbox" : void 0,
                  "aria-checked": _ctx.indeterminate ? "mixed" : void 0
                }, [
                  _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                    key: 0,
                    id: unref(inputId),
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
                    class: normalizeClass(unref(ns).e("original")),
                    type: "checkbox",
                    "aria-hidden": _ctx.indeterminate ? "true" : "false",
                    name: _ctx.name,
                    tabindex: _ctx.tabindex,
                    disabled: unref(isDisabled),
                    "true-value": _ctx.trueLabel,
                    "false-value": _ctx.falseLabel,
                    onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                    onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
                    onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false)
                  }, null, 42, _hoisted_2$x)), [
                    [vModelCheckbox, unref(model)]
                  ]) : withDirectives((openBlock(), createElementBlock("input", {
                    key: 1,
                    id: unref(inputId),
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isRef(model) ? model.value = $event : null),
                    class: normalizeClass(unref(ns).e("original")),
                    type: "checkbox",
                    "aria-hidden": _ctx.indeterminate ? "true" : "false",
                    disabled: unref(isDisabled),
                    value: _ctx.label,
                    name: _ctx.name,
                    tabindex: _ctx.tabindex,
                    onChange: _cache[5] || (_cache[5] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                    onFocus: _cache[6] || (_cache[6] = ($event) => isFocused.value = true),
                    onBlur: _cache[7] || (_cache[7] = ($event) => isFocused.value = false)
                  }, null, 42, _hoisted_3$p)), [
                    [vModelCheckbox, unref(model)]
                  ]),
                  createBaseVNode("span", {
                    class: normalizeClass(unref(ns).e("inner"))
                  }, null, 2)
                ], 10, _hoisted_1$G),
                unref(hasOwnLabel) ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("label"))
                }, [
                  renderSlot(_ctx.$slots, "default"),
                  !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createTextVNode(toDisplayString(_ctx.label), 1)
                  ], 64)) : createCommentVNode("v-if", true)
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["class", "aria-controls", "onClick"]);
          };
        }
      });
      var Checkbox = /* @__PURE__ */ _export_sfc$1(_sfc_main$M, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);
      const _hoisted_1$F = ["name", "tabindex", "disabled", "true-value", "false-value"];
      const _hoisted_2$w = ["name", "tabindex", "disabled", "value"];
      const __default__$l = defineComponent({
        name: "ElCheckboxButton"
      });
      const _sfc_main$L = /* @__PURE__ */ defineComponent({
        ...__default__$l,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props = __props;
          const slots = useSlots();
          const {
            isFocused,
            isChecked,
            isDisabled,
            checkboxButtonSize,
            model,
            handleChange
          } = useCheckbox(props, slots);
          const checkboxGroup = inject(checkboxGroupContextKey, void 0);
          const ns = useNamespace("checkbox");
          const activeStyle = computed(() => {
            var _a2, _b, _c, _d;
            const fillValue = (_b = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a2.value) != null ? _b : "";
            return {
              backgroundColor: fillValue,
              borderColor: fillValue,
              color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
              boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
            };
          });
          const labelKls = computed(() => {
            return [
              ns.b("button"),
              ns.bm("button", checkboxButtonSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("label", {
              class: normalizeClass(unref(labelKls))
            }, [
              _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                key: 0,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                "true-value": _ctx.trueLabel,
                "false-value": _ctx.falseLabel,
                onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
                onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false)
              }, null, 42, _hoisted_1$F)), [
                [vModelCheckbox, unref(model)]
              ]) : withDirectives((openBlock(), createElementBlock("input", {
                key: 1,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isRef(model) ? model.value = $event : null),
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                value: _ctx.label,
                onChange: _cache[5] || (_cache[5] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                onFocus: _cache[6] || (_cache[6] = ($event) => isFocused.value = true),
                onBlur: _cache[7] || (_cache[7] = ($event) => isFocused.value = false)
              }, null, 42, _hoisted_2$w)), [
                [vModelCheckbox, unref(model)]
              ]),
              _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
                key: 2,
                class: normalizeClass(unref(ns).be("button", "inner")),
                style: normalizeStyle(unref(isChecked) ? unref(activeStyle) : void 0)
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.label), 1)
                ])
              ], 6)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var CheckboxButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$L, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);
      const checkboxGroupProps = buildProps({
        modelValue: {
          type: definePropType(Array),
          default: () => []
        },
        disabled: Boolean,
        min: Number,
        max: Number,
        size: useSizeProp,
        label: String,
        fill: String,
        textColor: String,
        tag: {
          type: String,
          default: "div"
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const checkboxGroupEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isArray$2(val),
        change: (val) => isArray$2(val)
      };
      const __default__$k = defineComponent({
        name: "ElCheckboxGroup"
      });
      const _sfc_main$K = /* @__PURE__ */ defineComponent({
        ...__default__$k,
        props: checkboxGroupProps,
        emits: checkboxGroupEmits,
        setup(__props, { emit: emit2 }) {
          const props = __props;
          const ns = useNamespace("checkbox");
          const { formItem } = useFormItem();
          const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, {
            formItemContext: formItem
          });
          const changeEvent = async (value) => {
            emit2(UPDATE_MODEL_EVENT, value);
            await nextTick();
            emit2("change", value);
          };
          const modelValue = computed({
            get() {
              return props.modelValue;
            },
            set(val) {
              changeEvent(val);
            }
          });
          provide(checkboxGroupContextKey, {
            ...pick$1(toRefs(props), [
              "size",
              "min",
              "max",
              "disabled",
              "validateEvent",
              "fill",
              "textColor"
            ]),
            modelValue,
            changeEvent
          });
          watch(() => props.modelValue, () => {
            if (props.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
          });
          return (_ctx, _cache) => {
            var _a2;
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              id: unref(groupId),
              class: normalizeClass(unref(ns).b("group")),
              role: "group",
              "aria-label": !unref(isLabeledByFormItem) ? _ctx.label || "checkbox-group" : void 0,
              "aria-labelledby": unref(isLabeledByFormItem) ? (_a2 = unref(formItem)) == null ? void 0 : _a2.labelId : void 0
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
          };
        }
      });
      var CheckboxGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$K, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);
      const ElCheckbox = withInstall(Checkbox, {
        CheckboxButton,
        CheckboxGroup
      });
      withNoopInstall(CheckboxButton);
      withNoopInstall(CheckboxGroup);
      const tagProps = buildProps({
        type: {
          type: String,
          values: ["success", "info", "warning", "danger", ""],
          default: ""
        },
        closable: Boolean,
        disableTransitions: Boolean,
        hit: Boolean,
        color: {
          type: String,
          default: ""
        },
        size: {
          type: String,
          values: componentSizes,
          default: ""
        },
        effect: {
          type: String,
          values: ["dark", "light", "plain"],
          default: "light"
        },
        round: Boolean
      });
      const tagEmits = {
        close: (evt) => evt instanceof MouseEvent,
        click: (evt) => evt instanceof MouseEvent
      };
      const __default__$j = defineComponent({
        name: "ElTag"
      });
      const _sfc_main$J = /* @__PURE__ */ defineComponent({
        ...__default__$j,
        props: tagProps,
        emits: tagEmits,
        setup(__props, { emit: emit2 }) {
          const props = __props;
          const tagSize = useFormSize();
          const ns = useNamespace("tag");
          const containerKls = computed(() => {
            const { type: type2, hit, effect, closable, round } = props;
            return [
              ns.b(),
              ns.is("closable", closable),
              ns.m(type2),
              ns.m(tagSize.value),
              ns.m(effect),
              ns.is("hit", hit),
              ns.is("round", round)
            ];
          });
          const handleClose = (event) => {
            emit2("close", event);
          };
          const handleClick = (event) => {
            emit2("click", event);
          };
          return (_ctx, _cache) => {
            return _ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(unref(containerKls)),
              style: normalizeStyle({ backgroundColor: _ctx.color }),
              onClick: handleClick
            }, [
              createBaseVNode("span", {
                class: normalizeClass(unref(ns).e("content"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2),
              _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                key: 0,
                class: normalizeClass(unref(ns).e("close")),
                onClick: withModifiers(handleClose, ["stop"])
              }, {
                default: withCtx(() => [
                  createVNode(unref(close_default))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
            ], 6)) : (openBlock(), createBlock(Transition, {
              key: 1,
              name: `${unref(ns).namespace.value}-zoom-in-center`,
              appear: ""
            }, {
              default: withCtx(() => [
                createBaseVNode("span", {
                  class: normalizeClass(unref(containerKls)),
                  style: normalizeStyle({ backgroundColor: _ctx.color }),
                  onClick: handleClick
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(ns).e("content"))
                  }, [
                    renderSlot(_ctx.$slots, "default")
                  ], 2),
                  _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).e("close")),
                    onClick: withModifiers(handleClose, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(close_default))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ], 6)
              ]),
              _: 3
            }, 8, ["name"]));
          };
        }
      });
      var Tag = /* @__PURE__ */ _export_sfc$1(_sfc_main$J, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);
      const ElTag = withInstall(Tag);
      const __default__$i = defineComponent({
        name: "ElContainer"
      });
      const _sfc_main$I = /* @__PURE__ */ defineComponent({
        ...__default__$i,
        props: {
          direction: {
            type: String
          }
        },
        setup(__props) {
          const props = __props;
          const slots = useSlots();
          const ns = useNamespace("container");
          const isVertical = computed(() => {
            if (props.direction === "vertical") {
              return true;
            } else if (props.direction === "horizontal") {
              return false;
            }
            if (slots && slots.default) {
              const vNodes = slots.default();
              return vNodes.some((vNode) => {
                const tag = vNode.type.name;
                return tag === "ElHeader" || tag === "ElFooter";
              });
            } else {
              return false;
            }
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("section", {
              class: normalizeClass([unref(ns).b(), unref(ns).is("vertical", unref(isVertical))])
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Container = /* @__PURE__ */ _export_sfc$1(_sfc_main$I, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/container.vue"]]);
      const __default__$h = defineComponent({
        name: "ElAside"
      });
      const _sfc_main$H = /* @__PURE__ */ defineComponent({
        ...__default__$h,
        props: {
          width: {
            type: String,
            default: null
          }
        },
        setup(__props) {
          const props = __props;
          const ns = useNamespace("aside");
          const style = computed(() => props.width ? ns.cssVarBlock({ width: props.width }) : {});
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("aside", {
              class: normalizeClass(unref(ns).b()),
              style: normalizeStyle(unref(style))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 6);
          };
        }
      });
      var Aside = /* @__PURE__ */ _export_sfc$1(_sfc_main$H, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/aside.vue"]]);
      const __default__$g = defineComponent({
        name: "ElFooter"
      });
      const _sfc_main$G = /* @__PURE__ */ defineComponent({
        ...__default__$g,
        props: {
          height: {
            type: String,
            default: null
          }
        },
        setup(__props) {
          const props = __props;
          const ns = useNamespace("footer");
          const style = computed(() => props.height ? ns.cssVarBlock({ height: props.height }) : {});
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("footer", {
              class: normalizeClass(unref(ns).b()),
              style: normalizeStyle(unref(style))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 6);
          };
        }
      });
      var Footer = /* @__PURE__ */ _export_sfc$1(_sfc_main$G, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/footer.vue"]]);
      const __default__$f = defineComponent({
        name: "ElHeader"
      });
      const _sfc_main$F = /* @__PURE__ */ defineComponent({
        ...__default__$f,
        props: {
          height: {
            type: String,
            default: null
          }
        },
        setup(__props) {
          const props = __props;
          const ns = useNamespace("header");
          const style = computed(() => {
            return props.height ? ns.cssVarBlock({
              height: props.height
            }) : {};
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("header", {
              class: normalizeClass(unref(ns).b()),
              style: normalizeStyle(unref(style))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 6);
          };
        }
      });
      var Header = /* @__PURE__ */ _export_sfc$1(_sfc_main$F, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/header.vue"]]);
      const __default__$e = defineComponent({
        name: "ElMain"
      });
      const _sfc_main$E = /* @__PURE__ */ defineComponent({
        ...__default__$e,
        setup(__props) {
          const ns = useNamespace("main");
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("main", {
              class: normalizeClass(unref(ns).b())
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Main = /* @__PURE__ */ _export_sfc$1(_sfc_main$E, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/main.vue"]]);
      const ElContainer = withInstall(Container, {
        Aside,
        Footer,
        Header,
        Main
      });
      const ElAside = withNoopInstall(Aside);
      withNoopInstall(Footer);
      withNoopInstall(Header);
      const ElMain = withNoopInstall(Main);
      const overlayProps = buildProps({
        mask: {
          type: Boolean,
          default: true
        },
        customMaskEvent: {
          type: Boolean,
          default: false
        },
        overlayClass: {
          type: definePropType([
            String,
            Array,
            Object
          ])
        },
        zIndex: {
          type: definePropType([String, Number])
        }
      });
      const overlayEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      const BLOCK = "overlay";
      var Overlay = defineComponent({
        name: "ElOverlay",
        props: overlayProps,
        emits: overlayEmits,
        setup(props, { slots, emit: emit2 }) {
          const ns = useNamespace(BLOCK);
          const onMaskClick = (e) => {
            emit2("click", e);
          };
          const { onClick, onMousedown, onMouseup } = useSameTarget(props.customMaskEvent ? void 0 : onMaskClick);
          return () => {
            return props.mask ? createVNode("div", {
              class: [ns.b(), props.overlayClass],
              style: {
                zIndex: props.zIndex
              },
              onClick,
              onMousedown,
              onMouseup
            }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h("div", {
              class: props.overlayClass,
              style: {
                zIndex: props.zIndex,
                position: "fixed",
                top: "0px",
                right: "0px",
                bottom: "0px",
                left: "0px"
              }
            }, [renderSlot(slots, "default")]);
          };
        }
      });
      const ElOverlay = Overlay;
      const dialogInjectionKey = Symbol("dialogInjectionKey");
      const dialogContentProps = buildProps({
        center: {
          type: Boolean,
          default: false
        },
        alignCenter: {
          type: Boolean,
          default: false
        },
        closeIcon: {
          type: iconPropType
        },
        customClass: {
          type: String,
          default: ""
        },
        draggable: {
          type: Boolean,
          default: false
        },
        fullscreen: {
          type: Boolean,
          default: false
        },
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        }
      });
      const dialogContentEmits = {
        close: () => true
      };
      const _hoisted_1$E = ["aria-label"];
      const _hoisted_2$v = ["id"];
      const __default__$d = defineComponent({ name: "ElDialogContent" });
      const _sfc_main$D = /* @__PURE__ */ defineComponent({
        ...__default__$d,
        props: dialogContentProps,
        emits: dialogContentEmits,
        setup(__props) {
          const props = __props;
          const { t } = useLocale();
          const { Close } = CloseComponents;
          const { dialogRef, headerRef, bodyId, ns, style } = inject(dialogInjectionKey);
          const { focusTrapRef } = inject(FOCUS_TRAP_INJECTION_KEY);
          const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
          const draggable = computed(() => props.draggable);
          useDraggable(dialogRef, headerRef, draggable);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref: unref(composedDialogRef),
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).is("fullscreen", _ctx.fullscreen),
                unref(ns).is("draggable", unref(draggable)),
                unref(ns).is("align-center", _ctx.alignCenter),
                { [unref(ns).m("center")]: _ctx.center },
                _ctx.customClass
              ]),
              style: normalizeStyle(unref(style)),
              tabindex: "-1"
            }, [
              createBaseVNode("header", {
                ref_key: "headerRef",
                ref: headerRef,
                class: normalizeClass(unref(ns).e("header"))
              }, [
                renderSlot(_ctx.$slots, "header", {}, () => [
                  createBaseVNode("span", {
                    role: "heading",
                    class: normalizeClass(unref(ns).e("title"))
                  }, toDisplayString(_ctx.title), 3)
                ]),
                _ctx.showClose ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  "aria-label": unref(t)("el.dialog.close"),
                  class: normalizeClass(unref(ns).e("headerbtn")),
                  type: "button",
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
                }, [
                  createVNode(unref(ElIcon), {
                    class: normalizeClass(unref(ns).e("close"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon || unref(Close))))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ], 10, _hoisted_1$E)) : createCommentVNode("v-if", true)
              ], 2),
              createBaseVNode("div", {
                id: unref(bodyId),
                class: normalizeClass(unref(ns).e("body"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 10, _hoisted_2$v),
              _ctx.$slots.footer ? (openBlock(), createElementBlock("footer", {
                key: 0,
                class: normalizeClass(unref(ns).e("footer"))
              }, [
                renderSlot(_ctx.$slots, "footer")
              ], 2)) : createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var ElDialogContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$D, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog-content.vue"]]);
      const dialogProps = buildProps({
        ...dialogContentProps,
        appendToBody: {
          type: Boolean,
          default: false
        },
        beforeClose: {
          type: definePropType(Function)
        },
        destroyOnClose: {
          type: Boolean,
          default: false
        },
        closeOnClickModal: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        lockScroll: {
          type: Boolean,
          default: true
        },
        modal: {
          type: Boolean,
          default: true
        },
        openDelay: {
          type: Number,
          default: 0
        },
        closeDelay: {
          type: Number,
          default: 0
        },
        top: {
          type: String
        },
        modelValue: {
          type: Boolean,
          default: false
        },
        modalClass: String,
        width: {
          type: [String, Number]
        },
        zIndex: {
          type: Number
        },
        trapFocus: {
          type: Boolean,
          default: false
        }
      });
      const dialogEmits = {
        open: () => true,
        opened: () => true,
        close: () => true,
        closed: () => true,
        [UPDATE_MODEL_EVENT]: (value) => isBoolean(value),
        openAutoFocus: () => true,
        closeAutoFocus: () => true
      };
      const useDialog = (props, targetRef) => {
        const instance = getCurrentInstance();
        const emit2 = instance.emit;
        const { nextZIndex } = useZIndex();
        let lastPosition = "";
        const titleId = useId();
        const bodyId = useId();
        const visible = ref(false);
        const closed = ref(false);
        const rendered = ref(false);
        const zIndex2 = ref(props.zIndex || nextZIndex());
        let openTimer = void 0;
        let closeTimer = void 0;
        const namespace = useGlobalConfig("namespace", defaultNamespace);
        const style = computed(() => {
          const style2 = {};
          const varPrefix = `--${namespace.value}-dialog`;
          if (!props.fullscreen) {
            if (props.top) {
              style2[`${varPrefix}-margin-top`] = props.top;
            }
            if (props.width) {
              style2[`${varPrefix}-width`] = addUnit(props.width);
            }
          }
          return style2;
        });
        const overlayDialogStyle = computed(() => {
          if (props.alignCenter) {
            return { display: "flex" };
          }
          return {};
        });
        function afterEnter() {
          emit2("opened");
        }
        function afterLeave() {
          emit2("closed");
          emit2(UPDATE_MODEL_EVENT, false);
          if (props.destroyOnClose) {
            rendered.value = false;
          }
        }
        function beforeLeave() {
          emit2("close");
        }
        function open2() {
          closeTimer == null ? void 0 : closeTimer();
          openTimer == null ? void 0 : openTimer();
          if (props.openDelay && props.openDelay > 0) {
            ({ stop: openTimer } = useTimeoutFn$1(() => doOpen(), props.openDelay));
          } else {
            doOpen();
          }
        }
        function close2() {
          openTimer == null ? void 0 : openTimer();
          closeTimer == null ? void 0 : closeTimer();
          if (props.closeDelay && props.closeDelay > 0) {
            ({ stop: closeTimer } = useTimeoutFn$1(() => doClose(), props.closeDelay));
          } else {
            doClose();
          }
        }
        function handleClose() {
          function hide(shouldCancel) {
            if (shouldCancel)
              return;
            closed.value = true;
            visible.value = false;
          }
          if (props.beforeClose) {
            props.beforeClose(hide);
          } else {
            close2();
          }
        }
        function onModalClick() {
          if (props.closeOnClickModal) {
            handleClose();
          }
        }
        function doOpen() {
          if (!isClient$1)
            return;
          visible.value = true;
        }
        function doClose() {
          visible.value = false;
        }
        function onOpenAutoFocus() {
          emit2("openAutoFocus");
        }
        function onCloseAutoFocus() {
          emit2("closeAutoFocus");
        }
        function onFocusoutPrevented(event) {
          var _a2;
          if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) === "pointer") {
            event.preventDefault();
          }
        }
        if (props.lockScroll) {
          useLockscreen(visible);
        }
        function onCloseRequested() {
          if (props.closeOnPressEscape) {
            handleClose();
          }
        }
        watch(() => props.modelValue, (val) => {
          if (val) {
            closed.value = false;
            open2();
            rendered.value = true;
            zIndex2.value = props.zIndex ? zIndex2.value++ : nextZIndex();
            nextTick(() => {
              emit2("open");
              if (targetRef.value) {
                targetRef.value.scrollTop = 0;
              }
            });
          } else {
            if (visible.value) {
              close2();
            }
          }
        });
        watch(() => props.fullscreen, (val) => {
          if (!targetRef.value)
            return;
          if (val) {
            lastPosition = targetRef.value.style.transform;
            targetRef.value.style.transform = "";
          } else {
            targetRef.value.style.transform = lastPosition;
          }
        });
        onMounted(() => {
          if (props.modelValue) {
            visible.value = true;
            rendered.value = true;
            open2();
          }
        });
        return {
          afterEnter,
          afterLeave,
          beforeLeave,
          handleClose,
          onModalClick,
          close: close2,
          doClose,
          onOpenAutoFocus,
          onCloseAutoFocus,
          onCloseRequested,
          onFocusoutPrevented,
          titleId,
          bodyId,
          closed,
          style,
          overlayDialogStyle,
          rendered,
          visible,
          zIndex: zIndex2
        };
      };
      const _hoisted_1$D = ["aria-label", "aria-labelledby", "aria-describedby"];
      const __default__$c = defineComponent({
        name: "ElDialog",
        inheritAttrs: false
      });
      const _sfc_main$C = /* @__PURE__ */ defineComponent({
        ...__default__$c,
        props: dialogProps,
        emits: dialogEmits,
        setup(__props, { expose }) {
          const props = __props;
          const slots = useSlots();
          useDeprecated({
            scope: "el-dialog",
            from: "the title slot",
            replacement: "the header slot",
            version: "3.0.0",
            ref: "https://element-plus.org/en-US/component/dialog.html#slots"
          }, computed(() => !!slots.title));
          useDeprecated({
            scope: "el-dialog",
            from: "custom-class",
            replacement: "class",
            version: "2.3.0",
            ref: "https://element-plus.org/en-US/component/dialog.html#attributes",
            type: "Attribute"
          }, computed(() => !!props.customClass));
          const ns = useNamespace("dialog");
          const dialogRef = ref();
          const headerRef = ref();
          const dialogContentRef = ref();
          const {
            visible,
            titleId,
            bodyId,
            style,
            overlayDialogStyle,
            rendered,
            zIndex: zIndex2,
            afterEnter,
            afterLeave,
            beforeLeave,
            handleClose,
            onModalClick,
            onOpenAutoFocus,
            onCloseAutoFocus,
            onCloseRequested,
            onFocusoutPrevented
          } = useDialog(props, dialogRef);
          provide(dialogInjectionKey, {
            dialogRef,
            headerRef,
            bodyId,
            ns,
            rendered,
            style
          });
          const overlayEvent = useSameTarget(onModalClick);
          const draggable = computed(() => props.draggable && !props.fullscreen);
          expose({
            visible,
            dialogContentRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              to: "body",
              disabled: !_ctx.appendToBody
            }, [
              createVNode(Transition, {
                name: "dialog-fade",
                onAfterEnter: unref(afterEnter),
                onAfterLeave: unref(afterLeave),
                onBeforeLeave: unref(beforeLeave),
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createVNode(unref(ElOverlay), {
                    "custom-mask-event": "",
                    mask: _ctx.modal,
                    "overlay-class": _ctx.modalClass,
                    "z-index": unref(zIndex2)
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        role: "dialog",
                        "aria-modal": "true",
                        "aria-label": _ctx.title || void 0,
                        "aria-labelledby": !_ctx.title ? unref(titleId) : void 0,
                        "aria-describedby": unref(bodyId),
                        class: normalizeClass(`${unref(ns).namespace.value}-overlay-dialog`),
                        style: normalizeStyle(unref(overlayDialogStyle)),
                        onClick: _cache[0] || (_cache[0] = (...args) => unref(overlayEvent).onClick && unref(overlayEvent).onClick(...args)),
                        onMousedown: _cache[1] || (_cache[1] = (...args) => unref(overlayEvent).onMousedown && unref(overlayEvent).onMousedown(...args)),
                        onMouseup: _cache[2] || (_cache[2] = (...args) => unref(overlayEvent).onMouseup && unref(overlayEvent).onMouseup(...args))
                      }, [
                        createVNode(unref(ElFocusTrap), {
                          loop: "",
                          trapped: unref(visible),
                          "focus-start-el": "container",
                          onFocusAfterTrapped: unref(onOpenAutoFocus),
                          onFocusAfterReleased: unref(onCloseAutoFocus),
                          onFocusoutPrevented: unref(onFocusoutPrevented),
                          onReleaseRequested: unref(onCloseRequested)
                        }, {
                          default: withCtx(() => [
                            unref(rendered) ? (openBlock(), createBlock(ElDialogContent, mergeProps({
                              key: 0,
                              ref_key: "dialogContentRef",
                              ref: dialogContentRef
                            }, _ctx.$attrs, {
                              "custom-class": _ctx.customClass,
                              center: _ctx.center,
                              "align-center": _ctx.alignCenter,
                              "close-icon": _ctx.closeIcon,
                              draggable: unref(draggable),
                              fullscreen: _ctx.fullscreen,
                              "show-close": _ctx.showClose,
                              title: _ctx.title,
                              onClose: unref(handleClose)
                            }), createSlots({
                              header: withCtx(() => [
                                !_ctx.$slots.title ? renderSlot(_ctx.$slots, "header", {
                                  key: 0,
                                  close: unref(handleClose),
                                  titleId: unref(titleId),
                                  titleClass: unref(ns).e("title")
                                }) : renderSlot(_ctx.$slots, "title", { key: 1 })
                              ]),
                              default: withCtx(() => [
                                renderSlot(_ctx.$slots, "default")
                              ]),
                              _: 2
                            }, [
                              _ctx.$slots.footer ? {
                                name: "footer",
                                fn: withCtx(() => [
                                  renderSlot(_ctx.$slots, "footer")
                                ])
                              } : void 0
                            ]), 1040, ["custom-class", "center", "align-center", "close-icon", "draggable", "fullscreen", "show-close", "title", "onClose"])) : createCommentVNode("v-if", true)
                          ]),
                          _: 3
                        }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                      ], 46, _hoisted_1$D)
                    ]),
                    _: 3
                  }, 8, ["mask", "overlay-class", "z-index"]), [
                    [vShow, unref(visible)]
                  ])
                ]),
                _: 3
              }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
            ], 8, ["disabled"]);
          };
        }
      });
      var Dialog = /* @__PURE__ */ _export_sfc$1(_sfc_main$C, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog.vue"]]);
      const ElDialog = withInstall(Dialog);
      const _sfc_main$B = /* @__PURE__ */ defineComponent({
        inheritAttrs: false
      });
      function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default");
      }
      var Collection = /* @__PURE__ */ _export_sfc$1(_sfc_main$B, [["render", _sfc_render$g], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);
      const _sfc_main$A = /* @__PURE__ */ defineComponent({
        name: "ElCollectionItem",
        inheritAttrs: false
      });
      function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default");
      }
      var CollectionItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$A, [["render", _sfc_render$f], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);
      const COLLECTION_ITEM_SIGN = `data-el-collection-item`;
      const createCollectionWithScope = (name) => {
        const COLLECTION_NAME = `El${name}Collection`;
        const COLLECTION_ITEM_NAME = `${COLLECTION_NAME}Item`;
        const COLLECTION_INJECTION_KEY2 = Symbol(COLLECTION_NAME);
        const COLLECTION_ITEM_INJECTION_KEY2 = Symbol(COLLECTION_ITEM_NAME);
        const ElCollection2 = {
          ...Collection,
          name: COLLECTION_NAME,
          setup() {
            const collectionRef = ref(null);
            const itemMap = /* @__PURE__ */ new Map();
            const getItems = () => {
              const collectionEl = unref(collectionRef);
              if (!collectionEl)
                return [];
              const orderedNodes = Array.from(collectionEl.querySelectorAll(`[${COLLECTION_ITEM_SIGN}]`));
              const items = [...itemMap.values()];
              return items.sort((a, b) => orderedNodes.indexOf(a.ref) - orderedNodes.indexOf(b.ref));
            };
            provide(COLLECTION_INJECTION_KEY2, {
              itemMap,
              getItems,
              collectionRef
            });
          }
        };
        const ElCollectionItem2 = {
          ...CollectionItem,
          name: COLLECTION_ITEM_NAME,
          setup(_, { attrs }) {
            const collectionItemRef = ref(null);
            const collectionInjection = inject(COLLECTION_INJECTION_KEY2, void 0);
            provide(COLLECTION_ITEM_INJECTION_KEY2, {
              collectionItemRef
            });
            onMounted(() => {
              const collectionItemEl = unref(collectionItemRef);
              if (collectionItemEl) {
                collectionInjection.itemMap.set(collectionItemEl, {
                  ref: collectionItemEl,
                  ...attrs
                });
              }
            });
            onBeforeUnmount(() => {
              const collectionItemEl = unref(collectionItemRef);
              collectionInjection.itemMap.delete(collectionItemEl);
            });
          }
        };
        return {
          COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY2,
          COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY2,
          ElCollection: ElCollection2,
          ElCollectionItem: ElCollectionItem2
        };
      };
      const rovingFocusGroupProps = buildProps({
        style: { type: definePropType([String, Array, Object]) },
        currentTabId: {
          type: definePropType(String)
        },
        defaultCurrentTabId: String,
        loop: Boolean,
        dir: {
          type: String,
          values: ["ltr", "rtl"],
          default: "ltr"
        },
        orientation: {
          type: definePropType(String)
        },
        onBlur: Function,
        onFocus: Function,
        onMousedown: Function
      });
      const {
        ElCollection: ElCollection$1,
        ElCollectionItem: ElCollectionItem$1,
        COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY$1,
        COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY$1
      } = createCollectionWithScope("RovingFocusGroup");
      const ROVING_FOCUS_GROUP_INJECTION_KEY = Symbol("elRovingFocusGroup");
      const ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY = Symbol("elRovingFocusGroupItem");
      const MAP_KEY_TO_FOCUS_INTENT = {
        ArrowLeft: "prev",
        ArrowUp: "prev",
        ArrowRight: "next",
        ArrowDown: "next",
        PageUp: "first",
        Home: "first",
        PageDown: "last",
        End: "last"
      };
      const getDirectionAwareKey = (key, dir) => {
        if (dir !== "rtl")
          return key;
        switch (key) {
          case EVENT_CODE.right:
            return EVENT_CODE.left;
          case EVENT_CODE.left:
            return EVENT_CODE.right;
          default:
            return key;
        }
      };
      const getFocusIntent = (event, orientation, dir) => {
        const key = getDirectionAwareKey(event.key, dir);
        if (orientation === "vertical" && [EVENT_CODE.left, EVENT_CODE.right].includes(key))
          return void 0;
        if (orientation === "horizontal" && [EVENT_CODE.up, EVENT_CODE.down].includes(key))
          return void 0;
        return MAP_KEY_TO_FOCUS_INTENT[key];
      };
      const reorderArray = (array2, atIdx) => {
        return array2.map((_, idx) => array2[(idx + atIdx) % array2.length]);
      };
      const focusFirst = (elements) => {
        const { activeElement: prevActive } = document;
        for (const element of elements) {
          if (element === prevActive)
            return;
          element.focus();
          if (prevActive !== document.activeElement)
            return;
        }
      };
      const CURRENT_TAB_ID_CHANGE_EVT = "currentTabIdChange";
      const ENTRY_FOCUS_EVT = "rovingFocusGroup.entryFocus";
      const EVT_OPTS = { bubbles: false, cancelable: true };
      const _sfc_main$z = defineComponent({
        name: "ElRovingFocusGroupImpl",
        inheritAttrs: false,
        props: rovingFocusGroupProps,
        emits: [CURRENT_TAB_ID_CHANGE_EVT, "entryFocus"],
        setup(props, { emit: emit2 }) {
          var _a2;
          const currentTabbedId = ref((_a2 = props.currentTabId || props.defaultCurrentTabId) != null ? _a2 : null);
          const isBackingOut = ref(false);
          const isClickFocus = ref(false);
          const rovingFocusGroupRef = ref(null);
          const { getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
          const rovingFocusGroupRootStyle = computed(() => {
            return [
              {
                outline: "none"
              },
              props.style
            ];
          });
          const onItemFocus = (tabbedId) => {
            emit2(CURRENT_TAB_ID_CHANGE_EVT, tabbedId);
          };
          const onItemShiftTab = () => {
            isBackingOut.value = true;
          };
          const onMousedown = composeEventHandlers((e) => {
            var _a22;
            (_a22 = props.onMousedown) == null ? void 0 : _a22.call(props, e);
          }, () => {
            isClickFocus.value = true;
          });
          const onFocus = composeEventHandlers((e) => {
            var _a22;
            (_a22 = props.onFocus) == null ? void 0 : _a22.call(props, e);
          }, (e) => {
            const isKeyboardFocus = !unref(isClickFocus);
            const { target, currentTarget } = e;
            if (target === currentTarget && isKeyboardFocus && !unref(isBackingOut)) {
              const entryFocusEvt = new Event(ENTRY_FOCUS_EVT, EVT_OPTS);
              currentTarget == null ? void 0 : currentTarget.dispatchEvent(entryFocusEvt);
              if (!entryFocusEvt.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === unref(currentTabbedId));
                const candidates = [activeItem, currentItem, ...items].filter(Boolean);
                const candidateNodes = candidates.map((item) => item.ref);
                focusFirst(candidateNodes);
              }
            }
            isClickFocus.value = false;
          });
          const onBlur = composeEventHandlers((e) => {
            var _a22;
            (_a22 = props.onBlur) == null ? void 0 : _a22.call(props, e);
          }, () => {
            isBackingOut.value = false;
          });
          const handleEntryFocus = (...args) => {
            emit2("entryFocus", ...args);
          };
          provide(ROVING_FOCUS_GROUP_INJECTION_KEY, {
            currentTabbedId: readonly(currentTabbedId),
            loop: toRef$1(props, "loop"),
            tabIndex: computed(() => {
              return unref(isBackingOut) ? -1 : 0;
            }),
            rovingFocusGroupRef,
            rovingFocusGroupRootStyle,
            orientation: toRef$1(props, "orientation"),
            dir: toRef$1(props, "dir"),
            onItemFocus,
            onItemShiftTab,
            onBlur,
            onFocus,
            onMousedown
          });
          watch(() => props.currentTabId, (val) => {
            currentTabbedId.value = val != null ? val : null;
          });
          useEventListener$1(rovingFocusGroupRef, ENTRY_FOCUS_EVT, handleEntryFocus);
        }
      });
      function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default");
      }
      var ElRovingFocusGroupImpl = /* @__PURE__ */ _export_sfc$1(_sfc_main$z, [["render", _sfc_render$e], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group-impl.vue"]]);
      const _sfc_main$y = defineComponent({
        name: "ElRovingFocusGroup",
        components: {
          ElFocusGroupCollection: ElCollection$1,
          ElRovingFocusGroupImpl
        }
      });
      function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_roving_focus_group_impl = resolveComponent("el-roving-focus-group-impl");
        const _component_el_focus_group_collection = resolveComponent("el-focus-group-collection");
        return openBlock(), createBlock(_component_el_focus_group_collection, null, {
          default: withCtx(() => [
            createVNode(_component_el_roving_focus_group_impl, normalizeProps(guardReactiveProps(_ctx.$attrs)), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        });
      }
      var ElRovingFocusGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$y, [["render", _sfc_render$d], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group.vue"]]);
      const _sfc_main$x = defineComponent({
        components: {
          ElRovingFocusCollectionItem: ElCollectionItem$1
        },
        props: {
          focusable: {
            type: Boolean,
            default: true
          },
          active: {
            type: Boolean,
            default: false
          }
        },
        emits: ["mousedown", "focus", "keydown"],
        setup(props, { emit: emit2 }) {
          const { currentTabbedId, loop, onItemFocus, onItemShiftTab } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
          const { getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
          const id2 = useId();
          const rovingFocusGroupItemRef = ref(null);
          const handleMousedown = composeEventHandlers((e) => {
            emit2("mousedown", e);
          }, (e) => {
            if (!props.focusable) {
              e.preventDefault();
            } else {
              onItemFocus(unref(id2));
            }
          });
          const handleFocus = composeEventHandlers((e) => {
            emit2("focus", e);
          }, () => {
            onItemFocus(unref(id2));
          });
          const handleKeydown = composeEventHandlers((e) => {
            emit2("keydown", e);
          }, (e) => {
            const { key, shiftKey, target, currentTarget } = e;
            if (key === EVENT_CODE.tab && shiftKey) {
              onItemShiftTab();
              return;
            }
            if (target !== currentTarget)
              return;
            const focusIntent = getFocusIntent(e);
            if (focusIntent) {
              e.preventDefault();
              const items = getItems().filter((item) => item.focusable);
              let elements = items.map((item) => item.ref);
              switch (focusIntent) {
                case "last": {
                  elements.reverse();
                  break;
                }
                case "prev":
                case "next": {
                  if (focusIntent === "prev") {
                    elements.reverse();
                  }
                  const currentIdx = elements.indexOf(currentTarget);
                  elements = loop.value ? reorderArray(elements, currentIdx + 1) : elements.slice(currentIdx + 1);
                  break;
                }
              }
              nextTick(() => {
                focusFirst(elements);
              });
            }
          });
          const isCurrentTab = computed(() => currentTabbedId.value === unref(id2));
          provide(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, {
            rovingFocusGroupItemRef,
            tabIndex: computed(() => unref(isCurrentTab) ? 0 : -1),
            handleMousedown,
            handleFocus,
            handleKeydown
          });
          return {
            id: id2,
            handleKeydown,
            handleFocus,
            handleMousedown
          };
        }
      });
      function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_roving_focus_collection_item = resolveComponent("el-roving-focus-collection-item");
        return openBlock(), createBlock(_component_el_roving_focus_collection_item, {
          id: _ctx.id,
          focusable: _ctx.focusable,
          active: _ctx.active
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "focusable", "active"]);
      }
      var ElRovingFocusItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$x, [["render", _sfc_render$c], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-item.vue"]]);
      const dropdownProps = buildProps({
        trigger: useTooltipTriggerProps.trigger,
        effect: {
          ...useTooltipContentProps.effect,
          default: "light"
        },
        type: {
          type: definePropType(String)
        },
        placement: {
          type: definePropType(String),
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        id: String,
        size: {
          type: String,
          default: ""
        },
        splitButton: Boolean,
        hideOnClick: {
          type: Boolean,
          default: true
        },
        loop: {
          type: Boolean,
          default: true
        },
        showTimeout: {
          type: Number,
          default: 150
        },
        hideTimeout: {
          type: Number,
          default: 150
        },
        tabindex: {
          type: definePropType([Number, String]),
          default: 0
        },
        maxHeight: {
          type: definePropType([Number, String]),
          default: ""
        },
        popperClass: {
          type: String,
          default: ""
        },
        disabled: {
          type: Boolean,
          default: false
        },
        role: {
          type: String,
          default: "menu"
        },
        buttonProps: {
          type: definePropType(Object)
        },
        teleported: useTooltipContentProps.teleported
      });
      const dropdownItemProps = buildProps({
        command: {
          type: [Object, String, Number],
          default: () => ({})
        },
        disabled: Boolean,
        divided: Boolean,
        textValue: String,
        icon: {
          type: iconPropType
        }
      });
      const dropdownMenuProps = buildProps({
        onKeydown: { type: definePropType(Function) }
      });
      const FIRST_KEYS = [
        EVENT_CODE.down,
        EVENT_CODE.pageDown,
        EVENT_CODE.home
      ];
      const LAST_KEYS = [EVENT_CODE.up, EVENT_CODE.pageUp, EVENT_CODE.end];
      const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
      const {
        ElCollection,
        ElCollectionItem,
        COLLECTION_INJECTION_KEY,
        COLLECTION_ITEM_INJECTION_KEY
      } = createCollectionWithScope("Dropdown");
      const DROPDOWN_INJECTION_KEY = Symbol("elDropdown");
      const { ButtonGroup: ElButtonGroup } = ElButton;
      const _sfc_main$w = defineComponent({
        name: "ElDropdown",
        components: {
          ElButton,
          ElButtonGroup,
          ElScrollbar,
          ElDropdownCollection: ElCollection,
          ElTooltip,
          ElRovingFocusGroup,
          ElOnlyChild: OnlyChild,
          ElIcon,
          ArrowDown: arrow_down_default
        },
        props: dropdownProps,
        emits: ["visible-change", "click", "command"],
        setup(props, { emit: emit2 }) {
          const _instance = getCurrentInstance();
          const ns = useNamespace("dropdown");
          const { t } = useLocale();
          const triggeringElementRef = ref();
          const referenceElementRef = ref();
          const popperRef = ref(null);
          const contentRef = ref(null);
          const scrollbar = ref(null);
          const currentTabId = ref(null);
          const isUsingKeyboard = ref(false);
          const triggerKeys = [EVENT_CODE.enter, EVENT_CODE.space, EVENT_CODE.down];
          const wrapStyle = computed(() => ({
            maxHeight: addUnit(props.maxHeight)
          }));
          const dropdownTriggerKls = computed(() => [ns.m(dropdownSize.value)]);
          const defaultTriggerId = useId().value;
          const triggerId = computed(() => {
            return props.id || defaultTriggerId;
          });
          watch([triggeringElementRef, toRef$1(props, "trigger")], ([triggeringElement, trigger2], [prevTriggeringElement]) => {
            var _a2, _b, _c;
            const triggerArray = isArray$2(trigger2) ? trigger2 : [trigger2];
            if ((_a2 = prevTriggeringElement == null ? void 0 : prevTriggeringElement.$el) == null ? void 0 : _a2.removeEventListener) {
              prevTriggeringElement.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
            }
            if ((_b = triggeringElement == null ? void 0 : triggeringElement.$el) == null ? void 0 : _b.removeEventListener) {
              triggeringElement.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
            }
            if (((_c = triggeringElement == null ? void 0 : triggeringElement.$el) == null ? void 0 : _c.addEventListener) && triggerArray.includes("hover")) {
              triggeringElement.$el.addEventListener("pointerenter", onAutofocusTriggerEnter);
            }
          }, { immediate: true });
          onBeforeUnmount(() => {
            var _a2, _b;
            if ((_b = (_a2 = triggeringElementRef.value) == null ? void 0 : _a2.$el) == null ? void 0 : _b.removeEventListener) {
              triggeringElementRef.value.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
            }
          });
          function handleClick() {
            handleClose();
          }
          function handleClose() {
            var _a2;
            (_a2 = popperRef.value) == null ? void 0 : _a2.onClose();
          }
          function handleOpen() {
            var _a2;
            (_a2 = popperRef.value) == null ? void 0 : _a2.onOpen();
          }
          const dropdownSize = useFormSize();
          function commandHandler(...args) {
            emit2("command", ...args);
          }
          function onAutofocusTriggerEnter() {
            var _a2, _b;
            (_b = (_a2 = triggeringElementRef.value) == null ? void 0 : _a2.$el) == null ? void 0 : _b.focus();
          }
          function onItemEnter() {
          }
          function onItemLeave() {
            const contentEl = unref(contentRef);
            contentEl == null ? void 0 : contentEl.focus();
            currentTabId.value = null;
          }
          function handleCurrentTabIdChange(id2) {
            currentTabId.value = id2;
          }
          function handleEntryFocus(e) {
            if (!isUsingKeyboard.value) {
              e.preventDefault();
              e.stopImmediatePropagation();
            }
          }
          function handleBeforeShowTooltip() {
            emit2("visible-change", true);
          }
          function handleShowTooltip(event) {
            if ((event == null ? void 0 : event.type) === "keydown") {
              contentRef.value.focus();
            }
          }
          function handleBeforeHideTooltip() {
            emit2("visible-change", false);
          }
          provide(DROPDOWN_INJECTION_KEY, {
            contentRef,
            role: computed(() => props.role),
            triggerId,
            isUsingKeyboard,
            onItemEnter,
            onItemLeave
          });
          provide("elDropdown", {
            instance: _instance,
            dropdownSize,
            handleClick,
            commandHandler,
            trigger: toRef$1(props, "trigger"),
            hideOnClick: toRef$1(props, "hideOnClick")
          });
          const onFocusAfterTrapped = (e) => {
            var _a2, _b;
            e.preventDefault();
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2, {
              preventScroll: true
            });
          };
          const handlerMainButtonClick = (event) => {
            emit2("click", event);
          };
          return {
            t,
            ns,
            scrollbar,
            wrapStyle,
            dropdownTriggerKls,
            dropdownSize,
            triggerId,
            triggerKeys,
            currentTabId,
            handleCurrentTabIdChange,
            handlerMainButtonClick,
            handleEntryFocus,
            handleClose,
            handleOpen,
            handleBeforeShowTooltip,
            handleShowTooltip,
            handleBeforeHideTooltip,
            onFocusAfterTrapped,
            popperRef,
            contentRef,
            triggeringElementRef,
            referenceElementRef
          };
        }
      });
      function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
        var _a2;
        const _component_el_dropdown_collection = resolveComponent("el-dropdown-collection");
        const _component_el_roving_focus_group = resolveComponent("el-roving-focus-group");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_el_only_child = resolveComponent("el-only-child");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _component_el_button = resolveComponent("el-button");
        const _component_arrow_down = resolveComponent("arrow-down");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_button_group = resolveComponent("el-button-group");
        return openBlock(), createElementBlock("div", {
          class: normalizeClass([_ctx.ns.b(), _ctx.ns.is("disabled", _ctx.disabled)])
        }, [
          createVNode(_component_el_tooltip, {
            ref: "popperRef",
            role: _ctx.role,
            effect: _ctx.effect,
            "fallback-placements": ["bottom", "top"],
            "popper-options": _ctx.popperOptions,
            "gpu-acceleration": false,
            "hide-after": _ctx.trigger === "hover" ? _ctx.hideTimeout : 0,
            "manual-mode": true,
            placement: _ctx.placement,
            "popper-class": [_ctx.ns.e("popper"), _ctx.popperClass],
            "reference-element": (_a2 = _ctx.referenceElementRef) == null ? void 0 : _a2.$el,
            trigger: _ctx.trigger,
            "trigger-keys": _ctx.triggerKeys,
            "trigger-target-el": _ctx.contentRef,
            "show-after": _ctx.trigger === "hover" ? _ctx.showTimeout : 0,
            "stop-popper-mouse-event": false,
            "virtual-ref": _ctx.triggeringElementRef,
            "virtual-triggering": _ctx.splitButton,
            disabled: _ctx.disabled,
            transition: `${_ctx.ns.namespace.value}-zoom-in-top`,
            teleported: _ctx.teleported,
            pure: "",
            persistent: "",
            onBeforeShow: _ctx.handleBeforeShowTooltip,
            onShow: _ctx.handleShowTooltip,
            onBeforeHide: _ctx.handleBeforeHideTooltip
          }, createSlots({
            content: withCtx(() => [
              createVNode(_component_el_scrollbar, {
                ref: "scrollbar",
                "wrap-style": _ctx.wrapStyle,
                tag: "div",
                "view-class": _ctx.ns.e("list")
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_roving_focus_group, {
                    loop: _ctx.loop,
                    "current-tab-id": _ctx.currentTabId,
                    orientation: "horizontal",
                    onCurrentTabIdChange: _ctx.handleCurrentTabIdChange,
                    onEntryFocus: _ctx.handleEntryFocus
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_el_dropdown_collection, null, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "dropdown")
                        ]),
                        _: 3
                      })
                    ]),
                    _: 3
                  }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"])
                ]),
                _: 3
              }, 8, ["wrap-style", "view-class"])
            ]),
            _: 2
          }, [
            !_ctx.splitButton ? {
              name: "default",
              fn: withCtx(() => [
                createVNode(_component_el_only_child, {
                  id: _ctx.triggerId,
                  ref: "triggeringElementRef",
                  role: "button",
                  tabindex: _ctx.tabindex
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["id", "tabindex"])
              ])
            } : void 0
          ]), 1032, ["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "teleported", "onBeforeShow", "onShow", "onBeforeHide"]),
          _ctx.splitButton ? (openBlock(), createBlock(_component_el_button_group, { key: 0 }, {
            default: withCtx(() => [
              createVNode(_component_el_button, mergeProps({ ref: "referenceElementRef" }, _ctx.buttonProps, {
                size: _ctx.dropdownSize,
                type: _ctx.type,
                disabled: _ctx.disabled,
                tabindex: _ctx.tabindex,
                onClick: _ctx.handlerMainButtonClick
              }), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 16, ["size", "type", "disabled", "tabindex", "onClick"]),
              createVNode(_component_el_button, mergeProps({
                id: _ctx.triggerId,
                ref: "triggeringElementRef"
              }, _ctx.buttonProps, {
                role: "button",
                size: _ctx.dropdownSize,
                type: _ctx.type,
                class: _ctx.ns.e("caret-button"),
                disabled: _ctx.disabled,
                tabindex: _ctx.tabindex,
                "aria-label": _ctx.t("el.dropdown.toggleDropdown")
              }), {
                default: withCtx(() => [
                  createVNode(_component_el_icon, {
                    class: normalizeClass(_ctx.ns.e("icon"))
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_arrow_down)
                    ]),
                    _: 1
                  }, 8, ["class"])
                ]),
                _: 1
              }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])
            ]),
            _: 3
          })) : createCommentVNode("v-if", true)
        ], 2);
      }
      var Dropdown = /* @__PURE__ */ _export_sfc$1(_sfc_main$w, [["render", _sfc_render$b], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown.vue"]]);
      const _sfc_main$v = defineComponent({
        name: "DropdownItemImpl",
        components: {
          ElIcon
        },
        props: dropdownItemProps,
        emits: ["pointermove", "pointerleave", "click", "clickimpl"],
        setup(_, { emit: emit2 }) {
          const ns = useNamespace("dropdown");
          const { role: menuRole } = inject(DROPDOWN_INJECTION_KEY, void 0);
          const { collectionItemRef: dropdownCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY, void 0);
          const { collectionItemRef: rovingFocusCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY$1, void 0);
          const {
            rovingFocusGroupItemRef,
            tabIndex,
            handleFocus,
            handleKeydown: handleItemKeydown,
            handleMousedown
          } = inject(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, void 0);
          const itemRef = composeRefs(dropdownCollectionItemRef, rovingFocusCollectionItemRef, rovingFocusGroupItemRef);
          const role = computed(() => {
            if (menuRole.value === "menu") {
              return "menuitem";
            } else if (menuRole.value === "navigation") {
              return "link";
            }
            return "button";
          });
          const handleKeydown = composeEventHandlers((e) => {
            const { code } = e;
            if (code === EVENT_CODE.enter || code === EVENT_CODE.space) {
              e.preventDefault();
              e.stopImmediatePropagation();
              emit2("clickimpl", e);
              return true;
            }
          }, handleItemKeydown);
          return {
            ns,
            itemRef,
            dataset: {
              [COLLECTION_ITEM_SIGN]: ""
            },
            role,
            tabIndex,
            handleFocus,
            handleKeydown,
            handleMousedown
          };
        }
      });
      const _hoisted_1$C = ["aria-disabled", "tabindex", "role"];
      function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_icon = resolveComponent("el-icon");
        return openBlock(), createElementBlock(Fragment, null, [
          _ctx.divided ? (openBlock(), createElementBlock("li", mergeProps({
            key: 0,
            role: "separator",
            class: _ctx.ns.bem("menu", "item", "divided")
          }, _ctx.$attrs), null, 16)) : createCommentVNode("v-if", true),
          createBaseVNode("li", mergeProps({ ref: _ctx.itemRef }, { ..._ctx.dataset, ..._ctx.$attrs }, {
            "aria-disabled": _ctx.disabled,
            class: [_ctx.ns.be("menu", "item"), _ctx.ns.is("disabled", _ctx.disabled)],
            tabindex: _ctx.tabIndex,
            role: _ctx.role,
            onClick: _cache[0] || (_cache[0] = (e) => _ctx.$emit("clickimpl", e)),
            onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
            onKeydown: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args), ["self"])),
            onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.handleMousedown && _ctx.handleMousedown(...args)),
            onPointermove: _cache[4] || (_cache[4] = (e) => _ctx.$emit("pointermove", e)),
            onPointerleave: _cache[5] || (_cache[5] = (e) => _ctx.$emit("pointerleave", e))
          }), [
            _ctx.icon ? (openBlock(), createBlock(_component_el_icon, { key: 0 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
              ]),
              _: 1
            })) : createCommentVNode("v-if", true),
            renderSlot(_ctx.$slots, "default")
          ], 16, _hoisted_1$C)
        ], 64);
      }
      var ElDropdownItemImpl = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["render", _sfc_render$a], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item-impl.vue"]]);
      const useDropdown = () => {
        const elDropdown2 = inject("elDropdown", {});
        const _elDropdownSize = computed(() => elDropdown2 == null ? void 0 : elDropdown2.dropdownSize);
        return {
          elDropdown: elDropdown2,
          _elDropdownSize
        };
      };
      const _sfc_main$u = defineComponent({
        name: "ElDropdownItem",
        components: {
          ElDropdownCollectionItem: ElCollectionItem,
          ElRovingFocusItem,
          ElDropdownItemImpl
        },
        inheritAttrs: false,
        props: dropdownItemProps,
        emits: ["pointermove", "pointerleave", "click"],
        setup(props, { emit: emit2, attrs }) {
          const { elDropdown: elDropdown2 } = useDropdown();
          const _instance = getCurrentInstance();
          const itemRef = ref(null);
          const textContent = computed(() => {
            var _a2, _b;
            return (_b = (_a2 = unref(itemRef)) == null ? void 0 : _a2.textContent) != null ? _b : "";
          });
          const { onItemEnter, onItemLeave } = inject(DROPDOWN_INJECTION_KEY, void 0);
          const handlePointerMove = composeEventHandlers((e) => {
            emit2("pointermove", e);
            return e.defaultPrevented;
          }, whenMouse((e) => {
            if (props.disabled) {
              onItemLeave(e);
              return;
            }
            const target = e.currentTarget;
            if (target === document.activeElement || target.contains(document.activeElement)) {
              return;
            }
            onItemEnter(e);
            if (!e.defaultPrevented) {
              target == null ? void 0 : target.focus();
            }
          }));
          const handlePointerLeave = composeEventHandlers((e) => {
            emit2("pointerleave", e);
            return e.defaultPrevented;
          }, whenMouse((e) => {
            onItemLeave(e);
          }));
          const handleClick = composeEventHandlers((e) => {
            if (props.disabled) {
              return;
            }
            emit2("click", e);
            return e.type !== "keydown" && e.defaultPrevented;
          }, (e) => {
            var _a2, _b, _c;
            if (props.disabled) {
              e.stopImmediatePropagation();
              return;
            }
            if ((_a2 = elDropdown2 == null ? void 0 : elDropdown2.hideOnClick) == null ? void 0 : _a2.value) {
              (_b = elDropdown2.handleClick) == null ? void 0 : _b.call(elDropdown2);
            }
            (_c = elDropdown2.commandHandler) == null ? void 0 : _c.call(elDropdown2, props.command, _instance, e);
          });
          const propsAndAttrs = computed(() => {
            return { ...props, ...attrs };
          });
          return {
            handleClick,
            handlePointerMove,
            handlePointerLeave,
            textContent,
            propsAndAttrs
          };
        }
      });
      function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
        var _a2;
        const _component_el_dropdown_item_impl = resolveComponent("el-dropdown-item-impl");
        const _component_el_roving_focus_item = resolveComponent("el-roving-focus-item");
        const _component_el_dropdown_collection_item = resolveComponent("el-dropdown-collection-item");
        return openBlock(), createBlock(_component_el_dropdown_collection_item, {
          disabled: _ctx.disabled,
          "text-value": (_a2 = _ctx.textValue) != null ? _a2 : _ctx.textContent
        }, {
          default: withCtx(() => [
            createVNode(_component_el_roving_focus_item, {
              focusable: !_ctx.disabled
            }, {
              default: withCtx(() => [
                createVNode(_component_el_dropdown_item_impl, mergeProps(_ctx.propsAndAttrs, {
                  onPointerleave: _ctx.handlePointerLeave,
                  onPointermove: _ctx.handlePointerMove,
                  onClickimpl: _ctx.handleClick
                }), {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])
              ]),
              _: 3
            }, 8, ["focusable"])
          ]),
          _: 3
        }, 8, ["disabled", "text-value"]);
      }
      var DropdownItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["render", _sfc_render$9], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item.vue"]]);
      const _sfc_main$t = defineComponent({
        name: "ElDropdownMenu",
        props: dropdownMenuProps,
        setup(props) {
          const ns = useNamespace("dropdown");
          const { _elDropdownSize } = useDropdown();
          const size2 = _elDropdownSize.value;
          const { focusTrapRef, onKeydown } = inject(FOCUS_TRAP_INJECTION_KEY, void 0);
          const { contentRef, role, triggerId } = inject(DROPDOWN_INJECTION_KEY, void 0);
          const { collectionRef: dropdownCollectionRef, getItems } = inject(COLLECTION_INJECTION_KEY, void 0);
          const {
            rovingFocusGroupRef,
            rovingFocusGroupRootStyle,
            tabIndex,
            onBlur,
            onFocus,
            onMousedown
          } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
          const { collectionRef: rovingFocusGroupCollectionRef } = inject(COLLECTION_INJECTION_KEY$1, void 0);
          const dropdownKls = computed(() => {
            return [ns.b("menu"), ns.bm("menu", size2 == null ? void 0 : size2.value)];
          });
          const dropdownListWrapperRef = composeRefs(contentRef, dropdownCollectionRef, focusTrapRef, rovingFocusGroupRef, rovingFocusGroupCollectionRef);
          const composedKeydown = composeEventHandlers((e) => {
            var _a2;
            (_a2 = props.onKeydown) == null ? void 0 : _a2.call(props, e);
          }, (e) => {
            const { currentTarget, code, target } = e;
            currentTarget.contains(target);
            if (EVENT_CODE.tab === code) {
              e.stopImmediatePropagation();
            }
            e.preventDefault();
            if (target !== unref(contentRef))
              return;
            if (!FIRST_LAST_KEYS.includes(code))
              return;
            const items = getItems().filter((item) => !item.disabled);
            const targets = items.map((item) => item.ref);
            if (LAST_KEYS.includes(code)) {
              targets.reverse();
            }
            focusFirst(targets);
          });
          const handleKeydown = (e) => {
            composedKeydown(e);
            onKeydown(e);
          };
          return {
            size: size2,
            rovingFocusGroupRootStyle,
            tabIndex,
            dropdownKls,
            role,
            triggerId,
            dropdownListWrapperRef,
            handleKeydown,
            onBlur,
            onFocus,
            onMousedown
          };
        }
      });
      const _hoisted_1$B = ["role", "aria-labelledby"];
      function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("ul", {
          ref: _ctx.dropdownListWrapperRef,
          class: normalizeClass(_ctx.dropdownKls),
          style: normalizeStyle(_ctx.rovingFocusGroupRootStyle),
          tabindex: -1,
          role: _ctx.role,
          "aria-labelledby": _ctx.triggerId,
          onBlur: _cache[0] || (_cache[0] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
          onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
          onKeydown: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args), ["self"])),
          onMousedown: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.onMousedown && _ctx.onMousedown(...args), ["self"]))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 46, _hoisted_1$B);
      }
      var DropdownMenu = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["render", _sfc_render$8], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-menu.vue"]]);
      const ElDropdown = withInstall(Dropdown, {
        DropdownItem,
        DropdownMenu
      });
      const ElDropdownItem = withNoopInstall(DropdownItem);
      const ElDropdownMenu = withNoopInstall(DropdownMenu);
      const inputNumberProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        step: {
          type: Number,
          default: 1
        },
        stepStrictly: Boolean,
        max: {
          type: Number,
          default: Number.POSITIVE_INFINITY
        },
        min: {
          type: Number,
          default: Number.NEGATIVE_INFINITY
        },
        modelValue: Number,
        readonly: Boolean,
        disabled: Boolean,
        size: useSizeProp,
        controls: {
          type: Boolean,
          default: true
        },
        controlsPosition: {
          type: String,
          default: "",
          values: ["", "right"]
        },
        valueOnClear: {
          type: [String, Number, null],
          validator: (val) => val === null || isNumber(val) || ["min", "max"].includes(val),
          default: null
        },
        name: String,
        label: String,
        placeholder: String,
        precision: {
          type: Number,
          validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const inputNumberEmits = {
        [CHANGE_EVENT]: (cur, prev) => prev !== cur,
        blur: (e) => e instanceof FocusEvent,
        focus: (e) => e instanceof FocusEvent,
        [INPUT_EVENT]: (val) => isNumber(val) || isNil(val),
        [UPDATE_MODEL_EVENT]: (val) => isNumber(val) || isNil(val)
      };
      const _hoisted_1$A = ["aria-label", "onKeydown"];
      const _hoisted_2$u = ["aria-label", "onKeydown"];
      const __default__$b = defineComponent({
        name: "ElInputNumber"
      });
      const _sfc_main$s = /* @__PURE__ */ defineComponent({
        ...__default__$b,
        props: inputNumberProps,
        emits: inputNumberEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const { t } = useLocale();
          const ns = useNamespace("input-number");
          const input = ref();
          const data = reactive({
            currentValue: props.modelValue,
            userInput: null
          });
          const { formItem } = useFormItem();
          const minDisabled = computed(() => isNumber(props.modelValue) && props.modelValue <= props.min);
          const maxDisabled = computed(() => isNumber(props.modelValue) && props.modelValue >= props.max);
          const numPrecision = computed(() => {
            const stepPrecision = getPrecision(props.step);
            if (!isUndefined(props.precision)) {
              if (stepPrecision > props.precision)
                ;
              return props.precision;
            } else {
              return Math.max(getPrecision(props.modelValue), stepPrecision);
            }
          });
          const controlsAtRight = computed(() => {
            return props.controls && props.controlsPosition === "right";
          });
          const inputNumberSize = useFormSize();
          const inputNumberDisabled = useFormDisabled();
          const displayValue = computed(() => {
            if (data.userInput !== null) {
              return data.userInput;
            }
            let currentValue = data.currentValue;
            if (isNil(currentValue))
              return "";
            if (isNumber(currentValue)) {
              if (Number.isNaN(currentValue))
                return "";
              if (!isUndefined(props.precision)) {
                currentValue = currentValue.toFixed(props.precision);
              }
            }
            return currentValue;
          });
          const toPrecision = (num, pre) => {
            if (isUndefined(pre))
              pre = numPrecision.value;
            if (pre === 0)
              return Math.round(num);
            let snum = String(num);
            const pointPos = snum.indexOf(".");
            if (pointPos === -1)
              return num;
            const nums = snum.replace(".", "").split("");
            const datum = nums[pointPos + pre];
            if (!datum)
              return num;
            const length = snum.length;
            if (snum.charAt(length - 1) === "5") {
              snum = `${snum.slice(0, Math.max(0, length - 1))}6`;
            }
            return Number.parseFloat(Number(snum).toFixed(pre));
          };
          const getPrecision = (value) => {
            if (isNil(value))
              return 0;
            const valueString = value.toString();
            const dotPosition = valueString.indexOf(".");
            let precision = 0;
            if (dotPosition !== -1) {
              precision = valueString.length - dotPosition - 1;
            }
            return precision;
          };
          const ensurePrecision = (val, coefficient = 1) => {
            if (!isNumber(val))
              return data.currentValue;
            return toPrecision(val + props.step * coefficient);
          };
          const increase = () => {
            if (props.readonly || inputNumberDisabled.value || maxDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value);
            setCurrentValue(newVal);
            emit2(INPUT_EVENT, data.currentValue);
          };
          const decrease = () => {
            if (props.readonly || inputNumberDisabled.value || minDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value, -1);
            setCurrentValue(newVal);
            emit2(INPUT_EVENT, data.currentValue);
          };
          const verifyValue = (value, update) => {
            const { max, min, step, precision, stepStrictly, valueOnClear } = props;
            if (max < min) {
              throwError("InputNumber", "min should not be greater than max.");
            }
            let newVal = Number(value);
            if (isNil(value) || Number.isNaN(newVal)) {
              return null;
            }
            if (value === "") {
              if (valueOnClear === null) {
                return null;
              }
              newVal = isString$1(valueOnClear) ? { min, max }[valueOnClear] : valueOnClear;
            }
            if (stepStrictly) {
              newVal = toPrecision(Math.round(newVal / step) * step, precision);
            }
            if (!isUndefined(precision)) {
              newVal = toPrecision(newVal, precision);
            }
            if (newVal > max || newVal < min) {
              newVal = newVal > max ? max : min;
              update && emit2(UPDATE_MODEL_EVENT, newVal);
            }
            return newVal;
          };
          const setCurrentValue = (value, emitChange = true) => {
            var _a2;
            const oldVal = data.currentValue;
            const newVal = verifyValue(value);
            if (!emitChange) {
              emit2(UPDATE_MODEL_EVENT, newVal);
              return;
            }
            if (oldVal === newVal)
              return;
            data.userInput = null;
            emit2(UPDATE_MODEL_EVENT, newVal);
            emit2(CHANGE_EVENT, newVal, oldVal);
            if (props.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
            }
            data.currentValue = newVal;
          };
          const handleInput = (value) => {
            data.userInput = value;
            const newVal = value === "" ? null : Number(value);
            emit2(INPUT_EVENT, newVal);
            setCurrentValue(newVal, false);
          };
          const handleInputChange = (value) => {
            const newVal = value !== "" ? Number(value) : "";
            if (isNumber(newVal) && !Number.isNaN(newVal) || value === "") {
              setCurrentValue(newVal);
            }
            data.userInput = null;
          };
          const focus = () => {
            var _a2, _b;
            (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          };
          const blur = () => {
            var _a2, _b;
            (_b = (_a2 = input.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
          };
          const handleFocus = (event) => {
            emit2("focus", event);
          };
          const handleBlur = (event) => {
            var _a2;
            emit2("blur", event);
            if (props.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn());
            }
          };
          watch(() => props.modelValue, (value) => {
            const userInput = verifyValue(data.userInput);
            const newValue = verifyValue(value, true);
            if (!isNumber(userInput) && (!userInput || userInput !== newValue)) {
              data.currentValue = newValue;
              data.userInput = null;
            }
          }, { immediate: true });
          onMounted(() => {
            var _a2;
            const { min, max, modelValue } = props;
            const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
            innerInput.setAttribute("role", "spinbutton");
            if (Number.isFinite(max)) {
              innerInput.setAttribute("aria-valuemax", String(max));
            } else {
              innerInput.removeAttribute("aria-valuemax");
            }
            if (Number.isFinite(min)) {
              innerInput.setAttribute("aria-valuemin", String(min));
            } else {
              innerInput.removeAttribute("aria-valuemin");
            }
            innerInput.setAttribute("aria-valuenow", String(data.currentValue));
            innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
            if (!isNumber(modelValue) && modelValue != null) {
              let val = Number(modelValue);
              if (Number.isNaN(val)) {
                val = null;
              }
              emit2(UPDATE_MODEL_EVENT, val);
            }
          });
          onUpdated(() => {
            var _a2;
            const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
            innerInput == null ? void 0 : innerInput.setAttribute("aria-valuenow", `${data.currentValue}`);
          });
          expose({
            focus,
            blur
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).m(unref(inputNumberSize)),
                unref(ns).is("disabled", unref(inputNumberDisabled)),
                unref(ns).is("without-controls", !_ctx.controls),
                unref(ns).is("controls-right", unref(controlsAtRight))
              ]),
              onDragstart: _cache[1] || (_cache[1] = withModifiers(() => {
              }, ["prevent"]))
            }, [
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 0,
                role: "button",
                "aria-label": unref(t)("el.inputNumber.decrease"),
                class: normalizeClass([unref(ns).e("decrease"), unref(ns).is("disabled", unref(minDisabled))]),
                onKeydown: withKeys(decrease, ["enter"])
              }, [
                createVNode(unref(ElIcon), null, {
                  default: withCtx(() => [
                    unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_down_default), { key: 0 })) : (openBlock(), createBlock(unref(minus_default), { key: 1 }))
                  ]),
                  _: 1
                })
              ], 42, _hoisted_1$A)), [
                [unref(vRepeatClick), decrease]
              ]) : createCommentVNode("v-if", true),
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 1,
                role: "button",
                "aria-label": unref(t)("el.inputNumber.increase"),
                class: normalizeClass([unref(ns).e("increase"), unref(ns).is("disabled", unref(maxDisabled))]),
                onKeydown: withKeys(increase, ["enter"])
              }, [
                createVNode(unref(ElIcon), null, {
                  default: withCtx(() => [
                    unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_up_default), { key: 0 })) : (openBlock(), createBlock(unref(plus_default), { key: 1 }))
                  ]),
                  _: 1
                })
              ], 42, _hoisted_2$u)), [
                [unref(vRepeatClick), increase]
              ]) : createCommentVNode("v-if", true),
              createVNode(unref(ElInput), {
                id: _ctx.id,
                ref_key: "input",
                ref: input,
                type: "number",
                step: _ctx.step,
                "model-value": unref(displayValue),
                placeholder: _ctx.placeholder,
                readonly: _ctx.readonly,
                disabled: unref(inputNumberDisabled),
                size: unref(inputNumberSize),
                max: _ctx.max,
                min: _ctx.min,
                name: _ctx.name,
                label: _ctx.label,
                "validate-event": false,
                onWheel: _cache[0] || (_cache[0] = withModifiers(() => {
                }, ["prevent"])),
                onKeydown: [
                  withKeys(withModifiers(increase, ["prevent"]), ["up"]),
                  withKeys(withModifiers(decrease, ["prevent"]), ["down"])
                ],
                onBlur: handleBlur,
                onFocus: handleFocus,
                onInput: handleInput,
                onChange: handleInputChange
              }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])
            ], 34);
          };
        }
      });
      var InputNumber = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input-number/src/input-number.vue"]]);
      const ElInputNumber = withInstall(InputNumber);
      const selectGroupKey = Symbol("ElSelectGroup");
      const selectKey = Symbol("ElSelect");
      function useOption$1(props, states) {
        const select = inject(selectKey);
        const selectGroup = inject(selectGroupKey, { disabled: false });
        const isObject2 = computed(() => {
          return Object.prototype.toString.call(props.value).toLowerCase() === "[object object]";
        });
        const itemSelected = computed(() => {
          if (!select.props.multiple) {
            return isEqual2(props.value, select.props.modelValue);
          } else {
            return contains(select.props.modelValue, props.value);
          }
        });
        const limitReached = computed(() => {
          if (select.props.multiple) {
            const modelValue = select.props.modelValue || [];
            return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
          } else {
            return false;
          }
        });
        const currentLabel = computed(() => {
          return props.label || (isObject2.value ? "" : props.value);
        });
        const currentValue = computed(() => {
          return props.value || props.label || "";
        });
        const isDisabled = computed(() => {
          return props.disabled || states.groupDisabled || limitReached.value;
        });
        const instance = getCurrentInstance();
        const contains = (arr = [], target) => {
          if (!isObject2.value) {
            return arr && arr.includes(target);
          } else {
            const valueKey = select.props.valueKey;
            return arr && arr.some((item) => {
              return toRaw(get(item, valueKey)) === get(target, valueKey);
            });
          }
        };
        const isEqual2 = (a, b) => {
          if (!isObject2.value) {
            return a === b;
          } else {
            const { valueKey } = select.props;
            return get(a, valueKey) === get(b, valueKey);
          }
        };
        const hoverItem = () => {
          if (!props.disabled && !selectGroup.disabled) {
            select.hoverIndex = select.optionsArray.indexOf(instance.proxy);
          }
        };
        watch(() => currentLabel.value, () => {
          if (!props.created && !select.props.remote)
            select.setSelected();
        });
        watch(() => props.value, (val, oldVal) => {
          const { remote, valueKey } = select.props;
          if (!Object.is(val, oldVal)) {
            select.onOptionDestroy(oldVal, instance.proxy);
            select.onOptionCreate(instance.proxy);
          }
          if (!props.created && !remote) {
            if (valueKey && typeof val === "object" && typeof oldVal === "object" && val[valueKey] === oldVal[valueKey]) {
              return;
            }
            select.setSelected();
          }
        });
        watch(() => selectGroup.disabled, () => {
          states.groupDisabled = selectGroup.disabled;
        }, { immediate: true });
        const { queryChange } = toRaw(select);
        watch(queryChange, (changes) => {
          const { query } = unref(changes);
          const regexp2 = new RegExp(escapeStringRegexp(query), "i");
          states.visible = regexp2.test(currentLabel.value) || props.created;
          if (!states.visible) {
            select.filteredOptionsCount--;
          }
        }, { immediate: true });
        return {
          select,
          currentLabel,
          currentValue,
          itemSelected,
          isDisabled,
          hoverItem
        };
      }
      const _sfc_main$r = defineComponent({
        name: "ElOption",
        componentName: "ElOption",
        props: {
          value: {
            required: true,
            type: [String, Number, Boolean, Object]
          },
          label: [String, Number],
          created: Boolean,
          disabled: {
            type: Boolean,
            default: false
          }
        },
        setup(props) {
          const ns = useNamespace("select");
          const containerKls = computed(() => [
            ns.be("dropdown", "item"),
            ns.is("disabled", unref(isDisabled)),
            {
              selected: unref(itemSelected),
              hover: unref(hover)
            }
          ]);
          const states = reactive({
            index: -1,
            groupDisabled: false,
            visible: true,
            hitState: false,
            hover: false
          });
          const { currentLabel, itemSelected, isDisabled, select, hoverItem } = useOption$1(props, states);
          const { visible, hover } = toRefs(states);
          const vm = getCurrentInstance().proxy;
          select.onOptionCreate(vm);
          onBeforeUnmount(() => {
            const key = vm.value;
            const { selected } = select;
            const selectedOptions = select.props.multiple ? selected : [selected];
            const doesSelected = selectedOptions.some((item) => {
              return item.value === vm.value;
            });
            nextTick(() => {
              if (select.cachedOptions.get(key) === vm && !doesSelected) {
                select.cachedOptions.delete(key);
              }
            });
            select.onOptionDestroy(key, vm);
          });
          function selectOptionClick() {
            if (props.disabled !== true && states.groupDisabled !== true) {
              select.handleOptionSelect(vm);
            }
          }
          return {
            ns,
            containerKls,
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            visible,
            hover,
            selectOptionClick,
            states
          };
        }
      });
      function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
        return withDirectives((openBlock(), createElementBlock("li", {
          class: normalizeClass(_ctx.containerKls),
          onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createBaseVNode("span", null, toDisplayString(_ctx.currentLabel), 1)
          ])
        ], 34)), [
          [vShow, _ctx.visible]
        ]);
      }
      var Option = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["render", _sfc_render$7], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);
      const _sfc_main$q = defineComponent({
        name: "ElSelectDropdown",
        componentName: "ElSelectDropdown",
        setup() {
          const select = inject(selectKey);
          const ns = useNamespace("select");
          const popperClass = computed(() => select.props.popperClass);
          const isMultiple = computed(() => select.props.multiple);
          const isFitInputWidth = computed(() => select.props.fitInputWidth);
          const minWidth = ref("");
          function updateMinWidth() {
            var _a2;
            minWidth.value = `${(_a2 = select.selectWrapper) == null ? void 0 : _a2.offsetWidth}px`;
          }
          onMounted(() => {
            updateMinWidth();
            useResizeObserver(select.selectWrapper, updateMinWidth);
          });
          return {
            ns,
            minWidth,
            popperClass,
            isMultiple,
            isFitInputWidth
          };
        }
      });
      function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
          style: normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 6);
      }
      var ElSelectMenu$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["render", _sfc_render$6], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);
      function useSelectStates(props) {
        const { t } = useLocale();
        return reactive({
          options: /* @__PURE__ */ new Map(),
          cachedOptions: /* @__PURE__ */ new Map(),
          createdLabel: null,
          createdSelected: false,
          selected: props.multiple ? [] : {},
          inputLength: 20,
          inputWidth: 0,
          optionsCount: 0,
          filteredOptionsCount: 0,
          visible: false,
          selectedLabel: "",
          hoverIndex: -1,
          query: "",
          previousQuery: null,
          inputHovering: false,
          cachedPlaceHolder: "",
          currentPlaceholder: t("el.select.placeholder"),
          menuVisibleOnFocus: false,
          isOnComposition: false,
          prefixWidth: 11,
          mouseEnter: false
        });
      }
      let ignoreFocusEvent = false;
      const useSelect$1 = (props, states, ctx) => {
        const { t } = useLocale();
        const ns = useNamespace("select");
        useDeprecated({
          from: "suffixTransition",
          replacement: "override style scheme",
          version: "2.3.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
        }, computed(() => props.suffixTransition === false));
        const reference = ref(null);
        const input = ref(null);
        const iOSInput = ref(null);
        const tooltipRef = ref(null);
        const tagTooltipRef = ref(null);
        const tags = ref(null);
        const selectWrapper = ref(null);
        const scrollbar = ref(null);
        const hoverOption = ref(-1);
        const queryChange = shallowRef({ query: "" });
        const groupQueryChange = shallowRef("");
        const optionList = ref([]);
        let originClientHeight = 0;
        const { form, formItem } = useFormItem();
        const readonly2 = computed(() => !props.filterable || props.multiple || !states.visible);
        const selectDisabled = computed(() => props.disabled || (form == null ? void 0 : form.disabled));
        const showClose = computed(() => {
          const hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== "";
          const criteria = props.clearable && !selectDisabled.value && states.inputHovering && hasValue;
          return criteria;
        });
        const iconComponent = computed(() => props.remote && props.filterable && !props.remoteShowSuffix ? "" : props.suffixIcon);
        const iconReverse = computed(() => ns.is("reverse", iconComponent.value && states.visible && props.suffixTransition));
        const debounce$1 = computed(() => props.remote ? 300 : 0);
        const emptyText = computed(() => {
          if (props.loading) {
            return props.loadingText || t("el.select.loading");
          } else {
            if (props.remote && states.query === "" && states.options.size === 0)
              return false;
            if (props.filterable && states.query && states.options.size > 0 && states.filteredOptionsCount === 0) {
              return props.noMatchText || t("el.select.noMatch");
            }
            if (states.options.size === 0) {
              return props.noDataText || t("el.select.noData");
            }
          }
          return null;
        });
        const optionsArray = computed(() => {
          const list = Array.from(states.options.values());
          const newList = [];
          optionList.value.forEach((item) => {
            const index = list.findIndex((i) => i.currentLabel === item);
            if (index > -1) {
              newList.push(list[index]);
            }
          });
          return newList.length ? newList : list;
        });
        const cachedOptionsArray = computed(() => Array.from(states.cachedOptions.values()));
        const showNewOption = computed(() => {
          const hasExistingOption = optionsArray.value.filter((option) => {
            return !option.created;
          }).some((option) => {
            return option.currentLabel === states.query;
          });
          return props.filterable && props.allowCreate && states.query !== "" && !hasExistingOption;
        });
        const selectSize = useFormSize();
        const collapseTagSize = computed(() => ["small"].includes(selectSize.value) ? "small" : "default");
        const dropMenuVisible = computed({
          get() {
            return states.visible && emptyText.value !== false;
          },
          set(val) {
            states.visible = val;
          }
        });
        watch([() => selectDisabled.value, () => selectSize.value, () => form == null ? void 0 : form.size], () => {
          nextTick(() => {
            resetInputHeight();
          });
        });
        watch(() => props.placeholder, (val) => {
          states.cachedPlaceHolder = states.currentPlaceholder = val;
          const hasValue = props.multiple && Array.isArray(props.modelValue) && props.modelValue.length > 0;
          if (hasValue) {
            states.currentPlaceholder = "";
          }
        });
        watch(() => props.modelValue, (val, oldVal) => {
          if (props.multiple) {
            resetInputHeight();
            if (val && val.length > 0 || input.value && states.query !== "") {
              states.currentPlaceholder = "";
            } else {
              states.currentPlaceholder = states.cachedPlaceHolder;
            }
            if (props.filterable && !props.reserveKeyword) {
              states.query = "";
              handleQueryChange(states.query);
            }
          }
          setSelected();
          if (props.filterable && !props.multiple) {
            states.inputLength = 20;
          }
          if (!isEqual$1(val, oldVal) && props.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        }, {
          flush: "post",
          deep: true
        });
        watch(() => states.visible, (val) => {
          var _a2, _b, _c, _d, _e;
          if (!val) {
            if (props.filterable) {
              if (isFunction$1(props.filterMethod)) {
                props.filterMethod("");
              }
              if (isFunction$1(props.remoteMethod)) {
                props.remoteMethod("");
              }
            }
            input.value && input.value.blur();
            states.query = "";
            states.previousQuery = null;
            states.selectedLabel = "";
            states.inputLength = 20;
            states.menuVisibleOnFocus = false;
            resetHoverIndex();
            nextTick(() => {
              if (input.value && input.value.value === "" && states.selected.length === 0) {
                states.currentPlaceholder = states.cachedPlaceHolder;
              }
            });
            if (!props.multiple) {
              if (states.selected) {
                if (props.filterable && props.allowCreate && states.createdSelected && states.createdLabel) {
                  states.selectedLabel = states.createdLabel;
                } else {
                  states.selectedLabel = states.selected.currentLabel;
                }
                if (props.filterable)
                  states.query = states.selectedLabel;
              }
              if (props.filterable) {
                states.currentPlaceholder = states.cachedPlaceHolder;
              }
            }
          } else {
            (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            if (props.filterable) {
              states.filteredOptionsCount = states.optionsCount;
              states.query = props.remote ? "" : states.selectedLabel;
              (_d = (_c = iOSInput.value) == null ? void 0 : _c.focus) == null ? void 0 : _d.call(_c);
              if (props.multiple) {
                (_e = input.value) == null ? void 0 : _e.focus();
              } else {
                if (states.selectedLabel) {
                  states.currentPlaceholder = `${states.selectedLabel}`;
                  states.selectedLabel = "";
                }
              }
              handleQueryChange(states.query);
              if (!props.multiple && !props.remote) {
                queryChange.value.query = "";
                triggerRef(queryChange);
                triggerRef(groupQueryChange);
              }
            }
          }
          ctx.emit("visible-change", val);
        });
        watch(() => states.options.entries(), () => {
          var _a2, _b, _c;
          if (!isClient$1)
            return;
          (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          if (props.multiple) {
            resetInputHeight();
          }
          const inputs = ((_c = selectWrapper.value) == null ? void 0 : _c.querySelectorAll("input")) || [];
          if (!Array.from(inputs).includes(document.activeElement)) {
            setSelected();
          }
          if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {
            checkDefaultFirstOption();
          }
        }, {
          flush: "post"
        });
        watch(() => states.hoverIndex, (val) => {
          if (isNumber(val) && val > -1) {
            hoverOption.value = optionsArray.value[val] || {};
          } else {
            hoverOption.value = {};
          }
          optionsArray.value.forEach((option) => {
            option.hover = hoverOption.value === option;
          });
        });
        const resetInputHeight = () => {
          nextTick(() => {
            var _a2, _b;
            if (!reference.value)
              return;
            const input2 = reference.value.$el.querySelector("input");
            originClientHeight = originClientHeight || (input2.clientHeight > 0 ? input2.clientHeight + 2 : 0);
            const _tags = tags.value;
            const gotSize = getComponentSize(selectSize.value || (form == null ? void 0 : form.size));
            const sizeInMap = selectSize.value || gotSize === originClientHeight || originClientHeight <= 0 ? gotSize : originClientHeight;
            const isElHidden = input2.offsetParent === null;
            !isElHidden && (input2.style.height = `${(states.selected.length === 0 ? sizeInMap : Math.max(_tags ? _tags.clientHeight + (_tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap)) - 2}px`);
            if (states.visible && emptyText.value !== false) {
              (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            }
          });
        };
        const handleQueryChange = async (val) => {
          if (states.previousQuery === val || states.isOnComposition)
            return;
          if (states.previousQuery === null && (isFunction$1(props.filterMethod) || isFunction$1(props.remoteMethod))) {
            states.previousQuery = val;
            return;
          }
          states.previousQuery = val;
          nextTick(() => {
            var _a2, _b;
            if (states.visible)
              (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          });
          states.hoverIndex = -1;
          if (props.multiple && props.filterable) {
            nextTick(() => {
              const length = input.value.value.length * 15 + 20;
              states.inputLength = props.collapseTags ? Math.min(50, length) : length;
              managePlaceholder();
              resetInputHeight();
            });
          }
          if (props.remote && isFunction$1(props.remoteMethod)) {
            states.hoverIndex = -1;
            props.remoteMethod(val);
          } else if (isFunction$1(props.filterMethod)) {
            props.filterMethod(val);
            triggerRef(groupQueryChange);
          } else {
            states.filteredOptionsCount = states.optionsCount;
            queryChange.value.query = val;
            triggerRef(queryChange);
            triggerRef(groupQueryChange);
          }
          if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {
            await nextTick();
            checkDefaultFirstOption();
          }
        };
        const managePlaceholder = () => {
          if (states.currentPlaceholder !== "") {
            states.currentPlaceholder = input.value.value ? "" : states.cachedPlaceHolder;
          }
        };
        const checkDefaultFirstOption = () => {
          const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.states.groupDisabled);
          const userCreatedOption = optionsInDropdown.find((n) => n.created);
          const firstOriginOption = optionsInDropdown[0];
          states.hoverIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
        };
        const setSelected = () => {
          var _a2;
          if (!props.multiple) {
            const option = getOption(props.modelValue);
            if ((_a2 = option.props) == null ? void 0 : _a2.created) {
              states.createdLabel = option.props.value;
              states.createdSelected = true;
            } else {
              states.createdSelected = false;
            }
            states.selectedLabel = option.currentLabel;
            states.selected = option;
            if (props.filterable)
              states.query = states.selectedLabel;
            return;
          } else {
            states.selectedLabel = "";
          }
          const result = [];
          if (Array.isArray(props.modelValue)) {
            props.modelValue.forEach((value) => {
              result.push(getOption(value));
            });
          }
          states.selected = result;
          nextTick(() => {
            resetInputHeight();
          });
        };
        const getOption = (value) => {
          let option;
          const isObjectValue = toRawType(value).toLowerCase() === "object";
          const isNull = toRawType(value).toLowerCase() === "null";
          const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
          for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
            const cachedOption = cachedOptionsArray.value[i];
            const isEqualValue = isObjectValue ? get(cachedOption.value, props.valueKey) === get(value, props.valueKey) : cachedOption.value === value;
            if (isEqualValue) {
              option = {
                value,
                currentLabel: cachedOption.currentLabel,
                isDisabled: cachedOption.isDisabled
              };
              break;
            }
          }
          if (option)
            return option;
          const label = isObjectValue ? value.label : !isNull && !isUndefined2 ? value : "";
          const newOption = {
            value,
            currentLabel: label
          };
          if (props.multiple) {
            newOption.hitState = false;
          }
          return newOption;
        };
        const resetHoverIndex = () => {
          setTimeout(() => {
            const valueKey = props.valueKey;
            if (!props.multiple) {
              states.hoverIndex = optionsArray.value.findIndex((item) => {
                return getValueKey(item) === getValueKey(states.selected);
              });
            } else {
              if (states.selected.length > 0) {
                states.hoverIndex = Math.min.apply(null, states.selected.map((selected) => {
                  return optionsArray.value.findIndex((item) => {
                    return get(item, valueKey) === get(selected, valueKey);
                  });
                }));
              } else {
                states.hoverIndex = -1;
              }
            }
          }, 300);
        };
        const handleResize = () => {
          var _a2, _b;
          resetInputWidth();
          (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          props.multiple && resetInputHeight();
        };
        const resetInputWidth = () => {
          var _a2;
          states.inputWidth = (_a2 = reference.value) == null ? void 0 : _a2.$el.offsetWidth;
        };
        const onInputChange = () => {
          if (props.filterable && states.query !== states.selectedLabel) {
            states.query = states.selectedLabel;
            handleQueryChange(states.query);
          }
        };
        const debouncedOnInputChange = debounce(() => {
          onInputChange();
        }, debounce$1.value);
        const debouncedQueryChange = debounce((e) => {
          handleQueryChange(e.target.value);
        }, debounce$1.value);
        const emitChange = (val) => {
          if (!isEqual$1(props.modelValue, val)) {
            ctx.emit(CHANGE_EVENT, val);
          }
        };
        const deletePrevTag = (e) => {
          if (e.code === EVENT_CODE.delete)
            return;
          if (e.target.value.length <= 0 && !toggleLastOptionHitState()) {
            const value = props.modelValue.slice();
            value.pop();
            ctx.emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
          }
          if (e.target.value.length === 1 && props.modelValue.length === 0) {
            states.currentPlaceholder = states.cachedPlaceHolder;
          }
        };
        const deleteTag = (event, tag) => {
          const index = states.selected.indexOf(tag);
          if (index > -1 && !selectDisabled.value) {
            const value = props.modelValue.slice();
            value.splice(index, 1);
            ctx.emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            ctx.emit("remove-tag", tag.value);
          }
          event.stopPropagation();
        };
        const deleteSelected = (event) => {
          event.stopPropagation();
          const value = props.multiple ? [] : "";
          if (!isString$1(value)) {
            for (const item of states.selected) {
              if (item.isDisabled)
                value.push(item.value);
            }
          }
          ctx.emit(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          states.hoverIndex = -1;
          states.visible = false;
          ctx.emit("clear");
        };
        const handleOptionSelect = (option) => {
          var _a2;
          if (props.multiple) {
            const value = (props.modelValue || []).slice();
            const optionIndex = getValueIndex(value, option.value);
            if (optionIndex > -1) {
              value.splice(optionIndex, 1);
            } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
              value.push(option.value);
            }
            ctx.emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            if (option.created) {
              states.query = "";
              handleQueryChange("");
              states.inputLength = 20;
            }
            if (props.filterable)
              (_a2 = input.value) == null ? void 0 : _a2.focus();
          } else {
            ctx.emit(UPDATE_MODEL_EVENT, option.value);
            emitChange(option.value);
            states.visible = false;
          }
          setSoftFocus();
          if (states.visible)
            return;
          nextTick(() => {
            scrollToOption(option);
          });
        };
        const getValueIndex = (arr = [], value) => {
          if (!isObject$1(value))
            return arr.indexOf(value);
          const valueKey = props.valueKey;
          let index = -1;
          arr.some((item, i) => {
            if (toRaw(get(item, valueKey)) === get(value, valueKey)) {
              index = i;
              return true;
            }
            return false;
          });
          return index;
        };
        const setSoftFocus = () => {
          const _input = input.value || reference.value;
          if (_input) {
            _input == null ? void 0 : _input.focus();
          }
        };
        const scrollToOption = (option) => {
          var _a2, _b, _c, _d, _e;
          const targetOption = Array.isArray(option) ? option[0] : option;
          let target = null;
          if (targetOption == null ? void 0 : targetOption.value) {
            const options = optionsArray.value.filter((item) => item.value === targetOption.value);
            if (options.length > 0) {
              target = options[0].$el;
            }
          }
          if (tooltipRef.value && target) {
            const menu = (_d = (_c = (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${ns.be("dropdown", "wrap")}`);
            if (menu) {
              scrollIntoView(menu, target);
            }
          }
          (_e = scrollbar.value) == null ? void 0 : _e.handleScroll();
        };
        const onOptionCreate = (vm) => {
          states.optionsCount++;
          states.filteredOptionsCount++;
          states.options.set(vm.value, vm);
          states.cachedOptions.set(vm.value, vm);
        };
        const onOptionDestroy = (key, vm) => {
          if (states.options.get(key) === vm) {
            states.optionsCount--;
            states.filteredOptionsCount--;
            states.options.delete(key);
          }
        };
        const resetInputState = (e) => {
          if (e.code !== EVENT_CODE.backspace)
            toggleLastOptionHitState(false);
          states.inputLength = input.value.value.length * 15 + 20;
          resetInputHeight();
        };
        const toggleLastOptionHitState = (hit) => {
          if (!Array.isArray(states.selected))
            return;
          const option = states.selected[states.selected.length - 1];
          if (!option)
            return;
          if (hit === true || hit === false) {
            option.hitState = hit;
            return hit;
          }
          option.hitState = !option.hitState;
          return option.hitState;
        };
        const handleComposition = (event) => {
          const text = event.target.value;
          if (event.type === "compositionend") {
            states.isOnComposition = false;
            nextTick(() => handleQueryChange(text));
          } else {
            const lastCharacter = text[text.length - 1] || "";
            states.isOnComposition = !isKorean(lastCharacter);
          }
        };
        const handleMenuEnter = () => {
          nextTick(() => scrollToOption(states.selected));
        };
        const handleFocus = (event) => {
          if (!ignoreFocusEvent) {
            if (props.automaticDropdown || props.filterable) {
              if (props.filterable && !states.visible) {
                states.menuVisibleOnFocus = true;
              }
              states.visible = true;
            }
            ctx.emit("focus", event);
          } else {
            ignoreFocusEvent = false;
          }
        };
        const blur = () => {
          var _a2, _b, _c;
          states.visible = false;
          (_a2 = reference.value) == null ? void 0 : _a2.blur();
          (_c = (_b = iOSInput.value) == null ? void 0 : _b.blur) == null ? void 0 : _c.call(_b);
        };
        const handleBlur = (event) => {
          setTimeout(() => {
            var _a2;
            if ((_a2 = tooltipRef.value) == null ? void 0 : _a2.isFocusInsideContent()) {
              ignoreFocusEvent = true;
              return;
            }
            states.visible && handleClose();
            ctx.emit("blur", event);
          });
        };
        const handleClearClick = (event) => {
          deleteSelected(event);
        };
        const handleClose = () => {
          states.visible = false;
        };
        const handleKeydownEscape = (event) => {
          if (states.visible) {
            event.preventDefault();
            event.stopPropagation();
            states.visible = false;
          }
        };
        const toggleMenu = (e) => {
          var _a2;
          if (e && !states.mouseEnter) {
            return;
          }
          if (!selectDisabled.value) {
            if (states.menuVisibleOnFocus) {
              states.menuVisibleOnFocus = false;
            } else {
              if (!tooltipRef.value || !tooltipRef.value.isFocusInsideContent()) {
                states.visible = !states.visible;
              }
            }
            if (states.visible) {
              (_a2 = input.value || reference.value) == null ? void 0 : _a2.focus();
            }
          }
        };
        const selectOption = () => {
          if (!states.visible) {
            toggleMenu();
          } else {
            if (optionsArray.value[states.hoverIndex]) {
              handleOptionSelect(optionsArray.value[states.hoverIndex]);
            }
          }
        };
        const getValueKey = (item) => {
          return isObject$1(item.value) ? get(item.value, props.valueKey) : item.value;
        };
        const optionsAllDisabled = computed(() => optionsArray.value.filter((option) => option.visible).every((option) => option.disabled));
        const showTagList = computed(() => states.selected.slice(0, props.maxCollapseTags));
        const collapseTagList = computed(() => states.selected.slice(props.maxCollapseTags));
        const navigateOptions = (direction2) => {
          if (!states.visible) {
            states.visible = true;
            return;
          }
          if (states.options.size === 0 || states.filteredOptionsCount === 0)
            return;
          if (states.isOnComposition)
            return;
          if (!optionsAllDisabled.value) {
            if (direction2 === "next") {
              states.hoverIndex++;
              if (states.hoverIndex === states.options.size) {
                states.hoverIndex = 0;
              }
            } else if (direction2 === "prev") {
              states.hoverIndex--;
              if (states.hoverIndex < 0) {
                states.hoverIndex = states.options.size - 1;
              }
            }
            const option = optionsArray.value[states.hoverIndex];
            if (option.disabled === true || option.states.groupDisabled === true || !option.visible) {
              navigateOptions(direction2);
            }
            nextTick(() => scrollToOption(hoverOption.value));
          }
        };
        const handleMouseEnter = () => {
          states.mouseEnter = true;
        };
        const handleMouseLeave = () => {
          states.mouseEnter = false;
        };
        const handleDeleteTooltipTag = (event, tag) => {
          var _a2, _b;
          deleteTag(event, tag);
          (_b = (_a2 = tagTooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        };
        return {
          optionList,
          optionsArray,
          selectSize,
          handleResize,
          debouncedOnInputChange,
          debouncedQueryChange,
          deletePrevTag,
          deleteTag,
          deleteSelected,
          handleOptionSelect,
          scrollToOption,
          readonly: readonly2,
          resetInputHeight,
          showClose,
          iconComponent,
          iconReverse,
          showNewOption,
          collapseTagSize,
          setSelected,
          managePlaceholder,
          selectDisabled,
          emptyText,
          toggleLastOptionHitState,
          resetInputState,
          handleComposition,
          onOptionCreate,
          onOptionDestroy,
          handleMenuEnter,
          handleFocus,
          blur,
          handleBlur,
          handleClearClick,
          handleClose,
          handleKeydownEscape,
          toggleMenu,
          selectOption,
          getValueKey,
          navigateOptions,
          handleDeleteTooltipTag,
          dropMenuVisible,
          queryChange,
          groupQueryChange,
          showTagList,
          collapseTagList,
          reference,
          input,
          iOSInput,
          tooltipRef,
          tagTooltipRef,
          tags,
          selectWrapper,
          scrollbar,
          handleMouseEnter,
          handleMouseLeave
        };
      };
      var ElOptions = defineComponent({
        name: "ElOptions",
        emits: ["update-options"],
        setup(_, { slots, emit: emit2 }) {
          let cachedOptions = [];
          function isSameOptions(a, b) {
            if (a.length !== b.length)
              return false;
            for (const [index] of a.entries()) {
              if (a[index] != b[index]) {
                return false;
              }
            }
            return true;
          }
          return () => {
            var _a2, _b;
            const children = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
            const filteredOptions = [];
            function filterOptions(children2) {
              if (!Array.isArray(children2))
                return;
              children2.forEach((item) => {
                var _a22, _b2, _c, _d;
                const name = (_a22 = (item == null ? void 0 : item.type) || {}) == null ? void 0 : _a22.name;
                if (name === "ElOptionGroup") {
                  filterOptions(!isString$1(item.children) && !Array.isArray(item.children) && isFunction$1((_b2 = item.children) == null ? void 0 : _b2.default) ? (_c = item.children) == null ? void 0 : _c.default() : item.children);
                } else if (name === "ElOption") {
                  filteredOptions.push((_d = item.props) == null ? void 0 : _d.label);
                } else if (Array.isArray(item.children)) {
                  filterOptions(item.children);
                }
              });
            }
            if (children.length) {
              filterOptions((_b = children[0]) == null ? void 0 : _b.children);
            }
            if (!isSameOptions(filteredOptions, cachedOptions)) {
              cachedOptions = filteredOptions;
              emit2("update-options", filteredOptions);
            }
            return children;
          };
        }
      });
      const COMPONENT_NAME$3 = "ElSelect";
      const _sfc_main$p = defineComponent({
        name: COMPONENT_NAME$3,
        componentName: COMPONENT_NAME$3,
        components: {
          ElInput,
          ElSelectMenu: ElSelectMenu$1,
          ElOption: Option,
          ElOptions,
          ElTag,
          ElScrollbar,
          ElTooltip,
          ElIcon
        },
        directives: { ClickOutside },
        props: {
          name: String,
          id: String,
          modelValue: {
            type: [Array, String, Number, Boolean, Object],
            default: void 0
          },
          autocomplete: {
            type: String,
            default: "off"
          },
          automaticDropdown: Boolean,
          size: {
            type: String,
            validator: isValidComponentSize
          },
          effect: {
            type: String,
            default: "light"
          },
          disabled: Boolean,
          clearable: Boolean,
          filterable: Boolean,
          allowCreate: Boolean,
          loading: Boolean,
          popperClass: {
            type: String,
            default: ""
          },
          popperOptions: {
            type: Object,
            default: () => ({})
          },
          remote: Boolean,
          loadingText: String,
          noMatchText: String,
          noDataText: String,
          remoteMethod: Function,
          filterMethod: Function,
          multiple: Boolean,
          multipleLimit: {
            type: Number,
            default: 0
          },
          placeholder: {
            type: String
          },
          defaultFirstOption: Boolean,
          reserveKeyword: {
            type: Boolean,
            default: true
          },
          valueKey: {
            type: String,
            default: "value"
          },
          collapseTags: Boolean,
          collapseTagsTooltip: {
            type: Boolean,
            default: false
          },
          maxCollapseTags: {
            type: Number,
            default: 1
          },
          teleported: useTooltipContentProps.teleported,
          persistent: {
            type: Boolean,
            default: true
          },
          clearIcon: {
            type: iconPropType,
            default: circle_close_default
          },
          fitInputWidth: {
            type: Boolean,
            default: false
          },
          suffixIcon: {
            type: iconPropType,
            default: arrow_down_default
          },
          tagType: { ...tagProps.type, default: "info" },
          validateEvent: {
            type: Boolean,
            default: true
          },
          remoteShowSuffix: {
            type: Boolean,
            default: false
          },
          suffixTransition: {
            type: Boolean,
            default: true
          },
          placement: {
            type: String,
            values: Ee,
            default: "bottom-start"
          }
        },
        emits: [
          UPDATE_MODEL_EVENT,
          CHANGE_EVENT,
          "remove-tag",
          "clear",
          "visible-change",
          "focus",
          "blur"
        ],
        setup(props, ctx) {
          const nsSelect = useNamespace("select");
          const nsInput = useNamespace("input");
          const { t } = useLocale();
          const states = useSelectStates(props);
          const {
            optionList,
            optionsArray,
            selectSize,
            readonly: readonly2,
            handleResize,
            collapseTagSize,
            debouncedOnInputChange,
            debouncedQueryChange,
            deletePrevTag,
            deleteTag,
            deleteSelected,
            handleOptionSelect,
            scrollToOption,
            setSelected,
            resetInputHeight,
            managePlaceholder,
            showClose,
            selectDisabled,
            iconComponent,
            iconReverse,
            showNewOption,
            emptyText,
            toggleLastOptionHitState,
            resetInputState,
            handleComposition,
            onOptionCreate,
            onOptionDestroy,
            handleMenuEnter,
            handleFocus,
            blur,
            handleBlur,
            handleClearClick,
            handleClose,
            handleKeydownEscape,
            toggleMenu,
            selectOption,
            getValueKey,
            navigateOptions,
            handleDeleteTooltipTag,
            dropMenuVisible,
            reference,
            input,
            iOSInput,
            tooltipRef,
            tagTooltipRef,
            tags,
            selectWrapper,
            scrollbar,
            queryChange,
            groupQueryChange,
            handleMouseEnter,
            handleMouseLeave,
            showTagList,
            collapseTagList
          } = useSelect$1(props, states, ctx);
          const { focus } = useFocus(reference);
          const {
            inputWidth,
            selected,
            inputLength,
            filteredOptionsCount,
            visible,
            selectedLabel,
            hoverIndex,
            query,
            inputHovering,
            currentPlaceholder,
            menuVisibleOnFocus,
            isOnComposition,
            options,
            cachedOptions,
            optionsCount,
            prefixWidth
          } = toRefs(states);
          const wrapperKls = computed(() => {
            const classList = [nsSelect.b()];
            const _selectSize = unref(selectSize);
            if (_selectSize) {
              classList.push(nsSelect.m(_selectSize));
            }
            if (props.disabled) {
              classList.push(nsSelect.m("disabled"));
            }
            return classList;
          });
          const tagsKls = computed(() => [
            nsSelect.e("tags"),
            nsSelect.is("disabled", unref(selectDisabled))
          ]);
          const tagWrapperKls = computed(() => [
            nsSelect.b("tags-wrapper"),
            { "has-prefix": unref(prefixWidth) && unref(selected).length }
          ]);
          const inputKls = computed(() => [
            nsSelect.e("input"),
            nsSelect.is(unref(selectSize)),
            nsSelect.is("disabled", unref(selectDisabled))
          ]);
          const iOSInputKls = computed(() => [
            nsSelect.e("input"),
            nsSelect.is(unref(selectSize)),
            nsSelect.em("input", "iOS")
          ]);
          const scrollbarKls = computed(() => [
            nsSelect.is("empty", !props.allowCreate && Boolean(unref(query)) && unref(filteredOptionsCount) === 0)
          ]);
          const selectTagsStyle = computed(() => ({
            maxWidth: `${unref(inputWidth) - 32}px`,
            width: "100%"
          }));
          const tagTextStyle = computed(() => {
            const maxWidth = unref(inputWidth) > 123 ? unref(inputWidth) - 123 : unref(inputWidth) - 75;
            return { maxWidth: `${maxWidth}px` };
          });
          const inputStyle = computed(() => ({
            marginLeft: `${unref(prefixWidth)}px`,
            flexGrow: 1,
            width: `${unref(inputLength) / (unref(inputWidth) - 32)}%`,
            maxWidth: `${unref(inputWidth) - 42}px`
          }));
          provide(selectKey, reactive({
            props,
            options,
            optionsArray,
            cachedOptions,
            optionsCount,
            filteredOptionsCount,
            hoverIndex,
            handleOptionSelect,
            onOptionCreate,
            onOptionDestroy,
            selectWrapper,
            selected,
            setSelected,
            queryChange,
            groupQueryChange
          }));
          onMounted(() => {
            states.cachedPlaceHolder = currentPlaceholder.value = props.placeholder || (() => t("el.select.placeholder"));
            if (props.multiple && Array.isArray(props.modelValue) && props.modelValue.length > 0) {
              currentPlaceholder.value = "";
            }
            useResizeObserver(selectWrapper, handleResize);
            if (props.remote && props.multiple) {
              resetInputHeight();
            }
            nextTick(() => {
              const refEl = reference.value && reference.value.$el;
              if (!refEl)
                return;
              inputWidth.value = refEl.getBoundingClientRect().width;
              if (ctx.slots.prefix) {
                const prefix = refEl.querySelector(`.${nsInput.e("prefix")}`);
                prefixWidth.value = Math.max(prefix.getBoundingClientRect().width + 11, 30);
              }
            });
            setSelected();
          });
          if (props.multiple && !Array.isArray(props.modelValue)) {
            ctx.emit(UPDATE_MODEL_EVENT, []);
          }
          if (!props.multiple && Array.isArray(props.modelValue)) {
            ctx.emit(UPDATE_MODEL_EVENT, "");
          }
          const popperPaneRef = computed(() => {
            var _a2, _b;
            return (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
          });
          const onOptionsRendered = (v) => {
            optionList.value = v;
          };
          return {
            isIOS,
            onOptionsRendered,
            prefixWidth,
            selectSize,
            readonly: readonly2,
            handleResize,
            collapseTagSize,
            debouncedOnInputChange,
            debouncedQueryChange,
            deletePrevTag,
            deleteTag,
            handleDeleteTooltipTag,
            deleteSelected,
            handleOptionSelect,
            scrollToOption,
            inputWidth,
            selected,
            inputLength,
            filteredOptionsCount,
            visible,
            selectedLabel,
            hoverIndex,
            query,
            inputHovering,
            currentPlaceholder,
            menuVisibleOnFocus,
            isOnComposition,
            options,
            resetInputHeight,
            managePlaceholder,
            showClose,
            selectDisabled,
            iconComponent,
            iconReverse,
            showNewOption,
            emptyText,
            toggleLastOptionHitState,
            resetInputState,
            handleComposition,
            handleMenuEnter,
            handleFocus,
            blur,
            handleBlur,
            handleClearClick,
            handleClose,
            handleKeydownEscape,
            toggleMenu,
            selectOption,
            getValueKey,
            navigateOptions,
            dropMenuVisible,
            focus,
            reference,
            input,
            iOSInput,
            tooltipRef,
            popperPaneRef,
            tags,
            selectWrapper,
            scrollbar,
            wrapperKls,
            tagsKls,
            tagWrapperKls,
            inputKls,
            iOSInputKls,
            scrollbarKls,
            selectTagsStyle,
            nsSelect,
            tagTextStyle,
            inputStyle,
            handleMouseEnter,
            handleMouseLeave,
            showTagList,
            collapseTagList,
            tagTooltipRef
          };
        }
      });
      const _hoisted_1$z = ["disabled", "autocomplete"];
      const _hoisted_2$t = ["disabled"];
      const _hoisted_3$o = { style: { "height": "100%", "display": "flex", "justify-content": "center", "align-items": "center" } };
      function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_tag = resolveComponent("el-tag");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_input = resolveComponent("el-input");
        const _component_el_option = resolveComponent("el-option");
        const _component_el_options = resolveComponent("el-options");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_el_select_menu = resolveComponent("el-select-menu");
        const _directive_click_outside = resolveDirective("click-outside");
        return withDirectives((openBlock(), createElementBlock("div", {
          ref: "selectWrapper",
          class: normalizeClass(_ctx.wrapperKls),
          onMouseenter: _cache[21] || (_cache[21] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
          onMouseleave: _cache[22] || (_cache[22] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
          onClick: _cache[23] || (_cache[23] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
        }, [
          createVNode(_component_el_tooltip, {
            ref: "tooltipRef",
            visible: _ctx.dropMenuVisible,
            placement: _ctx.placement,
            teleported: _ctx.teleported,
            "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
            "popper-options": _ctx.popperOptions,
            "fallback-placements": ["bottom-start", "top-start", "right", "left"],
            effect: _ctx.effect,
            pure: "",
            trigger: "click",
            transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
            "stop-popper-mouse-event": false,
            "gpu-acceleration": false,
            persistent: _ctx.persistent,
            onShow: _ctx.handleMenuEnter
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                class: "select-trigger",
                onMouseenter: _cache[19] || (_cache[19] = ($event) => _ctx.inputHovering = true),
                onMouseleave: _cache[20] || (_cache[20] = ($event) => _ctx.inputHovering = false)
              }, [
                _ctx.multiple ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref: "tags",
                  class: normalizeClass(_ctx.tagsKls),
                  style: normalizeStyle(_ctx.selectTagsStyle)
                }, [
                  _ctx.collapseTags && _ctx.selected.length ? (openBlock(), createBlock(Transition, {
                    key: 0,
                    onAfterLeave: _ctx.resetInputHeight
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("span", {
                        class: normalizeClass(_ctx.tagWrapperKls)
                      }, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showTagList, (item) => {
                          return openBlock(), createBlock(_component_el_tag, {
                            key: _ctx.getValueKey(item),
                            closable: !_ctx.selectDisabled && !item.isDisabled,
                            size: _ctx.collapseTagSize,
                            hit: item.hitState,
                            type: _ctx.tagType,
                            "disable-transitions": "",
                            onClose: ($event) => _ctx.deleteTag($event, item)
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", {
                                class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                                style: normalizeStyle(_ctx.tagTextStyle)
                              }, toDisplayString(item.currentLabel), 7)
                            ]),
                            _: 2
                          }, 1032, ["closable", "size", "hit", "type", "onClose"]);
                        }), 128)),
                        _ctx.selected.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tag, {
                          key: 0,
                          closable: false,
                          size: _ctx.collapseTagSize,
                          type: _ctx.tagType,
                          "disable-transitions": ""
                        }, {
                          default: withCtx(() => [
                            _ctx.collapseTagsTooltip ? (openBlock(), createBlock(_component_el_tooltip, {
                              key: 0,
                              ref: "tagTooltipRef",
                              disabled: _ctx.dropMenuVisible,
                              "fallback-placements": ["bottom", "top", "right", "left"],
                              effect: _ctx.effect,
                              placement: "bottom",
                              teleported: _ctx.teleported
                            }, {
                              default: withCtx(() => [
                                createBaseVNode("span", {
                                  class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                }, "+ " + toDisplayString(_ctx.selected.length - _ctx.maxCollapseTags), 3)
                              ]),
                              content: withCtx(() => [
                                createBaseVNode("div", {
                                  class: normalizeClass(_ctx.nsSelect.e("collapse-tags"))
                                }, [
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapseTagList, (item) => {
                                    return openBlock(), createElementBlock("div", {
                                      key: _ctx.getValueKey(item),
                                      class: normalizeClass(_ctx.nsSelect.e("collapse-tag"))
                                    }, [
                                      createVNode(_component_el_tag, {
                                        class: "in-tooltip",
                                        closable: !_ctx.selectDisabled && !item.isDisabled,
                                        size: _ctx.collapseTagSize,
                                        hit: item.hitState,
                                        type: _ctx.tagType,
                                        "disable-transitions": "",
                                        style: { margin: "2px" },
                                        onClose: ($event) => _ctx.handleDeleteTooltipTag($event, item)
                                      }, {
                                        default: withCtx(() => [
                                          createBaseVNode("span", {
                                            class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                                            style: normalizeStyle({
                                              maxWidth: _ctx.inputWidth - 75 + "px"
                                            })
                                          }, toDisplayString(item.currentLabel), 7)
                                        ]),
                                        _: 2
                                      }, 1032, ["closable", "size", "hit", "type", "onClose"])
                                    ], 2);
                                  }), 128))
                                ], 2)
                              ]),
                              _: 1
                            }, 8, ["disabled", "effect", "teleported"])) : (openBlock(), createElementBlock("span", {
                              key: 1,
                              class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                            }, "+ " + toDisplayString(_ctx.selected.length - _ctx.maxCollapseTags), 3))
                          ]),
                          _: 1
                        }, 8, ["size", "type"])) : createCommentVNode("v-if", true)
                      ], 2)
                    ]),
                    _: 1
                  }, 8, ["onAfterLeave"])) : createCommentVNode("v-if", true),
                  !_ctx.collapseTags ? (openBlock(), createBlock(Transition, {
                    key: 1,
                    onAfterLeave: _ctx.resetInputHeight
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("span", {
                        class: normalizeClass(_ctx.tagWrapperKls),
                        style: normalizeStyle(_ctx.prefixWidth && _ctx.selected.length ? { marginLeft: `${_ctx.prefixWidth}px` } : "")
                      }, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.selected, (item) => {
                          return openBlock(), createBlock(_component_el_tag, {
                            key: _ctx.getValueKey(item),
                            closable: !_ctx.selectDisabled && !item.isDisabled,
                            size: _ctx.collapseTagSize,
                            hit: item.hitState,
                            type: _ctx.tagType,
                            "disable-transitions": "",
                            onClose: ($event) => _ctx.deleteTag($event, item)
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", {
                                class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                                style: normalizeStyle({ maxWidth: _ctx.inputWidth - 75 + "px" })
                              }, toDisplayString(item.currentLabel), 7)
                            ]),
                            _: 2
                          }, 1032, ["closable", "size", "hit", "type", "onClose"]);
                        }), 128))
                      ], 6)
                    ]),
                    _: 1
                  }, 8, ["onAfterLeave"])) : createCommentVNode("v-if", true),
                  _ctx.filterable && !_ctx.selectDisabled ? withDirectives((openBlock(), createElementBlock("input", {
                    key: 2,
                    ref: "input",
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.query = $event),
                    type: "text",
                    class: normalizeClass(_ctx.inputKls),
                    disabled: _ctx.selectDisabled,
                    autocomplete: _ctx.autocomplete,
                    style: normalizeStyle(_ctx.inputStyle),
                    onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                    onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                    onKeyup: _cache[3] || (_cache[3] = (...args) => _ctx.managePlaceholder && _ctx.managePlaceholder(...args)),
                    onKeydown: [
                      _cache[4] || (_cache[4] = (...args) => _ctx.resetInputState && _ctx.resetInputState(...args)),
                      _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["prevent"]), ["down"])),
                      _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["prevent"]), ["up"])),
                      _cache[7] || (_cache[7] = withKeys((...args) => _ctx.handleKeydownEscape && _ctx.handleKeydownEscape(...args), ["esc"])),
                      _cache[8] || (_cache[8] = withKeys(withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                      _cache[9] || (_cache[9] = withKeys((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["delete"])),
                      _cache[10] || (_cache[10] = withKeys(($event) => _ctx.visible = false, ["tab"]))
                    ],
                    onCompositionstart: _cache[11] || (_cache[11] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                    onCompositionupdate: _cache[12] || (_cache[12] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                    onCompositionend: _cache[13] || (_cache[13] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                    onInput: _cache[14] || (_cache[14] = (...args) => _ctx.debouncedQueryChange && _ctx.debouncedQueryChange(...args))
                  }, null, 46, _hoisted_1$z)), [
                    [vModelText, _ctx.query]
                  ]) : createCommentVNode("v-if", true)
                ], 6)) : createCommentVNode("v-if", true),
                createCommentVNode(" fix: https://github.com/element-plus/element-plus/issues/11415 "),
                _ctx.isIOS && !_ctx.multiple && _ctx.filterable && _ctx.readonly ? (openBlock(), createElementBlock("input", {
                  key: 1,
                  ref: "iOSInput",
                  class: normalizeClass(_ctx.iOSInputKls),
                  disabled: _ctx.selectDisabled,
                  type: "text"
                }, null, 10, _hoisted_2$t)) : createCommentVNode("v-if", true),
                createVNode(_component_el_input, {
                  id: _ctx.id,
                  ref: "reference",
                  modelValue: _ctx.selectedLabel,
                  "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => _ctx.selectedLabel = $event),
                  type: "text",
                  placeholder: typeof _ctx.currentPlaceholder === "function" ? _ctx.currentPlaceholder() : _ctx.currentPlaceholder,
                  name: _ctx.name,
                  autocomplete: _ctx.autocomplete,
                  size: _ctx.selectSize,
                  disabled: _ctx.selectDisabled,
                  readonly: _ctx.readonly,
                  "validate-event": false,
                  class: normalizeClass([_ctx.nsSelect.is("focus", _ctx.visible)]),
                  tabindex: _ctx.multiple && _ctx.filterable ? -1 : void 0,
                  onFocus: _ctx.handleFocus,
                  onBlur: _ctx.handleBlur,
                  onInput: _ctx.debouncedOnInputChange,
                  onPaste: _ctx.debouncedOnInputChange,
                  onCompositionstart: _ctx.handleComposition,
                  onCompositionupdate: _ctx.handleComposition,
                  onCompositionend: _ctx.handleComposition,
                  onKeydown: [
                    _cache[16] || (_cache[16] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                    _cache[17] || (_cache[17] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                    withKeys(withModifiers(_ctx.selectOption, ["stop", "prevent"]), ["enter"]),
                    withKeys(_ctx.handleKeydownEscape, ["esc"]),
                    _cache[18] || (_cache[18] = withKeys(($event) => _ctx.visible = false, ["tab"]))
                  ]
                }, createSlots({
                  suffix: withCtx(() => [
                    _ctx.iconComponent && !_ctx.showClose ? (openBlock(), createBlock(_component_el_icon, {
                      key: 0,
                      class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true),
                    _ctx.showClose && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                      key: 1,
                      class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
                      onClick: _ctx.handleClearClick
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 2
                }, [
                  _ctx.$slots.prefix ? {
                    name: "prefix",
                    fn: withCtx(() => [
                      createBaseVNode("div", _hoisted_3$o, [
                        renderSlot(_ctx.$slots, "prefix")
                      ])
                    ])
                  } : void 0
                ]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])
              ], 32)
            ]),
            content: withCtx(() => [
              createVNode(_component_el_select_menu, null, {
                default: withCtx(() => [
                  withDirectives(createVNode(_component_el_scrollbar, {
                    ref: "scrollbar",
                    tag: "ul",
                    "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
                    "view-class": _ctx.nsSelect.be("dropdown", "list"),
                    class: normalizeClass(_ctx.scrollbarKls)
                  }, {
                    default: withCtx(() => [
                      _ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
                        key: 0,
                        value: _ctx.query,
                        created: true
                      }, null, 8, ["value"])) : createCommentVNode("v-if", true),
                      createVNode(_component_el_options, { onUpdateOptions: _ctx.onOptionsRendered }, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "default")
                        ]),
                        _: 3
                      }, 8, ["onUpdateOptions"])
                    ]),
                    _: 3
                  }, 8, ["wrap-class", "view-class", "class"]), [
                    [vShow, _ctx.options.size > 0 && !_ctx.loading]
                  ]),
                  _ctx.emptyText && (!_ctx.allowCreate || _ctx.loading || _ctx.allowCreate && _ctx.options.size === 0) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    _ctx.$slots.empty ? renderSlot(_ctx.$slots, "empty", { key: 0 }) : (openBlock(), createElementBlock("p", {
                      key: 1,
                      class: normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                    }, toDisplayString(_ctx.emptyText), 3))
                  ], 64)) : createCommentVNode("v-if", true)
                ]),
                _: 3
              })
            ]),
            _: 3
          }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onShow"])
        ], 34)), [
          [_directive_click_outside, _ctx.handleClose, _ctx.popperPaneRef]
        ]);
      }
      var Select$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["render", _sfc_render$5], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);
      const _sfc_main$o = defineComponent({
        name: "ElOptionGroup",
        componentName: "ElOptionGroup",
        props: {
          label: String,
          disabled: {
            type: Boolean,
            default: false
          }
        },
        setup(props) {
          const ns = useNamespace("select");
          const visible = ref(true);
          const instance = getCurrentInstance();
          const children = ref([]);
          provide(selectGroupKey, reactive({
            ...toRefs(props)
          }));
          const select = inject(selectKey);
          onMounted(() => {
            children.value = flattedChildren2(instance.subTree);
          });
          const flattedChildren2 = (node) => {
            const children2 = [];
            if (Array.isArray(node.children)) {
              node.children.forEach((child) => {
                var _a2;
                if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
                  children2.push(child.component.proxy);
                } else if ((_a2 = child.children) == null ? void 0 : _a2.length) {
                  children2.push(...flattedChildren2(child));
                }
              });
            }
            return children2;
          };
          const { groupQueryChange } = toRaw(select);
          watch(groupQueryChange, () => {
            visible.value = children.value.some((option) => option.visible === true);
          }, { flush: "post" });
          return {
            visible,
            ns
          };
        }
      });
      function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
        return withDirectives((openBlock(), createElementBlock("ul", {
          class: normalizeClass(_ctx.ns.be("group", "wrap"))
        }, [
          createBaseVNode("li", {
            class: normalizeClass(_ctx.ns.be("group", "title"))
          }, toDisplayString(_ctx.label), 3),
          createBaseVNode("li", null, [
            createBaseVNode("ul", {
              class: normalizeClass(_ctx.ns.b("group"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)
          ])
        ], 2)), [
          [vShow, _ctx.visible]
        ]);
      }
      var OptionGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["render", _sfc_render$4], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);
      const ElSelect = withInstall(Select$1, {
        Option,
        OptionGroup
      });
      const ElOption = withNoopInstall(Option);
      withNoopInstall(OptionGroup);
      const popoverProps = buildProps({
        trigger: useTooltipTriggerProps.trigger,
        placement: dropdownProps.placement,
        disabled: useTooltipTriggerProps.disabled,
        visible: useTooltipContentProps.visible,
        transition: useTooltipContentProps.transition,
        popperOptions: dropdownProps.popperOptions,
        tabindex: dropdownProps.tabindex,
        content: useTooltipContentProps.content,
        popperStyle: useTooltipContentProps.popperStyle,
        popperClass: useTooltipContentProps.popperClass,
        enterable: {
          ...useTooltipContentProps.enterable,
          default: true
        },
        effect: {
          ...useTooltipContentProps.effect,
          default: "light"
        },
        teleported: useTooltipContentProps.teleported,
        title: String,
        width: {
          type: [String, Number],
          default: 150
        },
        offset: {
          type: Number,
          default: void 0
        },
        showAfter: {
          type: Number,
          default: 0
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        autoClose: {
          type: Number,
          default: 0
        },
        showArrow: {
          type: Boolean,
          default: true
        },
        persistent: {
          type: Boolean,
          default: true
        },
        "onUpdate:visible": {
          type: Function
        }
      });
      const popoverEmits = {
        "update:visible": (value) => isBoolean(value),
        "before-enter": () => true,
        "before-leave": () => true,
        "after-enter": () => true,
        "after-leave": () => true
      };
      const updateEventKeyRaw = `onUpdate:visible`;
      const __default__$a = defineComponent({
        name: "ElPopover"
      });
      const _sfc_main$n = /* @__PURE__ */ defineComponent({
        ...__default__$a,
        props: popoverProps,
        emits: popoverEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const onUpdateVisible = computed(() => {
            return props[updateEventKeyRaw];
          });
          const ns = useNamespace("popover");
          const tooltipRef = ref();
          const popperRef = computed(() => {
            var _a2;
            return (_a2 = unref(tooltipRef)) == null ? void 0 : _a2.popperRef;
          });
          const style = computed(() => {
            return [
              {
                width: addUnit(props.width)
              },
              props.popperStyle
            ];
          });
          const kls = computed(() => {
            return [ns.b(), props.popperClass, { [ns.m("plain")]: !!props.content }];
          });
          const gpuAcceleration = computed(() => {
            return props.transition === `${ns.namespace.value}-fade-in-linear`;
          });
          const hide = () => {
            var _a2;
            (_a2 = tooltipRef.value) == null ? void 0 : _a2.hide();
          };
          const beforeEnter = () => {
            emit2("before-enter");
          };
          const beforeLeave = () => {
            emit2("before-leave");
          };
          const afterEnter = () => {
            emit2("after-enter");
          };
          const afterLeave = () => {
            emit2("update:visible", false);
            emit2("after-leave");
          };
          expose({
            popperRef,
            hide
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTooltip), mergeProps({
              ref_key: "tooltipRef",
              ref: tooltipRef
            }, _ctx.$attrs, {
              trigger: _ctx.trigger,
              placement: _ctx.placement,
              disabled: _ctx.disabled,
              visible: _ctx.visible,
              transition: _ctx.transition,
              "popper-options": _ctx.popperOptions,
              tabindex: _ctx.tabindex,
              content: _ctx.content,
              offset: _ctx.offset,
              "show-after": _ctx.showAfter,
              "hide-after": _ctx.hideAfter,
              "auto-close": _ctx.autoClose,
              "show-arrow": _ctx.showArrow,
              "aria-label": _ctx.title,
              effect: _ctx.effect,
              enterable: _ctx.enterable,
              "popper-class": unref(kls),
              "popper-style": unref(style),
              teleported: _ctx.teleported,
              persistent: _ctx.persistent,
              "gpu-acceleration": unref(gpuAcceleration),
              "onUpdate:visible": unref(onUpdateVisible),
              onBeforeShow: beforeEnter,
              onBeforeHide: beforeLeave,
              onShow: afterEnter,
              onHide: afterLeave
            }), {
              content: withCtx(() => [
                _ctx.title ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("title")),
                  role: "title"
                }, toDisplayString(_ctx.title), 3)) : createCommentVNode("v-if", true),
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.content), 1)
                ])
              ]),
              default: withCtx(() => [
                _ctx.$slots.reference ? renderSlot(_ctx.$slots, "reference", { key: 0 }) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onUpdate:visible"]);
          };
        }
      });
      var Popover = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/popover.vue"]]);
      const attachEvents = (el, binding) => {
        const popperComponent = binding.arg || binding.value;
        const popover = popperComponent == null ? void 0 : popperComponent.popperRef;
        if (popover) {
          popover.triggerRef = el;
        }
      };
      var PopoverDirective = {
        mounted(el, binding) {
          attachEvents(el, binding);
        },
        updated(el, binding) {
          attachEvents(el, binding);
        }
      };
      const VPopover = "popover";
      const ElPopoverDirective = withInstallDirective(PopoverDirective, VPopover);
      const ElPopover = withInstall(Popover, {
        directive: ElPopoverDirective
      });
      const progressProps = buildProps({
        type: {
          type: String,
          default: "line",
          values: ["line", "circle", "dashboard"]
        },
        percentage: {
          type: Number,
          default: 0,
          validator: (val) => val >= 0 && val <= 100
        },
        status: {
          type: String,
          default: "",
          values: ["", "success", "exception", "warning"]
        },
        indeterminate: {
          type: Boolean,
          default: false
        },
        duration: {
          type: Number,
          default: 3
        },
        strokeWidth: {
          type: Number,
          default: 6
        },
        strokeLinecap: {
          type: definePropType(String),
          default: "round"
        },
        textInside: {
          type: Boolean,
          default: false
        },
        width: {
          type: Number,
          default: 126
        },
        showText: {
          type: Boolean,
          default: true
        },
        color: {
          type: definePropType([
            String,
            Array,
            Function
          ]),
          default: ""
        },
        striped: Boolean,
        stripedFlow: Boolean,
        format: {
          type: definePropType(Function),
          default: (percentage) => `${percentage}%`
        }
      });
      const _hoisted_1$y = ["aria-valuenow"];
      const _hoisted_2$s = { viewBox: "0 0 100 100" };
      const _hoisted_3$n = ["d", "stroke", "stroke-linecap", "stroke-width"];
      const _hoisted_4$9 = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"];
      const _hoisted_5$5 = { key: 0 };
      const __default__$9 = defineComponent({
        name: "ElProgress"
      });
      const _sfc_main$m = /* @__PURE__ */ defineComponent({
        ...__default__$9,
        props: progressProps,
        setup(__props) {
          const props = __props;
          const STATUS_COLOR_MAP = {
            success: "#13ce66",
            exception: "#ff4949",
            warning: "#e6a23c",
            default: "#20a0ff"
          };
          const ns = useNamespace("progress");
          const barStyle = computed(() => ({
            width: `${props.percentage}%`,
            animationDuration: `${props.duration}s`,
            backgroundColor: getCurrentColor(props.percentage)
          }));
          const relativeStrokeWidth = computed(() => (props.strokeWidth / props.width * 100).toFixed(1));
          const radius = computed(() => {
            if (["circle", "dashboard"].includes(props.type)) {
              return Number.parseInt(`${50 - Number.parseFloat(relativeStrokeWidth.value) / 2}`, 10);
            }
            return 0;
          });
          const trackPath = computed(() => {
            const r = radius.value;
            const isDashboard = props.type === "dashboard";
            return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "-" : ""}${r * 2}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "" : "-"}${r * 2}
          `;
          });
          const perimeter = computed(() => 2 * Math.PI * radius.value);
          const rate = computed(() => props.type === "dashboard" ? 0.75 : 1);
          const strokeDashoffset = computed(() => {
            const offset = -1 * perimeter.value * (1 - rate.value) / 2;
            return `${offset}px`;
          });
          const trailPathStyle = computed(() => ({
            strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
            strokeDashoffset: strokeDashoffset.value
          }));
          const circlePathStyle = computed(() => ({
            strokeDasharray: `${perimeter.value * rate.value * (props.percentage / 100)}px, ${perimeter.value}px`,
            strokeDashoffset: strokeDashoffset.value,
            transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
          }));
          const stroke = computed(() => {
            let ret;
            if (props.color) {
              ret = getCurrentColor(props.percentage);
            } else {
              ret = STATUS_COLOR_MAP[props.status] || STATUS_COLOR_MAP.default;
            }
            return ret;
          });
          const statusIcon = computed(() => {
            if (props.status === "warning") {
              return warning_filled_default;
            }
            if (props.type === "line") {
              return props.status === "success" ? circle_check_default : circle_close_default;
            } else {
              return props.status === "success" ? check_default : close_default;
            }
          });
          const progressTextSize = computed(() => {
            return props.type === "line" ? 12 + props.strokeWidth * 0.4 : props.width * 0.111111 + 2;
          });
          const content = computed(() => props.format(props.percentage));
          function getColors(color) {
            const span = 100 / color.length;
            const seriesColors = color.map((seriesColor, index) => {
              if (isString$1(seriesColor)) {
                return {
                  color: seriesColor,
                  percentage: (index + 1) * span
                };
              }
              return seriesColor;
            });
            return seriesColors.sort((a, b) => a.percentage - b.percentage);
          }
          const getCurrentColor = (percentage) => {
            var _a2;
            const { color } = props;
            if (isFunction$1(color)) {
              return color(percentage);
            } else if (isString$1(color)) {
              return color;
            } else {
              const colors = getColors(color);
              for (const color2 of colors) {
                if (color2.percentage > percentage)
                  return color2.color;
              }
              return (_a2 = colors[colors.length - 1]) == null ? void 0 : _a2.color;
            }
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).m(_ctx.type),
                unref(ns).is(_ctx.status),
                {
                  [unref(ns).m("without-text")]: !_ctx.showText,
                  [unref(ns).m("text-inside")]: _ctx.textInside
                }
              ]),
              role: "progressbar",
              "aria-valuenow": _ctx.percentage,
              "aria-valuemin": "0",
              "aria-valuemax": "100"
            }, [
              _ctx.type === "line" ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).b("bar"))
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).be("bar", "outer")),
                  style: normalizeStyle({ height: `${_ctx.strokeWidth}px` })
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass([
                      unref(ns).be("bar", "inner"),
                      { [unref(ns).bem("bar", "inner", "indeterminate")]: _ctx.indeterminate },
                      { [unref(ns).bem("bar", "inner", "striped")]: _ctx.striped },
                      { [unref(ns).bem("bar", "inner", "striped-flow")]: _ctx.stripedFlow }
                    ]),
                    style: normalizeStyle(unref(barStyle))
                  }, [
                    (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass(unref(ns).be("bar", "innerText"))
                    }, [
                      renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                        createBaseVNode("span", null, toDisplayString(unref(content)), 1)
                      ])
                    ], 2)) : createCommentVNode("v-if", true)
                  ], 6)
                ], 6)
              ], 2)) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).b("circle")),
                style: normalizeStyle({ height: `${_ctx.width}px`, width: `${_ctx.width}px` })
              }, [
                (openBlock(), createElementBlock("svg", _hoisted_2$s, [
                  createBaseVNode("path", {
                    class: normalizeClass(unref(ns).be("circle", "track")),
                    d: unref(trackPath),
                    stroke: `var(${unref(ns).cssVarName("fill-color-light")}, #e5e9f2)`,
                    "stroke-linecap": _ctx.strokeLinecap,
                    "stroke-width": unref(relativeStrokeWidth),
                    fill: "none",
                    style: normalizeStyle(unref(trailPathStyle))
                  }, null, 14, _hoisted_3$n),
                  createBaseVNode("path", {
                    class: normalizeClass(unref(ns).be("circle", "path")),
                    d: unref(trackPath),
                    stroke: unref(stroke),
                    fill: "none",
                    opacity: _ctx.percentage ? 1 : 0,
                    "stroke-linecap": _ctx.strokeLinecap,
                    "stroke-width": unref(relativeStrokeWidth),
                    style: normalizeStyle(unref(circlePathStyle))
                  }, null, 14, _hoisted_4$9)
                ]))
              ], 6)),
              (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? (openBlock(), createElementBlock("div", {
                key: 2,
                class: normalizeClass(unref(ns).e("text")),
                style: normalizeStyle({ fontSize: `${unref(progressTextSize)}px` })
              }, [
                renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                  !_ctx.status ? (openBlock(), createElementBlock("span", _hoisted_5$5, toDisplayString(unref(content)), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(statusIcon))))
                    ]),
                    _: 1
                  }))
                ])
              ], 6)) : createCommentVNode("v-if", true)
            ], 10, _hoisted_1$y);
          };
        }
      });
      var Progress = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]);
      const ElProgress = withInstall(Progress);
      var safeIsNaN = Number.isNaN || function ponyfill(value) {
        return typeof value === "number" && value !== value;
      };
      function isEqual(first, second) {
        if (first === second) {
          return true;
        }
        if (safeIsNaN(first) && safeIsNaN(second)) {
          return true;
        }
        return false;
      }
      function areInputsEqual(newInputs, lastInputs) {
        if (newInputs.length !== lastInputs.length) {
          return false;
        }
        for (var i = 0; i < newInputs.length; i++) {
          if (!isEqual(newInputs[i], lastInputs[i])) {
            return false;
          }
        }
        return true;
      }
      function memoizeOne(resultFn, isEqual2) {
        if (isEqual2 === void 0) {
          isEqual2 = areInputsEqual;
        }
        var cache2 = null;
        function memoized() {
          var newArgs = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
          }
          if (cache2 && cache2.lastThis === this && isEqual2(newArgs, cache2.lastArgs)) {
            return cache2.lastResult;
          }
          var lastResult = resultFn.apply(this, newArgs);
          cache2 = {
            lastResult,
            lastArgs: newArgs,
            lastThis: this
          };
          return lastResult;
        }
        memoized.clear = function clear2() {
          cache2 = null;
        };
        return memoized;
      }
      const useCache = () => {
        const vm = getCurrentInstance();
        const props = vm.proxy.$props;
        return computed(() => {
          const _getItemStyleCache = (_, __, ___) => ({});
          return props.perfMode ? memoize(_getItemStyleCache) : memoizeOne(_getItemStyleCache);
        });
      };
      const DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;
      const ITEM_RENDER_EVT = "itemRendered";
      const SCROLL_EVT = "scroll";
      const FORWARD = "forward";
      const BACKWARD = "backward";
      const AUTO_ALIGNMENT = "auto";
      const SMART_ALIGNMENT = "smart";
      const START_ALIGNMENT = "start";
      const CENTERED_ALIGNMENT = "center";
      const END_ALIGNMENT = "end";
      const HORIZONTAL = "horizontal";
      const VERTICAL = "vertical";
      const LTR = "ltr";
      const RTL = "rtl";
      const RTL_OFFSET_NAG = "negative";
      const RTL_OFFSET_POS_ASC = "positive-ascending";
      const RTL_OFFSET_POS_DESC = "positive-descending";
      const ScrollbarDirKey = {
        [HORIZONTAL]: "left",
        [VERTICAL]: "top"
      };
      const SCROLLBAR_MIN_SIZE = 20;
      const LayoutKeys = {
        [HORIZONTAL]: "deltaX",
        [VERTICAL]: "deltaY"
      };
      const useWheel = ({ atEndEdge, atStartEdge, layout: layout2 }, onWheelDelta) => {
        let frameHandle;
        let offset = 0;
        const hasReachedEdge = (offset2) => {
          const edgeReached = offset2 < 0 && atStartEdge.value || offset2 > 0 && atEndEdge.value;
          return edgeReached;
        };
        const onWheel = (e) => {
          cAF(frameHandle);
          const newOffset = e[LayoutKeys[layout2.value]];
          if (hasReachedEdge(offset) && hasReachedEdge(offset + newOffset))
            return;
          offset += newOffset;
          if (!isFirefox()) {
            e.preventDefault();
          }
          frameHandle = rAF(() => {
            onWheelDelta(offset);
            offset = 0;
          });
        };
        return {
          hasReachedEdge,
          onWheel
        };
      };
      const itemSize$1 = buildProp({
        type: definePropType([Number, Function]),
        required: true
      });
      const estimatedItemSize = buildProp({
        type: Number
      });
      const cache = buildProp({
        type: Number,
        default: 2
      });
      const direction = buildProp({
        type: String,
        values: ["ltr", "rtl"],
        default: "ltr"
      });
      const initScrollOffset = buildProp({
        type: Number,
        default: 0
      });
      const total = buildProp({
        type: Number,
        required: true
      });
      const layout = buildProp({
        type: String,
        values: ["horizontal", "vertical"],
        default: VERTICAL
      });
      const virtualizedProps = buildProps({
        className: {
          type: String,
          default: ""
        },
        containerElement: {
          type: definePropType([String, Object]),
          default: "div"
        },
        data: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        direction,
        height: {
          type: [String, Number],
          required: true
        },
        innerElement: {
          type: [String, Object],
          default: "div"
        },
        style: {
          type: definePropType([Object, String, Array])
        },
        useIsScrolling: {
          type: Boolean,
          default: false
        },
        width: {
          type: [Number, String],
          required: false
        },
        perfMode: {
          type: Boolean,
          default: true
        },
        scrollbarAlwaysOn: {
          type: Boolean,
          default: false
        }
      });
      const virtualizedListProps = buildProps({
        cache,
        estimatedItemSize,
        layout,
        initScrollOffset,
        total,
        itemSize: itemSize$1,
        ...virtualizedProps
      });
      const scrollbarSize = {
        type: Number,
        default: 6
      };
      const startGap = { type: Number, default: 0 };
      const endGap = { type: Number, default: 2 };
      buildProps({
        columnCache: cache,
        columnWidth: itemSize$1,
        estimatedColumnWidth: estimatedItemSize,
        estimatedRowHeight: estimatedItemSize,
        initScrollLeft: initScrollOffset,
        initScrollTop: initScrollOffset,
        itemKey: {
          type: definePropType(Function),
          default: ({
            columnIndex,
            rowIndex
          }) => `${rowIndex}:${columnIndex}`
        },
        rowCache: cache,
        rowHeight: itemSize$1,
        totalColumn: total,
        totalRow: total,
        hScrollbarSize: scrollbarSize,
        vScrollbarSize: scrollbarSize,
        scrollbarStartGap: startGap,
        scrollbarEndGap: endGap,
        role: String,
        ...virtualizedProps
      });
      const virtualizedScrollbarProps = buildProps({
        alwaysOn: Boolean,
        class: String,
        layout,
        total,
        ratio: {
          type: Number,
          required: true
        },
        clientSize: {
          type: Number,
          required: true
        },
        scrollFrom: {
          type: Number,
          required: true
        },
        scrollbarSize,
        startGap,
        endGap,
        visible: Boolean
      });
      const getScrollDir = (prev, cur) => prev < cur ? FORWARD : BACKWARD;
      const isHorizontal = (dir) => dir === LTR || dir === RTL || dir === HORIZONTAL;
      let cachedRTLResult = null;
      function getRTLOffsetType(recalculate = false) {
        if (cachedRTLResult === null || recalculate) {
          const outerDiv = document.createElement("div");
          const outerStyle = outerDiv.style;
          outerStyle.width = "50px";
          outerStyle.height = "50px";
          outerStyle.overflow = "scroll";
          outerStyle.direction = "rtl";
          const innerDiv = document.createElement("div");
          const innerStyle = innerDiv.style;
          innerStyle.width = "100px";
          innerStyle.height = "100px";
          outerDiv.appendChild(innerDiv);
          document.body.appendChild(outerDiv);
          if (outerDiv.scrollLeft > 0) {
            cachedRTLResult = RTL_OFFSET_POS_DESC;
          } else {
            outerDiv.scrollLeft = 1;
            if (outerDiv.scrollLeft === 0) {
              cachedRTLResult = RTL_OFFSET_NAG;
            } else {
              cachedRTLResult = RTL_OFFSET_POS_ASC;
            }
          }
          document.body.removeChild(outerDiv);
          return cachedRTLResult;
        }
        return cachedRTLResult;
      }
      function renderThumbStyle({ move, size: size2, bar }, layout2) {
        const style = {};
        const translate2 = `translate${bar.axis}(${move}px)`;
        style[bar.size] = size2;
        style.transform = translate2;
        style.msTransform = translate2;
        style.webkitTransform = translate2;
        if (layout2 === "horizontal") {
          style.height = "100%";
        } else {
          style.width = "100%";
        }
        return style;
      }
      const ScrollBar = defineComponent({
        name: "ElVirtualScrollBar",
        props: virtualizedScrollbarProps,
        emits: ["scroll", "start-move", "stop-move"],
        setup(props, { emit: emit2 }) {
          const GAP2 = computed(() => props.startGap + props.endGap);
          const nsVirtualScrollbar = useNamespace("virtual-scrollbar");
          const nsScrollbar = useNamespace("scrollbar");
          const trackRef = ref();
          const thumbRef = ref();
          let frameHandle = null;
          let onselectstartStore = null;
          const state = reactive({
            isDragging: false,
            traveled: 0
          });
          const bar = computed(() => BAR_MAP[props.layout]);
          const trackSize = computed(() => props.clientSize - unref(GAP2));
          const trackStyle = computed(() => ({
            position: "absolute",
            width: `${HORIZONTAL === props.layout ? trackSize.value : props.scrollbarSize}px`,
            height: `${HORIZONTAL === props.layout ? props.scrollbarSize : trackSize.value}px`,
            [ScrollbarDirKey[props.layout]]: "2px",
            right: "2px",
            bottom: "2px",
            borderRadius: "4px"
          }));
          const thumbSize = computed(() => {
            const ratio = props.ratio;
            const clientSize = props.clientSize;
            if (ratio >= 100) {
              return Number.POSITIVE_INFINITY;
            }
            if (ratio >= 50) {
              return ratio * clientSize / 100;
            }
            const SCROLLBAR_MAX_SIZE = clientSize / 3;
            return Math.floor(Math.min(Math.max(ratio * clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));
          });
          const thumbStyle = computed(() => {
            if (!Number.isFinite(thumbSize.value)) {
              return {
                display: "none"
              };
            }
            const thumb = `${thumbSize.value}px`;
            const style = renderThumbStyle({
              bar: bar.value,
              size: thumb,
              move: state.traveled
            }, props.layout);
            return style;
          });
          const totalSteps = computed(() => Math.floor(props.clientSize - thumbSize.value - unref(GAP2)));
          const attachEvents2 = () => {
            window.addEventListener("mousemove", onMouseMove);
            window.addEventListener("mouseup", onMouseUp);
            const thumbEl = unref(thumbRef);
            if (!thumbEl)
              return;
            onselectstartStore = document.onselectstart;
            document.onselectstart = () => false;
            thumbEl.addEventListener("touchmove", onMouseMove);
            thumbEl.addEventListener("touchend", onMouseUp);
          };
          const detachEvents = () => {
            window.removeEventListener("mousemove", onMouseMove);
            window.removeEventListener("mouseup", onMouseUp);
            document.onselectstart = onselectstartStore;
            onselectstartStore = null;
            const thumbEl = unref(thumbRef);
            if (!thumbEl)
              return;
            thumbEl.removeEventListener("touchmove", onMouseMove);
            thumbEl.removeEventListener("touchend", onMouseUp);
          };
          const onThumbMouseDown = (e) => {
            e.stopImmediatePropagation();
            if (e.ctrlKey || [1, 2].includes(e.button)) {
              return;
            }
            state.isDragging = true;
            state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);
            emit2("start-move");
            attachEvents2();
          };
          const onMouseUp = () => {
            state.isDragging = false;
            state[bar.value.axis] = 0;
            emit2("stop-move");
            detachEvents();
          };
          const onMouseMove = (e) => {
            const { isDragging } = state;
            if (!isDragging)
              return;
            if (!thumbRef.value || !trackRef.value)
              return;
            const prevPage = state[bar.value.axis];
            if (!prevPage)
              return;
            cAF(frameHandle);
            const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
            const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;
            const distance = offset - thumbClickPosition;
            frameHandle = rAF(() => {
              state.traveled = Math.max(props.startGap, Math.min(distance, totalSteps.value));
              emit2("scroll", distance, totalSteps.value);
            });
          };
          const clickTrackHandler = (e) => {
            const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
            const thumbHalf = thumbRef.value[bar.value.offset] / 2;
            const distance = offset - thumbHalf;
            state.traveled = Math.max(0, Math.min(distance, totalSteps.value));
            emit2("scroll", distance, totalSteps.value);
          };
          watch(() => props.scrollFrom, (v) => {
            if (state.isDragging)
              return;
            state.traveled = Math.ceil(v * totalSteps.value);
          });
          onBeforeUnmount(() => {
            detachEvents();
          });
          return () => {
            return h("div", {
              role: "presentation",
              ref: trackRef,
              class: [
                nsVirtualScrollbar.b(),
                props.class,
                (props.alwaysOn || state.isDragging) && "always-on"
              ],
              style: trackStyle.value,
              onMousedown: withModifiers(clickTrackHandler, ["stop", "prevent"]),
              onTouchstartPrevent: onThumbMouseDown
            }, h("div", {
              ref: thumbRef,
              class: nsScrollbar.e("thumb"),
              style: thumbStyle.value,
              onMousedown: onThumbMouseDown
            }, []));
          };
        }
      });
      const createList = ({
        name,
        getOffset,
        getItemSize,
        getItemOffset,
        getEstimatedTotalSize: getEstimatedTotalSize2,
        getStartIndexForOffset,
        getStopIndexForStartIndex,
        initCache,
        clearCache,
        validateProps
      }) => {
        return defineComponent({
          name: name != null ? name : "ElVirtualList",
          props: virtualizedListProps,
          emits: [ITEM_RENDER_EVT, SCROLL_EVT],
          setup(props, { emit: emit2, expose }) {
            validateProps(props);
            const instance = getCurrentInstance();
            const ns = useNamespace("vl");
            const dynamicSizeCache = ref(initCache(props, instance));
            const getItemStyleCache = useCache();
            const windowRef = ref();
            const innerRef = ref();
            const scrollbarRef = ref();
            const states = ref({
              isScrolling: false,
              scrollDir: "forward",
              scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,
              updateRequested: false,
              isScrollbarDragging: false,
              scrollbarAlwaysOn: props.scrollbarAlwaysOn
            });
            const itemsToRender = computed(() => {
              const { total: total2, cache: cache2 } = props;
              const { isScrolling, scrollDir, scrollOffset } = unref(states);
              if (total2 === 0) {
                return [0, 0, 0, 0];
              }
              const startIndex = getStartIndexForOffset(props, scrollOffset, unref(dynamicSizeCache));
              const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, unref(dynamicSizeCache));
              const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache2) : 1;
              const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache2) : 1;
              return [
                Math.max(0, startIndex - cacheBackward),
                Math.max(0, Math.min(total2 - 1, stopIndex + cacheForward)),
                startIndex,
                stopIndex
              ];
            });
            const estimatedTotalSize = computed(() => getEstimatedTotalSize2(props, unref(dynamicSizeCache)));
            const _isHorizontal = computed(() => isHorizontal(props.layout));
            const windowStyle = computed(() => [
              {
                position: "relative",
                [`overflow-${_isHorizontal.value ? "x" : "y"}`]: "scroll",
                WebkitOverflowScrolling: "touch",
                willChange: "transform"
              },
              {
                direction: props.direction,
                height: isNumber(props.height) ? `${props.height}px` : props.height,
                width: isNumber(props.width) ? `${props.width}px` : props.width
              },
              props.style
            ]);
            const innerStyle = computed(() => {
              const size2 = unref(estimatedTotalSize);
              const horizontal = unref(_isHorizontal);
              return {
                height: horizontal ? "100%" : `${size2}px`,
                pointerEvents: unref(states).isScrolling ? "none" : void 0,
                width: horizontal ? `${size2}px` : "100%"
              };
            });
            const clientSize = computed(() => _isHorizontal.value ? props.width : props.height);
            const { onWheel } = useWheel({
              atStartEdge: computed(() => states.value.scrollOffset <= 0),
              atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),
              layout: computed(() => props.layout)
            }, (offset) => {
              var _a2, _b;
              (_b = (_a2 = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a2);
              scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));
            });
            const emitEvents = () => {
              const { total: total2 } = props;
              if (total2 > 0) {
                const [cacheStart, cacheEnd, visibleStart, visibleEnd] = unref(itemsToRender);
                emit2(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);
              }
              const { scrollDir, scrollOffset, updateRequested } = unref(states);
              emit2(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);
            };
            const scrollVertically = (e) => {
              const { clientHeight, scrollHeight, scrollTop } = e.currentTarget;
              const _states = unref(states);
              if (_states.scrollOffset === scrollTop) {
                return;
              }
              const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
              states.value = {
                ..._states,
                isScrolling: true,
                scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),
                scrollOffset,
                updateRequested: false
              };
              nextTick(resetIsScrolling);
            };
            const scrollHorizontally = (e) => {
              const { clientWidth, scrollLeft, scrollWidth } = e.currentTarget;
              const _states = unref(states);
              if (_states.scrollOffset === scrollLeft) {
                return;
              }
              const { direction: direction2 } = props;
              let scrollOffset = scrollLeft;
              if (direction2 === RTL) {
                switch (getRTLOffsetType()) {
                  case RTL_OFFSET_NAG: {
                    scrollOffset = -scrollLeft;
                    break;
                  }
                  case RTL_OFFSET_POS_DESC: {
                    scrollOffset = scrollWidth - clientWidth - scrollLeft;
                    break;
                  }
                }
              }
              scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
              states.value = {
                ..._states,
                isScrolling: true,
                scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),
                scrollOffset,
                updateRequested: false
              };
              nextTick(resetIsScrolling);
            };
            const onScroll = (e) => {
              unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);
              emitEvents();
            };
            const onScrollbarScroll = (distanceToGo, totalSteps) => {
              const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;
              scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));
            };
            const scrollTo = (offset) => {
              offset = Math.max(offset, 0);
              if (offset === unref(states).scrollOffset) {
                return;
              }
              states.value = {
                ...unref(states),
                scrollOffset: offset,
                scrollDir: getScrollDir(unref(states).scrollOffset, offset),
                updateRequested: true
              };
              nextTick(resetIsScrolling);
            };
            const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {
              const { scrollOffset } = unref(states);
              idx = Math.max(0, Math.min(idx, props.total - 1));
              scrollTo(getOffset(props, idx, alignment, scrollOffset, unref(dynamicSizeCache)));
            };
            const getItemStyle = (idx) => {
              const { direction: direction2, itemSize: itemSize2, layout: layout2 } = props;
              const itemStyleCache = getItemStyleCache.value(clearCache && itemSize2, clearCache && layout2, clearCache && direction2);
              let style;
              if (hasOwn(itemStyleCache, String(idx))) {
                style = itemStyleCache[idx];
              } else {
                const offset = getItemOffset(props, idx, unref(dynamicSizeCache));
                const size2 = getItemSize(props, idx, unref(dynamicSizeCache));
                const horizontal = unref(_isHorizontal);
                const isRtl = direction2 === RTL;
                const offsetHorizontal = horizontal ? offset : 0;
                itemStyleCache[idx] = style = {
                  position: "absolute",
                  left: isRtl ? void 0 : `${offsetHorizontal}px`,
                  right: isRtl ? `${offsetHorizontal}px` : void 0,
                  top: !horizontal ? `${offset}px` : 0,
                  height: !horizontal ? `${size2}px` : "100%",
                  width: horizontal ? `${size2}px` : "100%"
                };
              }
              return style;
            };
            const resetIsScrolling = () => {
              states.value.isScrolling = false;
              nextTick(() => {
                getItemStyleCache.value(-1, null, null);
              });
            };
            const resetScrollTop = () => {
              const window2 = windowRef.value;
              if (window2) {
                window2.scrollTop = 0;
              }
            };
            onMounted(() => {
              if (!isClient$1)
                return;
              const { initScrollOffset: initScrollOffset2 } = props;
              const windowElement = unref(windowRef);
              if (isNumber(initScrollOffset2) && windowElement) {
                if (unref(_isHorizontal)) {
                  windowElement.scrollLeft = initScrollOffset2;
                } else {
                  windowElement.scrollTop = initScrollOffset2;
                }
              }
              emitEvents();
            });
            onUpdated(() => {
              const { direction: direction2, layout: layout2 } = props;
              const { scrollOffset, updateRequested } = unref(states);
              const windowElement = unref(windowRef);
              if (updateRequested && windowElement) {
                if (layout2 === HORIZONTAL) {
                  if (direction2 === RTL) {
                    switch (getRTLOffsetType()) {
                      case RTL_OFFSET_NAG: {
                        windowElement.scrollLeft = -scrollOffset;
                        break;
                      }
                      case RTL_OFFSET_POS_ASC: {
                        windowElement.scrollLeft = scrollOffset;
                        break;
                      }
                      default: {
                        const { clientWidth, scrollWidth } = windowElement;
                        windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                        break;
                      }
                    }
                  } else {
                    windowElement.scrollLeft = scrollOffset;
                  }
                } else {
                  windowElement.scrollTop = scrollOffset;
                }
              }
            });
            const api = {
              ns,
              clientSize,
              estimatedTotalSize,
              windowStyle,
              windowRef,
              innerRef,
              innerStyle,
              itemsToRender,
              scrollbarRef,
              states,
              getItemStyle,
              onScroll,
              onScrollbarScroll,
              onWheel,
              scrollTo,
              scrollToItem,
              resetScrollTop
            };
            expose({
              windowRef,
              innerRef,
              getItemStyleCache,
              scrollTo,
              scrollToItem,
              resetScrollTop,
              states
            });
            return api;
          },
          render(ctx) {
            var _a2;
            const {
              $slots,
              className,
              clientSize,
              containerElement,
              data,
              getItemStyle,
              innerElement,
              itemsToRender,
              innerStyle,
              layout: layout2,
              total: total2,
              onScroll,
              onScrollbarScroll,
              onWheel,
              states,
              useIsScrolling,
              windowStyle,
              ns
            } = ctx;
            const [start, end2] = itemsToRender;
            const Container2 = resolveDynamicComponent(containerElement);
            const Inner = resolveDynamicComponent(innerElement);
            const children = [];
            if (total2 > 0) {
              for (let i = start; i <= end2; i++) {
                children.push((_a2 = $slots.default) == null ? void 0 : _a2.call($slots, {
                  data,
                  key: i,
                  index: i,
                  isScrolling: useIsScrolling ? states.isScrolling : void 0,
                  style: getItemStyle(i)
                }));
              }
            }
            const InnerNode = [
              h(Inner, {
                style: innerStyle,
                ref: "innerRef"
              }, !isString$1(Inner) ? {
                default: () => children
              } : children)
            ];
            const scrollbar = h(ScrollBar, {
              ref: "scrollbarRef",
              clientSize,
              layout: layout2,
              onScroll: onScrollbarScroll,
              ratio: clientSize * 100 / this.estimatedTotalSize,
              scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),
              total: total2
            });
            const listContainer = h(Container2, {
              class: [ns.e("window"), className],
              style: windowStyle,
              onScroll,
              onWheel,
              ref: "windowRef",
              key: 0
            }, !isString$1(Container2) ? { default: () => [InnerNode] } : [InnerNode]);
            return h("div", {
              key: 0,
              class: [ns.e("wrapper"), states.scrollbarAlwaysOn ? "always-on" : ""]
            }, [listContainer, scrollbar]);
          }
        });
      };
      const FixedSizeList = createList({
        name: "ElFixedSizeList",
        getItemOffset: ({ itemSize: itemSize2 }, index) => index * itemSize2,
        getItemSize: ({ itemSize: itemSize2 }) => itemSize2,
        getEstimatedTotalSize: ({ total: total2, itemSize: itemSize2 }) => itemSize2 * total2,
        getOffset: ({ height, total: total2, itemSize: itemSize2, layout: layout2, width }, index, alignment, scrollOffset) => {
          const size2 = isHorizontal(layout2) ? width : height;
          const lastItemOffset = Math.max(0, total2 * itemSize2 - size2);
          const maxOffset = Math.min(lastItemOffset, index * itemSize2);
          const minOffset = Math.max(0, (index + 1) * itemSize2 - size2);
          if (alignment === SMART_ALIGNMENT) {
            if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
              alignment = AUTO_ALIGNMENT;
            } else {
              alignment = CENTERED_ALIGNMENT;
            }
          }
          switch (alignment) {
            case START_ALIGNMENT: {
              return maxOffset;
            }
            case END_ALIGNMENT: {
              return minOffset;
            }
            case CENTERED_ALIGNMENT: {
              const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
              if (middleOffset < Math.ceil(size2 / 2)) {
                return 0;
              } else if (middleOffset > lastItemOffset + Math.floor(size2 / 2)) {
                return lastItemOffset;
              } else {
                return middleOffset;
              }
            }
            case AUTO_ALIGNMENT:
            default: {
              if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
                return scrollOffset;
              } else if (scrollOffset < minOffset) {
                return minOffset;
              } else {
                return maxOffset;
              }
            }
          }
        },
        getStartIndexForOffset: ({ total: total2, itemSize: itemSize2 }, offset) => Math.max(0, Math.min(total2 - 1, Math.floor(offset / itemSize2))),
        getStopIndexForStartIndex: ({ height, total: total2, itemSize: itemSize2, layout: layout2, width }, startIndex, scrollOffset) => {
          const offset = startIndex * itemSize2;
          const size2 = isHorizontal(layout2) ? width : height;
          const numVisibleItems = Math.ceil((size2 + scrollOffset - offset) / itemSize2);
          return Math.max(0, Math.min(total2 - 1, startIndex + numVisibleItems - 1));
        },
        initCache() {
          return void 0;
        },
        clearCache: true,
        validateProps() {
        }
      });
      const getItemFromCache = (props, index, listCache) => {
        const { itemSize: itemSize2 } = props;
        const { items, lastVisitedIndex } = listCache;
        if (index > lastVisitedIndex) {
          let offset = 0;
          if (lastVisitedIndex >= 0) {
            const item = items[lastVisitedIndex];
            offset = item.offset + item.size;
          }
          for (let i = lastVisitedIndex + 1; i <= index; i++) {
            const size2 = itemSize2(i);
            items[i] = {
              offset,
              size: size2
            };
            offset += size2;
          }
          listCache.lastVisitedIndex = index;
        }
        return items[index];
      };
      const findItem = (props, listCache, offset) => {
        const { items, lastVisitedIndex } = listCache;
        const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;
        if (lastVisitedOffset >= offset) {
          return bs(props, listCache, 0, lastVisitedIndex, offset);
        }
        return es(props, listCache, Math.max(0, lastVisitedIndex), offset);
      };
      const bs = (props, listCache, low, high, offset) => {
        while (low <= high) {
          const mid = low + Math.floor((high - low) / 2);
          const currentOffset = getItemFromCache(props, mid, listCache).offset;
          if (currentOffset === offset) {
            return mid;
          } else if (currentOffset < offset) {
            low = mid + 1;
          } else if (currentOffset > offset) {
            high = mid - 1;
          }
        }
        return Math.max(0, low - 1);
      };
      const es = (props, listCache, index, offset) => {
        const { total: total2 } = props;
        let exponent = 1;
        while (index < total2 && getItemFromCache(props, index, listCache).offset < offset) {
          index += exponent;
          exponent *= 2;
        }
        return bs(props, listCache, Math.floor(index / 2), Math.min(index, total2 - 1), offset);
      };
      const getEstimatedTotalSize = ({ total: total2 }, { items, estimatedItemSize: estimatedItemSize2, lastVisitedIndex }) => {
        let totalSizeOfMeasuredItems = 0;
        if (lastVisitedIndex >= total2) {
          lastVisitedIndex = total2 - 1;
        }
        if (lastVisitedIndex >= 0) {
          const item = items[lastVisitedIndex];
          totalSizeOfMeasuredItems = item.offset + item.size;
        }
        const numUnmeasuredItems = total2 - lastVisitedIndex - 1;
        const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize2;
        return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
      };
      const DynamicSizeList = createList({
        name: "ElDynamicSizeList",
        getItemOffset: (props, index, listCache) => getItemFromCache(props, index, listCache).offset,
        getItemSize: (_, index, { items }) => items[index].size,
        getEstimatedTotalSize,
        getOffset: (props, index, alignment, scrollOffset, listCache) => {
          const { height, layout: layout2, width } = props;
          const size2 = isHorizontal(layout2) ? width : height;
          const item = getItemFromCache(props, index, listCache);
          const estimatedTotalSize = getEstimatedTotalSize(props, listCache);
          const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size2, item.offset));
          const minOffset = Math.max(0, item.offset - size2 + item.size);
          if (alignment === SMART_ALIGNMENT) {
            if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
              alignment = AUTO_ALIGNMENT;
            } else {
              alignment = CENTERED_ALIGNMENT;
            }
          }
          switch (alignment) {
            case START_ALIGNMENT: {
              return maxOffset;
            }
            case END_ALIGNMENT: {
              return minOffset;
            }
            case CENTERED_ALIGNMENT: {
              return Math.round(minOffset + (maxOffset - minOffset) / 2);
            }
            case AUTO_ALIGNMENT:
            default: {
              if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
                return scrollOffset;
              } else if (scrollOffset < minOffset) {
                return minOffset;
              } else {
                return maxOffset;
              }
            }
          }
        },
        getStartIndexForOffset: (props, offset, listCache) => findItem(props, listCache, offset),
        getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {
          const { height, total: total2, layout: layout2, width } = props;
          const size2 = isHorizontal(layout2) ? width : height;
          const item = getItemFromCache(props, startIndex, listCache);
          const maxOffset = scrollOffset + size2;
          let offset = item.offset + item.size;
          let stopIndex = startIndex;
          while (stopIndex < total2 - 1 && offset < maxOffset) {
            stopIndex++;
            offset += getItemFromCache(props, stopIndex, listCache).size;
          }
          return stopIndex;
        },
        initCache({ estimatedItemSize: estimatedItemSize2 = DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {
          const cache2 = {
            items: {},
            estimatedItemSize: estimatedItemSize2,
            lastVisitedIndex: -1
          };
          cache2.clearCacheAfterIndex = (index, forceUpdate = true) => {
            var _a2, _b;
            cache2.lastVisitedIndex = Math.min(cache2.lastVisitedIndex, index - 1);
            (_a2 = instance.exposed) == null ? void 0 : _a2.getItemStyleCache(-1);
            if (forceUpdate) {
              (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();
            }
          };
          return cache2;
        },
        clearCache: false,
        validateProps: ({ itemSize: itemSize2 }) => {
        }
      });
      const _sfc_main$l = defineComponent({
        props: {
          item: {
            type: Object,
            required: true
          },
          style: Object,
          height: Number
        },
        setup() {
          const ns = useNamespace("select");
          return {
            ns
          };
        }
      });
      function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
        return _ctx.item.isTitle ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.ns.be("group", "title")),
          style: normalizeStyle([_ctx.style, { lineHeight: `${_ctx.height}px` }])
        }, toDisplayString(_ctx.item.label), 7)) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.ns.be("group", "split")),
          style: normalizeStyle(_ctx.style)
        }, [
          createBaseVNode("span", {
            class: normalizeClass(_ctx.ns.be("group", "split-dash")),
            style: normalizeStyle({ top: `${_ctx.height / 2}px` })
          }, null, 6)
        ], 6));
      }
      var GroupItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["render", _sfc_render$3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/group-item.vue"]]);
      function useOption(props, { emit: emit2 }) {
        return {
          hoverItem: () => {
            if (!props.disabled) {
              emit2("hover", props.index);
            }
          },
          selectOptionClick: () => {
            if (!props.disabled) {
              emit2("select", props.item, props.index);
            }
          }
        };
      }
      const SelectProps = {
        allowCreate: Boolean,
        autocomplete: {
          type: String,
          default: "none"
        },
        automaticDropdown: Boolean,
        clearable: Boolean,
        clearIcon: {
          type: [String, Object],
          default: circle_close_default
        },
        effect: {
          type: String,
          default: "light"
        },
        collapseTags: Boolean,
        collapseTagsTooltip: {
          type: Boolean,
          default: false
        },
        maxCollapseTags: {
          type: Number,
          default: 1
        },
        defaultFirstOption: Boolean,
        disabled: Boolean,
        estimatedOptionHeight: {
          type: Number,
          default: void 0
        },
        filterable: Boolean,
        filterMethod: Function,
        height: {
          type: Number,
          default: 170
        },
        itemHeight: {
          type: Number,
          default: 34
        },
        id: String,
        loading: Boolean,
        loadingText: String,
        label: String,
        modelValue: [Array, String, Number, Boolean, Object],
        multiple: Boolean,
        multipleLimit: {
          type: Number,
          default: 0
        },
        name: String,
        noDataText: String,
        noMatchText: String,
        remoteMethod: Function,
        reserveKeyword: {
          type: Boolean,
          default: true
        },
        options: {
          type: Array,
          required: true
        },
        placeholder: {
          type: String
        },
        teleported: useTooltipContentProps.teleported,
        persistent: {
          type: Boolean,
          default: true
        },
        popperClass: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: Object,
          default: () => ({})
        },
        remote: Boolean,
        size: {
          type: String,
          validator: isValidComponentSize
        },
        valueKey: {
          type: String,
          default: "value"
        },
        scrollbarAlwaysOn: {
          type: Boolean,
          default: false
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        placement: {
          type: definePropType(String),
          values: Ee,
          default: "bottom-start"
        }
      };
      const OptionProps = {
        data: Array,
        disabled: Boolean,
        hovering: Boolean,
        item: Object,
        index: Number,
        style: Object,
        selected: Boolean,
        created: Boolean
      };
      const _sfc_main$k = defineComponent({
        props: OptionProps,
        emits: ["select", "hover"],
        setup(props, { emit: emit2 }) {
          const ns = useNamespace("select");
          const { hoverItem, selectOptionClick } = useOption(props, { emit: emit2 });
          return {
            ns,
            hoverItem,
            selectOptionClick
          };
        }
      });
      const _hoisted_1$x = ["aria-selected"];
      function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("li", {
          "aria-selected": _ctx.selected,
          style: normalizeStyle(_ctx.style),
          class: normalizeClass([
            _ctx.ns.be("dropdown", "option-item"),
            _ctx.ns.is("selected", _ctx.selected),
            _ctx.ns.is("disabled", _ctx.disabled),
            _ctx.ns.is("created", _ctx.created),
            { hover: _ctx.hovering }
          ]),
          onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "default", {
            item: _ctx.item,
            index: _ctx.index,
            disabled: _ctx.disabled
          }, () => [
            createBaseVNode("span", null, toDisplayString(_ctx.item.label), 1)
          ])
        ], 46, _hoisted_1$x);
      }
      var OptionItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["render", _sfc_render$2], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/option-item.vue"]]);
      const selectV2InjectionKey = Symbol("ElSelectV2Injection");
      var ElSelectMenu = defineComponent({
        name: "ElSelectDropdown",
        props: {
          data: {
            type: Array,
            required: true
          },
          hoveringIndex: Number,
          width: Number
        },
        setup(props, {
          slots,
          expose
        }) {
          const select = inject(selectV2InjectionKey);
          const ns = useNamespace("select");
          const cachedHeights = ref([]);
          const listRef = ref();
          const size2 = computed(() => props.data.length);
          watch(() => size2.value, () => {
            var _a2, _b;
            (_b = (_a2 = select.popper.value).updatePopper) == null ? void 0 : _b.call(_a2);
          });
          const isSized = computed(() => isUndefined(select.props.estimatedOptionHeight));
          const listProps = computed(() => {
            if (isSized.value) {
              return {
                itemSize: select.props.itemHeight
              };
            }
            return {
              estimatedSize: select.props.estimatedOptionHeight,
              itemSize: (idx) => cachedHeights.value[idx]
            };
          });
          const contains = (arr = [], target) => {
            const {
              props: {
                valueKey
              }
            } = select;
            if (!isObject$1(target)) {
              return arr.includes(target);
            }
            return arr && arr.some((item) => {
              return get(item, valueKey) === get(target, valueKey);
            });
          };
          const isEqual2 = (selected, target) => {
            if (!isObject$1(target)) {
              return selected === target;
            } else {
              const {
                valueKey
              } = select.props;
              return get(selected, valueKey) === get(target, valueKey);
            }
          };
          const isItemSelected = (modelValue, target) => {
            const {
              valueKey
            } = select.props;
            if (select.props.multiple) {
              return contains(modelValue, get(target, valueKey));
            }
            return isEqual2(modelValue, get(target, valueKey));
          };
          const isItemDisabled = (modelValue, selected) => {
            const {
              disabled,
              multiple,
              multipleLimit
            } = select.props;
            return disabled || !selected && (multiple ? multipleLimit > 0 && modelValue.length >= multipleLimit : false);
          };
          const isItemHovering = (target) => props.hoveringIndex === target;
          const scrollToItem = (index) => {
            const list = listRef.value;
            if (list) {
              list.scrollToItem(index);
            }
          };
          const resetScrollTop = () => {
            const list = listRef.value;
            if (list) {
              list.resetScrollTop();
            }
          };
          expose({
            listRef,
            isSized,
            isItemDisabled,
            isItemHovering,
            isItemSelected,
            scrollToItem,
            resetScrollTop
          });
          const Item = (itemProps) => {
            const {
              index,
              data,
              style
            } = itemProps;
            const sized = unref(isSized);
            const {
              itemSize: itemSize2,
              estimatedSize
            } = unref(listProps);
            const {
              modelValue
            } = select.props;
            const {
              onSelect,
              onHover
            } = select;
            const item = data[index];
            if (item.type === "Group") {
              return createVNode(GroupItem, {
                "item": item,
                "style": style,
                "height": sized ? itemSize2 : estimatedSize
              }, null);
            }
            const isSelected = isItemSelected(modelValue, item);
            const isDisabled = isItemDisabled(modelValue, isSelected);
            const isHovering = isItemHovering(index);
            return createVNode(OptionItem, mergeProps(itemProps, {
              "selected": isSelected,
              "disabled": item.disabled || isDisabled,
              "created": !!item.created,
              "hovering": isHovering,
              "item": item,
              "onSelect": onSelect,
              "onHover": onHover
            }), {
              default: (props2) => {
                var _a2;
                return ((_a2 = slots.default) == null ? void 0 : _a2.call(slots, props2)) || createVNode("span", null, [item.label]);
              }
            });
          };
          const {
            onKeyboardNavigate,
            onKeyboardSelect
          } = select;
          const onForward = () => {
            onKeyboardNavigate("forward");
          };
          const onBackward = () => {
            onKeyboardNavigate("backward");
          };
          const onEscOrTab = () => {
            select.expanded = false;
          };
          const onKeydown = (e) => {
            const {
              code
            } = e;
            const {
              tab,
              esc,
              down: down2,
              up: up2,
              enter
            } = EVENT_CODE;
            if (code !== tab) {
              e.preventDefault();
              e.stopPropagation();
            }
            switch (code) {
              case tab:
              case esc: {
                onEscOrTab();
                break;
              }
              case down2: {
                onForward();
                break;
              }
              case up2: {
                onBackward();
                break;
              }
              case enter: {
                onKeyboardSelect();
                break;
              }
            }
          };
          return () => {
            var _a2;
            const {
              data,
              width
            } = props;
            const {
              height,
              multiple,
              scrollbarAlwaysOn
            } = select.props;
            if (data.length === 0) {
              return createVNode("div", {
                "class": ns.b("dropdown"),
                "style": {
                  width: `${width}px`
                }
              }, [(_a2 = slots.empty) == null ? void 0 : _a2.call(slots)]);
            }
            const List = unref(isSized) ? FixedSizeList : DynamicSizeList;
            return createVNode("div", {
              "class": [ns.b("dropdown"), ns.is("multiple", multiple)]
            }, [createVNode(List, mergeProps({
              "ref": listRef
            }, unref(listProps), {
              "className": ns.be("dropdown", "list"),
              "scrollbarAlwaysOn": scrollbarAlwaysOn,
              "data": data,
              "height": height,
              "width": width,
              "total": data.length,
              "onKeydown": onKeydown
            }), {
              default: (props2) => createVNode(Item, props2, null)
            })]);
          };
        }
      });
      function useAllowCreate(props, states) {
        const createOptionCount = ref(0);
        const cachedSelectedOption = ref(null);
        const enableAllowCreateMode = computed(() => {
          return props.allowCreate && props.filterable;
        });
        function hasExistingOption(query) {
          const hasValue = (option) => option.value === query;
          return props.options && props.options.some(hasValue) || states.createdOptions.some(hasValue);
        }
        function selectNewOption(option) {
          if (!enableAllowCreateMode.value) {
            return;
          }
          if (props.multiple && option.created) {
            createOptionCount.value++;
          } else {
            cachedSelectedOption.value = option;
          }
        }
        function createNewOption(query) {
          if (enableAllowCreateMode.value) {
            if (query && query.length > 0 && !hasExistingOption(query)) {
              const newOption = {
                value: query,
                label: query,
                created: true,
                disabled: false
              };
              if (states.createdOptions.length >= createOptionCount.value) {
                states.createdOptions[createOptionCount.value] = newOption;
              } else {
                states.createdOptions.push(newOption);
              }
            } else {
              if (props.multiple) {
                states.createdOptions.length = createOptionCount.value;
              } else {
                const selectedOption = cachedSelectedOption.value;
                states.createdOptions.length = 0;
                if (selectedOption && selectedOption.created) {
                  states.createdOptions.push(selectedOption);
                }
              }
            }
          }
        }
        function removeNewOption(option) {
          if (!enableAllowCreateMode.value || !option || !option.created || option.created && props.reserveKeyword && states.inputValue === option.label) {
            return;
          }
          const idx = states.createdOptions.findIndex((it2) => it2.value === option.value);
          if (~idx) {
            states.createdOptions.splice(idx, 1);
            createOptionCount.value--;
          }
        }
        function clearAllNewOption() {
          if (enableAllowCreateMode.value) {
            states.createdOptions.length = 0;
            createOptionCount.value = 0;
          }
        }
        return {
          createNewOption,
          removeNewOption,
          selectNewOption,
          clearAllNewOption
        };
      }
      const flattenOptions = (options) => {
        const flattened = [];
        options.forEach((option) => {
          if (isArray$2(option.options)) {
            flattened.push({
              label: option.label,
              isTitle: true,
              type: "Group"
            });
            option.options.forEach((o) => {
              flattened.push(o);
            });
            flattened.push({
              type: "Group"
            });
          } else {
            flattened.push(option);
          }
        });
        return flattened;
      };
      function useInput(handleInput) {
        const isComposing = ref(false);
        const handleCompositionStart = () => {
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          const text = event.target.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          if (isComposing.value) {
            isComposing.value = false;
            if (isFunction$1(handleInput)) {
              handleInput(event);
            }
          }
        };
        return {
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        };
      }
      const DEFAULT_INPUT_PLACEHOLDER = "";
      const MINIMUM_INPUT_WIDTH = 11;
      const TAG_BASE_WIDTH = {
        larget: 51,
        default: 42,
        small: 33
      };
      const useSelect = (props, emit2) => {
        const { t } = useLocale();
        const nsSelectV2 = useNamespace("select-v2");
        const nsInput = useNamespace("input");
        const { form: elForm2, formItem: elFormItem2 } = useFormItem();
        const states = reactive({
          inputValue: DEFAULT_INPUT_PLACEHOLDER,
          displayInputValue: DEFAULT_INPUT_PLACEHOLDER,
          calculatedWidth: 0,
          cachedPlaceholder: "",
          cachedOptions: [],
          createdOptions: [],
          createdLabel: "",
          createdSelected: false,
          currentPlaceholder: "",
          hoveringIndex: -1,
          comboBoxHovering: false,
          isOnComposition: false,
          isSilentBlur: false,
          isComposing: false,
          inputLength: 20,
          selectWidth: 200,
          initialInputHeight: 0,
          previousQuery: null,
          previousValue: void 0,
          query: "",
          selectedLabel: "",
          softFocus: false,
          tagInMultiLine: false
        });
        const selectedIndex = ref(-1);
        const popperSize = ref(-1);
        const controlRef = ref(null);
        const inputRef = ref(null);
        const menuRef = ref(null);
        const popper = ref(null);
        const selectRef = ref(null);
        const selectionRef = ref(null);
        const calculatorRef = ref(null);
        const expanded = ref(false);
        const selectDisabled = computed(() => props.disabled || (elForm2 == null ? void 0 : elForm2.disabled));
        const popupHeight = computed(() => {
          const totalHeight = filteredOptions.value.length * 34;
          return totalHeight > props.height ? props.height : totalHeight;
        });
        const hasModelValue = computed(() => {
          return !isNil(props.modelValue);
        });
        const showClearBtn = computed(() => {
          const hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : hasModelValue.value;
          const criteria = props.clearable && !selectDisabled.value && states.comboBoxHovering && hasValue;
          return criteria;
        });
        const iconComponent = computed(() => props.remote && props.filterable ? "" : arrow_up_default);
        const iconReverse = computed(() => iconComponent.value && nsSelectV2.is("reverse", expanded.value));
        const validateState = computed(() => (elFormItem2 == null ? void 0 : elFormItem2.validateState) || "");
        const validateIcon = computed(() => ValidateComponentsMap[validateState.value]);
        const debounce$1 = computed(() => props.remote ? 300 : 0);
        const emptyText = computed(() => {
          const options = filteredOptions.value;
          if (props.loading) {
            return props.loadingText || t("el.select.loading");
          } else {
            if (props.remote && states.inputValue === "" && options.length === 0)
              return false;
            if (props.filterable && states.inputValue && options.length > 0) {
              return props.noMatchText || t("el.select.noMatch");
            }
            if (options.length === 0) {
              return props.noDataText || t("el.select.noData");
            }
          }
          return null;
        });
        const filteredOptions = computed(() => {
          const isValidOption = (o) => {
            const query = states.inputValue;
            const regexp2 = new RegExp(escapeStringRegexp(query), "i");
            const containsQueryString = query ? regexp2.test(o.label || "") : true;
            return containsQueryString;
          };
          if (props.loading) {
            return [];
          }
          return flattenOptions(props.options.concat(states.createdOptions).map((v) => {
            if (isArray$2(v.options)) {
              const filtered = v.options.filter(isValidOption);
              if (filtered.length > 0) {
                return {
                  ...v,
                  options: filtered
                };
              }
            } else {
              if (props.remote || isValidOption(v)) {
                return v;
              }
            }
            return null;
          }).filter((v) => v !== null));
        });
        const filteredOptionsValueMap = computed(() => {
          const valueMap = /* @__PURE__ */ new Map();
          filteredOptions.value.forEach((option, index) => {
            valueMap.set(getValueKey(option), { option, index });
          });
          return valueMap;
        });
        const optionsAllDisabled = computed(() => filteredOptions.value.every((option) => option.disabled));
        const selectSize = useFormSize();
        const collapseTagSize = computed(() => selectSize.value === "small" ? "small" : "default");
        const tagMaxWidth = computed(() => {
          const select = selectionRef.value;
          const size2 = collapseTagSize.value || "default";
          const paddingLeft = select ? Number.parseInt(getComputedStyle(select).paddingLeft) : 0;
          const paddingRight = select ? Number.parseInt(getComputedStyle(select).paddingRight) : 0;
          return states.selectWidth - paddingRight - paddingLeft - TAG_BASE_WIDTH[size2];
        });
        const calculatePopperSize = () => {
          var _a2;
          popperSize.value = ((_a2 = selectRef.value) == null ? void 0 : _a2.offsetWidth) || 200;
        };
        const inputWrapperStyle = computed(() => {
          return {
            width: `${states.calculatedWidth === 0 ? MINIMUM_INPUT_WIDTH : Math.ceil(states.calculatedWidth) + MINIMUM_INPUT_WIDTH}px`
          };
        });
        const shouldShowPlaceholder = computed(() => {
          if (isArray$2(props.modelValue)) {
            return props.modelValue.length === 0 && !states.displayInputValue;
          }
          return props.filterable ? states.displayInputValue.length === 0 : true;
        });
        const currentPlaceholder = computed(() => {
          const _placeholder = props.placeholder || t("el.select.placeholder");
          return props.multiple || isNil(props.modelValue) ? _placeholder : states.selectedLabel;
        });
        const popperRef = computed(() => {
          var _a2, _b;
          return (_b = (_a2 = popper.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
        });
        const indexRef = computed(() => {
          if (props.multiple) {
            const len = props.modelValue.length;
            if (props.modelValue.length > 0 && filteredOptionsValueMap.value.has(props.modelValue[len - 1])) {
              const { index } = filteredOptionsValueMap.value.get(props.modelValue[len - 1]);
              return index;
            }
          } else {
            if (props.modelValue && filteredOptionsValueMap.value.has(props.modelValue)) {
              const { index } = filteredOptionsValueMap.value.get(props.modelValue);
              return index;
            }
          }
          return -1;
        });
        const dropdownMenuVisible = computed({
          get() {
            return expanded.value && emptyText.value !== false;
          },
          set(val) {
            expanded.value = val;
          }
        });
        const showTagList = computed(() => states.cachedOptions.slice(0, props.maxCollapseTags));
        const collapseTagList = computed(() => states.cachedOptions.slice(props.maxCollapseTags));
        const {
          createNewOption,
          removeNewOption,
          selectNewOption,
          clearAllNewOption
        } = useAllowCreate(props, states);
        const {
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        } = useInput((e) => onInput(e));
        const focusAndUpdatePopup = () => {
          var _a2, _b, _c;
          (_b = (_a2 = inputRef.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          (_c = popper.value) == null ? void 0 : _c.updatePopper();
        };
        const toggleMenu = () => {
          if (props.automaticDropdown)
            return;
          if (!selectDisabled.value) {
            if (states.isComposing)
              states.softFocus = true;
            return nextTick(() => {
              var _a2, _b;
              expanded.value = !expanded.value;
              (_b = (_a2 = inputRef.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
            });
          }
        };
        const onInputChange = () => {
          if (props.filterable && states.inputValue !== states.selectedLabel) {
            states.query = states.selectedLabel;
          }
          handleQueryChange(states.inputValue);
          return nextTick(() => {
            createNewOption(states.inputValue);
          });
        };
        const debouncedOnInputChange = debounce(onInputChange, debounce$1.value);
        const handleQueryChange = (val) => {
          if (states.previousQuery === val) {
            return;
          }
          states.previousQuery = val;
          if (props.filterable && isFunction$1(props.filterMethod)) {
            props.filterMethod(val);
          } else if (props.filterable && props.remote && isFunction$1(props.remoteMethod)) {
            props.remoteMethod(val);
          }
        };
        const emitChange = (val) => {
          if (!isEqual$1(props.modelValue, val)) {
            emit2(CHANGE_EVENT, val);
          }
        };
        const update = (val) => {
          emit2(UPDATE_MODEL_EVENT, val);
          emitChange(val);
          states.previousValue = val == null ? void 0 : val.toString();
        };
        const getValueIndex = (arr = [], value) => {
          if (!isObject$1(value)) {
            return arr.indexOf(value);
          }
          const valueKey = props.valueKey;
          let index = -1;
          arr.some((item, i) => {
            if (get(item, valueKey) === get(value, valueKey)) {
              index = i;
              return true;
            }
            return false;
          });
          return index;
        };
        const getValueKey = (item) => {
          return isObject$1(item) ? get(item, props.valueKey) : item;
        };
        const getLabel = (item) => {
          return isObject$1(item) ? item.label : item;
        };
        const resetInputHeight = () => {
          return nextTick(() => {
            var _a2, _b;
            if (!inputRef.value)
              return;
            const selection = selectionRef.value;
            selectRef.value.height = selection.offsetHeight;
            if (expanded.value && emptyText.value !== false) {
              (_b = (_a2 = popper.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            }
          });
        };
        const handleResize = () => {
          var _a2, _b;
          resetInputWidth();
          calculatePopperSize();
          (_b = (_a2 = popper.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          if (props.multiple) {
            return resetInputHeight();
          }
        };
        const resetInputWidth = () => {
          const select = selectionRef.value;
          if (select) {
            states.selectWidth = select.getBoundingClientRect().width;
          }
        };
        const onSelect = (option, idx, byClick = true) => {
          var _a2, _b;
          if (props.multiple) {
            let selectedOptions = props.modelValue.slice();
            const index = getValueIndex(selectedOptions, getValueKey(option));
            if (index > -1) {
              selectedOptions = [
                ...selectedOptions.slice(0, index),
                ...selectedOptions.slice(index + 1)
              ];
              states.cachedOptions.splice(index, 1);
              removeNewOption(option);
            } else if (props.multipleLimit <= 0 || selectedOptions.length < props.multipleLimit) {
              selectedOptions = [...selectedOptions, getValueKey(option)];
              states.cachedOptions.push(option);
              selectNewOption(option);
              updateHoveringIndex(idx);
            }
            update(selectedOptions);
            if (option.created) {
              states.query = "";
              handleQueryChange("");
              states.inputLength = 20;
            }
            if (props.filterable && !props.reserveKeyword) {
              (_b = (_a2 = inputRef.value).focus) == null ? void 0 : _b.call(_a2);
              onUpdateInputValue("");
            }
            if (props.filterable) {
              states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
            }
            resetInputHeight();
            setSoftFocus();
          } else {
            selectedIndex.value = idx;
            states.selectedLabel = option.label;
            update(getValueKey(option));
            expanded.value = false;
            states.isComposing = false;
            states.isSilentBlur = byClick;
            selectNewOption(option);
            if (!option.created) {
              clearAllNewOption();
            }
            updateHoveringIndex(idx);
          }
        };
        const deleteTag = (event, tag) => {
          const { valueKey } = props;
          const index = props.modelValue.indexOf(get(tag, valueKey));
          if (index > -1 && !selectDisabled.value) {
            const value = [
              ...props.modelValue.slice(0, index),
              ...props.modelValue.slice(index + 1)
            ];
            states.cachedOptions.splice(index, 1);
            update(value);
            emit2("remove-tag", get(tag, valueKey));
            states.softFocus = true;
            removeNewOption(tag);
            return nextTick(focusAndUpdatePopup);
          }
          event.stopPropagation();
        };
        const handleFocus = (event) => {
          const focused = states.isComposing;
          states.isComposing = true;
          if (!states.softFocus) {
            if (!focused)
              emit2("focus", event);
          } else {
            states.softFocus = false;
          }
        };
        const handleBlur = (event) => {
          states.softFocus = false;
          return nextTick(() => {
            var _a2, _b;
            (_b = (_a2 = inputRef.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
            if (calculatorRef.value) {
              states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
            }
            if (states.isSilentBlur) {
              states.isSilentBlur = false;
            } else {
              if (states.isComposing) {
                emit2("blur", event);
              }
            }
            states.isComposing = false;
          });
        };
        const handleEsc = () => {
          if (states.displayInputValue.length > 0) {
            onUpdateInputValue("");
          } else {
            expanded.value = false;
          }
        };
        const handleDel = (e) => {
          if (states.displayInputValue.length === 0) {
            e.preventDefault();
            const selected = props.modelValue.slice();
            selected.pop();
            removeNewOption(states.cachedOptions.pop());
            update(selected);
          }
        };
        const handleClear = () => {
          let emptyValue;
          if (isArray$2(props.modelValue)) {
            emptyValue = [];
          } else {
            emptyValue = void 0;
          }
          states.softFocus = true;
          if (props.multiple) {
            states.cachedOptions = [];
          } else {
            states.selectedLabel = "";
          }
          expanded.value = false;
          update(emptyValue);
          emit2("clear");
          clearAllNewOption();
          return nextTick(focusAndUpdatePopup);
        };
        const onUpdateInputValue = (val) => {
          states.displayInputValue = val;
          states.inputValue = val;
        };
        const onKeyboardNavigate = (direction2, hoveringIndex = void 0) => {
          const options = filteredOptions.value;
          if (!["forward", "backward"].includes(direction2) || selectDisabled.value || options.length <= 0 || optionsAllDisabled.value) {
            return;
          }
          if (!expanded.value) {
            return toggleMenu();
          }
          if (hoveringIndex === void 0) {
            hoveringIndex = states.hoveringIndex;
          }
          let newIndex = -1;
          if (direction2 === "forward") {
            newIndex = hoveringIndex + 1;
            if (newIndex >= options.length) {
              newIndex = 0;
            }
          } else if (direction2 === "backward") {
            newIndex = hoveringIndex - 1;
            if (newIndex < 0 || newIndex >= options.length) {
              newIndex = options.length - 1;
            }
          }
          const option = options[newIndex];
          if (option.disabled || option.type === "Group") {
            return onKeyboardNavigate(direction2, newIndex);
          } else {
            updateHoveringIndex(newIndex);
            scrollToItem(newIndex);
          }
        };
        const onKeyboardSelect = () => {
          if (!expanded.value) {
            return toggleMenu();
          } else if (~states.hoveringIndex && filteredOptions.value[states.hoveringIndex]) {
            onSelect(filteredOptions.value[states.hoveringIndex], states.hoveringIndex, false);
          }
        };
        const updateHoveringIndex = (idx) => {
          states.hoveringIndex = idx;
        };
        const resetHoveringIndex = () => {
          states.hoveringIndex = -1;
        };
        const setSoftFocus = () => {
          var _a2;
          const _input = inputRef.value;
          if (_input) {
            (_a2 = _input.focus) == null ? void 0 : _a2.call(_input);
          }
        };
        const onInput = (event) => {
          const value = event.target.value;
          onUpdateInputValue(value);
          if (states.displayInputValue.length > 0 && !expanded.value) {
            expanded.value = true;
          }
          states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
          if (props.multiple) {
            resetInputHeight();
          }
          if (props.remote) {
            debouncedOnInputChange();
          } else {
            return onInputChange();
          }
        };
        const handleClickOutside = () => {
          expanded.value = false;
          return handleBlur();
        };
        const handleMenuEnter = () => {
          states.inputValue = states.displayInputValue;
          return nextTick(() => {
            if (~indexRef.value) {
              updateHoveringIndex(indexRef.value);
              scrollToItem(states.hoveringIndex);
            }
          });
        };
        const scrollToItem = (index) => {
          menuRef.value.scrollToItem(index);
        };
        const initStates = () => {
          resetHoveringIndex();
          if (props.multiple) {
            if (props.modelValue.length > 0) {
              let initHovering = false;
              states.cachedOptions.length = 0;
              states.previousValue = props.modelValue.toString();
              for (const value of props.modelValue) {
                if (filteredOptionsValueMap.value.has(value)) {
                  const { index, option } = filteredOptionsValueMap.value.get(value);
                  states.cachedOptions.push(option);
                  if (!initHovering) {
                    updateHoveringIndex(index);
                  }
                  initHovering = true;
                }
              }
            } else {
              states.cachedOptions = [];
              states.previousValue = void 0;
            }
          } else {
            if (hasModelValue.value) {
              states.previousValue = props.modelValue;
              const options = filteredOptions.value;
              const selectedItemIndex = options.findIndex((option) => getValueKey(option) === getValueKey(props.modelValue));
              if (~selectedItemIndex) {
                states.selectedLabel = options[selectedItemIndex].label;
                updateHoveringIndex(selectedItemIndex);
              } else {
                states.selectedLabel = `${props.modelValue}`;
              }
            } else {
              states.selectedLabel = "";
              states.previousValue = void 0;
            }
          }
          clearAllNewOption();
          calculatePopperSize();
        };
        watch(expanded, (val) => {
          var _a2, _b;
          emit2("visible-change", val);
          if (val) {
            (_b = (_a2 = popper.value).update) == null ? void 0 : _b.call(_a2);
          } else {
            states.displayInputValue = "";
            states.previousQuery = null;
            createNewOption("");
          }
        });
        watch(() => props.modelValue, (val, oldVal) => {
          var _a2;
          if (!val || val.toString() !== states.previousValue) {
            initStates();
          }
          if (!isEqual$1(val, oldVal) && props.validateEvent) {
            (_a2 = elFormItem2 == null ? void 0 : elFormItem2.validate) == null ? void 0 : _a2.call(elFormItem2, "change").catch((err) => debugWarn());
          }
        }, {
          deep: true
        });
        watch(() => props.options, () => {
          const input = inputRef.value;
          if (!input || input && document.activeElement !== input) {
            initStates();
          }
        }, {
          deep: true
        });
        watch(filteredOptions, () => {
          return nextTick(menuRef.value.resetScrollTop);
        });
        watch(() => dropdownMenuVisible.value, (val) => {
          if (!val) {
            resetHoveringIndex();
          }
        });
        onMounted(() => {
          initStates();
        });
        useResizeObserver(selectRef, handleResize);
        return {
          collapseTagSize,
          currentPlaceholder,
          expanded,
          emptyText,
          popupHeight,
          debounce: debounce$1,
          filteredOptions,
          iconComponent,
          iconReverse,
          inputWrapperStyle,
          popperSize,
          dropdownMenuVisible,
          hasModelValue,
          shouldShowPlaceholder,
          selectDisabled,
          selectSize,
          showClearBtn,
          states,
          tagMaxWidth,
          nsSelectV2,
          nsInput,
          calculatorRef,
          controlRef,
          inputRef,
          menuRef,
          popper,
          selectRef,
          selectionRef,
          popperRef,
          validateState,
          validateIcon,
          showTagList,
          collapseTagList,
          debouncedOnInputChange,
          deleteTag,
          getLabel,
          getValueKey,
          handleBlur,
          handleClear,
          handleClickOutside,
          handleDel,
          handleEsc,
          handleFocus,
          handleMenuEnter,
          handleResize,
          toggleMenu,
          scrollTo: scrollToItem,
          onInput,
          onKeyboardNavigate,
          onKeyboardSelect,
          onSelect,
          onHover: updateHoveringIndex,
          onUpdateInputValue,
          handleCompositionStart,
          handleCompositionEnd,
          handleCompositionUpdate
        };
      };
      const _sfc_main$j = defineComponent({
        name: "ElSelectV2",
        components: {
          ElSelectMenu,
          ElTag,
          ElTooltip,
          ElIcon
        },
        directives: { ClickOutside, ModelText: vModelText },
        props: SelectProps,
        emits: [
          UPDATE_MODEL_EVENT,
          CHANGE_EVENT,
          "remove-tag",
          "clear",
          "visible-change",
          "focus",
          "blur"
        ],
        setup(props, { emit: emit2 }) {
          const modelValue = computed(() => {
            const { modelValue: rawModelValue, multiple } = props;
            const fallback = multiple ? [] : void 0;
            if (isArray$2(rawModelValue)) {
              return multiple ? rawModelValue : fallback;
            }
            return multiple ? fallback : rawModelValue;
          });
          const API = useSelect(reactive({
            ...toRefs(props),
            modelValue
          }), emit2);
          provide(selectV2InjectionKey, {
            props: reactive({
              ...toRefs(props),
              height: API.popupHeight,
              modelValue
            }),
            popper: API.popper,
            onSelect: API.onSelect,
            onHover: API.onHover,
            onKeyboardNavigate: API.onKeyboardNavigate,
            onKeyboardSelect: API.onKeyboardSelect
          });
          return {
            ...API,
            modelValue
          };
        }
      });
      const _hoisted_1$w = { key: 0 };
      const _hoisted_2$r = ["id", "autocomplete", "aria-expanded", "aria-labelledby", "disabled", "readonly", "name", "unselectable"];
      const _hoisted_3$m = ["textContent"];
      const _hoisted_4$8 = ["id", "aria-labelledby", "aria-expanded", "autocomplete", "disabled", "name", "readonly", "unselectable"];
      const _hoisted_5$4 = ["textContent"];
      function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_tag = resolveComponent("el-tag");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_select_menu = resolveComponent("el-select-menu");
        const _directive_model_text = resolveDirective("model-text");
        const _directive_click_outside = resolveDirective("click-outside");
        return withDirectives((openBlock(), createElementBlock("div", {
          ref: "selectRef",
          class: normalizeClass([_ctx.nsSelectV2.b(), _ctx.nsSelectV2.m(_ctx.selectSize)]),
          onClick: _cache[24] || (_cache[24] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"])),
          onMouseenter: _cache[25] || (_cache[25] = ($event) => _ctx.states.comboBoxHovering = true),
          onMouseleave: _cache[26] || (_cache[26] = ($event) => _ctx.states.comboBoxHovering = false)
        }, [
          createVNode(_component_el_tooltip, {
            ref: "popper",
            visible: _ctx.dropdownMenuVisible,
            teleported: _ctx.teleported,
            "popper-class": [_ctx.nsSelectV2.e("popper"), _ctx.popperClass],
            "gpu-acceleration": false,
            "stop-popper-mouse-event": false,
            "popper-options": _ctx.popperOptions,
            "fallback-placements": ["bottom-start", "top-start", "right", "left"],
            effect: _ctx.effect,
            placement: _ctx.placement,
            pure: "",
            transition: `${_ctx.nsSelectV2.namespace.value}-zoom-in-top`,
            trigger: "click",
            persistent: _ctx.persistent,
            onBeforeShow: _ctx.handleMenuEnter,
            onHide: _cache[23] || (_cache[23] = ($event) => _ctx.states.inputValue = _ctx.states.displayInputValue)
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                ref: "selectionRef",
                class: normalizeClass([
                  _ctx.nsSelectV2.e("wrapper"),
                  _ctx.nsSelectV2.is("focused", _ctx.states.isComposing || _ctx.expanded),
                  _ctx.nsSelectV2.is("hovering", _ctx.states.comboBoxHovering),
                  _ctx.nsSelectV2.is("filterable", _ctx.filterable),
                  _ctx.nsSelectV2.is("disabled", _ctx.selectDisabled)
                ])
              }, [
                _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", _hoisted_1$w, [
                  renderSlot(_ctx.$slots, "prefix")
                ])) : createCommentVNode("v-if", true),
                _ctx.multiple ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(_ctx.nsSelectV2.e("selection"))
                }, [
                  _ctx.collapseTags && _ctx.modelValue.length > 0 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showTagList, (item) => {
                      return openBlock(), createElementBlock("div", {
                        key: _ctx.getValueKey(item),
                        class: normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                      }, [
                        createVNode(_component_el_tag, {
                          closable: !_ctx.selectDisabled && !(item == null ? void 0 : item.disable),
                          size: _ctx.collapseTagSize,
                          type: "info",
                          "disable-transitions": "",
                          onClose: ($event) => _ctx.deleteTag($event, item)
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("span", {
                              class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                              style: normalizeStyle({
                                maxWidth: `${_ctx.tagMaxWidth}px`
                              })
                            }, toDisplayString(item == null ? void 0 : item.label), 7)
                          ]),
                          _: 2
                        }, 1032, ["closable", "size", "onClose"])
                      ], 2);
                    }), 128)),
                    createBaseVNode("div", {
                      class: normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                    }, [
                      _ctx.modelValue.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tag, {
                        key: 0,
                        closable: false,
                        size: _ctx.collapseTagSize,
                        type: "info",
                        "disable-transitions": ""
                      }, {
                        default: withCtx(() => [
                          _ctx.collapseTagsTooltip ? (openBlock(), createBlock(_component_el_tooltip, {
                            key: 0,
                            disabled: _ctx.dropdownMenuVisible,
                            "fallback-placements": ["bottom", "top", "right", "left"],
                            effect: _ctx.effect,
                            placement: "bottom",
                            teleported: false
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", {
                                class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                                style: normalizeStyle({
                                  maxWidth: `${_ctx.tagMaxWidth}px`
                                })
                              }, "+ " + toDisplayString(_ctx.modelValue.length - _ctx.maxCollapseTags), 7)
                            ]),
                            content: withCtx(() => [
                              createBaseVNode("div", {
                                class: normalizeClass(_ctx.nsSelectV2.e("selection"))
                              }, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapseTagList, (selected) => {
                                  return openBlock(), createElementBlock("div", {
                                    key: _ctx.getValueKey(selected),
                                    class: normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                                  }, [
                                    createVNode(_component_el_tag, {
                                      closable: !_ctx.selectDisabled && !selected.disabled,
                                      size: _ctx.collapseTagSize,
                                      class: "in-tooltip",
                                      type: "info",
                                      "disable-transitions": "",
                                      onClose: ($event) => _ctx.deleteTag($event, selected)
                                    }, {
                                      default: withCtx(() => [
                                        createBaseVNode("span", {
                                          class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                                          style: normalizeStyle({
                                            maxWidth: `${_ctx.tagMaxWidth}px`
                                          })
                                        }, toDisplayString(_ctx.getLabel(selected)), 7)
                                      ]),
                                      _: 2
                                    }, 1032, ["closable", "size", "onClose"])
                                  ], 2);
                                }), 128))
                              ], 2)
                            ]),
                            _: 1
                          }, 8, ["disabled", "effect"])) : (openBlock(), createElementBlock("span", {
                            key: 1,
                            class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                            style: normalizeStyle({
                              maxWidth: `${_ctx.tagMaxWidth}px`
                            })
                          }, "+ " + toDisplayString(_ctx.modelValue.length - _ctx.maxCollapseTags), 7))
                        ]),
                        _: 1
                      }, 8, ["size"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 64)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.states.cachedOptions, (selected) => {
                    return openBlock(), createElementBlock("div", {
                      key: _ctx.getValueKey(selected),
                      class: normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                    }, [
                      createVNode(_component_el_tag, {
                        closable: !_ctx.selectDisabled && !selected.disabled,
                        size: _ctx.collapseTagSize,
                        type: "info",
                        "disable-transitions": "",
                        onClose: ($event) => _ctx.deleteTag($event, selected)
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("span", {
                            class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                            style: normalizeStyle({
                              maxWidth: `${_ctx.tagMaxWidth}px`
                            })
                          }, toDisplayString(_ctx.getLabel(selected)), 7)
                        ]),
                        _: 2
                      }, 1032, ["closable", "size", "onClose"])
                    ], 2);
                  }), 128)),
                  createBaseVNode("div", {
                    class: normalizeClass([
                      _ctx.nsSelectV2.e("selected-item"),
                      _ctx.nsSelectV2.e("input-wrapper")
                    ]),
                    style: normalizeStyle(_ctx.inputWrapperStyle)
                  }, [
                    withDirectives(createBaseVNode("input", {
                      id: _ctx.id,
                      ref: "inputRef",
                      autocomplete: _ctx.autocomplete,
                      "aria-autocomplete": "list",
                      "aria-haspopup": "listbox",
                      autocapitalize: "off",
                      "aria-expanded": _ctx.expanded,
                      "aria-labelledby": _ctx.label,
                      class: normalizeClass([
                        _ctx.nsSelectV2.is(_ctx.selectSize),
                        _ctx.nsSelectV2.e("combobox-input")
                      ]),
                      disabled: _ctx.disabled,
                      role: "combobox",
                      readonly: !_ctx.filterable,
                      spellcheck: "false",
                      type: "text",
                      name: _ctx.name,
                      unselectable: _ctx.expanded ? "on" : void 0,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = (...args) => _ctx.onUpdateInputValue && _ctx.onUpdateInputValue(...args)),
                      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                      onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                      onInput: _cache[3] || (_cache[3] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                      onCompositionstart: _cache[4] || (_cache[4] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                      onCompositionupdate: _cache[5] || (_cache[5] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                      onCompositionend: _cache[6] || (_cache[6] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                      onKeydown: [
                        _cache[7] || (_cache[7] = withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                        _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                        _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => _ctx.onKeyboardSelect && _ctx.onKeyboardSelect(...args), ["stop", "prevent"]), ["enter"])),
                        _cache[10] || (_cache[10] = withKeys(withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"])),
                        _cache[11] || (_cache[11] = withKeys(withModifiers((...args) => _ctx.handleDel && _ctx.handleDel(...args), ["stop"]), ["delete"]))
                      ]
                    }, null, 42, _hoisted_2$r), [
                      [_directive_model_text, _ctx.states.displayInputValue]
                    ]),
                    _ctx.filterable ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      ref: "calculatorRef",
                      "aria-hidden": "true",
                      class: normalizeClass(_ctx.nsSelectV2.e("input-calculator")),
                      textContent: toDisplayString(_ctx.states.displayInputValue)
                    }, null, 10, _hoisted_3$m)) : createCommentVNode("v-if", true)
                  ], 6)
                ], 2)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                  createBaseVNode("div", {
                    class: normalizeClass([
                      _ctx.nsSelectV2.e("selected-item"),
                      _ctx.nsSelectV2.e("input-wrapper")
                    ])
                  }, [
                    withDirectives(createBaseVNode("input", {
                      id: _ctx.id,
                      ref: "inputRef",
                      "aria-autocomplete": "list",
                      "aria-haspopup": "listbox",
                      "aria-labelledby": _ctx.label,
                      "aria-expanded": _ctx.expanded,
                      autocapitalize: "off",
                      autocomplete: _ctx.autocomplete,
                      class: normalizeClass(_ctx.nsSelectV2.e("combobox-input")),
                      disabled: _ctx.disabled,
                      name: _ctx.name,
                      role: "combobox",
                      readonly: !_ctx.filterable,
                      spellcheck: "false",
                      type: "text",
                      unselectable: _ctx.expanded ? "on" : void 0,
                      onCompositionstart: _cache[12] || (_cache[12] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                      onCompositionupdate: _cache[13] || (_cache[13] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                      onCompositionend: _cache[14] || (_cache[14] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                      onFocus: _cache[15] || (_cache[15] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                      onBlur: _cache[16] || (_cache[16] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                      onInput: _cache[17] || (_cache[17] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                      onKeydown: [
                        _cache[18] || (_cache[18] = withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                        _cache[19] || (_cache[19] = withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                        _cache[20] || (_cache[20] = withKeys(withModifiers((...args) => _ctx.onKeyboardSelect && _ctx.onKeyboardSelect(...args), ["stop", "prevent"]), ["enter"])),
                        _cache[21] || (_cache[21] = withKeys(withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"]))
                      ],
                      "onUpdate:modelValue": _cache[22] || (_cache[22] = (...args) => _ctx.onUpdateInputValue && _ctx.onUpdateInputValue(...args))
                    }, null, 42, _hoisted_4$8), [
                      [_directive_model_text, _ctx.states.displayInputValue]
                    ])
                  ], 2),
                  _ctx.filterable ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    ref: "calculatorRef",
                    "aria-hidden": "true",
                    class: normalizeClass([
                      _ctx.nsSelectV2.e("selected-item"),
                      _ctx.nsSelectV2.e("input-calculator")
                    ]),
                    textContent: toDisplayString(_ctx.states.displayInputValue)
                  }, null, 10, _hoisted_5$4)) : createCommentVNode("v-if", true)
                ], 64)),
                _ctx.shouldShowPlaceholder ? (openBlock(), createElementBlock("span", {
                  key: 3,
                  class: normalizeClass([
                    _ctx.nsSelectV2.e("placeholder"),
                    _ctx.nsSelectV2.is("transparent", _ctx.multiple ? _ctx.modelValue.length === 0 : !_ctx.hasModelValue)
                  ])
                }, toDisplayString(_ctx.currentPlaceholder), 3)) : createCommentVNode("v-if", true),
                createBaseVNode("span", {
                  class: normalizeClass(_ctx.nsSelectV2.e("suffix"))
                }, [
                  _ctx.iconComponent ? withDirectives((openBlock(), createBlock(_component_el_icon, {
                    key: 0,
                    class: normalizeClass([_ctx.nsSelectV2.e("caret"), _ctx.nsInput.e("icon"), _ctx.iconReverse])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                    ]),
                    _: 1
                  }, 8, ["class"])), [
                    [vShow, !_ctx.showClearBtn]
                  ]) : createCommentVNode("v-if", true),
                  _ctx.showClearBtn && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 1,
                    class: normalizeClass([_ctx.nsSelectV2.e("caret"), _ctx.nsInput.e("icon")]),
                    onClick: withModifiers(_ctx.handleClear, ["prevent", "stop"])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                  _ctx.validateState && _ctx.validateIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 2,
                    class: normalizeClass([_ctx.nsInput.e("icon"), _ctx.nsInput.e("validateIcon")])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.validateIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 2)
              ], 2)
            ]),
            content: withCtx(() => [
              createVNode(_component_el_select_menu, {
                ref: "menuRef",
                data: _ctx.filteredOptions,
                width: _ctx.popperSize,
                "hovering-index": _ctx.states.hoveringIndex,
                "scrollbar-always-on": _ctx.scrollbarAlwaysOn
              }, {
                default: withCtx((scope) => [
                  renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(scope)))
                ]),
                empty: withCtx(() => [
                  renderSlot(_ctx.$slots, "empty", {}, () => [
                    createBaseVNode("p", {
                      class: normalizeClass(_ctx.nsSelectV2.e("empty"))
                    }, toDisplayString(_ctx.emptyText ? _ctx.emptyText : ""), 3)
                  ])
                ]),
                _: 3
              }, 8, ["data", "width", "hovering-index", "scrollbar-always-on"])
            ]),
            _: 3
          }, 8, ["visible", "teleported", "popper-class", "popper-options", "effect", "placement", "transition", "persistent", "onBeforeShow"])
        ], 34)), [
          [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
        ]);
      }
      var Select = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["render", _sfc_render$1], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/select.vue"]]);
      Select.install = (app2) => {
        app2.component(Select.name, Select);
      };
      const _Select = Select;
      const ElSelectV2 = _Select;
      const sliderContextKey = Symbol("sliderContextKey");
      const sliderProps = buildProps({
        modelValue: {
          type: definePropType([Number, Array]),
          default: 0
        },
        id: {
          type: String,
          default: void 0
        },
        min: {
          type: Number,
          default: 0
        },
        max: {
          type: Number,
          default: 100
        },
        step: {
          type: Number,
          default: 1
        },
        showInput: Boolean,
        showInputControls: {
          type: Boolean,
          default: true
        },
        size: useSizeProp,
        inputSize: useSizeProp,
        showStops: Boolean,
        showTooltip: {
          type: Boolean,
          default: true
        },
        formatTooltip: {
          type: definePropType(Function),
          default: void 0
        },
        disabled: Boolean,
        range: Boolean,
        vertical: Boolean,
        height: String,
        debounce: {
          type: Number,
          default: 300
        },
        label: {
          type: String,
          default: void 0
        },
        rangeStartLabel: {
          type: String,
          default: void 0
        },
        rangeEndLabel: {
          type: String,
          default: void 0
        },
        formatValueText: {
          type: definePropType(Function),
          default: void 0
        },
        tooltipClass: {
          type: String,
          default: void 0
        },
        placement: {
          type: String,
          values: Ee,
          default: "top"
        },
        marks: {
          type: definePropType(Object)
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const isValidValue = (value) => isNumber(value) || isArray$2(value) && value.every(isNumber);
      const sliderEmits = {
        [UPDATE_MODEL_EVENT]: isValidValue,
        [INPUT_EVENT]: isValidValue,
        [CHANGE_EVENT]: isValidValue
      };
      const useLifecycle = (props, initData, resetSize) => {
        const sliderWrapper = ref();
        onMounted(async () => {
          if (props.range) {
            if (Array.isArray(props.modelValue)) {
              initData.firstValue = Math.max(props.min, props.modelValue[0]);
              initData.secondValue = Math.min(props.max, props.modelValue[1]);
            } else {
              initData.firstValue = props.min;
              initData.secondValue = props.max;
            }
            initData.oldValue = [initData.firstValue, initData.secondValue];
          } else {
            if (typeof props.modelValue !== "number" || Number.isNaN(props.modelValue)) {
              initData.firstValue = props.min;
            } else {
              initData.firstValue = Math.min(props.max, Math.max(props.min, props.modelValue));
            }
            initData.oldValue = initData.firstValue;
          }
          useEventListener$1(window, "resize", resetSize);
          await nextTick();
          resetSize();
        });
        return {
          sliderWrapper
        };
      };
      const useMarks = (props) => {
        return computed(() => {
          if (!props.marks) {
            return [];
          }
          const marksKeys = Object.keys(props.marks);
          return marksKeys.map(Number.parseFloat).sort((a, b) => a - b).filter((point) => point <= props.max && point >= props.min).map((point) => ({
            point,
            position: (point - props.min) * 100 / (props.max - props.min),
            mark: props.marks[point]
          }));
        });
      };
      const useSlide = (props, initData, emit2) => {
        const { form: elForm2, formItem: elFormItem2 } = useFormItem();
        const slider = shallowRef();
        const firstButton = ref();
        const secondButton = ref();
        const buttonRefs = {
          firstButton,
          secondButton
        };
        const sliderDisabled = computed(() => {
          return props.disabled || (elForm2 == null ? void 0 : elForm2.disabled) || false;
        });
        const minValue = computed(() => {
          return Math.min(initData.firstValue, initData.secondValue);
        });
        const maxValue = computed(() => {
          return Math.max(initData.firstValue, initData.secondValue);
        });
        const barSize = computed(() => {
          return props.range ? `${100 * (maxValue.value - minValue.value) / (props.max - props.min)}%` : `${100 * (initData.firstValue - props.min) / (props.max - props.min)}%`;
        });
        const barStart = computed(() => {
          return props.range ? `${100 * (minValue.value - props.min) / (props.max - props.min)}%` : "0%";
        });
        const runwayStyle = computed(() => {
          return props.vertical ? { height: props.height } : {};
        });
        const barStyle = computed(() => {
          return props.vertical ? {
            height: barSize.value,
            bottom: barStart.value
          } : {
            width: barSize.value,
            left: barStart.value
          };
        });
        const resetSize = () => {
          if (slider.value) {
            initData.sliderSize = slider.value[`client${props.vertical ? "Height" : "Width"}`];
          }
        };
        const getButtonRefByPercent = (percent) => {
          const targetValue = props.min + percent * (props.max - props.min) / 100;
          if (!props.range) {
            return firstButton;
          }
          let buttonRefName;
          if (Math.abs(minValue.value - targetValue) < Math.abs(maxValue.value - targetValue)) {
            buttonRefName = initData.firstValue < initData.secondValue ? "firstButton" : "secondButton";
          } else {
            buttonRefName = initData.firstValue > initData.secondValue ? "firstButton" : "secondButton";
          }
          return buttonRefs[buttonRefName];
        };
        const setPosition = (percent) => {
          const buttonRef = getButtonRefByPercent(percent);
          buttonRef.value.setPosition(percent);
          return buttonRef;
        };
        const setFirstValue = (firstValue) => {
          initData.firstValue = firstValue;
          _emit(props.range ? [minValue.value, maxValue.value] : firstValue);
        };
        const setSecondValue = (secondValue) => {
          initData.secondValue = secondValue;
          if (props.range) {
            _emit([minValue.value, maxValue.value]);
          }
        };
        const _emit = (val) => {
          emit2(UPDATE_MODEL_EVENT, val);
          emit2(INPUT_EVENT, val);
        };
        const emitChange = async () => {
          await nextTick();
          emit2(CHANGE_EVENT, props.range ? [minValue.value, maxValue.value] : props.modelValue);
        };
        const handleSliderPointerEvent = (event) => {
          var _a2, _b, _c, _d, _e, _f;
          if (sliderDisabled.value || initData.dragging)
            return;
          resetSize();
          let newPercent = 0;
          if (props.vertical) {
            const clientY = (_c = (_b = (_a2 = event.touches) == null ? void 0 : _a2.item(0)) == null ? void 0 : _b.clientY) != null ? _c : event.clientY;
            const sliderOffsetBottom = slider.value.getBoundingClientRect().bottom;
            newPercent = (sliderOffsetBottom - clientY) / initData.sliderSize * 100;
          } else {
            const clientX = (_f = (_e = (_d = event.touches) == null ? void 0 : _d.item(0)) == null ? void 0 : _e.clientX) != null ? _f : event.clientX;
            const sliderOffsetLeft = slider.value.getBoundingClientRect().left;
            newPercent = (clientX - sliderOffsetLeft) / initData.sliderSize * 100;
          }
          if (newPercent < 0 || newPercent > 100)
            return;
          return setPosition(newPercent);
        };
        const onSliderWrapperPrevent = (event) => {
          var _a2, _b;
          if (((_a2 = buttonRefs["firstButton"].value) == null ? void 0 : _a2.dragging) || ((_b = buttonRefs["secondButton"].value) == null ? void 0 : _b.dragging)) {
            event.preventDefault();
          }
        };
        const onSliderDown = async (event) => {
          const buttonRef = handleSliderPointerEvent(event);
          if (buttonRef) {
            await nextTick();
            buttonRef.value.onButtonDown(event);
          }
        };
        const onSliderClick = (event) => {
          const buttonRef = handleSliderPointerEvent(event);
          if (buttonRef) {
            emitChange();
          }
        };
        return {
          elFormItem: elFormItem2,
          slider,
          firstButton,
          secondButton,
          sliderDisabled,
          minValue,
          maxValue,
          runwayStyle,
          barStyle,
          resetSize,
          setPosition,
          emitChange,
          onSliderWrapperPrevent,
          onSliderClick,
          onSliderDown,
          setFirstValue,
          setSecondValue
        };
      };
      const { left, down, right, up, home, end, pageUp, pageDown } = EVENT_CODE;
      const useTooltip = (props, formatTooltip, showTooltip) => {
        const tooltip = ref();
        const tooltipVisible = ref(false);
        const enableFormat = computed(() => {
          return formatTooltip.value instanceof Function;
        });
        const formatValue = computed(() => {
          return enableFormat.value && formatTooltip.value(props.modelValue) || props.modelValue;
        });
        const displayTooltip = debounce(() => {
          showTooltip.value && (tooltipVisible.value = true);
        }, 50);
        const hideTooltip = debounce(() => {
          showTooltip.value && (tooltipVisible.value = false);
        }, 50);
        return {
          tooltip,
          tooltipVisible,
          formatValue,
          displayTooltip,
          hideTooltip
        };
      };
      const useSliderButton = (props, initData, emit2) => {
        const {
          disabled,
          min,
          max,
          step,
          showTooltip,
          precision,
          sliderSize,
          formatTooltip,
          emitChange,
          resetSize,
          updateDragging
        } = inject(sliderContextKey);
        const { tooltip, tooltipVisible, formatValue, displayTooltip, hideTooltip } = useTooltip(props, formatTooltip, showTooltip);
        const button = ref();
        const currentPosition = computed(() => {
          return `${(props.modelValue - min.value) / (max.value - min.value) * 100}%`;
        });
        const wrapperStyle = computed(() => {
          return props.vertical ? { bottom: currentPosition.value } : { left: currentPosition.value };
        });
        const handleMouseEnter = () => {
          initData.hovering = true;
          displayTooltip();
        };
        const handleMouseLeave = () => {
          initData.hovering = false;
          if (!initData.dragging) {
            hideTooltip();
          }
        };
        const onButtonDown = (event) => {
          if (disabled.value)
            return;
          event.preventDefault();
          onDragStart(event);
          window.addEventListener("mousemove", onDragging);
          window.addEventListener("touchmove", onDragging);
          window.addEventListener("mouseup", onDragEnd);
          window.addEventListener("touchend", onDragEnd);
          window.addEventListener("contextmenu", onDragEnd);
          button.value.focus();
        };
        const incrementPosition = (amount) => {
          if (disabled.value)
            return;
          initData.newPosition = Number.parseFloat(currentPosition.value) + amount / (max.value - min.value) * 100;
          setPosition(initData.newPosition);
          emitChange();
        };
        const onLeftKeyDown = () => {
          incrementPosition(-step.value);
        };
        const onRightKeyDown = () => {
          incrementPosition(step.value);
        };
        const onPageDownKeyDown = () => {
          incrementPosition(-step.value * 4);
        };
        const onPageUpKeyDown = () => {
          incrementPosition(step.value * 4);
        };
        const onHomeKeyDown = () => {
          if (disabled.value)
            return;
          setPosition(0);
          emitChange();
        };
        const onEndKeyDown = () => {
          if (disabled.value)
            return;
          setPosition(100);
          emitChange();
        };
        const onKeyDown = (event) => {
          let isPreventDefault = true;
          if ([left, down].includes(event.key)) {
            onLeftKeyDown();
          } else if ([right, up].includes(event.key)) {
            onRightKeyDown();
          } else if (event.key === home) {
            onHomeKeyDown();
          } else if (event.key === end) {
            onEndKeyDown();
          } else if (event.key === pageDown) {
            onPageDownKeyDown();
          } else if (event.key === pageUp) {
            onPageUpKeyDown();
          } else {
            isPreventDefault = false;
          }
          isPreventDefault && event.preventDefault();
        };
        const getClientXY = (event) => {
          let clientX;
          let clientY;
          if (event.type.startsWith("touch")) {
            clientY = event.touches[0].clientY;
            clientX = event.touches[0].clientX;
          } else {
            clientY = event.clientY;
            clientX = event.clientX;
          }
          return {
            clientX,
            clientY
          };
        };
        const onDragStart = (event) => {
          initData.dragging = true;
          initData.isClick = true;
          const { clientX, clientY } = getClientXY(event);
          if (props.vertical) {
            initData.startY = clientY;
          } else {
            initData.startX = clientX;
          }
          initData.startPosition = Number.parseFloat(currentPosition.value);
          initData.newPosition = initData.startPosition;
        };
        const onDragging = (event) => {
          if (initData.dragging) {
            initData.isClick = false;
            displayTooltip();
            resetSize();
            let diff;
            const { clientX, clientY } = getClientXY(event);
            if (props.vertical) {
              initData.currentY = clientY;
              diff = (initData.startY - initData.currentY) / sliderSize.value * 100;
            } else {
              initData.currentX = clientX;
              diff = (initData.currentX - initData.startX) / sliderSize.value * 100;
            }
            initData.newPosition = initData.startPosition + diff;
            setPosition(initData.newPosition);
          }
        };
        const onDragEnd = () => {
          if (initData.dragging) {
            setTimeout(() => {
              initData.dragging = false;
              if (!initData.hovering) {
                hideTooltip();
              }
              if (!initData.isClick) {
                setPosition(initData.newPosition);
              }
              emitChange();
            }, 0);
            window.removeEventListener("mousemove", onDragging);
            window.removeEventListener("touchmove", onDragging);
            window.removeEventListener("mouseup", onDragEnd);
            window.removeEventListener("touchend", onDragEnd);
            window.removeEventListener("contextmenu", onDragEnd);
          }
        };
        const setPosition = async (newPosition) => {
          if (newPosition === null || Number.isNaN(+newPosition))
            return;
          if (newPosition < 0) {
            newPosition = 0;
          } else if (newPosition > 100) {
            newPosition = 100;
          }
          const lengthPerStep = 100 / ((max.value - min.value) / step.value);
          const steps = Math.round(newPosition / lengthPerStep);
          let value = steps * lengthPerStep * (max.value - min.value) * 0.01 + min.value;
          value = Number.parseFloat(value.toFixed(precision.value));
          if (value !== props.modelValue) {
            emit2(UPDATE_MODEL_EVENT, value);
          }
          if (!initData.dragging && props.modelValue !== initData.oldValue) {
            initData.oldValue = props.modelValue;
          }
          await nextTick();
          initData.dragging && displayTooltip();
          tooltip.value.updatePopper();
        };
        watch(() => initData.dragging, (val) => {
          updateDragging(val);
        });
        return {
          disabled,
          button,
          tooltip,
          tooltipVisible,
          showTooltip,
          wrapperStyle,
          formatValue,
          handleMouseEnter,
          handleMouseLeave,
          onButtonDown,
          onKeyDown,
          setPosition
        };
      };
      const useStops = (props, initData, minValue, maxValue) => {
        const stops = computed(() => {
          if (!props.showStops || props.min > props.max)
            return [];
          if (props.step === 0) {
            return [];
          }
          const stopCount = (props.max - props.min) / props.step;
          const stepWidth = 100 * props.step / (props.max - props.min);
          const result = Array.from({ length: stopCount - 1 }).map((_, index) => (index + 1) * stepWidth);
          if (props.range) {
            return result.filter((step) => {
              return step < 100 * (minValue.value - props.min) / (props.max - props.min) || step > 100 * (maxValue.value - props.min) / (props.max - props.min);
            });
          } else {
            return result.filter((step) => step > 100 * (initData.firstValue - props.min) / (props.max - props.min));
          }
        });
        const getStopStyle = (position) => {
          return props.vertical ? { bottom: `${position}%` } : { left: `${position}%` };
        };
        return {
          stops,
          getStopStyle
        };
      };
      const useWatch = (props, initData, minValue, maxValue, emit2, elFormItem2) => {
        const _emit = (val) => {
          emit2(UPDATE_MODEL_EVENT, val);
          emit2(INPUT_EVENT, val);
        };
        const valueChanged = () => {
          if (props.range) {
            return ![minValue.value, maxValue.value].every((item, index) => item === initData.oldValue[index]);
          } else {
            return props.modelValue !== initData.oldValue;
          }
        };
        const setValues = () => {
          var _a2, _b;
          if (props.min > props.max) {
            throwError("Slider", "min should not be greater than max.");
          }
          const val = props.modelValue;
          if (props.range && Array.isArray(val)) {
            if (val[1] < props.min) {
              _emit([props.min, props.min]);
            } else if (val[0] > props.max) {
              _emit([props.max, props.max]);
            } else if (val[0] < props.min) {
              _emit([props.min, val[1]]);
            } else if (val[1] > props.max) {
              _emit([val[0], props.max]);
            } else {
              initData.firstValue = val[0];
              initData.secondValue = val[1];
              if (valueChanged()) {
                if (props.validateEvent) {
                  (_a2 = elFormItem2 == null ? void 0 : elFormItem2.validate) == null ? void 0 : _a2.call(elFormItem2, "change").catch((err) => debugWarn());
                }
                initData.oldValue = val.slice();
              }
            }
          } else if (!props.range && typeof val === "number" && !Number.isNaN(val)) {
            if (val < props.min) {
              _emit(props.min);
            } else if (val > props.max) {
              _emit(props.max);
            } else {
              initData.firstValue = val;
              if (valueChanged()) {
                if (props.validateEvent) {
                  (_b = elFormItem2 == null ? void 0 : elFormItem2.validate) == null ? void 0 : _b.call(elFormItem2, "change").catch((err) => debugWarn());
                }
                initData.oldValue = val;
              }
            }
          }
        };
        setValues();
        watch(() => initData.dragging, (val) => {
          if (!val) {
            setValues();
          }
        });
        watch(() => props.modelValue, (val, oldVal) => {
          if (initData.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every((item, index) => item === oldVal[index]) && initData.firstValue === val[0] && initData.secondValue === val[1]) {
            return;
          }
          setValues();
        }, {
          deep: true
        });
        watch(() => [props.min, props.max], () => {
          setValues();
        });
      };
      const sliderButtonProps = buildProps({
        modelValue: {
          type: Number,
          default: 0
        },
        vertical: Boolean,
        tooltipClass: String,
        placement: {
          type: String,
          values: Ee,
          default: "top"
        }
      });
      const sliderButtonEmits = {
        [UPDATE_MODEL_EVENT]: (value) => isNumber(value)
      };
      const _hoisted_1$v = ["tabindex"];
      const __default__$8 = defineComponent({
        name: "ElSliderButton"
      });
      const _sfc_main$i = /* @__PURE__ */ defineComponent({
        ...__default__$8,
        props: sliderButtonProps,
        emits: sliderButtonEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const ns = useNamespace("slider");
          const initData = reactive({
            hovering: false,
            dragging: false,
            isClick: false,
            startX: 0,
            currentX: 0,
            startY: 0,
            currentY: 0,
            startPosition: 0,
            newPosition: 0,
            oldValue: props.modelValue
          });
          const {
            disabled,
            button,
            tooltip,
            showTooltip,
            tooltipVisible,
            wrapperStyle,
            formatValue,
            handleMouseEnter,
            handleMouseLeave,
            onButtonDown,
            onKeyDown,
            setPosition
          } = useSliderButton(props, initData, emit2);
          const { hovering, dragging } = toRefs(initData);
          expose({
            onButtonDown,
            onKeyDown,
            setPosition,
            hovering,
            dragging
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "button",
              ref: button,
              class: normalizeClass([unref(ns).e("button-wrapper"), { hover: unref(hovering), dragging: unref(dragging) }]),
              style: normalizeStyle(unref(wrapperStyle)),
              tabindex: unref(disabled) ? -1 : 0,
              onMouseenter: _cache[0] || (_cache[0] = (...args) => unref(handleMouseEnter) && unref(handleMouseEnter)(...args)),
              onMouseleave: _cache[1] || (_cache[1] = (...args) => unref(handleMouseLeave) && unref(handleMouseLeave)(...args)),
              onMousedown: _cache[2] || (_cache[2] = (...args) => unref(onButtonDown) && unref(onButtonDown)(...args)),
              onTouchstart: _cache[3] || (_cache[3] = (...args) => unref(onButtonDown) && unref(onButtonDown)(...args)),
              onFocus: _cache[4] || (_cache[4] = (...args) => unref(handleMouseEnter) && unref(handleMouseEnter)(...args)),
              onBlur: _cache[5] || (_cache[5] = (...args) => unref(handleMouseLeave) && unref(handleMouseLeave)(...args)),
              onKeydown: _cache[6] || (_cache[6] = (...args) => unref(onKeyDown) && unref(onKeyDown)(...args))
            }, [
              createVNode(unref(ElTooltip), {
                ref_key: "tooltip",
                ref: tooltip,
                visible: unref(tooltipVisible),
                placement: _ctx.placement,
                "fallback-placements": ["top", "bottom", "right", "left"],
                "stop-popper-mouse-event": false,
                "popper-class": _ctx.tooltipClass,
                disabled: !unref(showTooltip),
                persistent: ""
              }, {
                content: withCtx(() => [
                  createBaseVNode("span", null, toDisplayString(unref(formatValue)), 1)
                ]),
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: normalizeClass([unref(ns).e("button"), { hover: unref(hovering), dragging: unref(dragging) }])
                  }, null, 2)
                ]),
                _: 1
              }, 8, ["visible", "placement", "popper-class", "disabled"])
            ], 46, _hoisted_1$v);
          };
        }
      });
      var SliderButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/button.vue"]]);
      const sliderMarkerProps = buildProps({
        mark: {
          type: definePropType([String, Object]),
          default: void 0
        }
      });
      var SliderMarker = defineComponent({
        name: "ElSliderMarker",
        props: sliderMarkerProps,
        setup(props) {
          const ns = useNamespace("slider");
          const label = computed(() => {
            return isString$1(props.mark) ? props.mark : props.mark.label;
          });
          const style = computed(() => isString$1(props.mark) ? void 0 : props.mark.style);
          return () => h("div", {
            class: ns.e("marks-text"),
            style: style.value
          }, label.value);
        }
      });
      const _hoisted_1$u = ["id", "role", "aria-label", "aria-labelledby"];
      const _hoisted_2$q = { key: 1 };
      const __default__$7 = defineComponent({
        name: "ElSlider"
      });
      const _sfc_main$h = /* @__PURE__ */ defineComponent({
        ...__default__$7,
        props: sliderProps,
        emits: sliderEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const ns = useNamespace("slider");
          const { t } = useLocale();
          const initData = reactive({
            firstValue: 0,
            secondValue: 0,
            oldValue: 0,
            dragging: false,
            sliderSize: 1
          });
          const {
            elFormItem: elFormItem2,
            slider,
            firstButton,
            secondButton,
            sliderDisabled,
            minValue,
            maxValue,
            runwayStyle,
            barStyle,
            resetSize,
            emitChange,
            onSliderWrapperPrevent,
            onSliderClick,
            onSliderDown,
            setFirstValue,
            setSecondValue
          } = useSlide(props, initData, emit2);
          const { stops, getStopStyle } = useStops(props, initData, minValue, maxValue);
          const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
            formItemContext: elFormItem2
          });
          const sliderWrapperSize = useFormSize();
          const sliderInputSize = computed(() => props.inputSize || sliderWrapperSize.value);
          const groupLabel = computed(() => {
            return props.label || t("el.slider.defaultLabel", {
              min: props.min,
              max: props.max
            });
          });
          const firstButtonLabel = computed(() => {
            if (props.range) {
              return props.rangeStartLabel || t("el.slider.defaultRangeStartLabel");
            } else {
              return groupLabel.value;
            }
          });
          const firstValueText = computed(() => {
            return props.formatValueText ? props.formatValueText(firstValue.value) : `${firstValue.value}`;
          });
          const secondButtonLabel = computed(() => {
            return props.rangeEndLabel || t("el.slider.defaultRangeEndLabel");
          });
          const secondValueText = computed(() => {
            return props.formatValueText ? props.formatValueText(secondValue.value) : `${secondValue.value}`;
          });
          const sliderKls = computed(() => [
            ns.b(),
            ns.m(sliderWrapperSize.value),
            ns.is("vertical", props.vertical),
            { [ns.m("with-input")]: props.showInput }
          ]);
          const markList = useMarks(props);
          useWatch(props, initData, minValue, maxValue, emit2, elFormItem2);
          const precision = computed(() => {
            const precisions = [props.min, props.max, props.step].map((item) => {
              const decimal = `${item}`.split(".")[1];
              return decimal ? decimal.length : 0;
            });
            return Math.max.apply(null, precisions);
          });
          const { sliderWrapper } = useLifecycle(props, initData, resetSize);
          const { firstValue, secondValue, sliderSize } = toRefs(initData);
          const updateDragging = (val) => {
            initData.dragging = val;
          };
          provide(sliderContextKey, {
            ...toRefs(props),
            sliderSize,
            disabled: sliderDisabled,
            precision,
            emitChange,
            resetSize,
            updateDragging
          });
          expose({
            onSliderClick
          });
          return (_ctx, _cache) => {
            var _a2, _b;
            return openBlock(), createElementBlock("div", {
              id: _ctx.range ? unref(inputId) : void 0,
              ref_key: "sliderWrapper",
              ref: sliderWrapper,
              class: normalizeClass(unref(sliderKls)),
              role: _ctx.range ? "group" : void 0,
              "aria-label": _ctx.range && !unref(isLabeledByFormItem) ? unref(groupLabel) : void 0,
              "aria-labelledby": _ctx.range && unref(isLabeledByFormItem) ? (_a2 = unref(elFormItem2)) == null ? void 0 : _a2.labelId : void 0,
              onTouchstart: _cache[2] || (_cache[2] = (...args) => unref(onSliderWrapperPrevent) && unref(onSliderWrapperPrevent)(...args)),
              onTouchmove: _cache[3] || (_cache[3] = (...args) => unref(onSliderWrapperPrevent) && unref(onSliderWrapperPrevent)(...args))
            }, [
              createBaseVNode("div", {
                ref_key: "slider",
                ref: slider,
                class: normalizeClass([
                  unref(ns).e("runway"),
                  { "show-input": _ctx.showInput && !_ctx.range },
                  unref(ns).is("disabled", unref(sliderDisabled))
                ]),
                style: normalizeStyle(unref(runwayStyle)),
                onMousedown: _cache[0] || (_cache[0] = (...args) => unref(onSliderDown) && unref(onSliderDown)(...args)),
                onTouchstart: _cache[1] || (_cache[1] = (...args) => unref(onSliderDown) && unref(onSliderDown)(...args))
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).e("bar")),
                  style: normalizeStyle(unref(barStyle))
                }, null, 6),
                createVNode(SliderButton, {
                  id: !_ctx.range ? unref(inputId) : void 0,
                  ref_key: "firstButton",
                  ref: firstButton,
                  "model-value": unref(firstValue),
                  vertical: _ctx.vertical,
                  "tooltip-class": _ctx.tooltipClass,
                  placement: _ctx.placement,
                  role: "slider",
                  "aria-label": _ctx.range || !unref(isLabeledByFormItem) ? unref(firstButtonLabel) : void 0,
                  "aria-labelledby": !_ctx.range && unref(isLabeledByFormItem) ? (_b = unref(elFormItem2)) == null ? void 0 : _b.labelId : void 0,
                  "aria-valuemin": _ctx.min,
                  "aria-valuemax": _ctx.range ? unref(secondValue) : _ctx.max,
                  "aria-valuenow": unref(firstValue),
                  "aria-valuetext": unref(firstValueText),
                  "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                  "aria-disabled": unref(sliderDisabled),
                  "onUpdate:modelValue": unref(setFirstValue)
                }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
                _ctx.range ? (openBlock(), createBlock(SliderButton, {
                  key: 0,
                  ref_key: "secondButton",
                  ref: secondButton,
                  "model-value": unref(secondValue),
                  vertical: _ctx.vertical,
                  "tooltip-class": _ctx.tooltipClass,
                  placement: _ctx.placement,
                  role: "slider",
                  "aria-label": unref(secondButtonLabel),
                  "aria-valuemin": unref(firstValue),
                  "aria-valuemax": _ctx.max,
                  "aria-valuenow": unref(secondValue),
                  "aria-valuetext": unref(secondValueText),
                  "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                  "aria-disabled": unref(sliderDisabled),
                  "onUpdate:modelValue": unref(setSecondValue)
                }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : createCommentVNode("v-if", true),
                _ctx.showStops ? (openBlock(), createElementBlock("div", _hoisted_2$q, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(stops), (item, key) => {
                    return openBlock(), createElementBlock("div", {
                      key,
                      class: normalizeClass(unref(ns).e("stop")),
                      style: normalizeStyle(unref(getStopStyle)(item))
                    }, null, 6);
                  }), 128))
                ])) : createCommentVNode("v-if", true),
                unref(markList).length > 0 ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                  createBaseVNode("div", null, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(markList), (item, key) => {
                      return openBlock(), createElementBlock("div", {
                        key,
                        style: normalizeStyle(unref(getStopStyle)(item.position)),
                        class: normalizeClass([unref(ns).e("stop"), unref(ns).e("marks-stop")])
                      }, null, 6);
                    }), 128))
                  ]),
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ns).e("marks"))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(markList), (item, key) => {
                      return openBlock(), createBlock(unref(SliderMarker), {
                        key,
                        mark: item.mark,
                        style: normalizeStyle(unref(getStopStyle)(item.position))
                      }, null, 8, ["mark", "style"]);
                    }), 128))
                  ], 2)
                ], 64)) : createCommentVNode("v-if", true)
              ], 38),
              _ctx.showInput && !_ctx.range ? (openBlock(), createBlock(unref(ElInputNumber), {
                key: 0,
                ref: "input",
                "model-value": unref(firstValue),
                class: normalizeClass(unref(ns).e("input")),
                step: _ctx.step,
                disabled: unref(sliderDisabled),
                controls: _ctx.showInputControls,
                min: _ctx.min,
                max: _ctx.max,
                debounce: _ctx.debounce,
                size: unref(sliderInputSize),
                "onUpdate:modelValue": unref(setFirstValue),
                onChange: unref(emitChange)
              }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : createCommentVNode("v-if", true)
            ], 42, _hoisted_1$u);
          };
        }
      });
      var Slider = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/slider.vue"]]);
      const ElSlider = withInstall(Slider);
      const statisticProps = buildProps({
        decimalSeparator: {
          type: String,
          default: "."
        },
        groupSeparator: {
          type: String,
          default: ","
        },
        precision: {
          type: Number,
          default: 0
        },
        formatter: Function,
        value: {
          type: definePropType([Number, Object]),
          default: 0
        },
        prefix: String,
        suffix: String,
        title: String,
        valueStyle: {
          type: definePropType([String, Object, Array])
        }
      });
      const __default__$6 = defineComponent({
        name: "ElStatistic"
      });
      const _sfc_main$g = /* @__PURE__ */ defineComponent({
        ...__default__$6,
        props: statisticProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("statistic");
          const displayValue = computed(() => {
            const { value, formatter, precision, decimalSeparator, groupSeparator } = props;
            if (isFunction$1(formatter))
              return formatter(value);
            if (!isNumber(value))
              return value;
            let [integer2, decimal = ""] = String(value).split(".");
            decimal = decimal.padEnd(precision, "0").slice(0, precision > 0 ? precision : 0);
            integer2 = integer2.replace(/\B(?=(\d{3})+(?!\d))/g, groupSeparator);
            return [integer2, decimal].join(decimal ? decimalSeparator : "");
          });
          expose({
            displayValue
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b())
            }, [
              _ctx.$slots.title || _ctx.title ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("head"))
              }, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString(_ctx.title), 1)
                ])
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).e("content"))
              }, [
                _ctx.$slots.prefix || _ctx.prefix ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("prefix"))
                }, [
                  renderSlot(_ctx.$slots, "prefix", {}, () => [
                    createBaseVNode("span", null, toDisplayString(_ctx.prefix), 1)
                  ])
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("span", {
                  class: normalizeClass(unref(ns).e("number")),
                  style: normalizeStyle(_ctx.valueStyle)
                }, toDisplayString(unref(displayValue)), 7),
                _ctx.$slots.suffix || _ctx.suffix ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(ns).e("suffix"))
                }, [
                  renderSlot(_ctx.$slots, "suffix", {}, () => [
                    createBaseVNode("span", null, toDisplayString(_ctx.suffix), 1)
                  ])
                ], 2)) : createCommentVNode("v-if", true)
              ], 2)
            ], 2);
          };
        }
      });
      var Statistic = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/statistic/src/statistic.vue"]]);
      const ElStatistic = withInstall(Statistic);
      const tabsRootContextKey = Symbol("tabsRootContextKey");
      const tabBarProps = buildProps({
        tabs: {
          type: definePropType(Array),
          default: () => mutable([])
        }
      });
      const COMPONENT_NAME$2 = "ElTabBar";
      const __default__$5 = defineComponent({
        name: COMPONENT_NAME$2
      });
      const _sfc_main$f = /* @__PURE__ */ defineComponent({
        ...__default__$5,
        props: tabBarProps,
        setup(__props, { expose }) {
          const props = __props;
          const instance = getCurrentInstance();
          const rootTabs = inject(tabsRootContextKey);
          if (!rootTabs)
            throwError(COMPONENT_NAME$2, "<el-tabs><el-tab-bar /></el-tabs>");
          const ns = useNamespace("tabs");
          const barRef = ref();
          const barStyle = ref();
          const getBarStyle = () => {
            let offset = 0;
            let tabSize = 0;
            const sizeName = ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height";
            const sizeDir = sizeName === "width" ? "x" : "y";
            const position = sizeDir === "x" ? "left" : "top";
            props.tabs.every((tab) => {
              var _a2, _b;
              const $el = (_b = (_a2 = instance.parent) == null ? void 0 : _a2.refs) == null ? void 0 : _b[`tab-${tab.uid}`];
              if (!$el)
                return false;
              if (!tab.active) {
                return true;
              }
              offset = $el[`offset${capitalize(position)}`];
              tabSize = $el[`client${capitalize(sizeName)}`];
              const tabStyles = window.getComputedStyle($el);
              if (sizeName === "width") {
                if (props.tabs.length > 1) {
                  tabSize -= Number.parseFloat(tabStyles.paddingLeft) + Number.parseFloat(tabStyles.paddingRight);
                }
                offset += Number.parseFloat(tabStyles.paddingLeft);
              }
              return false;
            });
            return {
              [sizeName]: `${tabSize}px`,
              transform: `translate${capitalize(sizeDir)}(${offset}px)`
            };
          };
          const update = () => barStyle.value = getBarStyle();
          watch(() => props.tabs, async () => {
            await nextTick();
            update();
          }, { immediate: true });
          useResizeObserver(barRef, () => update());
          expose({
            ref: barRef,
            update
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "barRef",
              ref: barRef,
              class: normalizeClass([unref(ns).e("active-bar"), unref(ns).is(unref(rootTabs).props.tabPosition)]),
              style: normalizeStyle(barStyle.value)
            }, null, 6);
          };
        }
      });
      var TabBar = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-bar.vue"]]);
      const tabNavProps = buildProps({
        panes: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        currentName: {
          type: [String, Number],
          default: ""
        },
        editable: Boolean,
        type: {
          type: String,
          values: ["card", "border-card", ""],
          default: ""
        },
        stretch: Boolean
      });
      const tabNavEmits = {
        tabClick: (tab, tabName, ev) => ev instanceof Event,
        tabRemove: (tab, ev) => ev instanceof Event
      };
      const COMPONENT_NAME$1 = "ElTabNav";
      const TabNav = defineComponent({
        name: COMPONENT_NAME$1,
        props: tabNavProps,
        emits: tabNavEmits,
        setup(props, {
          expose,
          emit: emit2
        }) {
          const vm = getCurrentInstance();
          const rootTabs = inject(tabsRootContextKey);
          if (!rootTabs)
            throwError(COMPONENT_NAME$1, `<el-tabs><tab-nav /></el-tabs>`);
          const ns = useNamespace("tabs");
          const visibility = useDocumentVisibility();
          const focused = useWindowFocus();
          const navScroll$ = ref();
          const nav$ = ref();
          const el$ = ref();
          const tabBarRef = ref();
          const scrollable = ref(false);
          const navOffset = ref(0);
          const isFocus = ref(false);
          const focusable = ref(true);
          const sizeName = computed(() => ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height");
          const navStyle = computed(() => {
            const dir = sizeName.value === "width" ? "X" : "Y";
            return {
              transform: `translate${dir}(-${navOffset.value}px)`
            };
          });
          const scrollPrev = () => {
            if (!navScroll$.value)
              return;
            const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (!currentOffset)
              return;
            const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;
            navOffset.value = newOffset;
          };
          const scrollNext = () => {
            if (!navScroll$.value || !nav$.value)
              return;
            const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
            const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (navSize - currentOffset <= containerSize)
              return;
            const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;
            navOffset.value = newOffset;
          };
          const scrollToActiveTab = async () => {
            const nav = nav$.value;
            if (!scrollable.value || !el$.value || !navScroll$.value || !nav)
              return;
            await nextTick();
            const activeTab = el$.value.querySelector(".is-active");
            if (!activeTab)
              return;
            const navScroll = navScroll$.value;
            const isHorizontal2 = ["top", "bottom"].includes(rootTabs.props.tabPosition);
            const activeTabBounding = activeTab.getBoundingClientRect();
            const navScrollBounding = navScroll.getBoundingClientRect();
            const maxOffset = isHorizontal2 ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;
            const currentOffset = navOffset.value;
            let newOffset = currentOffset;
            if (isHorizontal2) {
              if (activeTabBounding.left < navScrollBounding.left) {
                newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
              }
              if (activeTabBounding.right > navScrollBounding.right) {
                newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
              }
            } else {
              if (activeTabBounding.top < navScrollBounding.top) {
                newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);
              }
              if (activeTabBounding.bottom > navScrollBounding.bottom) {
                newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);
              }
            }
            newOffset = Math.max(newOffset, 0);
            navOffset.value = Math.min(newOffset, maxOffset);
          };
          const update = () => {
            var _a2;
            if (!nav$.value || !navScroll$.value)
              return;
            props.stretch && ((_a2 = tabBarRef.value) == null ? void 0 : _a2.update());
            const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
            const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (containerSize < navSize) {
              scrollable.value = scrollable.value || {};
              scrollable.value.prev = currentOffset;
              scrollable.value.next = currentOffset + containerSize < navSize;
              if (navSize - currentOffset < containerSize) {
                navOffset.value = navSize - containerSize;
              }
            } else {
              scrollable.value = false;
              if (currentOffset > 0) {
                navOffset.value = 0;
              }
            }
          };
          const changeTab = (e) => {
            const code = e.code;
            const {
              up: up2,
              down: down2,
              left: left2,
              right: right2
            } = EVENT_CODE;
            if (![up2, down2, left2, right2].includes(code))
              return;
            const tabList = Array.from(e.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)"));
            const currentIndex = tabList.indexOf(e.target);
            let nextIndex;
            if (code === left2 || code === up2) {
              if (currentIndex === 0) {
                nextIndex = tabList.length - 1;
              } else {
                nextIndex = currentIndex - 1;
              }
            } else {
              if (currentIndex < tabList.length - 1) {
                nextIndex = currentIndex + 1;
              } else {
                nextIndex = 0;
              }
            }
            tabList[nextIndex].focus({
              preventScroll: true
            });
            tabList[nextIndex].click();
            setFocus();
          };
          const setFocus = () => {
            if (focusable.value)
              isFocus.value = true;
          };
          const removeFocus = () => isFocus.value = false;
          watch(visibility, (visibility2) => {
            if (visibility2 === "hidden") {
              focusable.value = false;
            } else if (visibility2 === "visible") {
              setTimeout(() => focusable.value = true, 50);
            }
          });
          watch(focused, (focused2) => {
            if (focused2) {
              setTimeout(() => focusable.value = true, 50);
            } else {
              focusable.value = false;
            }
          });
          useResizeObserver(el$, update);
          onMounted(() => setTimeout(() => scrollToActiveTab(), 0));
          onUpdated(() => update());
          expose({
            scrollToActiveTab,
            removeFocus
          });
          watch(() => props.panes, () => vm.update(), {
            flush: "post",
            deep: true
          });
          return () => {
            const scrollBtn = scrollable.value ? [createVNode("span", {
              "class": [ns.e("nav-prev"), ns.is("disabled", !scrollable.value.prev)],
              "onClick": scrollPrev
            }, [createVNode(ElIcon, null, {
              default: () => [createVNode(arrow_left_default, null, null)]
            })]), createVNode("span", {
              "class": [ns.e("nav-next"), ns.is("disabled", !scrollable.value.next)],
              "onClick": scrollNext
            }, [createVNode(ElIcon, null, {
              default: () => [createVNode(arrow_right_default, null, null)]
            })])] : null;
            const tabs = props.panes.map((pane, index) => {
              var _a2, _b, _c, _d;
              const uid2 = pane.uid;
              const disabled = pane.props.disabled;
              const tabName = (_b = (_a2 = pane.props.name) != null ? _a2 : pane.index) != null ? _b : `${index}`;
              const closable = !disabled && (pane.isClosable || props.editable);
              pane.index = `${index}`;
              const btnClose = closable ? createVNode(ElIcon, {
                "class": "is-icon-close",
                "onClick": (ev) => emit2("tabRemove", pane, ev)
              }, {
                default: () => [createVNode(close_default, null, null)]
              }) : null;
              const tabLabelContent = ((_d = (_c = pane.slots).label) == null ? void 0 : _d.call(_c)) || pane.props.label;
              const tabindex = !disabled && pane.active ? 0 : -1;
              return createVNode("div", {
                "ref": `tab-${uid2}`,
                "class": [ns.e("item"), ns.is(rootTabs.props.tabPosition), ns.is("active", pane.active), ns.is("disabled", disabled), ns.is("closable", closable), ns.is("focus", isFocus.value)],
                "id": `tab-${tabName}`,
                "key": `tab-${uid2}`,
                "aria-controls": `pane-${tabName}`,
                "role": "tab",
                "aria-selected": pane.active,
                "tabindex": tabindex,
                "onFocus": () => setFocus(),
                "onBlur": () => removeFocus(),
                "onClick": (ev) => {
                  removeFocus();
                  emit2("tabClick", pane, tabName, ev);
                },
                "onKeydown": (ev) => {
                  if (closable && (ev.code === EVENT_CODE.delete || ev.code === EVENT_CODE.backspace)) {
                    emit2("tabRemove", pane, ev);
                  }
                }
              }, [...[tabLabelContent, btnClose]]);
            });
            return createVNode("div", {
              "ref": el$,
              "class": [ns.e("nav-wrap"), ns.is("scrollable", !!scrollable.value), ns.is(rootTabs.props.tabPosition)]
            }, [scrollBtn, createVNode("div", {
              "class": ns.e("nav-scroll"),
              "ref": navScroll$
            }, [createVNode("div", {
              "class": [ns.e("nav"), ns.is(rootTabs.props.tabPosition), ns.is("stretch", props.stretch && ["top", "bottom"].includes(rootTabs.props.tabPosition))],
              "ref": nav$,
              "style": navStyle.value,
              "role": "tablist",
              "onKeydown": changeTab
            }, [...[!props.type ? createVNode(TabBar, {
              "ref": tabBarRef,
              "tabs": [...props.panes]
            }, null) : null, tabs]])])]);
          };
        }
      });
      const tabsProps = buildProps({
        type: {
          type: String,
          values: ["card", "border-card", ""],
          default: ""
        },
        activeName: {
          type: [String, Number]
        },
        closable: Boolean,
        addable: Boolean,
        modelValue: {
          type: [String, Number]
        },
        editable: Boolean,
        tabPosition: {
          type: String,
          values: ["top", "right", "bottom", "left"],
          default: "top"
        },
        beforeLeave: {
          type: definePropType(Function),
          default: () => true
        },
        stretch: Boolean
      });
      const isPaneName = (value) => isString$1(value) || isNumber(value);
      const tabsEmits = {
        [UPDATE_MODEL_EVENT]: (name) => isPaneName(name),
        tabClick: (pane, ev) => ev instanceof Event,
        tabChange: (name) => isPaneName(name),
        edit: (paneName, action) => ["remove", "add"].includes(action),
        tabRemove: (name) => isPaneName(name),
        tabAdd: () => true
      };
      var Tabs = defineComponent({
        name: "ElTabs",
        props: tabsProps,
        emits: tabsEmits,
        setup(props, {
          emit: emit2,
          slots,
          expose
        }) {
          var _a2, _b;
          const ns = useNamespace("tabs");
          const {
            children: panes,
            addChild: registerPane,
            removeChild: unregisterPane
          } = useOrderedChildren(getCurrentInstance(), "ElTabPane");
          const nav$ = ref();
          const currentName = ref((_b = (_a2 = props.modelValue) != null ? _a2 : props.activeName) != null ? _b : "0");
          const changeCurrentName = (value) => {
            currentName.value = value;
            emit2(UPDATE_MODEL_EVENT, value);
            emit2("tabChange", value);
          };
          const setCurrentName = async (value) => {
            var _a22, _b2, _c;
            if (currentName.value === value || isUndefined(value))
              return;
            try {
              const canLeave = await ((_a22 = props.beforeLeave) == null ? void 0 : _a22.call(props, value, currentName.value));
              if (canLeave !== false) {
                changeCurrentName(value);
                (_c = (_b2 = nav$.value) == null ? void 0 : _b2.removeFocus) == null ? void 0 : _c.call(_b2);
              }
            } catch (e) {
            }
          };
          const handleTabClick = (tab, tabName, event) => {
            if (tab.props.disabled)
              return;
            setCurrentName(tabName);
            emit2("tabClick", tab, event);
          };
          const handleTabRemove = (pane, ev) => {
            if (pane.props.disabled || isUndefined(pane.props.name))
              return;
            ev.stopPropagation();
            emit2("edit", pane.props.name, "remove");
            emit2("tabRemove", pane.props.name);
          };
          const handleTabAdd = () => {
            emit2("edit", void 0, "add");
            emit2("tabAdd");
          };
          useDeprecated({
            from: '"activeName"',
            replacement: '"model-value" or "v-model"',
            scope: "ElTabs",
            version: "2.3.0",
            ref: "https://element-plus.org/en-US/component/tabs.html#attributes",
            type: "Attribute"
          }, computed(() => !!props.activeName));
          watch(() => props.activeName, (modelValue) => setCurrentName(modelValue));
          watch(() => props.modelValue, (modelValue) => setCurrentName(modelValue));
          watch(currentName, async () => {
            var _a22;
            await nextTick();
            (_a22 = nav$.value) == null ? void 0 : _a22.scrollToActiveTab();
          });
          provide(tabsRootContextKey, {
            props,
            currentName,
            registerPane,
            unregisterPane
          });
          expose({
            currentName
          });
          return () => {
            const newButton = props.editable || props.addable ? createVNode("span", {
              "class": ns.e("new-tab"),
              "tabindex": "0",
              "onClick": handleTabAdd,
              "onKeydown": (ev) => {
                if (ev.code === EVENT_CODE.enter)
                  handleTabAdd();
              }
            }, [createVNode(ElIcon, {
              "class": ns.is("icon-plus")
            }, {
              default: () => [createVNode(plus_default, null, null)]
            })]) : null;
            const header = createVNode("div", {
              "class": [ns.e("header"), ns.is(props.tabPosition)]
            }, [newButton, createVNode(TabNav, {
              "ref": nav$,
              "currentName": currentName.value,
              "editable": props.editable,
              "type": props.type,
              "panes": panes.value,
              "stretch": props.stretch,
              "onTabClick": handleTabClick,
              "onTabRemove": handleTabRemove
            }, null)]);
            const panels = createVNode("div", {
              "class": ns.e("content")
            }, [renderSlot(slots, "default")]);
            return createVNode("div", {
              "class": [ns.b(), ns.m(props.tabPosition), {
                [ns.m("card")]: props.type === "card",
                [ns.m("border-card")]: props.type === "border-card"
              }]
            }, [...props.tabPosition !== "bottom" ? [header, panels] : [panels, header]]);
          };
        }
      });
      const tabPaneProps = buildProps({
        label: {
          type: String,
          default: ""
        },
        name: {
          type: [String, Number]
        },
        closable: Boolean,
        disabled: Boolean,
        lazy: Boolean
      });
      const _hoisted_1$t = ["id", "aria-hidden", "aria-labelledby"];
      const COMPONENT_NAME = "ElTabPane";
      const __default__$4 = defineComponent({
        name: COMPONENT_NAME
      });
      const _sfc_main$e = /* @__PURE__ */ defineComponent({
        ...__default__$4,
        props: tabPaneProps,
        setup(__props) {
          const props = __props;
          const instance = getCurrentInstance();
          const slots = useSlots();
          const tabsRoot = inject(tabsRootContextKey);
          if (!tabsRoot)
            throwError(COMPONENT_NAME, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
          const ns = useNamespace("tab-pane");
          const index = ref();
          const isClosable = computed(() => props.closable || tabsRoot.props.closable);
          const active = computedEager(() => {
            var _a2;
            return tabsRoot.currentName.value === ((_a2 = props.name) != null ? _a2 : index.value);
          });
          const loaded = ref(active.value);
          const paneName = computed(() => {
            var _a2;
            return (_a2 = props.name) != null ? _a2 : index.value;
          });
          const shouldBeRender = computedEager(() => !props.lazy || loaded.value || active.value);
          watch(active, (val) => {
            if (val)
              loaded.value = true;
          });
          const pane = reactive({
            uid: instance.uid,
            slots,
            props,
            paneName,
            active,
            index,
            isClosable
          });
          onMounted(() => {
            tabsRoot.registerPane(pane);
          });
          onUnmounted(() => {
            tabsRoot.unregisterPane(pane.uid);
          });
          return (_ctx, _cache) => {
            return unref(shouldBeRender) ? withDirectives((openBlock(), createElementBlock("div", {
              key: 0,
              id: `pane-${unref(paneName)}`,
              class: normalizeClass(unref(ns).b()),
              role: "tabpanel",
              "aria-hidden": !unref(active),
              "aria-labelledby": `tab-${unref(paneName)}`
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 10, _hoisted_1$t)), [
              [vShow, unref(active)]
            ]) : createCommentVNode("v-if", true);
          };
        }
      });
      var TabPane = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-pane.vue"]]);
      const ElTabs = withInstall(Tabs, {
        TabPane
      });
      const ElTabPane = withNoopInstall(TabPane);
      const ROOT_TREE_INJECTION_KEY = Symbol();
      const EMPTY_NODE = {
        key: -1,
        level: -1,
        data: {}
      };
      var TreeOptionsEnum = /* @__PURE__ */ ((TreeOptionsEnum2) => {
        TreeOptionsEnum2["KEY"] = "id";
        TreeOptionsEnum2["LABEL"] = "label";
        TreeOptionsEnum2["CHILDREN"] = "children";
        TreeOptionsEnum2["DISABLED"] = "disabled";
        return TreeOptionsEnum2;
      })(TreeOptionsEnum || {});
      var SetOperationEnum = /* @__PURE__ */ ((SetOperationEnum2) => {
        SetOperationEnum2["ADD"] = "add";
        SetOperationEnum2["DELETE"] = "delete";
        return SetOperationEnum2;
      })(SetOperationEnum || {});
      const itemSize = {
        type: Number,
        default: 26
      };
      const treeProps = buildProps({
        data: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        emptyText: {
          type: String
        },
        height: {
          type: Number,
          default: 200
        },
        props: {
          type: definePropType(Object),
          default: () => mutable({
            children: "children",
            label: "label",
            disabled: "disabled",
            value: "id"
            /* KEY */
          })
        },
        highlightCurrent: {
          type: Boolean,
          default: false
        },
        showCheckbox: {
          type: Boolean,
          default: false
        },
        defaultCheckedKeys: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        checkStrictly: {
          type: Boolean,
          default: false
        },
        defaultExpandedKeys: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        indent: {
          type: Number,
          default: 16
        },
        itemSize,
        icon: {
          type: iconPropType
        },
        expandOnClickNode: {
          type: Boolean,
          default: true
        },
        checkOnClickNode: {
          type: Boolean,
          default: false
        },
        currentNodeKey: {
          type: definePropType([String, Number])
        },
        accordion: {
          type: Boolean,
          default: false
        },
        filterMethod: {
          type: definePropType(Function)
        },
        perfMode: {
          type: Boolean,
          default: true
        }
      });
      const treeNodeProps = buildProps({
        node: {
          type: definePropType(Object),
          default: () => mutable(EMPTY_NODE)
        },
        expanded: {
          type: Boolean,
          default: false
        },
        checked: {
          type: Boolean,
          default: false
        },
        indeterminate: {
          type: Boolean,
          default: false
        },
        showCheckbox: {
          type: Boolean,
          default: false
        },
        disabled: {
          type: Boolean,
          default: false
        },
        current: {
          type: Boolean,
          default: false
        },
        hiddenExpandIcon: {
          type: Boolean,
          default: false
        },
        itemSize
      });
      const treeNodeContentProps = buildProps({
        node: {
          type: definePropType(Object),
          required: true
        }
      });
      const NODE_CLICK = "node-click";
      const NODE_EXPAND = "node-expand";
      const NODE_COLLAPSE = "node-collapse";
      const CURRENT_CHANGE = "current-change";
      const NODE_CHECK = "check";
      const NODE_CHECK_CHANGE = "check-change";
      const NODE_CONTEXTMENU = "node-contextmenu";
      const treeEmits = {
        [NODE_CLICK]: (data, node, e) => data && node && e,
        [NODE_EXPAND]: (data, node) => data && node,
        [NODE_COLLAPSE]: (data, node) => data && node,
        [CURRENT_CHANGE]: (data, node) => data && node,
        [NODE_CHECK]: (data, checkedInfo) => data && checkedInfo,
        [NODE_CHECK_CHANGE]: (data, checked) => data && typeof checked === "boolean",
        [NODE_CONTEXTMENU]: (event, data, node) => event && data && node
      };
      const treeNodeEmits = {
        click: (node, e) => !!(node && e),
        toggle: (node) => !!node,
        check: (node, checked) => node && typeof checked === "boolean"
      };
      function useCheck(props, tree) {
        const checkedKeys = ref(/* @__PURE__ */ new Set());
        const indeterminateKeys = ref(/* @__PURE__ */ new Set());
        const { emit: emit2 } = getCurrentInstance();
        watch([() => tree.value, () => props.defaultCheckedKeys], () => {
          return nextTick(() => {
            _setCheckedKeys(props.defaultCheckedKeys);
          });
        }, {
          immediate: true
        });
        const updateCheckedKeys = () => {
          if (!tree.value || !props.showCheckbox || props.checkStrictly) {
            return;
          }
          const { levelTreeNodeMap, maxLevel } = tree.value;
          const checkedKeySet = checkedKeys.value;
          const indeterminateKeySet = /* @__PURE__ */ new Set();
          for (let level = maxLevel - 1; level >= 1; --level) {
            const nodes = levelTreeNodeMap.get(level);
            if (!nodes)
              continue;
            nodes.forEach((node) => {
              const children = node.children;
              if (children) {
                let allChecked = true;
                let hasChecked = false;
                for (const childNode of children) {
                  const key = childNode.key;
                  if (checkedKeySet.has(key)) {
                    hasChecked = true;
                  } else if (indeterminateKeySet.has(key)) {
                    allChecked = false;
                    hasChecked = true;
                    break;
                  } else {
                    allChecked = false;
                  }
                }
                if (allChecked) {
                  checkedKeySet.add(node.key);
                } else if (hasChecked) {
                  indeterminateKeySet.add(node.key);
                  checkedKeySet.delete(node.key);
                } else {
                  checkedKeySet.delete(node.key);
                  indeterminateKeySet.delete(node.key);
                }
              }
            });
          }
          indeterminateKeys.value = indeterminateKeySet;
        };
        const isChecked = (node) => checkedKeys.value.has(node.key);
        const isIndeterminate = (node) => indeterminateKeys.value.has(node.key);
        const toggleCheckbox = (node, isChecked2, nodeClick = true) => {
          const checkedKeySet = checkedKeys.value;
          const toggle = (node2, checked) => {
            checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](node2.key);
            const children = node2.children;
            if (!props.checkStrictly && children) {
              children.forEach((childNode) => {
                if (!childNode.disabled) {
                  toggle(childNode, checked);
                }
              });
            }
          };
          toggle(node, isChecked2);
          updateCheckedKeys();
          if (nodeClick) {
            afterNodeCheck(node, isChecked2);
          }
        };
        const afterNodeCheck = (node, checked) => {
          const { checkedNodes, checkedKeys: checkedKeys2 } = getChecked();
          const { halfCheckedNodes, halfCheckedKeys } = getHalfChecked();
          emit2(NODE_CHECK, node.data, {
            checkedKeys: checkedKeys2,
            checkedNodes,
            halfCheckedKeys,
            halfCheckedNodes
          });
          emit2(NODE_CHECK_CHANGE, node.data, checked);
        };
        function getCheckedKeys(leafOnly = false) {
          return getChecked(leafOnly).checkedKeys;
        }
        function getCheckedNodes(leafOnly = false) {
          return getChecked(leafOnly).checkedNodes;
        }
        function getHalfCheckedKeys() {
          return getHalfChecked().halfCheckedKeys;
        }
        function getHalfCheckedNodes() {
          return getHalfChecked().halfCheckedNodes;
        }
        function getChecked(leafOnly = false) {
          const checkedNodes = [];
          const keys2 = [];
          if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {
            const { treeNodeMap } = tree.value;
            checkedKeys.value.forEach((key) => {
              const node = treeNodeMap.get(key);
              if (node && (!leafOnly || leafOnly && node.isLeaf)) {
                keys2.push(key);
                checkedNodes.push(node.data);
              }
            });
          }
          return {
            checkedKeys: keys2,
            checkedNodes
          };
        }
        function getHalfChecked() {
          const halfCheckedNodes = [];
          const halfCheckedKeys = [];
          if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {
            const { treeNodeMap } = tree.value;
            indeterminateKeys.value.forEach((key) => {
              const node = treeNodeMap.get(key);
              if (node) {
                halfCheckedKeys.push(key);
                halfCheckedNodes.push(node.data);
              }
            });
          }
          return {
            halfCheckedNodes,
            halfCheckedKeys
          };
        }
        function setCheckedKeys(keys2) {
          checkedKeys.value.clear();
          indeterminateKeys.value.clear();
          _setCheckedKeys(keys2);
        }
        function setChecked2(key, isChecked2) {
          if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {
            const node = tree.value.treeNodeMap.get(key);
            if (node) {
              toggleCheckbox(node, isChecked2, false);
            }
          }
        }
        function _setCheckedKeys(keys2) {
          if (tree == null ? void 0 : tree.value) {
            const { treeNodeMap } = tree.value;
            if (props.showCheckbox && treeNodeMap && keys2) {
              for (const key of keys2) {
                const node = treeNodeMap.get(key);
                if (node && !isChecked(node)) {
                  toggleCheckbox(node, true, false);
                }
              }
            }
          }
        }
        return {
          updateCheckedKeys,
          toggleCheckbox,
          isChecked,
          isIndeterminate,
          getCheckedKeys,
          getCheckedNodes,
          getHalfCheckedKeys,
          getHalfCheckedNodes,
          setChecked: setChecked2,
          setCheckedKeys
        };
      }
      function useFilter(props, tree) {
        const hiddenNodeKeySet = ref(/* @__PURE__ */ new Set([]));
        const hiddenExpandIconKeySet = ref(/* @__PURE__ */ new Set([]));
        const filterable = computed(() => {
          return isFunction$1(props.filterMethod);
        });
        function doFilter(query) {
          var _a2;
          if (!filterable.value) {
            return;
          }
          const expandKeySet = /* @__PURE__ */ new Set();
          const hiddenExpandIconKeys = hiddenExpandIconKeySet.value;
          const hiddenKeys = hiddenNodeKeySet.value;
          const family = [];
          const nodes = ((_a2 = tree.value) == null ? void 0 : _a2.treeNodes) || [];
          const filter = props.filterMethod;
          hiddenKeys.clear();
          function traverse2(nodes2) {
            nodes2.forEach((node) => {
              family.push(node);
              if (filter == null ? void 0 : filter(query, node.data)) {
                family.forEach((member) => {
                  expandKeySet.add(member.key);
                });
              } else if (node.isLeaf) {
                hiddenKeys.add(node.key);
              }
              const children = node.children;
              if (children) {
                traverse2(children);
              }
              if (!node.isLeaf) {
                if (!expandKeySet.has(node.key)) {
                  hiddenKeys.add(node.key);
                } else if (children) {
                  let allHidden = true;
                  for (const childNode of children) {
                    if (!hiddenKeys.has(childNode.key)) {
                      allHidden = false;
                      break;
                    }
                  }
                  if (allHidden) {
                    hiddenExpandIconKeys.add(node.key);
                  } else {
                    hiddenExpandIconKeys.delete(node.key);
                  }
                }
              }
              family.pop();
            });
          }
          traverse2(nodes);
          return expandKeySet;
        }
        function isForceHiddenExpandIcon(node) {
          return hiddenExpandIconKeySet.value.has(node.key);
        }
        return {
          hiddenExpandIconKeySet,
          hiddenNodeKeySet,
          doFilter,
          isForceHiddenExpandIcon
        };
      }
      function useTree(props, emit2) {
        const expandedKeySet = ref(new Set(props.defaultExpandedKeys));
        const currentKey = ref();
        const tree = shallowRef();
        watch(() => props.currentNodeKey, (key) => {
          currentKey.value = key;
        }, {
          immediate: true
        });
        watch(() => props.data, (data) => {
          setData(data);
        }, {
          immediate: true
        });
        const {
          isIndeterminate,
          isChecked,
          toggleCheckbox,
          getCheckedKeys,
          getCheckedNodes,
          getHalfCheckedKeys,
          getHalfCheckedNodes,
          setChecked: setChecked2,
          setCheckedKeys
        } = useCheck(props, tree);
        const { doFilter, hiddenNodeKeySet, isForceHiddenExpandIcon } = useFilter(props, tree);
        const valueKey = computed(() => {
          var _a2;
          return ((_a2 = props.props) == null ? void 0 : _a2.value) || TreeOptionsEnum.KEY;
        });
        const childrenKey = computed(() => {
          var _a2;
          return ((_a2 = props.props) == null ? void 0 : _a2.children) || TreeOptionsEnum.CHILDREN;
        });
        const disabledKey = computed(() => {
          var _a2;
          return ((_a2 = props.props) == null ? void 0 : _a2.disabled) || TreeOptionsEnum.DISABLED;
        });
        const labelKey = computed(() => {
          var _a2;
          return ((_a2 = props.props) == null ? void 0 : _a2.label) || TreeOptionsEnum.LABEL;
        });
        const flattenTree = computed(() => {
          const expandedKeys = expandedKeySet.value;
          const hiddenKeys = hiddenNodeKeySet.value;
          const flattenNodes = [];
          const nodes = tree.value && tree.value.treeNodes || [];
          function traverse2() {
            const stack = [];
            for (let i = nodes.length - 1; i >= 0; --i) {
              stack.push(nodes[i]);
            }
            while (stack.length) {
              const node = stack.pop();
              if (!node)
                continue;
              if (!hiddenKeys.has(node.key)) {
                flattenNodes.push(node);
              }
              if (expandedKeys.has(node.key)) {
                const children = node.children;
                if (children) {
                  const length = children.length;
                  for (let i = length - 1; i >= 0; --i) {
                    stack.push(children[i]);
                  }
                }
              }
            }
          }
          traverse2();
          return flattenNodes;
        });
        const isNotEmpty = computed(() => {
          return flattenTree.value.length > 0;
        });
        function createTree(data) {
          const treeNodeMap = /* @__PURE__ */ new Map();
          const levelTreeNodeMap = /* @__PURE__ */ new Map();
          let maxLevel = 1;
          function traverse2(nodes, level = 1, parent = void 0) {
            var _a2;
            const siblings = [];
            for (const rawNode of nodes) {
              const value = getKey(rawNode);
              const node = {
                level,
                key: value,
                data: rawNode
              };
              node.label = getLabel(rawNode);
              node.parent = parent;
              const children = getChildren(rawNode);
              node.disabled = getDisabled(rawNode);
              node.isLeaf = !children || children.length === 0;
              if (children && children.length) {
                node.children = traverse2(children, level + 1, node);
              }
              siblings.push(node);
              treeNodeMap.set(value, node);
              if (!levelTreeNodeMap.has(level)) {
                levelTreeNodeMap.set(level, []);
              }
              (_a2 = levelTreeNodeMap.get(level)) == null ? void 0 : _a2.push(node);
            }
            if (level > maxLevel) {
              maxLevel = level;
            }
            return siblings;
          }
          const treeNodes = traverse2(data);
          return {
            treeNodeMap,
            levelTreeNodeMap,
            maxLevel,
            treeNodes
          };
        }
        function filter(query) {
          const keys2 = doFilter(query);
          if (keys2) {
            expandedKeySet.value = keys2;
          }
        }
        function getChildren(node) {
          return node[childrenKey.value];
        }
        function getKey(node) {
          if (!node) {
            return "";
          }
          return node[valueKey.value];
        }
        function getDisabled(node) {
          return node[disabledKey.value];
        }
        function getLabel(node) {
          return node[labelKey.value];
        }
        function toggleExpand(node) {
          const expandedKeys = expandedKeySet.value;
          if (expandedKeys.has(node.key)) {
            collapseNode(node);
          } else {
            expandNode(node);
          }
        }
        function setExpandedKeys(keys2) {
          expandedKeySet.value = new Set(keys2);
        }
        function handleNodeClick(node, e) {
          emit2(NODE_CLICK, node.data, node, e);
          handleCurrentChange(node);
          if (props.expandOnClickNode) {
            toggleExpand(node);
          }
          if (props.showCheckbox && props.checkOnClickNode && !node.disabled) {
            toggleCheckbox(node, !isChecked(node), true);
          }
        }
        function handleCurrentChange(node) {
          if (!isCurrent(node)) {
            currentKey.value = node.key;
            emit2(CURRENT_CHANGE, node.data, node);
          }
        }
        function handleNodeCheck(node, checked) {
          toggleCheckbox(node, checked);
        }
        function expandNode(node) {
          const keySet = expandedKeySet.value;
          if (tree.value && props.accordion) {
            const { treeNodeMap } = tree.value;
            keySet.forEach((key) => {
              const treeNode = treeNodeMap.get(key);
              if (node && node.level === (treeNode == null ? void 0 : treeNode.level)) {
                keySet.delete(key);
              }
            });
          }
          keySet.add(node.key);
          emit2(NODE_EXPAND, node.data, node);
        }
        function collapseNode(node) {
          expandedKeySet.value.delete(node.key);
          emit2(NODE_COLLAPSE, node.data, node);
        }
        function isExpanded(node) {
          return expandedKeySet.value.has(node.key);
        }
        function isDisabled(node) {
          return !!node.disabled;
        }
        function isCurrent(node) {
          const current = currentKey.value;
          return !!current && current === node.key;
        }
        function getCurrentNode() {
          var _a2, _b;
          if (!currentKey.value)
            return void 0;
          return (_b = (_a2 = tree.value) == null ? void 0 : _a2.treeNodeMap.get(currentKey.value)) == null ? void 0 : _b.data;
        }
        function getCurrentKey() {
          return currentKey.value;
        }
        function setCurrentKey(key) {
          currentKey.value = key;
        }
        function setData(data) {
          nextTick(() => tree.value = createTree(data));
        }
        function getNode(data) {
          var _a2;
          const key = isObject$1(data) ? getKey(data) : data;
          return (_a2 = tree.value) == null ? void 0 : _a2.treeNodeMap.get(key);
        }
        return {
          tree,
          flattenTree,
          isNotEmpty,
          getKey,
          getChildren,
          toggleExpand,
          toggleCheckbox,
          isExpanded,
          isChecked,
          isIndeterminate,
          isDisabled,
          isCurrent,
          isForceHiddenExpandIcon,
          handleNodeClick,
          handleNodeCheck,
          getCurrentNode,
          getCurrentKey,
          setCurrentKey,
          getCheckedKeys,
          getCheckedNodes,
          getHalfCheckedKeys,
          getHalfCheckedNodes,
          setChecked: setChecked2,
          setCheckedKeys,
          filter,
          setData,
          getNode,
          expandNode,
          collapseNode,
          setExpandedKeys
        };
      }
      var ElNodeContent = defineComponent({
        name: "ElTreeNodeContent",
        props: treeNodeContentProps,
        setup(props) {
          const tree = inject(ROOT_TREE_INJECTION_KEY);
          const ns = useNamespace("tree");
          return () => {
            const node = props.node;
            const { data } = node;
            return (tree == null ? void 0 : tree.ctx.slots.default) ? tree.ctx.slots.default({ node, data }) : h("span", { class: ns.be("node", "label") }, [node == null ? void 0 : node.label]);
          };
        }
      });
      const _hoisted_1$s = ["aria-expanded", "aria-disabled", "aria-checked", "data-key", "onClick"];
      const __default__$3 = defineComponent({
        name: "ElTreeNode"
      });
      const _sfc_main$d = /* @__PURE__ */ defineComponent({
        ...__default__$3,
        props: treeNodeProps,
        emits: treeNodeEmits,
        setup(__props, { emit: emit2 }) {
          const props = __props;
          const tree = inject(ROOT_TREE_INJECTION_KEY);
          const ns = useNamespace("tree");
          const indent = computed(() => {
            var _a2;
            return (_a2 = tree == null ? void 0 : tree.props.indent) != null ? _a2 : 16;
          });
          const icon = computed(() => {
            var _a2;
            return (_a2 = tree == null ? void 0 : tree.props.icon) != null ? _a2 : caret_right_default;
          });
          const handleClick = (e) => {
            emit2("click", props.node, e);
          };
          const handleExpandIconClick = () => {
            emit2("toggle", props.node);
          };
          const handleCheckChange = (value) => {
            emit2("check", props.node, value);
          };
          const handleContextMenu = (event) => {
            var _a2, _b, _c, _d;
            if ((_c = (_b = (_a2 = tree == null ? void 0 : tree.instance) == null ? void 0 : _a2.vnode) == null ? void 0 : _b.props) == null ? void 0 : _c["onNodeContextmenu"]) {
              event.stopPropagation();
              event.preventDefault();
            }
            tree == null ? void 0 : tree.ctx.emit(NODE_CONTEXTMENU, event, (_d = props.node) == null ? void 0 : _d.data, props.node);
          };
          return (_ctx, _cache) => {
            var _a2, _b, _c;
            return openBlock(), createElementBlock("div", {
              ref: "node$",
              class: normalizeClass([
                unref(ns).b("node"),
                unref(ns).is("expanded", _ctx.expanded),
                unref(ns).is("current", _ctx.current),
                unref(ns).is("focusable", !_ctx.disabled),
                unref(ns).is("checked", !_ctx.disabled && _ctx.checked)
              ]),
              role: "treeitem",
              tabindex: "-1",
              "aria-expanded": _ctx.expanded,
              "aria-disabled": _ctx.disabled,
              "aria-checked": _ctx.checked,
              "data-key": (_a2 = _ctx.node) == null ? void 0 : _a2.key,
              onClick: withModifiers(handleClick, ["stop"]),
              onContextmenu: handleContextMenu
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).be("node", "content")),
                style: normalizeStyle({
                  paddingLeft: `${(_ctx.node.level - 1) * unref(indent)}px`,
                  height: _ctx.itemSize + "px"
                })
              }, [
                unref(icon) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass([
                    unref(ns).is("leaf", !!((_b = _ctx.node) == null ? void 0 : _b.isLeaf)),
                    unref(ns).is("hidden", _ctx.hiddenExpandIcon),
                    {
                      expanded: !((_c = _ctx.node) == null ? void 0 : _c.isLeaf) && _ctx.expanded
                    },
                    unref(ns).be("node", "expand-icon")
                  ]),
                  onClick: withModifiers(handleExpandIconClick, ["stop"])
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(icon))))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                _ctx.showCheckbox ? (openBlock(), createBlock(unref(ElCheckbox), {
                  key: 1,
                  "model-value": _ctx.checked,
                  indeterminate: _ctx.indeterminate,
                  disabled: _ctx.disabled,
                  onChange: handleCheckChange,
                  onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                  }, ["stop"]))
                }, null, 8, ["model-value", "indeterminate", "disabled"])) : createCommentVNode("v-if", true),
                createVNode(unref(ElNodeContent), { node: _ctx.node }, null, 8, ["node"])
              ], 6)
            ], 42, _hoisted_1$s);
          };
        }
      });
      var ElTreeNode = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree-node.vue"]]);
      const __default__$2 = defineComponent({
        name: "ElTreeV2"
      });
      const _sfc_main$c = /* @__PURE__ */ defineComponent({
        ...__default__$2,
        props: treeProps,
        emits: treeEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const slots = useSlots();
          const treeNodeSize = computed(() => props.itemSize);
          provide(ROOT_TREE_INJECTION_KEY, {
            ctx: {
              emit: emit2,
              slots
            },
            props,
            instance: getCurrentInstance()
          });
          provide(formItemContextKey, void 0);
          const { t } = useLocale();
          const ns = useNamespace("tree");
          const {
            flattenTree,
            isNotEmpty,
            toggleExpand,
            isExpanded,
            isIndeterminate,
            isChecked,
            isDisabled,
            isCurrent,
            isForceHiddenExpandIcon,
            handleNodeClick,
            handleNodeCheck,
            toggleCheckbox,
            getCurrentNode,
            getCurrentKey,
            setCurrentKey,
            getCheckedKeys,
            getCheckedNodes,
            getHalfCheckedKeys,
            getHalfCheckedNodes,
            setChecked: setChecked2,
            setCheckedKeys,
            filter,
            setData,
            getNode,
            expandNode,
            collapseNode,
            setExpandedKeys
          } = useTree(props, emit2);
          expose({
            toggleCheckbox,
            getCurrentNode,
            getCurrentKey,
            setCurrentKey,
            getCheckedKeys,
            getCheckedNodes,
            getHalfCheckedKeys,
            getHalfCheckedNodes,
            setChecked: setChecked2,
            setCheckedKeys,
            filter,
            setData,
            getNode,
            expandNode,
            collapseNode,
            setExpandedKeys
          });
          return (_ctx, _cache) => {
            var _a2;
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b(), { [unref(ns).m("highlight-current")]: _ctx.highlightCurrent }]),
              role: "tree"
            }, [
              unref(isNotEmpty) ? (openBlock(), createBlock(unref(FixedSizeList), {
                key: 0,
                "class-name": unref(ns).b("virtual-list"),
                data: unref(flattenTree),
                total: unref(flattenTree).length,
                height: _ctx.height,
                "item-size": unref(treeNodeSize),
                "perf-mode": _ctx.perfMode
              }, {
                default: withCtx(({ data, index, style }) => [
                  (openBlock(), createBlock(ElTreeNode, {
                    key: data[index].key,
                    style: normalizeStyle(style),
                    node: data[index],
                    expanded: unref(isExpanded)(data[index]),
                    "show-checkbox": _ctx.showCheckbox,
                    checked: unref(isChecked)(data[index]),
                    indeterminate: unref(isIndeterminate)(data[index]),
                    "item-size": unref(treeNodeSize),
                    disabled: unref(isDisabled)(data[index]),
                    current: unref(isCurrent)(data[index]),
                    "hidden-expand-icon": unref(isForceHiddenExpandIcon)(data[index]),
                    onClick: unref(handleNodeClick),
                    onToggle: unref(toggleExpand),
                    onCheck: unref(handleNodeCheck)
                  }, null, 8, ["style", "node", "expanded", "show-checkbox", "checked", "indeterminate", "item-size", "disabled", "current", "hidden-expand-icon", "onClick", "onToggle", "onCheck"]))
                ]),
                _: 1
              }, 8, ["class-name", "data", "total", "height", "item-size", "perf-mode"])) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).e("empty-block"))
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(unref(ns).e("empty-text"))
                }, toDisplayString((_a2 = _ctx.emptyText) != null ? _a2 : unref(t)("el.tree.emptyText")), 3)
              ], 2))
            ], 2);
          };
        }
      });
      var TreeV2 = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree.vue"]]);
      const ElTreeV2 = withInstall(TreeV2);
      const messageTypes = ["success", "info", "warning", "error"];
      const messageDefaults = mutable({
        customClass: "",
        center: false,
        dangerouslyUseHTMLString: false,
        duration: 3e3,
        icon: void 0,
        id: "",
        message: "",
        onClose: void 0,
        showClose: false,
        type: "info",
        offset: 16,
        zIndex: 0,
        grouping: false,
        repeatNum: 1,
        appendTo: isClient$1 ? document.body : void 0
      });
      const messageProps = buildProps({
        customClass: {
          type: String,
          default: messageDefaults.customClass
        },
        center: {
          type: Boolean,
          default: messageDefaults.center
        },
        dangerouslyUseHTMLString: {
          type: Boolean,
          default: messageDefaults.dangerouslyUseHTMLString
        },
        duration: {
          type: Number,
          default: messageDefaults.duration
        },
        icon: {
          type: iconPropType,
          default: messageDefaults.icon
        },
        id: {
          type: String,
          default: messageDefaults.id
        },
        message: {
          type: definePropType([
            String,
            Object,
            Function
          ]),
          default: messageDefaults.message
        },
        onClose: {
          type: definePropType(Function),
          required: false
        },
        showClose: {
          type: Boolean,
          default: messageDefaults.showClose
        },
        type: {
          type: String,
          values: messageTypes,
          default: messageDefaults.type
        },
        offset: {
          type: Number,
          default: messageDefaults.offset
        },
        zIndex: {
          type: Number,
          default: messageDefaults.zIndex
        },
        grouping: {
          type: Boolean,
          default: messageDefaults.grouping
        },
        repeatNum: {
          type: Number,
          default: messageDefaults.repeatNum
        }
      });
      const messageEmits = {
        destroy: () => true
      };
      const instances = shallowReactive([]);
      const getInstance = (id2) => {
        const idx = instances.findIndex((instance) => instance.id === id2);
        const current = instances[idx];
        let prev;
        if (idx > 0) {
          prev = instances[idx - 1];
        }
        return { current, prev };
      };
      const getLastOffset = (id2) => {
        const { prev } = getInstance(id2);
        if (!prev)
          return 0;
        return prev.vm.exposed.bottom.value;
      };
      const getOffsetOrSpace = (id2, offset) => {
        const idx = instances.findIndex((instance) => instance.id === id2);
        return idx > 0 ? 20 : offset;
      };
      const _hoisted_1$r = ["id"];
      const _hoisted_2$p = ["innerHTML"];
      const __default__$1 = defineComponent({
        name: "ElMessage"
      });
      const _sfc_main$b = /* @__PURE__ */ defineComponent({
        ...__default__$1,
        props: messageProps,
        emits: messageEmits,
        setup(__props, { expose }) {
          const props = __props;
          const { Close } = TypeComponents;
          const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("message");
          const { currentZIndex, nextZIndex } = zIndex2;
          const messageRef = ref();
          const visible = ref(false);
          const height = ref(0);
          let stopTimer = void 0;
          const badgeType = computed(() => props.type ? props.type === "error" ? "danger" : props.type : "info");
          const typeClass = computed(() => {
            const type2 = props.type;
            return { [ns.bm("icon", type2)]: type2 && TypeComponentsMap[type2] };
          });
          const iconComponent = computed(() => props.icon || TypeComponentsMap[props.type] || "");
          const lastOffset = computed(() => getLastOffset(props.id));
          const offset = computed(() => getOffsetOrSpace(props.id, props.offset) + lastOffset.value);
          const bottom = computed(() => height.value + offset.value);
          const customStyle = computed(() => ({
            top: `${offset.value}px`,
            zIndex: currentZIndex.value
          }));
          function startTimer() {
            if (props.duration === 0)
              return;
            ({ stop: stopTimer } = useTimeoutFn$1(() => {
              close2();
            }, props.duration));
          }
          function clearTimer() {
            stopTimer == null ? void 0 : stopTimer();
          }
          function close2() {
            visible.value = false;
          }
          function keydown({ code }) {
            if (code === EVENT_CODE.esc) {
              close2();
            }
          }
          onMounted(() => {
            startTimer();
            nextZIndex();
            visible.value = true;
          });
          watch(() => props.repeatNum, () => {
            clearTimer();
            startTimer();
          });
          useEventListener$1(document, "keydown", keydown);
          useResizeObserver(messageRef, () => {
            height.value = messageRef.value.getBoundingClientRect().height;
          });
          expose({
            visible,
            bottom,
            close: close2
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              onBeforeLeave: _ctx.onClose,
              onAfterLeave: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("destroy")),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  id: _ctx.id,
                  ref_key: "messageRef",
                  ref: messageRef,
                  class: normalizeClass([
                    unref(ns).b(),
                    { [unref(ns).m(_ctx.type)]: _ctx.type && !_ctx.icon },
                    unref(ns).is("center", _ctx.center),
                    unref(ns).is("closable", _ctx.showClose),
                    _ctx.customClass
                  ]),
                  style: normalizeStyle(unref(customStyle)),
                  role: "alert",
                  onMouseenter: clearTimer,
                  onMouseleave: startTimer
                }, [
                  _ctx.repeatNum > 1 ? (openBlock(), createBlock(unref(ElBadge), {
                    key: 0,
                    value: _ctx.repeatNum,
                    type: unref(badgeType),
                    class: normalizeClass(unref(ns).e("badge"))
                  }, null, 8, ["value", "type", "class"])) : createCommentVNode("v-if", true),
                  unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass([unref(ns).e("icon"), unref(typeClass)])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  renderSlot(_ctx.$slots, "default", {}, () => [
                    !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", {
                      key: 0,
                      class: normalizeClass(unref(ns).e("content"))
                    }, toDisplayString(_ctx.message), 3)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                      createBaseVNode("p", {
                        class: normalizeClass(unref(ns).e("content")),
                        innerHTML: _ctx.message
                      }, null, 10, _hoisted_2$p)
                    ], 2112))
                  ]),
                  _ctx.showClose ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 2,
                    class: normalizeClass(unref(ns).e("closeBtn")),
                    onClick: withModifiers(close2, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(Close))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ], 46, _hoisted_1$r), [
                  [vShow, visible.value]
                ])
              ]),
              _: 3
            }, 8, ["name", "onBeforeLeave"]);
          };
        }
      });
      var MessageConstructor = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]]);
      let seed$1 = 1;
      const normalizeOptions = (params) => {
        const options = !params || isString$1(params) || isVNode(params) || isFunction$1(params) ? { message: params } : params;
        const normalized = {
          ...messageDefaults,
          ...options
        };
        if (!normalized.appendTo) {
          normalized.appendTo = document.body;
        } else if (isString$1(normalized.appendTo)) {
          let appendTo = document.querySelector(normalized.appendTo);
          if (!isElement(appendTo)) {
            appendTo = document.body;
          }
          normalized.appendTo = appendTo;
        }
        return normalized;
      };
      const closeMessage = (instance) => {
        const idx = instances.indexOf(instance);
        if (idx === -1)
          return;
        instances.splice(idx, 1);
        const { handler } = instance;
        handler.close();
      };
      const createMessage = ({ appendTo, ...options }, context) => {
        const id2 = `message_${seed$1++}`;
        const userOnClose = options.onClose;
        const container = document.createElement("div");
        const props = {
          ...options,
          id: id2,
          onClose: () => {
            userOnClose == null ? void 0 : userOnClose();
            closeMessage(instance);
          },
          onDestroy: () => {
            render$h(null, container);
          }
        };
        const vnode = createVNode(MessageConstructor, props, isFunction$1(props.message) || isVNode(props.message) ? {
          default: isFunction$1(props.message) ? props.message : () => props.message
        } : null);
        vnode.appContext = context || message._context;
        render$h(vnode, container);
        appendTo.appendChild(container.firstElementChild);
        const vm = vnode.component;
        const handler = {
          close: () => {
            vm.exposed.visible.value = false;
          }
        };
        const instance = {
          id: id2,
          vnode,
          vm,
          handler,
          props: vnode.component.props
        };
        return instance;
      };
      const message = (options = {}, context) => {
        if (!isClient$1)
          return { close: () => void 0 };
        if (isNumber(messageConfig.max) && instances.length >= messageConfig.max) {
          return { close: () => void 0 };
        }
        const normalized = normalizeOptions(options);
        if (normalized.grouping && instances.length) {
          const instance2 = instances.find(({ vnode: vm }) => {
            var _a2;
            return ((_a2 = vm.props) == null ? void 0 : _a2.message) === normalized.message;
          });
          if (instance2) {
            instance2.props.repeatNum += 1;
            instance2.props.type = normalized.type;
            return instance2.handler;
          }
        }
        const instance = createMessage(normalized, context);
        instances.push(instance);
        return instance.handler;
      };
      messageTypes.forEach((type2) => {
        message[type2] = (options = {}, appContext) => {
          const normalized = normalizeOptions(options);
          return message({ ...normalized, type: type2 }, appContext);
        };
      });
      function closeAll$1(type2) {
        for (const instance of instances) {
          if (!type2 || type2 === instance.props.type) {
            instance.handler.close();
          }
        }
      }
      message.closeAll = closeAll$1;
      message._context = null;
      const ElMessage = withInstallFunction(message, "$message");
      const _sfc_main$a = defineComponent({
        name: "ElMessageBox",
        directives: {
          TrapFocus
        },
        components: {
          ElButton,
          ElFocusTrap,
          ElInput,
          ElOverlay,
          ElIcon,
          ...TypeComponents
        },
        inheritAttrs: false,
        props: {
          buttonSize: {
            type: String,
            validator: isValidComponentSize
          },
          modal: {
            type: Boolean,
            default: true
          },
          lockScroll: {
            type: Boolean,
            default: true
          },
          showClose: {
            type: Boolean,
            default: true
          },
          closeOnClickModal: {
            type: Boolean,
            default: true
          },
          closeOnPressEscape: {
            type: Boolean,
            default: true
          },
          closeOnHashChange: {
            type: Boolean,
            default: true
          },
          center: Boolean,
          draggable: Boolean,
          roundButton: {
            default: false,
            type: Boolean
          },
          container: {
            type: String,
            default: "body"
          },
          boxType: {
            type: String,
            default: ""
          }
        },
        emits: ["vanish", "action"],
        setup(props, { emit: emit2 }) {
          const {
            locale,
            zIndex: zIndex2,
            ns,
            size: btnSize
          } = useGlobalComponentSettings("message-box", computed(() => props.buttonSize));
          const { t } = locale;
          const { nextZIndex } = zIndex2;
          const visible = ref(false);
          const state = reactive({
            autofocus: true,
            beforeClose: null,
            callback: null,
            cancelButtonText: "",
            cancelButtonClass: "",
            confirmButtonText: "",
            confirmButtonClass: "",
            customClass: "",
            customStyle: {},
            dangerouslyUseHTMLString: false,
            distinguishCancelAndClose: false,
            icon: "",
            inputPattern: null,
            inputPlaceholder: "",
            inputType: "text",
            inputValue: null,
            inputValidator: null,
            inputErrorMessage: "",
            message: null,
            modalFade: true,
            modalClass: "",
            showCancelButton: false,
            showConfirmButton: true,
            type: "",
            title: void 0,
            showInput: false,
            action: "",
            confirmButtonLoading: false,
            cancelButtonLoading: false,
            confirmButtonDisabled: false,
            editorErrorMessage: "",
            validateError: false,
            zIndex: nextZIndex()
          });
          const typeClass = computed(() => {
            const type2 = state.type;
            return { [ns.bm("icon", type2)]: type2 && TypeComponentsMap[type2] };
          });
          const contentId = useId();
          const inputId = useId();
          const iconComponent = computed(() => state.icon || TypeComponentsMap[state.type] || "");
          const hasMessage = computed(() => !!state.message);
          const rootRef = ref();
          const headerRef = ref();
          const focusStartRef = ref();
          const inputRef = ref();
          const confirmRef = ref();
          const confirmButtonClasses = computed(() => state.confirmButtonClass);
          watch(() => state.inputValue, async (val) => {
            await nextTick();
            if (props.boxType === "prompt" && val !== null) {
              validate();
            }
          }, { immediate: true });
          watch(() => visible.value, (val) => {
            var _a2, _b;
            if (val) {
              if (props.boxType !== "prompt") {
                if (state.autofocus) {
                  focusStartRef.value = (_b = (_a2 = confirmRef.value) == null ? void 0 : _a2.$el) != null ? _b : rootRef.value;
                } else {
                  focusStartRef.value = rootRef.value;
                }
              }
              state.zIndex = nextZIndex();
            }
            if (props.boxType !== "prompt")
              return;
            if (val) {
              nextTick().then(() => {
                var _a22;
                if (inputRef.value && inputRef.value.$el) {
                  if (state.autofocus) {
                    focusStartRef.value = (_a22 = getInputElement()) != null ? _a22 : rootRef.value;
                  } else {
                    focusStartRef.value = rootRef.value;
                  }
                }
              });
            } else {
              state.editorErrorMessage = "";
              state.validateError = false;
            }
          });
          const draggable = computed(() => props.draggable);
          useDraggable(rootRef, headerRef, draggable);
          onMounted(async () => {
            await nextTick();
            if (props.closeOnHashChange) {
              window.addEventListener("hashchange", doClose);
            }
          });
          onBeforeUnmount(() => {
            if (props.closeOnHashChange) {
              window.removeEventListener("hashchange", doClose);
            }
          });
          function doClose() {
            if (!visible.value)
              return;
            visible.value = false;
            nextTick(() => {
              if (state.action)
                emit2("action", state.action);
            });
          }
          const handleWrapperClick = () => {
            if (props.closeOnClickModal) {
              handleAction(state.distinguishCancelAndClose ? "close" : "cancel");
            }
          };
          const overlayEvent = useSameTarget(handleWrapperClick);
          const handleInputEnter = (e) => {
            if (state.inputType !== "textarea") {
              e.preventDefault();
              return handleAction("confirm");
            }
          };
          const handleAction = (action) => {
            var _a2;
            if (props.boxType === "prompt" && action === "confirm" && !validate()) {
              return;
            }
            state.action = action;
            if (state.beforeClose) {
              (_a2 = state.beforeClose) == null ? void 0 : _a2.call(state, action, state, doClose);
            } else {
              doClose();
            }
          };
          const validate = () => {
            if (props.boxType === "prompt") {
              const inputPattern = state.inputPattern;
              if (inputPattern && !inputPattern.test(state.inputValue || "")) {
                state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
                state.validateError = true;
                return false;
              }
              const inputValidator = state.inputValidator;
              if (typeof inputValidator === "function") {
                const validateResult = inputValidator(state.inputValue);
                if (validateResult === false) {
                  state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
                  state.validateError = true;
                  return false;
                }
                if (typeof validateResult === "string") {
                  state.editorErrorMessage = validateResult;
                  state.validateError = true;
                  return false;
                }
              }
            }
            state.editorErrorMessage = "";
            state.validateError = false;
            return true;
          };
          const getInputElement = () => {
            const inputRefs = inputRef.value.$refs;
            return inputRefs.input || inputRefs.textarea;
          };
          const handleClose = () => {
            handleAction("close");
          };
          const onCloseRequested = () => {
            if (props.closeOnPressEscape) {
              handleClose();
            }
          };
          if (props.lockScroll) {
            useLockscreen(visible);
          }
          return {
            ...toRefs(state),
            ns,
            overlayEvent,
            visible,
            hasMessage,
            typeClass,
            contentId,
            inputId,
            btnSize,
            iconComponent,
            confirmButtonClasses,
            rootRef,
            focusStartRef,
            headerRef,
            inputRef,
            confirmRef,
            doClose,
            handleClose,
            onCloseRequested,
            handleWrapperClick,
            handleInputEnter,
            handleAction,
            t
          };
        }
      });
      const _hoisted_1$q = ["aria-label", "aria-describedby"];
      const _hoisted_2$o = ["aria-label"];
      const _hoisted_3$l = ["id"];
      function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_icon = resolveComponent("el-icon");
        const _component_close = resolveComponent("close");
        const _component_el_input = resolveComponent("el-input");
        const _component_el_button = resolveComponent("el-button");
        const _component_el_focus_trap = resolveComponent("el-focus-trap");
        const _component_el_overlay = resolveComponent("el-overlay");
        return openBlock(), createBlock(Transition, {
          name: "fade-in-linear",
          onAfterLeave: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("vanish")),
          persisted: ""
        }, {
          default: withCtx(() => [
            withDirectives(createVNode(_component_el_overlay, {
              "z-index": _ctx.zIndex,
              "overlay-class": [_ctx.ns.is("message-box"), _ctx.modalClass],
              mask: _ctx.modal
            }, {
              default: withCtx(() => [
                createBaseVNode("div", {
                  role: "dialog",
                  "aria-label": _ctx.title,
                  "aria-modal": "true",
                  "aria-describedby": !_ctx.showInput ? _ctx.contentId : void 0,
                  class: normalizeClass(`${_ctx.ns.namespace.value}-overlay-message-box`),
                  onClick: _cache[8] || (_cache[8] = (...args) => _ctx.overlayEvent.onClick && _ctx.overlayEvent.onClick(...args)),
                  onMousedown: _cache[9] || (_cache[9] = (...args) => _ctx.overlayEvent.onMousedown && _ctx.overlayEvent.onMousedown(...args)),
                  onMouseup: _cache[10] || (_cache[10] = (...args) => _ctx.overlayEvent.onMouseup && _ctx.overlayEvent.onMouseup(...args))
                }, [
                  createVNode(_component_el_focus_trap, {
                    loop: "",
                    trapped: _ctx.visible,
                    "focus-trap-el": _ctx.rootRef,
                    "focus-start-el": _ctx.focusStartRef,
                    onReleaseRequested: _ctx.onCloseRequested
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        ref: "rootRef",
                        class: normalizeClass([
                          _ctx.ns.b(),
                          _ctx.customClass,
                          _ctx.ns.is("draggable", _ctx.draggable),
                          { [_ctx.ns.m("center")]: _ctx.center }
                        ]),
                        style: normalizeStyle(_ctx.customStyle),
                        tabindex: "-1",
                        onClick: _cache[7] || (_cache[7] = withModifiers(() => {
                        }, ["stop"]))
                      }, [
                        _ctx.title !== null && _ctx.title !== void 0 ? (openBlock(), createElementBlock("div", {
                          key: 0,
                          ref: "headerRef",
                          class: normalizeClass(_ctx.ns.e("header"))
                        }, [
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.ns.e("title"))
                          }, [
                            _ctx.iconComponent && _ctx.center ? (openBlock(), createBlock(_component_el_icon, {
                              key: 0,
                              class: normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                            }, {
                              default: withCtx(() => [
                                (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                              ]),
                              _: 1
                            }, 8, ["class"])) : createCommentVNode("v-if", true),
                            createBaseVNode("span", null, toDisplayString(_ctx.title), 1)
                          ], 2),
                          _ctx.showClose ? (openBlock(), createElementBlock("button", {
                            key: 0,
                            type: "button",
                            class: normalizeClass(_ctx.ns.e("headerbtn")),
                            "aria-label": _ctx.t("el.messagebox.close"),
                            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel")),
                            onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
                          }, [
                            createVNode(_component_el_icon, {
                              class: normalizeClass(_ctx.ns.e("close"))
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_close)
                              ]),
                              _: 1
                            }, 8, ["class"])
                          ], 42, _hoisted_2$o)) : createCommentVNode("v-if", true)
                        ], 2)) : createCommentVNode("v-if", true),
                        createBaseVNode("div", {
                          id: _ctx.contentId,
                          class: normalizeClass(_ctx.ns.e("content"))
                        }, [
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.ns.e("container"))
                          }, [
                            _ctx.iconComponent && !_ctx.center && _ctx.hasMessage ? (openBlock(), createBlock(_component_el_icon, {
                              key: 0,
                              class: normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                            }, {
                              default: withCtx(() => [
                                (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                              ]),
                              _: 1
                            }, 8, ["class"])) : createCommentVNode("v-if", true),
                            _ctx.hasMessage ? (openBlock(), createElementBlock("div", {
                              key: 1,
                              class: normalizeClass(_ctx.ns.e("message"))
                            }, [
                              renderSlot(_ctx.$slots, "default", {}, () => [
                                !_ctx.dangerouslyUseHTMLString ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                                  key: 0,
                                  for: _ctx.showInput ? _ctx.inputId : void 0
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString(!_ctx.dangerouslyUseHTMLString ? _ctx.message : ""), 1)
                                  ]),
                                  _: 1
                                }, 8, ["for"])) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                                  key: 1,
                                  for: _ctx.showInput ? _ctx.inputId : void 0,
                                  innerHTML: _ctx.message
                                }, null, 8, ["for", "innerHTML"]))
                              ])
                            ], 2)) : createCommentVNode("v-if", true)
                          ], 2),
                          withDirectives(createBaseVNode("div", {
                            class: normalizeClass(_ctx.ns.e("input"))
                          }, [
                            createVNode(_component_el_input, {
                              id: _ctx.inputId,
                              ref: "inputRef",
                              modelValue: _ctx.inputValue,
                              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.inputValue = $event),
                              type: _ctx.inputType,
                              placeholder: _ctx.inputPlaceholder,
                              "aria-invalid": _ctx.validateError,
                              class: normalizeClass({ invalid: _ctx.validateError }),
                              onKeydown: withKeys(_ctx.handleInputEnter, ["enter"])
                            }, null, 8, ["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                            createBaseVNode("div", {
                              class: normalizeClass(_ctx.ns.e("errormsg")),
                              style: normalizeStyle({
                                visibility: !!_ctx.editorErrorMessage ? "visible" : "hidden"
                              })
                            }, toDisplayString(_ctx.editorErrorMessage), 7)
                          ], 2), [
                            [vShow, _ctx.showInput]
                          ])
                        ], 10, _hoisted_3$l),
                        createBaseVNode("div", {
                          class: normalizeClass(_ctx.ns.e("btns"))
                        }, [
                          _ctx.showCancelButton ? (openBlock(), createBlock(_component_el_button, {
                            key: 0,
                            loading: _ctx.cancelButtonLoading,
                            class: normalizeClass([_ctx.cancelButtonClass]),
                            round: _ctx.roundButton,
                            size: _ctx.btnSize,
                            onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleAction("cancel")),
                            onKeydown: _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.handleAction("cancel"), ["prevent"]), ["enter"]))
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(_ctx.cancelButtonText || _ctx.t("el.messagebox.cancel")), 1)
                            ]),
                            _: 1
                          }, 8, ["loading", "class", "round", "size"])) : createCommentVNode("v-if", true),
                          withDirectives(createVNode(_component_el_button, {
                            ref: "confirmRef",
                            type: "primary",
                            loading: _ctx.confirmButtonLoading,
                            class: normalizeClass([_ctx.confirmButtonClasses]),
                            round: _ctx.roundButton,
                            disabled: _ctx.confirmButtonDisabled,
                            size: _ctx.btnSize,
                            onClick: _cache[5] || (_cache[5] = ($event) => _ctx.handleAction("confirm")),
                            onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.handleAction("confirm"), ["prevent"]), ["enter"]))
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(_ctx.confirmButtonText || _ctx.t("el.messagebox.confirm")), 1)
                            ]),
                            _: 1
                          }, 8, ["loading", "class", "round", "disabled", "size"]), [
                            [vShow, _ctx.showConfirmButton]
                          ])
                        ], 2)
                      ], 6)
                    ]),
                    _: 3
                  }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
                ], 42, _hoisted_1$q)
              ]),
              _: 3
            }, 8, ["z-index", "overlay-class", "mask"]), [
              [vShow, _ctx.visible]
            ])
          ]),
          _: 3
        });
      }
      var MessageBoxConstructor = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["render", _sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/message-box/src/index.vue"]]);
      const messageInstance = /* @__PURE__ */ new Map();
      const getAppendToElement = (props) => {
        let appendTo = document.body;
        if (props.appendTo) {
          if (isString$1(props.appendTo)) {
            appendTo = document.querySelector(props.appendTo);
          }
          if (isElement(props.appendTo)) {
            appendTo = props.appendTo;
          }
          if (!isElement(appendTo)) {
            appendTo = document.body;
          }
        }
        return appendTo;
      };
      const initInstance = (props, container, appContext = null) => {
        const vnode = createVNode(MessageBoxConstructor, props, isFunction$1(props.message) || isVNode(props.message) ? {
          default: isFunction$1(props.message) ? props.message : () => props.message
        } : null);
        vnode.appContext = appContext;
        render$h(vnode, container);
        getAppendToElement(props).appendChild(container.firstElementChild);
        return vnode.component;
      };
      const genContainer = () => {
        return document.createElement("div");
      };
      const showMessage = (options, appContext) => {
        const container = genContainer();
        options.onVanish = () => {
          render$h(null, container);
          messageInstance.delete(vm);
        };
        options.onAction = (action) => {
          const currentMsg = messageInstance.get(vm);
          let resolve2;
          if (options.showInput) {
            resolve2 = { value: vm.inputValue, action };
          } else {
            resolve2 = action;
          }
          if (options.callback) {
            options.callback(resolve2, instance.proxy);
          } else {
            if (action === "cancel" || action === "close") {
              if (options.distinguishCancelAndClose && action !== "cancel") {
                currentMsg.reject("close");
              } else {
                currentMsg.reject("cancel");
              }
            } else {
              currentMsg.resolve(resolve2);
            }
          }
        };
        const instance = initInstance(options, container, appContext);
        const vm = instance.proxy;
        for (const prop in options) {
          if (hasOwn(options, prop) && !hasOwn(vm.$props, prop)) {
            vm[prop] = options[prop];
          }
        }
        vm.visible = true;
        return vm;
      };
      function MessageBox(options, appContext = null) {
        if (!isClient$1)
          return Promise.reject();
        let callback;
        if (isString$1(options) || isVNode(options)) {
          options = {
            message: options
          };
        } else {
          callback = options.callback;
        }
        return new Promise((resolve2, reject) => {
          const vm = showMessage(options, appContext != null ? appContext : MessageBox._context);
          messageInstance.set(vm, {
            options,
            callback,
            resolve: resolve2,
            reject
          });
        });
      }
      const MESSAGE_BOX_VARIANTS = ["alert", "confirm", "prompt"];
      const MESSAGE_BOX_DEFAULT_OPTS = {
        alert: { closeOnPressEscape: false, closeOnClickModal: false },
        confirm: { showCancelButton: true },
        prompt: { showCancelButton: true, showInput: true }
      };
      MESSAGE_BOX_VARIANTS.forEach((boxType) => {
        MessageBox[boxType] = messageBoxFactory(boxType);
      });
      function messageBoxFactory(boxType) {
        return (message2, title, options, appContext) => {
          let titleOrOpts = "";
          if (isObject$1(title)) {
            options = title;
            titleOrOpts = "";
          } else if (isUndefined(title)) {
            titleOrOpts = "";
          } else {
            titleOrOpts = title;
          }
          return MessageBox(Object.assign({
            title: titleOrOpts,
            message: message2,
            type: "",
            ...MESSAGE_BOX_DEFAULT_OPTS[boxType]
          }, options, {
            boxType
          }), appContext);
        };
      }
      MessageBox.close = () => {
        messageInstance.forEach((_, vm) => {
          vm.doClose();
        });
        messageInstance.clear();
      };
      MessageBox._context = null;
      const _MessageBox = MessageBox;
      _MessageBox.install = (app2) => {
        _MessageBox._context = app2._context;
        app2.config.globalProperties.$msgbox = _MessageBox;
        app2.config.globalProperties.$messageBox = _MessageBox;
        app2.config.globalProperties.$alert = _MessageBox.alert;
        app2.config.globalProperties.$confirm = _MessageBox.confirm;
        app2.config.globalProperties.$prompt = _MessageBox.prompt;
      };
      const ElMessageBox = _MessageBox;
      const notificationTypes = [
        "success",
        "info",
        "warning",
        "error"
      ];
      const notificationProps = buildProps({
        customClass: {
          type: String,
          default: ""
        },
        dangerouslyUseHTMLString: {
          type: Boolean,
          default: false
        },
        duration: {
          type: Number,
          default: 4500
        },
        icon: {
          type: iconPropType
        },
        id: {
          type: String,
          default: ""
        },
        message: {
          type: definePropType([String, Object]),
          default: ""
        },
        offset: {
          type: Number,
          default: 0
        },
        onClick: {
          type: definePropType(Function),
          default: () => void 0
        },
        onClose: {
          type: definePropType(Function),
          required: true
        },
        position: {
          type: String,
          values: ["top-right", "top-left", "bottom-right", "bottom-left"],
          default: "top-right"
        },
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        },
        type: {
          type: String,
          values: [...notificationTypes, ""],
          default: ""
        },
        zIndex: Number
      });
      const notificationEmits = {
        destroy: () => true
      };
      const _hoisted_1$p = ["id"];
      const _hoisted_2$n = ["textContent"];
      const _hoisted_3$k = { key: 0 };
      const _hoisted_4$7 = ["innerHTML"];
      const __default__ = defineComponent({
        name: "ElNotification"
      });
      const _sfc_main$9 = /* @__PURE__ */ defineComponent({
        ...__default__,
        props: notificationProps,
        emits: notificationEmits,
        setup(__props, { expose }) {
          const props = __props;
          const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("notification");
          const { nextZIndex, currentZIndex } = zIndex2;
          const { Close } = CloseComponents;
          const visible = ref(false);
          let timer = void 0;
          const typeClass = computed(() => {
            const type2 = props.type;
            return type2 && TypeComponentsMap[props.type] ? ns.m(type2) : "";
          });
          const iconComponent = computed(() => {
            if (!props.type)
              return props.icon;
            return TypeComponentsMap[props.type] || props.icon;
          });
          const horizontalClass = computed(() => props.position.endsWith("right") ? "right" : "left");
          const verticalProperty = computed(() => props.position.startsWith("top") ? "top" : "bottom");
          const positionStyle = computed(() => {
            var _a2;
            return {
              [verticalProperty.value]: `${props.offset}px`,
              zIndex: (_a2 = props.zIndex) != null ? _a2 : currentZIndex.value
            };
          });
          function startTimer() {
            if (props.duration > 0) {
              ({ stop: timer } = useTimeoutFn$1(() => {
                if (visible.value)
                  close2();
              }, props.duration));
            }
          }
          function clearTimer() {
            timer == null ? void 0 : timer();
          }
          function close2() {
            visible.value = false;
          }
          function onKeydown({ code }) {
            if (code === EVENT_CODE.delete || code === EVENT_CODE.backspace) {
              clearTimer();
            } else if (code === EVENT_CODE.esc) {
              if (visible.value) {
                close2();
              }
            } else {
              startTimer();
            }
          }
          onMounted(() => {
            startTimer();
            nextZIndex();
            visible.value = true;
          });
          useEventListener$1(document, "keydown", onKeydown);
          expose({
            visible,
            close: close2
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              onBeforeLeave: _ctx.onClose,
              onAfterLeave: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("destroy")),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  id: _ctx.id,
                  class: normalizeClass([unref(ns).b(), _ctx.customClass, unref(horizontalClass)]),
                  style: normalizeStyle(unref(positionStyle)),
                  role: "alert",
                  onMouseenter: clearTimer,
                  onMouseleave: startTimer,
                  onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
                }, [
                  unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass([unref(ns).e("icon"), unref(typeClass)])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ns).e("group"))
                  }, [
                    createBaseVNode("h2", {
                      class: normalizeClass(unref(ns).e("title")),
                      textContent: toDisplayString(_ctx.title)
                    }, null, 10, _hoisted_2$n),
                    withDirectives(createBaseVNode("div", {
                      class: normalizeClass(unref(ns).e("content")),
                      style: normalizeStyle(!!_ctx.title ? void 0 : { margin: 0 })
                    }, [
                      renderSlot(_ctx.$slots, "default", {}, () => [
                        !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", _hoisted_3$k, toDisplayString(_ctx.message), 1)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                          createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                          createBaseVNode("p", { innerHTML: _ctx.message }, null, 8, _hoisted_4$7)
                        ], 2112))
                      ])
                    ], 6), [
                      [vShow, _ctx.message]
                    ]),
                    _ctx.showClose ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(ns).e("closeBtn")),
                      onClick: withModifiers(close2, ["stop"])
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(Close))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 46, _hoisted_1$p), [
                  [vShow, visible.value]
                ])
              ]),
              _: 3
            }, 8, ["name", "onBeforeLeave"]);
          };
        }
      });
      var NotificationConstructor = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/notification/src/notification.vue"]]);
      const notifications = {
        "top-left": [],
        "top-right": [],
        "bottom-left": [],
        "bottom-right": []
      };
      const GAP_SIZE = 16;
      let seed = 1;
      const notify = function(options = {}, context = null) {
        if (!isClient$1)
          return { close: () => void 0 };
        if (typeof options === "string" || isVNode(options)) {
          options = { message: options };
        }
        const position = options.position || "top-right";
        let verticalOffset = options.offset || 0;
        notifications[position].forEach(({ vm: vm2 }) => {
          var _a2;
          verticalOffset += (((_a2 = vm2.el) == null ? void 0 : _a2.offsetHeight) || 0) + GAP_SIZE;
        });
        verticalOffset += GAP_SIZE;
        const id2 = `notification_${seed++}`;
        const userOnClose = options.onClose;
        const props = {
          ...options,
          offset: verticalOffset,
          id: id2,
          onClose: () => {
            close(id2, position, userOnClose);
          }
        };
        let appendTo = document.body;
        if (isElement(options.appendTo)) {
          appendTo = options.appendTo;
        } else if (isString$1(options.appendTo)) {
          appendTo = document.querySelector(options.appendTo);
        }
        if (!isElement(appendTo)) {
          appendTo = document.body;
        }
        const container = document.createElement("div");
        const vm = createVNode(NotificationConstructor, props, isVNode(props.message) ? {
          default: () => props.message
        } : null);
        vm.appContext = context != null ? context : notify._context;
        vm.props.onDestroy = () => {
          render$h(null, container);
        };
        render$h(vm, container);
        notifications[position].push({ vm });
        appendTo.appendChild(container.firstElementChild);
        return {
          close: () => {
            vm.component.exposed.visible.value = false;
          }
        };
      };
      notificationTypes.forEach((type2) => {
        notify[type2] = (options = {}) => {
          if (typeof options === "string" || isVNode(options)) {
            options = {
              message: options
            };
          }
          return notify({
            ...options,
            type: type2
          });
        };
      });
      function close(id2, position, userOnClose) {
        const orientedNotifications = notifications[position];
        const idx = orientedNotifications.findIndex(({ vm: vm2 }) => {
          var _a2;
          return ((_a2 = vm2.component) == null ? void 0 : _a2.props.id) === id2;
        });
        if (idx === -1)
          return;
        const { vm } = orientedNotifications[idx];
        if (!vm)
          return;
        userOnClose == null ? void 0 : userOnClose(vm);
        const removedHeight = vm.el.offsetHeight;
        const verticalPos = position.split("-")[0];
        orientedNotifications.splice(idx, 1);
        const len = orientedNotifications.length;
        if (len < 1)
          return;
        for (let i = idx; i < len; i++) {
          const { el, component } = orientedNotifications[i].vm;
          const pos = Number.parseInt(el.style[verticalPos], 10) - removedHeight - GAP_SIZE;
          component.props.offset = pos;
        }
      }
      function closeAll() {
        for (const orientedNotifications of Object.values(notifications)) {
          orientedNotifications.forEach(({ vm }) => {
            vm.component.exposed.visible.value = false;
          });
        }
      }
      notify.closeAll = closeAll;
      notify._context = null;
      const ElNotification = withInstallFunction(notify, "$notify");
      const _hoisted_1$o = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$m = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896a448 448 0 0 1 0-896zM288 512a38.4 38.4 0 0 0 38.4 38.4h371.2a38.4 38.4 0 0 0 0-76.8H326.4A38.4 38.4 0 0 0 288 512z"
      }, null, -1);
      const _hoisted_3$j = [
        _hoisted_2$m
      ];
      function render$g(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$o, _hoisted_3$j);
      }
      const __unplugin_components_13 = { name: "ep-remove-filled", render: render$g };
      const _hoisted_1$n = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$l = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M352 480h320a32 32 0 1 1 0 64H352a32 32 0 0 1 0-64z"
      }, null, -1);
      const _hoisted_3$i = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768a384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896a448 448 0 0 1 0 896z"
      }, null, -1);
      const _hoisted_4$6 = [
        _hoisted_2$l,
        _hoisted_3$i
      ];
      function render$f(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$n, _hoisted_4$6);
      }
      const __unplugin_components_12 = { name: "ep-remove", render: render$f };
      const _hoisted_1$m = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$k = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M352 192V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64H96a32 32 0 0 1 0-64h256zm64 0h192v-64H416v64zM192 960a32 32 0 0 1-32-32V256h704v672a32 32 0 0 1-32 32H192zm224-192a32 32 0 0 0 32-32V416a32 32 0 0 0-64 0v320a32 32 0 0 0 32 32zm192 0a32 32 0 0 0 32-32V416a32 32 0 0 0-64 0v320a32 32 0 0 0 32 32z"
      }, null, -1);
      const _hoisted_3$h = [
        _hoisted_2$k
      ];
      function render$e(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$m, _hoisted_3$h);
      }
      const __unplugin_components_2$2 = { name: "ep-delete-filled", render: render$e };
      const _hoisted_1$l = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$j = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32zm192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32z"
      }, null, -1);
      const _hoisted_3$g = [
        _hoisted_2$j
      ];
      function render$d(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$l, _hoisted_3$g);
      }
      const __unplugin_components_0$3 = { name: "ep-delete", render: render$d };
      const _hoisted_1$k = {
        key: 0,
        class: "default"
      };
      const _hoisted_2$i = {
        key: 0,
        class: "hover"
      };
      const _sfc_main$8 = /* @__PURE__ */ defineComponent({
        __name: "HoverButton",
        setup(__props) {
          let isHover = ref(false);
          return (_ctx, _cache) => {
            const _component_i_ep_Delete = __unplugin_components_0$3;
            const _component_el_icon = ElIcon;
            const _component_i_ep_DeleteFilled = __unplugin_components_2$2;
            return openBlock(), createElementBlock("span", {
              class: "container",
              onMouseenter: _cache[0] || (_cache[0] = ($event) => isRef(isHover) ? isHover.value = true : isHover = true),
              onMouseleave: _cache[1] || (_cache[1] = ($event) => isRef(isHover) ? isHover.value = false : isHover = false)
            }, [
              createVNode(Transition, null, {
                default: withCtx(() => [
                  !unref(isHover) ? (openBlock(), createElementBlock("span", _hoisted_1$k, [
                    renderSlot(_ctx.$slots, "default", {}, () => [
                      createVNode(_component_el_icon, null, {
                        default: withCtx(() => [
                          createVNode(_component_i_ep_Delete)
                        ]),
                        _: 1
                      })
                    ], true)
                  ])) : createCommentVNode("", true)
                ]),
                _: 3
              }),
              createVNode(Transition, null, {
                default: withCtx(() => [
                  unref(isHover) ? (openBlock(), createElementBlock("span", _hoisted_2$i, [
                    renderSlot(_ctx.$slots, "hover", {}, () => [
                      createVNode(_component_el_icon, null, {
                        default: withCtx(() => [
                          createVNode(_component_i_ep_DeleteFilled)
                        ]),
                        _: 1
                      })
                    ], true)
                  ])) : createCommentVNode("", true)
                ]),
                _: 3
              })
            ], 32);
          };
        }
      });
      const _export_sfc = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };
      const __unplugin_components_2$1 = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-c6eaee5b"]]);
      const _hoisted_1$j = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$h = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896a448 448 0 0 1 0-896zm-38.4 409.6H326.4a38.4 38.4 0 1 0 0 76.8h147.2v147.2a38.4 38.4 0 0 0 76.8 0V550.4h147.2a38.4 38.4 0 0 0 0-76.8H550.4V326.4a38.4 38.4 0 1 0-76.8 0v147.2z"
      }, null, -1);
      const _hoisted_3$f = [
        _hoisted_2$h
      ];
      function render$c(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$j, _hoisted_3$f);
      }
      const __unplugin_components_3$1 = { name: "ep-circle-plus-filled", render: render$c };
      const _hoisted_1$i = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$g = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M352 480h320a32 32 0 1 1 0 64H352a32 32 0 0 1 0-64z"
      }, null, -1);
      const _hoisted_3$e = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M480 672V352a32 32 0 1 1 64 0v320a32 32 0 0 1-64 0z"
      }, null, -1);
      const _hoisted_4$5 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768a384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896a448 448 0 0 1 0 896z"
      }, null, -1);
      const _hoisted_5$3 = [
        _hoisted_2$g,
        _hoisted_3$e,
        _hoisted_4$5
      ];
      function render$b(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$i, _hoisted_5$3);
      }
      const __unplugin_components_8$3 = { name: "ep-circle-plus", render: render$b };
      const _MatchRule = class _MatchRule {
        constructor(rule = {
          id: void 0,
          //* 规则id
          main: {
            name: void 0,
            //* 规则名称
            domainName: void 0,
            //* 作用域
            pathFilter: {
              pattern: void 0,
              //* 作用域
              flags: void 0
              //* 作用域
            },
            titleSelector: void 0
            //* 标题选择器
          },
          domItem: {
            //* 时候启用dom限定(开启后将以该项指定的dom作为起点查找查询其他项目)
            enable: void 0,
            selector: void 0
          },
          linkUrl: {
            selector: void 0,
            infoType: void 0,
            attribute: void 0
          },
          picUrl: {
            enable: void 0,
            origin: void 0,
            selector: void 0,
            infoType: void 0,
            attribute: void 0
          },
          name: {
            enable: void 0,
            origin: void 0,
            selector: void 0,
            infoType: void 0,
            attribute: void 0
          },
          meta: {
            enable: void 0,
            origin: void 0,
            selector: void 0,
            infoType: void 0,
            attribute: void 0
          }
        }, status = {
          editing: false,
          isNewCreated: false
        }) {
          //* 计数器
          //* 主要数据枚举
          __publicField(this, "enumMainKey", ["main", "domItem", "linkUrl", "picUrl", "name", "meta"]);
          __publicField(this, "enumMatchItemKey", ["selector", "attribute"]);
          __publicField(this, "matchItemCount", 1);
          //* 当前匹配项条数
          __publicField(this, "id");
          __publicField(this, "main");
          __publicField(this, "domItem");
          __publicField(this, "linkUrl");
          __publicField(this, "picUrl");
          __publicField(this, "name");
          __publicField(this, "meta");
          __publicField(this, "status");
          //* 状态对象;
          __publicField(this, "backup");
          //f 获取当前匹配条目数量
          __publicField(this, "getMatchItemCount", () => {
            let max = 0;
            for (const key of this.enumMainKey) {
              Object.keys(this.linkUrl).forEach((item) => {
                if (this.enumMatchItemKey.includes(item)) {
                  if (max < this[key][item].length) {
                    max = this[key][item].length;
                  }
                }
              });
            }
            return max;
          });
          //f 创建备份
          __publicField(this, "createBackup", () => {
            this.backup = {};
            for (const key of this.enumMainKey) {
              this.backup[key] = JSON.parse(JSON.stringify(this[key]));
            }
          });
          //f 删除备份
          __publicField(this, "removeBackup", () => {
            this.backup = null;
          });
          //f 通过备份还原
          __publicField(this, "restoreByBackup", () => {
            if (this.backup != null) {
              this.enumMainKey.forEach((key) => {
                this[key] = this.backup[key];
              });
            }
          });
          //f 生成JSON数据(用于存储)
          __publicField(this, "getJsonData", () => {
            const jsonObj = {
              id: this.id,
              main: this.main,
              domItem: this.domItem,
              linkUrl: this.linkUrl,
              picUrl: this.picUrl,
              name: this.name,
              meta: this.meta
            };
            return JSON.stringify(jsonObj);
          });
          //f 生成uuid
          __publicField(this, "buildUUID", () => {
            const hexList = [];
            for (let i = 0; i <= 15; i++) {
              hexList[i] = i.toString(16);
            }
            let uuid = "";
            for (let i = 1; i <= 36; i++) {
              if (i === 9 || i === 14 || i === 19 || i === 24) {
                uuid += "-";
              } else if (i === 15) {
                uuid += 4;
              } else if (i === 20) {
                uuid += hexList[Math.random() * 4 | 8];
              } else {
                uuid += hexList[Math.random() * 16 | 0];
              }
            }
            return uuid.replace(/-/g, "");
          });
          _MatchRule.count++;
          //! 主要参数
          rule = rule || {};
          rule["main"] = rule["main"] || {};
          rule["main"]["pathFilter"] = rule["main"]["pathFilter"] || {};
          rule["domItem"] = rule["domItem"] || {};
          rule["linkUrl"] = rule["linkUrl"] || {};
          rule["picUrl"] = rule["picUrl"] || {};
          rule["name"] = rule["name"] || {};
          rule["meta"] = rule["meta"] || {};
          this.id = rule["id"] || (() => this.buildUUID())();
          this.main = {
            name: rule["main"].name || "新规则",
            domainName: rule["main"].domainName || location.origin,
            pathFilter: {
              pattern: rule["main"]["pathFilter"].pattern || "",
              flags: rule["main"]["pathFilter"].flags || []
            },
            titleSelector: rule["main"].titleSelector || ""
          };
          this.domItem = {
            enable: rule["domItem"].enable || false,
            selector: rule["domItem"].selector || [""]
          };
          this.linkUrl = {
            selector: rule["linkUrl"].selector || [""],
            infoType: rule["linkUrl"].infoType || 3,
            attribute: rule["linkUrl"].attribute || [""]
          };
          this.picUrl = {
            enable: rule["picUrl"].enable || false,
            origin: rule["picUrl"].origin || 0,
            selector: rule["picUrl"].selector || [""],
            infoType: rule["picUrl"].infoType || 3,
            attribute: rule["picUrl"].attribute || [""]
          };
          this.name = {
            enable: rule["name"].enable || false,
            origin: rule["name"].origin || 0,
            selector: rule["name"].selector || [""],
            infoType: rule["name"].infoType || 4,
            attribute: rule["name"].attribute || [""]
          };
          this.meta = {
            enable: rule["meta"].enable || true,
            origin: rule["meta"].origin || 0,
            selector: rule["meta"].selector || [""],
            infoType: rule["meta"].infoType || 3,
            attribute: rule["meta"].attribute || [""]
          };
          status = status || {};
          this.status = {
            editing: status["editing"] || false,
            //* 编辑状态标记
            isNewCreated: status["isNewCreated"] || false
            //* 标记是否为新创建的规则
          };
          this.backup = null;
        }
      };
      //? 静态成员
      __publicField(_MatchRule, "count", 0);
      let MatchRule = _MatchRule;
      const _hoisted_1$h = { style: { "flex-grow": "1" } };
      const _hoisted_2$f = { style: { "flex-grow": "1" } };
      const _hoisted_3$d = { class: "side-button add-match-item" };
      const _hoisted_4$4 = { class: "side-button remove-match-item" };
      const _hoisted_5$2 = { style: { "flex-grow": "1" } };
      const _hoisted_6$2 = { class: "side-button add-match-item" };
      const _hoisted_7$2 = { class: "side-button remove-match-item" };
      const _hoisted_8$1 = { style: { "flex-grow": "1" } };
      const _hoisted_9$1 = { class: "side-button add-match-item" };
      const _hoisted_10$1 = { class: "side-button remove-match-item" };
      const _hoisted_11$1 = { style: { "flex-grow": "1" } };
      const _hoisted_12$1 = { class: "side-button add-match-item" };
      const _hoisted_13 = { class: "side-button remove-match-item" };
      const _hoisted_14 = { style: { "flex-grow": "1" } };
      const _hoisted_15 = { class: "side-button add-match-item" };
      const _hoisted_16 = { class: "side-button remove-match-item" };
      const _hoisted_17 = { style: { "flex-grow": "1" } };
      const _hoisted_18 = { class: "side-button add-match-item" };
      const _hoisted_19 = { class: "side-button remove-match-item" };
      const _hoisted_20 = { style: { "flex-grow": "1" } };
      const _hoisted_21 = { class: "side-button add-match-item" };
      const _hoisted_22 = { class: "side-button remove-match-item" };
      const _hoisted_23 = { style: { "flex-grow": "1" } };
      const _hoisted_24 = { class: "side-button add-match-item" };
      const _hoisted_25 = { class: "side-button remove-match-item" };
      const _hoisted_26 = { style: { "flex-grow": "1" } };
      const _hoisted_27 = { class: "side-button add-match-item" };
      const _hoisted_28 = { class: "side-button remove-match-item" };
      const _sfc_main$7 = /* @__PURE__ */ defineComponent({
        __name: "RuleForm",
        props: {
          formData: {
            type: MatchRule
          }
        },
        setup(__props) {
          const props = __props;
          const info = reactive({
            activeName: "main"
          });
          const pushMatchItem = (index) => {
            const rule = props.formData;
            for (const key of rule.enumMainKey) {
              for (const item of Object.keys(rule[key])) {
                if (rule.enumMatchItemKey.includes(item)) {
                  rule[key][item].splice(index + 1, 0, "");
                }
              }
            }
            rule.matchItemCount++;
          };
          const removeMatchItem = (index) => {
            const rule = props.formData;
            if (rule.matchItemCount <= 1) {
              return;
            }
            for (const key of rule.enumMainKey) {
              for (const item of Object.keys(rule[key])) {
                if (rule.enumMatchItemKey.includes(item)) {
                  rule[key][item].splice(index, 1);
                }
              }
            }
            rule.matchItemCount--;
          };
          watch(
            () => props.formData,
            (newVal, oldVal) => {
              info.activeName = "main";
            }
          );
          return (_ctx, _cache) => {
            const _component_el_input = ElInput;
            const _component_el_form_item = ElFormItem;
            const _component_el_option = ElOption;
            const _component_el_tooltip = ElTooltip;
            const _component_el_select = ElSelect;
            const _component_el_form = ElForm;
            const _component_el_tab_pane = ElTabPane;
            const _component_el_checkbox = ElCheckbox;
            const _component_i_ep_CirclePlus = __unplugin_components_8$3;
            const _component_el_icon = ElIcon;
            const _component_i_ep_CirclePlusFilled = __unplugin_components_3$1;
            const _component_HoverButton = __unplugin_components_2$1;
            const _component_i_ep_Remove = __unplugin_components_12;
            const _component_i_ep_RemoveFilled = __unplugin_components_13;
            const _component_el_tabs = ElTabs;
            return __props.formData != void 0 ? (openBlock(), createBlock(_component_el_tabs, {
              key: 0,
              modelValue: unref(info).activeName,
              "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => unref(info).activeName = $event),
              type: "border-card",
              onTabClick: _cache[15] || (_cache[15] = () => {
              })
            }, {
              default: withCtx(() => [
                createVNode(_component_el_tab_pane, {
                  label: "首选项",
                  name: "main"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: __props.formData.main,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_form_item, { label: "规则名称" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_input, {
                              modelValue: __props.formData.main.name,
                              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => __props.formData.main.name = $event)
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_form_item, { label: "根网址" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_input, {
                              modelValue: __props.formData.main.domainName,
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => __props.formData.main.domainName = $event)
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_form_item, { label: "路径过滤器" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_input, {
                              modelValue: __props.formData.main.pathFilter.pattern,
                              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => __props.formData.main.pathFilter.pattern = $event),
                              placeholder: "(正则表达式)"
                            }, {
                              prefix: withCtx(() => [
                                createTextVNode(" / ")
                              ]),
                              suffix: withCtx(() => [
                                createTextVNode(" / ")
                              ]),
                              append: withCtx(() => [
                                createVNode(_component_el_select, {
                                  style: { "width": "180px" },
                                  multiple: "",
                                  modelValue: __props.formData.main.pathFilter.flags,
                                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => __props.formData.main.pathFilter.flags = $event),
                                  placeholder: "修饰符"
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_tooltip, {
                                      "show-after": 500,
                                      effect: "dark",
                                      content: "global - 全局匹配",
                                      placement: "top"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(_component_el_option, {
                                          value: "g",
                                          label: "g"
                                        })
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(_component_el_tooltip, {
                                      "show-after": 500,
                                      effect: "dark",
                                      content: "ignore - 不区分大小写",
                                      placement: "top"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(_component_el_option, {
                                          value: "i",
                                          label: "i"
                                        })
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(_component_el_tooltip, {
                                      "show-after": 500,
                                      effect: "dark",
                                      content: "特殊字符圆点 . 中包含换行符 \\n",
                                      placement: "top"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(_component_el_option, {
                                          value: "s",
                                          label: "s"
                                        })
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 1
                                }, 8, ["modelValue"])
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_form_item, { label: "标题选择器" }, {
                          default: withCtx(() => [
                            createBaseVNode("span", _hoisted_1$h, [
                              createVNode(_component_el_input, {
                                modelValue: __props.formData.main.titleSelector,
                                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => __props.formData.main.titleSelector = $event),
                                type: "text"
                              }, null, 8, ["modelValue"])
                            ])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_tab_pane, {
                  label: "dom限定",
                  name: "domItem"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: __props.formData.domItem,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_form_item, { label: "启用" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_checkbox, {
                              modelValue: __props.formData.domItem.enable,
                              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => __props.formData.domItem.enable = $event),
                              type: "checkbox"
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        __props.formData.domItem.enable ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(__props.formData.domItem.selector, (selector, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `css选择器${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_2$f, [
                                createVNode(_component_el_input, {
                                  modelValue: __props.formData.domItem.selector[index],
                                  "onUpdate:modelValue": ($event) => __props.formData.domItem.selector[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_3$d, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_4$4, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true)
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_tab_pane, {
                  label: "链接(必填)",
                  name: "linkUrl"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: __props.formData.linkUrl,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.formData.linkUrl.selector, (selector, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `css选择器${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_5$2, [
                                createVNode(_component_el_input, {
                                  modelValue: __props.formData.linkUrl.selector[index],
                                  "onUpdate:modelValue": ($event) => __props.formData.linkUrl.selector[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_6$2, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_7$2, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)),
                        createVNode(_component_el_form_item, { label: "提取类型" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: __props.formData.linkUrl.infoType,
                              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => __props.formData.linkUrl.infoType = $event),
                              placeholder: "选择要提取的类型"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "值"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "Attribute属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "Property属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 4,
                                  label: "innerText 内部文本"
                                }),
                                createVNode(_component_el_option, {
                                  value: 5,
                                  label: "innerHTML 内部HTML"
                                }),
                                createVNode(_component_el_option, {
                                  value: 6,
                                  label: "outerHTML 全部HTML"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.formData.linkUrl.attribute, (attribute, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `匹配属性${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_8$1, [
                                createVNode(_component_el_input, {
                                  modelValue: __props.formData.linkUrl.attribute[index],
                                  "onUpdate:modelValue": ($event) => __props.formData.linkUrl.attribute[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_9$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_10$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_tab_pane, {
                  label: "图链",
                  name: "picUrl"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: __props.formData.picUrl,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_form_item, { label: "启用" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_checkbox, {
                              modelValue: __props.formData.picUrl.enable,
                              "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => __props.formData.picUrl.enable = $event),
                              type: "checkbox"
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        __props.formData.picUrl.enable ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(__props.formData.picUrl.selector, (selector, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `css选择器${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_11$1, [
                                createVNode(_component_el_input, {
                                  modelValue: __props.formData.picUrl.selector[index],
                                  "onUpdate:modelValue": ($event) => __props.formData.picUrl.selector[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_12$1, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_13, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true),
                        __props.formData.picUrl.enable ? (openBlock(), createBlock(_component_el_form_item, {
                          key: 1,
                          label: "提取类型"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: __props.formData.picUrl.infoType,
                              "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => __props.formData.picUrl.infoType = $event),
                              placeholder: "选择要提取的类型"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "值"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "Attribute属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "Property属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 4,
                                  label: "innerText 内部文本"
                                }),
                                createVNode(_component_el_option, {
                                  value: 5,
                                  label: "innerHTML 内部HTML"
                                }),
                                createVNode(_component_el_option, {
                                  value: 6,
                                  label: "outerHTML 全部HTML"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })) : createCommentVNode("", true),
                        __props.formData.picUrl.enable ? (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(__props.formData.picUrl.attribute, (attribute, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `匹配属性${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_14, [
                                createVNode(_component_el_input, {
                                  modelValue: __props.formData.picUrl.attribute[index],
                                  "onUpdate:modelValue": ($event) => __props.formData.picUrl.attribute[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_15, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_16, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true)
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_tab_pane, {
                  label: "名称",
                  name: "name"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: __props.formData.name,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_form_item, { label: "启用" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_checkbox, {
                              modelValue: __props.formData.name.enable,
                              "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => __props.formData.name.enable = $event),
                              type: "checkbox"
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        __props.formData.name.enable ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(__props.formData.name.selector, (selector, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `css选择器${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_17, [
                                createVNode(_component_el_input, {
                                  modelValue: __props.formData.name.selector[index],
                                  "onUpdate:modelValue": ($event) => __props.formData.name.selector[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_18, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_19, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true),
                        __props.formData.name.enable ? (openBlock(), createBlock(_component_el_form_item, {
                          key: 1,
                          label: "提取类型"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: __props.formData.name.infoType,
                              "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => __props.formData.name.infoType = $event),
                              placeholder: "选择要提取的类型"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "值"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "Attribute属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "Property属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 4,
                                  label: "innerText 内部文本"
                                }),
                                createVNode(_component_el_option, {
                                  value: 5,
                                  label: "innerHTML 内部HTML"
                                }),
                                createVNode(_component_el_option, {
                                  value: 6,
                                  label: "outerHTML 全部HTML"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })) : createCommentVNode("", true),
                        __props.formData.name.enable ? (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(__props.formData.name.attribute, (attribute, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `匹配属性${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_20, [
                                createVNode(_component_el_input, {
                                  modelValue: __props.formData.name.attribute[index],
                                  "onUpdate:modelValue": ($event) => __props.formData.name.attribute[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_21, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_22, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true)
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_tab_pane, {
                  label: "元信息",
                  name: "meta"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_form, {
                      model: __props.formData.meta,
                      "label-width": "100px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_form_item, { label: "启用" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_checkbox, {
                              modelValue: __props.formData.meta.enable,
                              "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => __props.formData.meta.enable = $event),
                              type: "checkbox"
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        __props.formData.meta.enable ? (openBlock(), createBlock(_component_el_form_item, {
                          key: 0,
                          label: "提取类型"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: __props.formData.meta.origin,
                              "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => __props.formData.meta.origin = $event),
                              placeholder: "提取来源"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 0,
                                  label: "单独指定目标dom"
                                }),
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "从“链接”dom获取"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "从“图链”dom获取"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "从“名称”dom获取"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })) : createCommentVNode("", true),
                        __props.formData.meta.enable && __props.formData.meta.origin === 0 ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(__props.formData.meta.selector, (selector, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `css选择器${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_23, [
                                createVNode(_component_el_input, {
                                  modelValue: __props.formData.meta.selector[index],
                                  "onUpdate:modelValue": ($event) => __props.formData.meta.selector[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_24, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_25, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true),
                        __props.formData.meta.enable ? (openBlock(), createBlock(_component_el_form_item, {
                          key: 2,
                          label: "提取类型"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: __props.formData.meta.infoType,
                              "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => __props.formData.meta.infoType = $event),
                              placeholder: "选择要提取的类型"
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_option, {
                                  value: 1,
                                  label: "值"
                                }),
                                createVNode(_component_el_option, {
                                  value: 2,
                                  label: "Attribute属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 3,
                                  label: "Property属性"
                                }),
                                createVNode(_component_el_option, {
                                  value: 4,
                                  label: "innerText 内部文本"
                                }),
                                createVNode(_component_el_option, {
                                  value: 5,
                                  label: "innerHTML 内部HTML"
                                }),
                                createVNode(_component_el_option, {
                                  value: 6,
                                  label: "outerHTML 全部HTML"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })) : createCommentVNode("", true),
                        __props.formData.meta.enable ? (openBlock(true), createElementBlock(Fragment, { key: 3 }, renderList(__props.formData.meta.attribute, (attribute, index) => {
                          return openBlock(), createBlock(_component_el_form_item, {
                            label: `匹配属性${index + 1}`,
                            key: index
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_26, [
                                createVNode(_component_el_input, {
                                  modelValue: __props.formData.meta.attribute[index],
                                  "onUpdate:modelValue": ($event) => __props.formData.meta.attribute[index] = $event,
                                  type: "text"
                                }, null, 8, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              createBaseVNode("span", _hoisted_27, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => pushMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlus)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ]),
                              createBaseVNode("span", _hoisted_28, [
                                createVNode(_component_HoverButton, {
                                  onClick: ($event) => removeMatchItem(index)
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_Remove)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  hover: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_RemoveFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"])
                              ])
                            ]),
                            _: 2
                          }, 1032, ["label"]);
                        }), 128)) : createCommentVNode("", true)
                      ]),
                      _: 1
                    }, 8, ["model"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["modelValue"])) : createCommentVNode("", true);
          };
        }
      });
      const __unplugin_components_8$2 = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-5a33bf4c"]]);
      function tryOnScopeDispose(fn2) {
        if (getCurrentScope()) {
          onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      function toValue(r) {
        return typeof r === "function" ? r() : unref(r);
      }
      const isClient = typeof window !== "undefined";
      const noop = () => {
      };
      function toRef(...args) {
        if (args.length !== 1)
          return toRef$1(...args);
        const r = args[0];
        return typeof r === "function" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);
      }
      function tryOnMounted(fn2, sync = true) {
        if (getCurrentInstance())
          onMounted(fn2);
        else if (sync)
          fn2();
        else
          nextTick(fn2);
      }
      function useTimeoutFn(cb, interval, options = {}) {
        const {
          immediate = true
        } = options;
        const isPending = ref(false);
        let timer = null;
        function clear2() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function stop() {
          isPending.value = false;
          clear2();
        }
        function start(...args) {
          clear2();
          isPending.value = true;
          timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            cb(...args);
          }, toValue(interval));
        }
        if (immediate) {
          isPending.value = true;
          if (isClient)
            start();
        }
        tryOnScopeDispose(stop);
        return {
          isPending: readonly(isPending),
          start,
          stop
        };
      }
      function unrefElement(elRef) {
        var _a2;
        const plain = toValue(elRef);
        return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
      }
      const defaultWindow = isClient ? window : void 0;
      const defaultNavigator = isClient ? window.navigator : void 0;
      function useEventListener(...args) {
        let target;
        let events;
        let listeners;
        let options;
        if (typeof args[0] === "string" || Array.isArray(args[0])) {
          [events, listeners, options] = args;
          target = defaultWindow;
        } else {
          [target, events, listeners, options] = args;
        }
        if (!target)
          return noop;
        if (!Array.isArray(events))
          events = [events];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = watch(
          () => [unrefElement(target), toValue(options)],
          ([el, options2]) => {
            cleanup();
            if (!el)
              return;
            cleanups.push(
              ...events.flatMap((event) => {
                return listeners.map((listener) => register(el, event, listener, options2));
              })
            );
          },
          { immediate: true, flush: "post" }
        );
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose(stop);
        return stop;
      }
      function useMounted() {
        const isMounted = ref(false);
        if (getCurrentInstance()) {
          onMounted(() => {
            isMounted.value = true;
          });
        }
        return isMounted;
      }
      function useSupported(callback) {
        const isMounted = useMounted();
        return computed(() => {
          isMounted.value;
          return Boolean(callback());
        });
      }
      function useMediaQuery(query, options = {}) {
        const { window: window2 = defaultWindow } = options;
        const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
        let mediaQuery;
        const matches = ref(false);
        const cleanup = () => {
          if (!mediaQuery)
            return;
          if ("removeEventListener" in mediaQuery)
            mediaQuery.removeEventListener("change", update);
          else
            mediaQuery.removeListener(update);
        };
        const update = () => {
          if (!isSupported.value)
            return;
          cleanup();
          mediaQuery = window2.matchMedia(toRef(query).value);
          matches.value = !!(mediaQuery == null ? void 0 : mediaQuery.matches);
          if (!mediaQuery)
            return;
          if ("addEventListener" in mediaQuery)
            mediaQuery.addEventListener("change", update);
          else
            mediaQuery.addListener(update);
        };
        watchEffect(update);
        tryOnScopeDispose(() => cleanup());
        return matches;
      }
      function useClipboard(options = {}) {
        const {
          navigator: navigator2 = defaultNavigator,
          read = false,
          source,
          copiedDuring = 1500,
          legacy = false
        } = options;
        const events = ["copy", "cut"];
        const isClipboardApiSupported = useSupported(() => navigator2 && "clipboard" in navigator2);
        const isSupported = computed(() => isClipboardApiSupported.value || legacy);
        const text = ref("");
        const copied = ref(false);
        const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);
        function updateText() {
          if (isClipboardApiSupported.value) {
            navigator2.clipboard.readText().then((value) => {
              text.value = value;
            });
          } else {
            text.value = legacyRead();
          }
        }
        if (isSupported.value && read) {
          for (const event of events)
            useEventListener(event, updateText);
        }
        async function copy(value = toValue(source)) {
          if (isSupported.value && value != null) {
            if (isClipboardApiSupported.value)
              await navigator2.clipboard.writeText(value);
            else
              legacyCopy(value);
            text.value = value;
            copied.value = true;
            timeout.start();
          }
        }
        function legacyCopy(value) {
          const ta = document.createElement("textarea");
          ta.value = value != null ? value : "";
          ta.style.position = "absolute";
          ta.style.opacity = "0";
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          ta.remove();
        }
        function legacyRead() {
          var _a2, _b, _c;
          return (_c = (_b = (_a2 = document == null ? void 0 : document.getSelection) == null ? void 0 : _a2.call(document)) == null ? void 0 : _b.toString()) != null ? _c : "";
        }
        return {
          isSupported,
          text,
          copied,
          copy
        };
      }
      function useWindowSize(options = {}) {
        const {
          window: window2 = defaultWindow,
          initialWidth = Infinity,
          initialHeight = Infinity,
          listenOrientation = true,
          includeScrollbar = true
        } = options;
        const width = ref(initialWidth);
        const height = ref(initialHeight);
        const update = () => {
          if (window2) {
            if (includeScrollbar) {
              width.value = window2.innerWidth;
              height.value = window2.innerHeight;
            } else {
              width.value = window2.document.documentElement.clientWidth;
              height.value = window2.document.documentElement.clientHeight;
            }
          }
        };
        update();
        tryOnMounted(update);
        useEventListener("resize", update, { passive: true });
        if (listenOrientation) {
          const matches = useMediaQuery("(orientation: portrait)");
          watch(matches, () => update());
        }
        return { width, height };
      }
      var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
      var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();
      var _GM_xmlhttpRequest = /* @__PURE__ */ (() => typeof GM_xmlhttpRequest != "undefined" ? GM_xmlhttpRequest : void 0)();
      var _unsafeWindow = /* @__PURE__ */ (() => typeof unsafeWindow != "undefined" ? unsafeWindow : void 0)();
      const useAppInfoStore = defineStore("appInfo", () => {
        const container = reactive({
          open: false,
          //* 开关标识符
          widthPercentage: 100
          //* 宽度百分比
        });
        const window2 = reactive({
          width: useWindowSize().width,
          height: useWindowSize().height
        });
        const loading = reactive({
          value: false,
          show: false,
          state: "",
          percentage: 0,
          //f 进度条初始化函数
          init: () => {
            loading.value = true;
            loading.show = true;
            loading.percentage = 0;
            loading.state = "";
          },
          //f 进度条重置函数
          reset: () => {
            setTimeout(() => {
              loading.value = false;
              loading.state = "success";
              setTimeout(() => {
                loading.show = false;
                loading.percentage = 0;
                loading.state = "";
              }, 1500);
            }, 500);
          }
        });
        return { container, window: window2, loading };
      });
      const useCardsStore = defineStore("Cards", () => {
        const toolBar = useToolBarStore();
        const filter = toolBar.filter;
        const data = reactive({
          cardList: [],
          //* 卡片列表
          //f 过滤后的cardList结果(计算属性) 返回结果在script中需要使用.value访问
          filterCards: computed(() => {
            let regex = filter.formats.value.length ? new RegExp(`\\.(${filter.formats.value.join("|")})$`) : new RegExp("");
            const result = data.cardList.filter(
              (card) => card.meta.width >= filter.size.width.value[0] && card.meta.width <= filter.size.width.value[1] && card.meta.height >= filter.size.height.value[0] && card.meta.height <= filter.size.height.value[1] && regex.test(card.url)
            );
            return result;
          }),
          //f 所有匹配到的链接集合
          urlSet: /* @__PURE__ */ new Set(),
          //f 所有匹配到的dom集合
          domSet: /* @__PURE__ */ new Set()
        });
        return { data };
      });
      const useToolBarStore = defineStore("ToolBar", () => {
        useCardsStore();
        const filter = reactive({
          size: {
            width: {
              value: [350, 500],
              max: 500
            },
            height: {
              value: [350, 500],
              max: 500
            }
          },
          formats: {
            options: [
              { value: "png", label: "png" },
              { value: "jpg", label: "jpg" },
              { value: "jpeg", label: "jpeg" },
              { value: "gif", label: "gif" },
              { value: "bmp", label: "bmp" },
              { value: "webp", label: "webp" },
              { value: "svg", label: "svg" }
            ],
            value: ["png", "jpg", "jpeg", "gif", "webp", "bmp"]
          }
        });
        return { filter };
      });
      const useRuleEditorStore = defineStore("ruleEditor", () => {
        const container = reactive({
          open: false
        });
        const info = reactive({
          showRuleId: "#",
          form: {
            activeName: "main",
            realTimeData: void 0
          },
          tree: {
            query: "",
            //* 查询(过滤)文本
            //* 树形列表配置信息对象
            treeProps: {
              value: "id",
              label: "label",
              children: "children",
              disabled: "disabled"
            },
            //* 树形列表数据
            treeData: computed(() => {
              let result = data.ruleList.map((rule) => {
                return {
                  id: rule.id,
                  label: rule.main.name || "未命名规则",
                  children: [],
                  disabled: false,
                  isNew: rule.status.isNewCreated
                };
              });
              result.push({
                id: "#",
                label: "创建规则",
                children: [],
                disabled: false
              });
              return result;
            })
          }
        });
        const data = reactive({
          ruleList: []
          //* 规则列表
        });
        const getLocationRule = async () => {
          let localRuleList = _GM_getValue("ruleList");
          if (localRuleList != null) {
            data.ruleList = JSON.parse(localRuleList).map((rawRule) => {
              return new MatchRule(rawRule);
            });
            console.log("数据已导入", data);
          } else {
            data.ruleList = [];
            console.log("本地数据为空 -> 初始化数据", data);
          }
        };
        const saveRuleToLocation = async () => {
          const list = data.ruleList.map((rule) => rule.getJsonData());
          const jsonData = `[${list.join(",")}]`;
          console.log("保存数据", jsonData);
          _GM_setValue("ruleList", jsonData);
        };
        const createRule = async () => {
          let rule = new MatchRule();
          data.ruleList.push(rule);
          console.log("规则创建", rule);
          return rule;
        };
        const deleteRule = async (id2) => {
          const index = data.ruleList.findIndex((item) => item.id === id2);
          const target = data.ruleList.splice(index, 1);
          console.log("移除规则", target);
          MatchRule.count--;
        };
        return {
          container,
          info,
          data,
          getLocationRule,
          saveRuleToLocation,
          createRule,
          deleteRule
        };
      });
      const useListInfoStore = defineStore("list", () => {
        const info = reactive({
          nowColumn: 3,
          allSelected: false
        });
        return { info };
      });
      const _hoisted_1$g = { class: "onlineGallery-RuleEditor-modal" };
      const _hoisted_2$e = /* @__PURE__ */ createBaseVNode("span", { style: { "color": "black", "font-size": "large" } }, "规则管理器", -1);
      const _hoisted_3$c = { style: { "color": "black", "font-size": "large" } };
      const _hoisted_4$3 = {
        key: 0,
        class: "tree-item tree-item-normal"
      };
      const _hoisted_5$1 = { class: "label-ruleName" };
      const _hoisted_6$1 = { class: "icon-button-deleteRule" };
      const _hoisted_7$1 = {
        key: 1,
        class: "tree-item tree-item-add-button"
      };
      const _sfc_main$6 = /* @__PURE__ */ defineComponent({
        __name: "RuleEditor",
        setup(__props) {
          const appInfo = useAppInfoStore();
          const ruleEditor = useRuleEditorStore();
          const treeRef = ref();
          const info = ruleEditor.info;
          const form = ruleEditor.info.form;
          const tree = ruleEditor.info.tree;
          const data = ruleEditor.data;
          const inputFormData = async (ruleData) => {
            if (ruleData != void 0) {
              if (!ruleData.status.editing && !ruleData.status.isNewCreated) {
                ruleData.createBackup();
                ruleData.status.editing = true;
              }
              ruleData.status.isNewCreated = false;
              form.realTimeData = ruleData;
              info.showRuleId = ruleData.id;
              form.activeName = "main";
            } else {
              form.realTimeData = void 0;
              info.showRuleId = "-1";
            }
          };
          const onQueryChanged = (query) => {
            treeRef.value.filter(query);
          };
          const treeFilterMethod = (query, node) => {
            return node.label.includes(query);
          };
          const treeNodeClick = (nodeData, node, e) => {
            const ruleIndex = data.ruleList.findIndex(
              (item) => item.id === nodeData.id
            );
            if (ruleIndex >= 0) {
              const rule = data.ruleList[ruleIndex];
              inputFormData(rule);
            }
          };
          const createRule = async () => {
            const rule = await ruleEditor.createRule();
            inputFormData(rule);
          };
          const deleteRule = async (id2, node) => {
            const ruleName = node.label;
            ElMessageBox.confirm(`确认删除规则 “${ruleName}” ？`, "提示", {
              confirmButtonText: "确认",
              cancelButtonText: "取消",
              lockScroll: false
            }).then(() => {
              ruleEditor.deleteRule(id2);
              inputFormData();
              ElMessage({
                type: "success",
                grouping: true,
                center: true,
                duration: 1e3,
                offset: 80,
                message: `规则 “${ruleName}” 删除成功!`
              });
            }).catch(() => {
            });
          };
          const handleOpen = () => {
            initDialog();
            ruleEditor.getLocationRule();
            console.log("规则管理器 - Open");
          };
          const handleClose = async () => {
            ElMessageBox.confirm("确认关闭？", "提示", {
              confirmButtonText: "确认",
              cancelButtonText: "取消",
              lockScroll: false
            }).then(() => {
              ruleEditor.container.open = false;
              //! 关闭窗口
            }).catch(() => {
            });
          };
          const handleClosed = async () => {
            initDialog();
            cleanTempData();
            console.log("规则管理器 - Close");
          };
          const cleanTempData = async () => {
            for (let i = 0, len = data.ruleList.length; i < len; i++) {
              delete data.ruleList[i];
              MatchRule.count--;
            }
            data.ruleList = [];
          };
          const initDialog = async () => {
            form.activeName = "main";
            inputFormData();
          };
          const allSave = async () => {
            ruleEditor.saveRuleToLocation();
            ruleEditor.container.open = false;
            //! 关闭窗口
          };
          return (_ctx, _cache) => {
            const _component_el_input = ElInput;
            const _component_el_tooltip = ElTooltip;
            const _component_HoverButton = __unplugin_components_2$1;
            const _component_i_ep_CirclePlusFilled = __unplugin_components_3$1;
            const _component_el_icon = ElIcon;
            const _component_el_button = ElButton;
            const _component_el_tree_v2 = ElTreeV2;
            const _component_el_aside = ElAside;
            const _component_RuleForm = __unplugin_components_8$2;
            const _component_el_main = ElMain;
            const _component_el_container = ElContainer;
            const _component_el_dialog = ElDialog;
            return openBlock(), createElementBlock("div", _hoisted_1$g, [
              createVNode(_component_el_dialog, {
                style: { "pointer-events": "auto !important", "padding": "0px" },
                modelValue: unref(ruleEditor).container.open,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(ruleEditor).container.open = $event),
                width: unref(appInfo).window.width > 800 ? "800px" : "100%",
                "before-close": handleClose,
                modal: false,
                "close-on-click-modal": false,
                "lock-scroll": false,
                "destroy-on-close": "",
                draggable: "",
                onOpen: handleOpen,
                onClosed: handleClosed
              }, {
                header: withCtx(() => [
                  _hoisted_2$e,
                  createBaseVNode("span", _hoisted_3$c, " (共" + toDisplayString(unref(ruleEditor).data.ruleList.length) + "条规则) ", 1)
                ]),
                default: withCtx(() => [
                  createVNode(_component_el_container, { style: { "user-select": "none" } }, {
                    default: withCtx(() => [
                      createVNode(_component_el_aside, {
                        width: "200px",
                        "show-checkbox": "",
                        "highlight-current": "",
                        style: { "padding": "5px" }
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_input, {
                            clearable: "",
                            modelValue: unref(tree).query,
                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(tree).query = $event),
                            placeholder: "输入关键词",
                            onInput: onQueryChanged
                          }, null, 8, ["modelValue"]),
                          createVNode(_component_el_tree_v2, {
                            ref_key: "treeRef",
                            ref: treeRef,
                            data: unref(tree).treeData,
                            props: unref(tree).treeProps,
                            height: 400,
                            "highlight-current": "",
                            "current-node-key": unref(info).showRuleId,
                            "filter-method": treeFilterMethod,
                            onNodeClick: treeNodeClick,
                            "item-size": 32
                          }, {
                            default: withCtx(({ node }) => [
                              node.key != "#" ? (openBlock(), createElementBlock("div", _hoisted_4$3, [
                                createVNode(_component_el_tooltip, {
                                  "show-after": 500,
                                  effect: "dark",
                                  content: node.label,
                                  placement: "top"
                                }, {
                                  default: withCtx(() => [
                                    createBaseVNode("span", _hoisted_5$1, toDisplayString(node.label), 1)
                                  ]),
                                  _: 2
                                }, 1032, ["content"]),
                                createBaseVNode("span", _hoisted_6$1, [
                                  createVNode(_component_HoverButton, {
                                    onClick: withModifiers(($event) => deleteRule(node.key, node), ["stop"])
                                  }, null, 8, ["onClick"])
                                ])
                              ])) : createCommentVNode("", true),
                              node.key == "#" ? (openBlock(), createElementBlock("div", _hoisted_7$1, [
                                createVNode(_component_el_button, {
                                  type: "primary",
                                  onClick: createRule
                                }, {
                                  icon: withCtx(() => [
                                    createVNode(_component_el_icon, null, {
                                      default: withCtx(() => [
                                        createVNode(_component_i_ep_CirclePlusFilled)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  default: withCtx(() => [
                                    createBaseVNode("span", null, toDisplayString(node.label), 1)
                                  ]),
                                  _: 2
                                }, 1024)
                              ])) : createCommentVNode("", true)
                            ]),
                            _: 1
                          }, 8, ["data", "props", "current-node-key"])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_main, { style: { "padding": "5px" } }, {
                        default: withCtx(() => [
                          createVNode(_component_RuleForm, {
                            formData: unref(form).realTimeData
                          }, null, 8, ["formData"])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                footer: withCtx(() => [
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: allSave
                  }, {
                    default: withCtx(() => [
                      createTextVNode("全部保存")
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_button, { onClick: handleClose }, {
                    default: withCtx(() => [
                      createTextVNode("取消")
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["modelValue", "width"])
            ]);
          };
        }
      });
      const _hoisted_1$f = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$d = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M764.416 254.72a351.68 351.68 0 0 1 86.336 149.184H960v192.064H850.752a351.68 351.68 0 0 1-86.336 149.312l54.72 94.72l-166.272 96l-54.592-94.72a352.64 352.64 0 0 1-172.48 0L371.136 936l-166.272-96l54.72-94.72a351.68 351.68 0 0 1-86.336-149.312H64v-192h109.248a351.68 351.68 0 0 1 86.336-149.312L204.8 160l166.208-96h.192l54.656 94.592a352.64 352.64 0 0 1 172.48 0L652.8 64h.128L819.2 160l-54.72 94.72zM704 499.968a192 192 0 1 0-384 0a192 192 0 0 0 384 0z"
      }, null, -1);
      const _hoisted_3$b = [
        _hoisted_2$d
      ];
      function render$a(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$f, _hoisted_3$b);
      }
      const __unplugin_components_8$1 = { name: "ep-tools", render: render$a };
      const _hoisted_1$e = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$c = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M576 128v288l96-96l96 96V128h128v768H320V128h256zm-448 0h128v768H128V128z"
      }, null, -1);
      const _hoisted_3$a = [
        _hoisted_2$c
      ];
      function render$9(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$e, _hoisted_3$a);
      }
      const __unplugin_components_7 = { name: "ep-management", render: render$9 };
      const _hoisted_1$d = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$b = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M640 384v256H384V384h256zm64 0h192v256H704V384zm-64 512H384V704h256v192zm64 0V704h192v192H704zm-64-768v192H384V128h256zm64 0h192v192H704V128zM320 384v256H128V384h192zm0 512H128V704h192v192zm0-768v192H128V128h192z"
      }, null, -1);
      const _hoisted_3$9 = [
        _hoisted_2$b
      ];
      function render$8(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$d, _hoisted_3$9);
      }
      const __unplugin_components_5 = { name: "ep-grid", render: render$8 };
      const _hoisted_1$c = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$a = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M338.752 104.704a64 64 0 0 0 0 90.496l316.8 316.8l-316.8 316.8a64 64 0 0 0 90.496 90.496l362.048-362.048a64 64 0 0 0 0-90.496L429.248 104.704a64 64 0 0 0-90.496 0z"
      }, null, -1);
      const _hoisted_3$8 = [
        _hoisted_2$a
      ];
      function render$7(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$c, _hoisted_3$8);
      }
      const __unplugin_components_4 = { name: "ep-arrow-right-bold", render: render$7 };
      const _hoisted_1$b = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$9 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M764.288 214.592L512 466.88L259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512L214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
      }, null, -1);
      const _hoisted_3$7 = [
        _hoisted_2$9
      ];
      function render$6(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$b, _hoisted_3$7);
      }
      const __unplugin_components_1$1 = { name: "ep-close", render: render$6 };
      const _hoisted_1$a = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$8 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M512 928c23.936 0 117.504-68.352 192.064-153.152C803.456 661.888 864 535.808 864 416c0-189.632-155.84-320-352-320S160 226.368 160 416c0 120.32 60.544 246.4 159.936 359.232C394.432 859.84 488 928 512 928zm0-435.2a64 64 0 1 0 0-128a64 64 0 0 0 0 128zm0 140.8a204.8 204.8 0 1 1 0-409.6a204.8 204.8 0 0 1 0 409.6z"
      }, null, -1);
      const _hoisted_3$6 = [
        _hoisted_2$8
      ];
      function render$5(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$a, _hoisted_3$6);
      }
      const __unplugin_components_6$1 = { name: "ep-location-filled", render: render$5 };
      const _hoisted_1$9 = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$7 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64zm384-253.696l236.288-236.352l45.248 45.248L508.8 704L192 387.2l45.248-45.248L480 584.704V128h64v450.304z"
      }, null, -1);
      const _hoisted_3$5 = [
        _hoisted_2$7
      ];
      function render$4(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$9, _hoisted_3$5);
      }
      const __unplugin_components_6 = { name: "ep-download", render: render$4 };
      const _hoisted_1$8 = ["parentSelector"];
      const _sfc_main$5 = {
        __name: "Img",
        props: {
          src: String,
          parentSelector: {
            type: String,
            default: "null"
          },
          margin: {
            type: String,
            default: "0%"
          }
        },
        setup(__props) {
          const vLazy = {
            mounted(el, binding, vNode) {
              el.dataset.show = false;
              let url = binding.value;
              let observer = new IntersectionObserver(
                (entries, observer2) => {
                  entries.forEach((entire) => {
                    if (entire.isIntersecting) {
                      observer2.unobserve(el);
                      el.src = url;
                      if (el.tagName == "IMG") {
                        if (el.complete) {
                          el.dataset.show = true;
                        } else {
                          let fn2 = function() {
                            el.dataset.show = true;
                            el.removeEventListener("load", fn2);
                            el.removeEventListener("error", fn2);
                          };
                          el.addEventListener("load", fn2);
                          el.addEventListener("error", fn2);
                        }
                      } else {
                        el.dataset.show = true;
                      }
                    }
                  });
                },
                {
                  root: document.querySelector(vNode.props.parentSelector),
                  rootMargin: vNode.props.margin
                }
              );
              observer.observe(el);
            }
          };
          return (_ctx, _cache) => {
            return withDirectives((openBlock(), createElementBlock("img", { parentSelector: __props.parentSelector }, null, 8, _hoisted_1$8)), [
              [vLazy, __props.src]
            ]);
          };
        }
      };
      const __unplugin_components_0$2 = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-00beb0aa"]]);
      class TaskQueue {
        constructor(options = { showMessage: false, max: 10 }, singleCallback = () => {
        }, finallyCallback = () => {
        }) {
          __publicField(this, "max");
          __publicField(this, "initMax");
          __publicField(this, "taskList");
          __publicField(this, "showMessage");
          __publicField(this, "singleCallback");
          __publicField(this, "finallyCallback");
          this.max = options.max;
          this.initMax = options.max;
          this.taskList = [];
          this.showMessage = options.showMessage;
          this.singleCallback = singleCallback;
          this.finallyCallback = finallyCallback;
        }
        /**
         * * 添加任务到队列
         * @param {any} task 任务项
         */
        addTask(task) {
          this.taskList.push(task);
        }
        run() {
          const length = this.taskList.length;
          if (!length) {
            if (this.max === this.initMax) {
              this.finallyCallback();
            }
            return;
          }
          const min = Math.min(length, this.max);
          for (let i = 0; i < min; i++) {
            const task = this.taskList.shift();
            this.max--;
            task().then((res) => {
              if (this.showMessage)
                console.log(res);
            }).catch((err) => {
              if (this.showMessage)
                console.log(err);
            }).finally(() => {
              this.max++;
              this.singleCallback();
              this.run();
            });
          }
        }
      }
      const getBlobByUrl = (url, mode = "Fetch", referer = void 0) => {
        if (mode === "Fetch") {
          return new Promise(async (resolve2, reject) => {
            let blob = await fetch(url).then((res) => res.blob()).catch((err) => null);
            if (blob != null) {
              console.log("Fetch成功", blob);
              resolve2(blob);
            } else {
              console.log("Fetch失败", blob);
              resolve2(new Blob(void 0, { type: "none" }));
            }
          });
        } else if (mode === "GM") {
          return new Promise(async (resolve2, reject) => {
            let headers;
            if (referer != null) {
              headers = {
                referer
              };
            }
            _GM_xmlhttpRequest({
              methods: "GET",
              url,
              responseType: "blob",
              headers,
              onload: (res) => {
                if (res.status == 200) {
                  console.log(`GM成功(referer:${referer})`, res.response, res.status);
                  resolve2(res.response);
                } else {
                  console.log(`GM失败(referer:${referer})`, res.response, res.status);
                  resolve2(new Blob(void 0, { type: "none" }));
                }
              },
              onerror: (err) => {
                resolve2(new Blob(void 0, { type: "none" }));
              },
              ontimeout: () => {
                resolve2(new Blob(void 0, { type: "none" }));
              },
              onabort: () => {
                resolve2(new Blob(void 0, { type: "none" }));
              }
            });
          });
        } else {
          return new Blob(void 0, { type: "none" });
        }
      };
      const buildUUID = () => {
        const hexList = [];
        for (let i = 0; i <= 15; i++) {
          hexList[i] = i.toString(16);
        }
        let uuid = "";
        for (let i = 1; i <= 36; i++) {
          if (i === 9 || i === 14 || i === 19 || i === 24) {
            uuid += "-";
          } else if (i === 15) {
            uuid += 4;
          } else if (i === 20) {
            uuid += hexList[Math.random() * 4 | 8];
          } else {
            uuid += hexList[Math.random() * 16 | 0];
          }
        }
        return uuid.replace(/-/g, "");
      };
      const getNameByUrl = (url) => {
        let list = url.match(new RegExp("(?<=\\/)([^\\/\\r\\n$]+)$", "g")) || [];
        if (list.length > 0) {
          return list[0] || url;
        } else {
          return url;
        }
      };
      const isEmpty = (str = "", includeSpace = false) => {
        return includeSpace ? str == null || str == void 0 || str == "" || /^ +?$/.test(str) : str == null || str == void 0 || str == "";
      };
      const getMetaByBlob = async (blob) => {
        const meta = await new Promise((resolve2, reject) => {
          let reader = new FileReader();
          reader.readAsDataURL(blob);
          reader.onload = (theFile) => {
            let image = new Image();
            image.src = theFile.target.result;
            image.onload = () => {
              resolve2({
                isOk: true,
                width: image.width,
                height: image.height,
                aspectRatio: image.width / image.height
              });
            };
            image.onerror = () => {
              reject({
                isOk: false,
                width: 0,
                height: 0
              });
            };
          };
        });
        return meta;
      };
      const getTagInfo = (domTag, type2, attr) => {
        let attrList = [];
        if (/\|/.test(attr)) {
          attrList = attr.split("|");
        } else {
          attrList = [attr];
        }
        if (domTag == null) {
          return null;
        }
        let result;
        if (type2 == 1) {
          result = domTag.value;
        } else if (type2 == 2) {
          result = "";
          for (let i = 0; i < attrList.length; i++) {
            const attr2 = attrList[i];
            let temp = domTag.getAttribute(attr2);
            if (!isEmpty(temp)) {
              if (attr2 == "srcset") {
                temp = getSrcsetMaximumValue(temp);
              }
              result = temp;
              break;
            }
          }
        } else if (type2 == 3) {
          result = "";
          for (let i = 0; i < attrList.length; i++) {
            const attr2 = attrList[i];
            let temp = domTag[attr2];
            if (!isEmpty(temp)) {
              if (attr2 == "srcset") {
                temp = getSrcsetMaximumValue(temp);
              }
              result = temp;
              break;
            }
          }
        } else if (type2 == 4) {
          result = domTag.innerText;
        } else if (type2 == 5) {
          result = domTag.innerHTML;
        } else if (type2 == 6) {
          result = domTag.outerHTML;
        }
        if (isUrl(result)) {
          result = urlCompletion(result);
        }
        return String(result);
      };
      const isUrl = (str) => {
        var v = /^(\/|(.\/)).+?$/i;
        return v.test(str);
      };
      const getSrcsetMaximumValue = (srcsetString) => {
        let result = srcsetString;
        if (/\d+w/.test(srcsetString)) {
          let dataList = srcsetString.split(/\, */).filter((item) => !isEmpty(item, true)).map((item) => {
            const itemDataInfos = item.split(" ");
            if (itemDataInfos.length == 2) {
              return {
                url: itemDataInfos[0],
                resolution: Number(itemDataInfos[1].split(/w|W/)[0])
              };
            } else {
              return {
                url: itemDataInfos[0],
                resolution: 0
              };
            }
          });
          let maxItem = dataList[0];
          dataList.forEach((item) => {
            if (maxItem.resolution < item.resolution) {
              maxItem = item;
            }
          });
          result = maxItem.url;
        }
        return result;
      };
      const urlCompletion = (url) => {
        const v1 = /^\/[^\/].*$/i;
        const v2 = /^\/\/.*$/i;
        if (v1.test(url)) {
          return window.document.location.origin + url;
        }
        if (v2.test(url)) {
          return window.document.location.protocol + url;
        }
      };
      const _hoisted_1$7 = { class: "tag-group" };
      const _hoisted_2$6 = { class: "button-group" };
      const _sfc_main$4 = /* @__PURE__ */ defineComponent({
        __name: "Card",
        props: {
          card: { default: () => {
            return {
              name: "",
              url: "",
              originUrls: [],
              meta: {
                width: 0,
                height: 0,
                aspectRatio: 3 / 4
              },
              selected: false,
              //? 选中标识符
              dom: null
            };
          } }
        },
        setup(__props) {
          const props = __props;
          const { text, isSupported, copy } = useClipboard();
          const appInfo = useAppInfoStore();
          const downloading = ref(false);
          const copyTagContent = async (content) => {
            await copy(content);
            ElMessage({
              type: "success",
              // showClose: true,
              grouping: true,
              center: true,
              duration: 1e3,
              offset: 80,
              message: h("p", { style: "display:flex;gap:10px" }, [
                h("i", { style: "color: teal" }, content),
                h("span", { style: "color: black" }, "复制成功！")
              ])
            });
          };
          const clickHandle = async (e) => {
            return;
          };
          const download = async () => {
            downloading.value = true;
            if (props.card.blob != null) {
              await saveAs(props.card.blob, props.card.name);
              downloading.value = false;
            } else {
              const url = props.card.url;
              let blob = await getBlobByUrl(url, "Fetch");
              if (blob.type === "none") {
                blob = await getBlobByUrl(url, "GM");
              }
              if (blob.type === "none") {
                blob = await getBlobByUrl(url, "GM", location.origin);
              }
              console.log(blob);
              if (blob && blob["type"] !== "none") {
                await saveAs(blob, props.card.name);
                downloading.value = false;
              } else {
                downloading.value = false;
              }
            }
          };
          const toPosition = async () => {
            const dom = props.card.dom;
            if (dom != null) {
              appInfo.container.open = !appInfo.container.open;
              dom.scrollIntoView({
                behavior: "smooth",
                block: "center",
                inline: "center"
              });
            }
          };
          return (_ctx, _cache) => {
            const _component_Img = __unplugin_components_0$2;
            const _component_el_tag = ElTag;
            const _component_el_checkbox = ElCheckbox;
            const _component_i_ep_Download = __unplugin_components_6;
            const _component_el_icon = ElIcon;
            const _component_el_button = ElButton;
            const _component_i_ep_LocationFilled = __unplugin_components_6$1;
            return openBlock(), createElementBlock("div", {
              class: "card",
              onContextmenu: _cache[3] || (_cache[3] = withModifiers(() => {
              }, ["prevent", "self"])),
              onClick: clickHandle
            }, [
              createVNode(_component_Img, {
                class: "content",
                src: _ctx.card.url
              }, null, 8, ["src"]),
              createBaseVNode("div", _hoisted_1$7, [
                createVNode(_component_el_tag, {
                  class: "tag-width-and-height",
                  round: "",
                  size: "small",
                  type: "info",
                  onContextmenu: _cache[0] || (_cache[0] = withModifiers(($event) => copyTagContent(`${_ctx.card.meta.width}x${_ctx.card.meta.height}`), ["right", "prevent"]))
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.card.meta.width) + "x" + toDisplayString(_ctx.card.meta.height), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_el_tag, {
                  class: "tag-width-and-height",
                  round: "",
                  size: "small",
                  onContextmenu: _cache[1] || (_cache[1] = withModifiers(($event) => copyTagContent(_ctx.card.name), ["right", "prevent"]))
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.card.name), 1)
                  ]),
                  _: 1
                })
              ]),
              createVNode(_component_el_checkbox, {
                modelValue: _ctx.card.selected,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.card.selected = $event),
                class: "checkbox",
                size: "default"
              }, null, 8, ["modelValue"]),
              createBaseVNode("div", _hoisted_2$6, [
                createVNode(_component_el_button, {
                  class: "button download",
                  type: "primary",
                  size: "small",
                  circle: "",
                  onClick: withModifiers(download, ["stop"]),
                  loading: unref(downloading)
                }, {
                  icon: withCtx(() => [
                    createVNode(_component_el_icon, null, {
                      default: withCtx(() => [
                        createVNode(_component_i_ep_Download)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["onClick", "loading"]),
                createVNode(_component_el_button, {
                  class: "button toPosition",
                  type: "primary",
                  size: "small",
                  circle: "",
                  onClick: withModifiers(toPosition, ["stop"]),
                  loading: unref(downloading)
                }, {
                  icon: withCtx(() => [
                    createVNode(_component_el_icon, null, {
                      default: withCtx(() => [
                        createVNode(_component_i_ep_LocationFilled)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["onClick", "loading"])
              ])
            ], 32);
          };
        }
      });
      const __unplugin_components_0$1 = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-ef6a9296"]]);
      const _sfc_main$3 = /* @__PURE__ */ defineComponent({
        __name: "List",
        setup(__props) {
          const listContainer = ref();
          const listBody = ref();
          const scrollbarRef = ref();
          const listStore = useListInfoStore();
          const cardsStore = useCardsStore();
          const getStyle2 = computed(() => {
            if (listContainer.value == null) {
              return;
            }
            const containerInfo = listContainer.value.getBoundingClientRect();
            let style = {
              "--nowColumn": listStore.info.nowColumn,
              "--listHeight": containerInfo.height - 8 * listStore.info.nowColumn - 10 + "px",
              "--cardMaxHeight": `calc(var(--listHeight) / var(--nowColumn))`
            };
            if (listStore.info.nowColumn <= 0) {
              style["--cardMaxHeight"] = "1000%";
            }
            return style;
          });
          return (_ctx, _cache) => {
            const _component_Card = __unplugin_components_0$1;
            const _component_el_scrollbar = ElScrollbar;
            return openBlock(), createElementBlock("div", {
              ref_key: "listContainer",
              ref: listContainer
            }, [
              createVNode(_component_el_scrollbar, {
                ref_key: "scrollbarRef",
                ref: scrollbarRef
              }, {
                default: withCtx(() => [
                  createVNode(TransitionGroup, {
                    class: "onlineGallery-listBody",
                    ref_key: "listBody",
                    ref: listBody,
                    style: normalizeStyle(unref(getStyle2)),
                    name: "list",
                    tag: "div"
                  }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(cardsStore).data.filterCards, (card, index) => {
                        return openBlock(), createBlock(_component_Card, {
                          card,
                          key: card.id,
                          "data-index": index,
                          style: normalizeStyle({
                            "--aspect-ratio": card.meta.aspectRatio
                          })
                        }, null, 8, ["card", "data-index", "style"]);
                      }), 128))
                    ]),
                    _: 1
                  }, 8, ["style"])
                ]),
                _: 1
              }, 512)
            ], 512);
          };
        }
      });
      const __unplugin_components_2 = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-c777563b"]]);
      const _hoisted_1$6 = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$5 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M176 416a112 112 0 1 1 0 224a112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224a112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224a112 112 0 0 1 0-224z"
      }, null, -1);
      const _hoisted_3$4 = [
        _hoisted_2$5
      ];
      function render$3(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$6, _hoisted_3$4);
      }
      const __unplugin_components_8 = { name: "ep-more-filled", render: render$3 };
      const _hoisted_1$5 = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      const _hoisted_2$4 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "currentColor",
        d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384a384 384 0 0 1-384-384a384 384 0 0 1 643.712-282.88z"
      }, null, -1);
      const _hoisted_3$3 = [
        _hoisted_2$4
      ];
      function render$2(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$5, _hoisted_3$3);
      }
      const __unplugin_components_3 = { name: "ep-refresh-right", render: render$2 };
      const _hoisted_1$4 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24"
      };
      const _hoisted_2$3 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "none",
        d: "M0 0h24v24H0z"
      }, null, -1);
      const _hoisted_3$2 = /* @__PURE__ */ createBaseVNode("path", { d: "M4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm1 2v14h14V5H5z" }, null, -1);
      const _hoisted_4$2 = [
        _hoisted_2$3,
        _hoisted_3$2
      ];
      function render$1(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$4, _hoisted_4$2);
      }
      const CheckboxNone = { render: render$1 };
      const _hoisted_1$3 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24"
      };
      const _hoisted_2$2 = /* @__PURE__ */ createBaseVNode("path", {
        fill: "none",
        d: "M0 0h24v24H0z"
      }, null, -1);
      const _hoisted_3$1 = /* @__PURE__ */ createBaseVNode("path", { d: "M4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm7.003 13 7.07-7.071-1.414-1.414-5.656 5.657-2.829-2.829-1.414 1.414L11.003 16z" }, null, -1);
      const _hoisted_4$1 = [
        _hoisted_2$2,
        _hoisted_3$1
      ];
      function render(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$3, _hoisted_4$1);
      }
      const CheckboxAll = { render };
      const _withScopeId = (n) => (pushScopeId("data-v-07826213"), n = n(), popScopeId(), n);
      const _hoisted_1$2 = { class: "onlineGallery-toolBar" };
      const _hoisted_2$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { style: { "display": "flex", "justify-content": "center" } }, " 选中 / 可见 / 总数 ", -1));
      const _hoisted_3 = { class: "filter" };
      const _hoisted_4 = { class: "size" };
      const _hoisted_5 = { class: "width row" };
      const _hoisted_6 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "label" }, "宽度", -1));
      const _hoisted_7 = { class: "height row" };
      const _hoisted_8 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "label" }, "高度", -1));
      const _hoisted_9 = { class: "format" };
      const _hoisted_10 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "label" }, "格式", -1));
      const _hoisted_11 = { class: "zoom-slider" };
      const _hoisted_12 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", null, "最大显示行数", -1));
      const _sfc_main$2 = /* @__PURE__ */ defineComponent({
        __name: "Toolbar",
        setup(__props, { expose: __expose }) {
          const appInfo = useAppInfoStore();
          const cardsStore = useCardsStore();
          const Toolbar = useToolBarStore();
          const listStore = useListInfoStore();
          const ruleEditor = useRuleEditorStore();
          const loading = appInfo.loading;
          const filter = Toolbar.filter;
          const refresh = async () => {
            await getCards();
          };
          const selectedCards = computed(() => {
            return cardsStore.data.cardList.filter((card) => card.selected);
          });
          const allSelectSwitch = async () => {
            listStore.info.allSelected = !listStore.info.allSelected;
            appInfo.loading.value = true;
            cardsStore.data.filterCards.forEach(
              (card) => card.selected = listStore.info.allSelected
            );
            appInfo.loading.value = false;
          };
          const downloadSelected = async () => {
            const downloadCards = selectedCards.value;
            if (!downloadCards.length) {
              ElMessage({
                message: "请选择要下载的数据",
                type: "info",
                showClose: true,
                grouping: true,
                offset: 80
              });
              return;
            }
            const taskQueue = new TaskQueue({ showMessage: false, max: 5 });
            loading.init();
            let finallyCount = 0;
            for (const card of downloadCards) {
              if (card.blob == null) {
                const task = async () => {
                  const url = card.url;
                  let blob = await getBlobByUrl(url, "Fetch");
                  if (blob.type === "none") {
                    blob = await getBlobByUrl(url, "GM");
                  }
                  if (blob.type === "none") {
                    blob = await getBlobByUrl(url, "GM", location.origin);
                  }
                  card.blob = blob;
                  if (card.blob && card.blob["type"] !== "none") {
                    return [card.name, "处理成功!"];
                  } else {
                    return [card.name, "处理失败"];
                  }
                };
                taskQueue.addTask(task);
              }
            }
            taskQueue.singleCallback = () => {
              finallyCount++;
              loading.percentage = finallyCount / downloadCards.length * 100;
            };
            taskQueue.finallyCallback = async () => {
              ElMessage({
                message: "下载成功! (正在生成压缩包)",
                type: "success",
                showClose: true,
                grouping: true,
                offset: 80
              });
              const zipContainer = new JSZip();
              for (const card of downloadCards) {
                if (card.name != null && card.blob != null) {
                  zipContainer.file(card.name, card.blob);
                }
              }
              const zip = await zipContainer.generateAsync({
                type: "blob",
                compression: "DEFLATE",
                level: 9
              });
              let zipName = document.querySelector("title").innerText;
              saveAs(zip, `${zipName}.zip`);
              loading.percentage = 100;
              loading.reset();
            };
            taskQueue.run();
          };
          const getCards = async () => {
            let cardDomList = await getImgOrVideoDom();
            let tempCardList = [];
            if (!cardDomList.length) {
              ElMessage({
                message: "没有匹配到相应数据",
                type: "info",
                showClose: true,
                grouping: true,
                offset: 80
              });
              return;
            }
            const taskQueue = new TaskQueue({ showMessage: false, max: 10 });
            loading.init();
            let finallyCount = 0;
            taskQueue.taskList = cardDomList.map((dom, index) => {
              return async () => {
                const card = {
                  name: "",
                  url: "",
                  originUrls: [],
                  //* 初始meta信息
                  meta: {
                    isOk: false,
                    width: 0,
                    height: 0,
                    aspectRatio: 3 / 4
                  },
                  match: false,
                  //? 匹配标识符
                  selected: false,
                  //? 选中标识符
                  dom
                };
                if (dom.tagName == "META") {
                  card.originUrls = [getTagInfo(dom, 3, "content")].filter((url) => !isEmpty(url, true));
                  if (card.originUrls.length > 0) {
                    card.url = card.originUrls[0];
                    const blob = await fetch(card.url).then((res) => res.blob()).catch(() => {
                      return new Blob(void 0, { type: "none" });
                    });
                    if (/^image/.test(blob.type)) {
                      //! 获取meta信息
                      const meta = await getMetaByBlob(blob);
                      if (meta.isOk) {
                        card.name = getNameByUrl(card.url);
                        card.meta.width = meta.width;
                        card.meta.height = meta.height;
                        card.meta.aspectRatio = meta.width / meta.height;
                        card.match = true;
                      }
                    }
                  }
                } else if (dom.tagName == "IMG" || dom.tagName == "VIDEO") {
                  if (dom.naturalWidth > 0 && dom.naturalHeight > 0) {
                    card.originUrls = [
                      getTagInfo(dom, 2, "srcset"),
                      getTagInfo(dom, 2, "data-src"),
                      getTagInfo(dom, 3, "src")
                    ].filter((url) => !isEmpty(url, true));
                    if (card.originUrls.length > 0) {
                      card.url = card.originUrls[0];
                      card.name = getNameByUrl(card.url);
                      card.meta.width = dom.naturalWidth;
                      card.meta.height = dom.naturalHeight;
                      card.meta.aspectRatio = dom.naturalWidth / dom.naturalHeight;
                      card.match = true;
                    }
                  } else {
                    card.originUrls = [
                      getTagInfo(dom, 2, "srcset"),
                      getTagInfo(dom, 2, "data-src"),
                      getTagInfo(dom, 3, "src")
                    ].filter((url) => !isEmpty(url, true));
                    if (card.originUrls.length > 0) {
                      card.url = card.originUrls[0];
                      const blob = await fetch(card.url).then((res) => res.blob()).catch((err) => {
                        return new Blob(void 0, { type: "none" });
                      });
                      if (/^image/.test(blob.type)) {
                        //! 获取meta信息
                        const meta = await getMetaByBlob(blob);
                        if (meta.isOk) {
                          card.name = getNameByUrl(card.url);
                          card.meta.width = meta.width;
                          card.meta.height = meta.height;
                          card.meta.aspectRatio = meta.width / meta.height;
                          card.match = true;
                        }
                      }
                    }
                  }
                } else if (dom.tagName == "A") {
                  card.originUrls = [getTagInfo(dom, 3, "href")].filter((url) => !isEmpty(url, true));
                  if (card.originUrls.length > 0) {
                    card.url = card.originUrls[0];
                    const blob = await fetch(card.url).then((res) => res.blob()).catch((err) => {
                      return new Blob(void 0, { type: "none" });
                    });
                    if (/^image/.test(blob.type)) {
                      //! 获取meta信息
                      const meta = await getMetaByBlob(blob);
                      if (meta.isOk) {
                        card.name = getNameByUrl(card.url);
                        card.meta.width = meta.width;
                        card.meta.height = meta.height;
                        card.meta.aspectRatio = meta.width / meta.height;
                        card.match = true;
                      }
                    }
                  }
                }
                if (card.match && !cardsStore.data.urlSet.has(card.url)) {
                  const max = filter.size.width.max = filter.size.height.max = Math.max(
                    filter.size.width.max,
                    filter.size.height.max,
                    card.meta.width,
                    card.meta.height
                  );
                  filter.size.width.value[1] = filter.size.height.value[1] = max;
                  delete card.match;
                  card["id"] = buildUUID();
                  tempCardList[index] = card;
                  cardsStore.data.urlSet.add(card.url);
                  cardsStore.data.domSet.add(card.dom);
                  return ["符合条件（添加）", card.dom];
                } else {
                  return ["不符合条件（排除）"];
                }
              };
            });
            taskQueue.singleCallback = () => {
              finallyCount++;
              loading.percentage = finallyCount / cardDomList.length * 100;
            };
            taskQueue.finallyCallback = () => {
              cardsStore.data.cardList.push(...tempCardList.filter((card) => card));
              ElMessage({
                message: "数据更新成功!",
                type: "success",
                showClose: true,
                grouping: true,
                offset: 80
              });
              loading.percentage = 100;
              loading.reset();
            };
            //! 执行队列
            taskQueue.run();
          };
          const getImgOrVideoDom = async () => {
            let imgDoms = [];
            if (filter.formats.value.length) {
              const formatList = filter.formats.value;
              for (const format2 of formatList) {
                imgDoms.push(
                  ...Array.from(
                    document.querySelectorAll(
                      `meta[property="og:image"][content $= '.${format2}']`
                    )
                  )
                );
                imgDoms.push(
                  ...Array.from(document.querySelectorAll(`img[src $= '.${format2}']`))
                );
                imgDoms.push(
                  ...Array.from(document.querySelectorAll(`[href $= '.${format2}']`))
                );
              }
            } else {
              imgDoms.push(
                ...Array.from(
                  document.querySelectorAll(`meta[property="og:image"][content]`)
                )
              );
              imgDoms.push(...Array.from(document.querySelectorAll(`img[src]`)));
            }
            return imgDoms;
          };
          __expose({
            getCards
          });
          return (_ctx, _cache) => {
            const _component_el_statistic = ElStatistic;
            const _component_el_slider = ElSlider;
            const _component_el_select_v2 = ElSelectV2;
            const _component_i_ep_RefreshRight = __unplugin_components_3;
            const _component_el_icon = ElIcon;
            const _component_el_button = ElButton;
            const _component_i_ep_Download = __unplugin_components_6;
            const _component_el_button_group = ElButtonGroup$1;
            const _component_i_ep_MoreFilled = __unplugin_components_8;
            const _component_i_ep_Management = __unplugin_components_7;
            const _component_el_dropdown_item = ElDropdownItem;
            const _component_i_ep_Tools = __unplugin_components_8$1;
            const _component_el_dropdown_menu = ElDropdownMenu;
            const _component_el_dropdown = ElDropdown;
            return openBlock(), createElementBlock("div", _hoisted_1$2, [
              createVNode(_component_el_statistic, {
                class: "statistic",
                value: unref(cardsStore).data.filterCards.length
              }, {
                title: withCtx(() => [
                  _hoisted_2$1
                ]),
                prefix: withCtx(() => [
                  createTextVNode(toDisplayString(unref(selectedCards).length) + " / ", 1)
                ]),
                suffix: withCtx(() => [
                  createTextVNode("/ " + toDisplayString(unref(cardsStore).data.cardList.length), 1)
                ]),
                _: 1
              }, 8, ["value"]),
              createBaseVNode("div", _hoisted_3, [
                createBaseVNode("div", _hoisted_4, [
                  createBaseVNode("div", _hoisted_5, [
                    _hoisted_6,
                    createVNode(_component_el_slider, {
                      debounce: 500,
                      class: "slider",
                      label: "宽度",
                      modelValue: unref(filter).size.width.value,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(filter).size.width.value = $event),
                      range: "",
                      min: 0,
                      max: unref(filter).size.width.max,
                      placement: "right"
                    }, null, 8, ["modelValue", "max"])
                  ]),
                  createBaseVNode("div", _hoisted_7, [
                    _hoisted_8,
                    createVNode(_component_el_slider, {
                      debounce: 500,
                      class: "slider",
                      label: "高度",
                      modelValue: unref(filter).size.height.value,
                      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(filter).size.height.value = $event),
                      range: "",
                      min: 0,
                      max: unref(filter).size.height.max,
                      placement: "right"
                    }, null, 8, ["modelValue", "max"])
                  ])
                ]),
                createBaseVNode("div", _hoisted_9, [
                  _hoisted_10,
                  createVNode(_component_el_select_v2, {
                    class: "select",
                    modelValue: unref(filter).formats.value,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(filter).formats.value = $event),
                    filterable: "",
                    clearable: "",
                    "allow-create": "",
                    "collapse-tags": "",
                    "collapse-tags-tooltip": "",
                    "max-collapse-tags": 1,
                    options: unref(filter).formats.options,
                    placeholder: "格式过滤",
                    multiple: ""
                  }, null, 8, ["modelValue", "options"])
                ])
              ]),
              createBaseVNode("div", _hoisted_11, [
                _hoisted_12,
                createVNode(_component_el_slider, {
                  label: "最大显示行数",
                  modelValue: unref(listStore).info.nowColumn,
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(listStore).info.nowColumn = $event),
                  min: 1,
                  max: 6,
                  step: 1,
                  placement: "right",
                  "show-stops": ""
                }, null, 8, ["modelValue"])
              ]),
              createVNode(_component_el_button_group, { class: "button-group" }, {
                default: withCtx(() => [
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: refresh,
                    loading: unref(loading).value
                  }, {
                    icon: withCtx(() => [
                      createVNode(_component_el_icon, null, {
                        default: withCtx(() => [
                          createVNode(_component_i_ep_RefreshRight)
                        ]),
                        _: 1
                      })
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" 刷新 ")
                    ]),
                    _: 1
                  }, 8, ["loading"]),
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: allSelectSwitch,
                    loading: unref(loading).value,
                    icon: unref(listStore).info.allSelected ? unref(CheckboxAll) : unref(CheckboxNone)
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(unref(listStore).info.allSelected ? "全选" : "取消全选"), 1)
                    ]),
                    _: 1
                  }, 8, ["loading", "icon"]),
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: downloadSelected,
                    loading: unref(loading).value
                  }, {
                    icon: withCtx(() => [
                      createVNode(_component_el_icon, null, {
                        default: withCtx(() => [
                          createVNode(_component_i_ep_Download)
                        ]),
                        _: 1
                      })
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" 下载选中 ")
                    ]),
                    _: 1
                  }, 8, ["loading"])
                ]),
                _: 1
              }),
              createVNode(_component_el_dropdown, null, {
                dropdown: withCtx(() => [
                  createVNode(_component_el_dropdown_menu, null, {
                    default: withCtx(() => [
                      createVNode(_component_el_dropdown_item, {
                        onClick: _cache[4] || (_cache[4] = ($event) => unref(ruleEditor).container.open = true)
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_icon, null, {
                            default: withCtx(() => [
                              createVNode(_component_i_ep_Management)
                            ]),
                            _: 1
                          }),
                          createTextVNode(" 规则管理 ")
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_dropdown_item, {
                        onClick: _cache[5] || (_cache[5] = () => {
                        })
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_icon, null, {
                            default: withCtx(() => [
                              createVNode(_component_i_ep_Tools)
                            ]),
                            _: 1
                          }),
                          createTextVNode(" 设置 ")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                default: withCtx(() => [
                  createVNode(_component_el_button, { type: "primary" }, {
                    icon: withCtx(() => [
                      createVNode(_component_el_icon, null, {
                        default: withCtx(() => [
                          createVNode(_component_i_ep_MoreFilled)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]);
          };
        }
      });
      const __unplugin_components_1 = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-07826213"]]);
      const _hoisted_1$1 = {
        class: "onlineGallery-body",
        ref: "body"
      };
      const _sfc_main$1 = /* @__PURE__ */ defineComponent({
        __name: "Body",
        setup(__props, { expose: __expose }) {
          const appInfo = useAppInfoStore();
          const cardsStore = useCardsStore();
          let toolbar = ref();
          const info = reactive({
            nowColumn: 4,
            allSelected: false
          });
          const data = cardsStore.data;
          const loading = appInfo.loading;
          let getCards = () => {
            toolbar.value.getCards();
          };
          __expose({
            data,
            info,
            loading,
            getCards
          });
          return (_ctx, _cache) => {
            const _component_el_progress = ElProgress;
            const _component_Toolbar = __unplugin_components_1;
            const _component_List = __unplugin_components_2;
            return openBlock(), createElementBlock("div", _hoisted_1$1, [
              withDirectives(createVNode(_component_el_progress, {
                class: "loadingBar",
                percentage: Math.round(unref(loading).percentage),
                status: unref(loading).state,
                striped: "",
                "striped-flow": ""
              }, null, 8, ["percentage", "status"]), [
                [vShow, unref(loading).show]
              ]),
              createVNode(_component_Toolbar, {
                ref_key: "toolbar",
                ref: toolbar,
                class: "toolBar"
              }, null, 512),
              createVNode(_component_List, {
                ref: "list",
                class: "listContainer"
              }, null, 512)
            ], 512);
          };
        }
      });
      const __unplugin_components_0 = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-d6047953"]]);
      const _hoisted_1 = ["data-open"];
      const _hoisted_2 = { class: "onlineGallery-child-window-container" };
      const _sfc_main = /* @__PURE__ */ defineComponent({
        __name: "App",
        setup(__props) {
          const appInfo = useAppInfoStore();
          const cardsStore = useCardsStore();
          const ruleEditor = useRuleEditorStore();
          const container = ref();
          const body = ref();
          const openSwitch = async () => {
            appInfo.container.open = !appInfo.container.open;
            if (appInfo.container.open) {
              document.documentElement.dataset.showScrollbar = false.toString();
              if (cardsStore.data.cardList.length < 1) {
                setTimeout(() => body.value.getCards(), 1e3);
              }
              container.value.focus();
            } else {
              document.documentElement.dataset.showScrollbar = true.toString();
            }
          };
          //! 挂载完成时执行
          onMounted(async () => {
            ElNotification({
              title: "提示",
              message: h("i", { style: "color: teal" }, "onlineGallery 已加载"),
              // type: "success",
              duration: 3e3
            });
            if (appInfo.container.open) {
              document.documentElement.dataset.showScrollbar = "false";
              container.value.focus();
            } else {
              document.documentElement.dataset.showScrollbar = "true";
            }
            setTimeout(() => body.value.getCards(), 1e3);
          });
          return (_ctx, _cache) => {
            const _component_Body = __unplugin_components_0;
            const _component_i_ep_Close = __unplugin_components_1$1;
            const _component_el_icon = ElIcon;
            const _component_el_button = ElButton;
            const _component_i_ep_ArrowRightBold = __unplugin_components_4;
            const _component_i_ep_Grid = __unplugin_components_5;
            const _component_el_badge = ElBadge;
            const _component_i_ep_Management = __unplugin_components_7;
            const _component_i_ep_Tools = __unplugin_components_8$1;
            const _component_el_popover = ElPopover;
            const _component_RuleEditor = _sfc_main$6;
            return openBlock(), createElementBlock(Fragment, null, [
              createBaseVNode("div", {
                class: "onlineGallery-container",
                ref_key: "container",
                ref: container,
                "data-open": unref(appInfo).container.open,
                style: normalizeStyle({
                  "--width": unref(appInfo).window.width * unref(appInfo).container.widthPercentage * 0.01 + "px"
                })
              }, [
                createVNode(_component_Body, {
                  ref_key: "body",
                  ref: body
                }, null, 512),
                createVNode(_component_el_button, {
                  class: "onlineGallery-button-close",
                  type: "danger",
                  circle: "",
                  onClick: openSwitch
                }, {
                  icon: withCtx(() => [
                    createVNode(_component_el_icon, null, {
                      default: withCtx(() => [
                        createVNode(_component_i_ep_Close)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(_component_el_popover, {
                  placement: "top-start",
                  title: "快捷菜单",
                  width: "auto",
                  trigger: "hover",
                  disabled: unref(appInfo).container.open
                }, {
                  reference: withCtx(() => [
                    createVNode(_component_el_button, {
                      type: "primary",
                      size: "default",
                      onClick: openSwitch,
                      class: "onlineGallery-button-drawerOpen"
                    }, {
                      icon: withCtx(() => [
                        createVNode(_component_el_icon, null, {
                          default: withCtx(() => [
                            createVNode(_component_i_ep_ArrowRightBold, { style: { "pointer-events": "none" } })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  default: withCtx(() => [
                    createVNode(_component_el_button, {
                      type: "success",
                      size: "small",
                      onClick: openSwitch
                    }, {
                      icon: withCtx(() => [
                        createVNode(_component_el_icon, null, {
                          default: withCtx(() => [
                            createVNode(_component_i_ep_Grid)
                          ]),
                          _: 1
                        })
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_el_badge, {
                          value: unref(cardsStore).data.cardList.length,
                          max: 999
                        }, {
                          default: withCtx(() => [
                            createTextVNode(" 图库 ")
                          ]),
                          _: 1
                        }, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_button, {
                      type: "primary",
                      size: "small",
                      onClick: _cache[0] || (_cache[0] = ($event) => unref(ruleEditor).container.open = true)
                    }, {
                      icon: withCtx(() => [
                        createVNode(_component_el_icon, null, {
                          default: withCtx(() => [
                            createVNode(_component_i_ep_Management)
                          ]),
                          _: 1
                        })
                      ]),
                      default: withCtx(() => [
                        createTextVNode(" 规则管理")
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_button, {
                      type: "primary",
                      size: "small",
                      onClick: _cache[1] || (_cache[1] = () => {
                      })
                    }, {
                      icon: withCtx(() => [
                        createVNode(_component_el_icon, null, {
                          default: withCtx(() => [
                            createVNode(_component_i_ep_Tools)
                          ]),
                          _: 1
                        })
                      ]),
                      default: withCtx(() => [
                        createTextVNode(" 设置 ")
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["disabled"])
              ], 12, _hoisted_1),
              createBaseVNode("div", _hoisted_2, [
                createVNode(_component_RuleEditor)
              ])
            ], 64);
          };
        }
      });
      const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-e88cacf6"]]);
      window["JSZip"] = JSZip$1;
      window["saveAs"] = FileSaver_minExports.saveAs;
      document.documentElement.dataset.showScrollbar = "true";
      const appDom = document.createElement("div");
      const id = `app_vue_${Date.now()}`;
      appDom.id = id;
      const pinia = createPinia();
      const app = createApp(App).use(pinia).use(vueTouchEvents);
      document.documentElement.append(appDom);
      app.mount(`#${id}`);
      console.log("挂载成功！", _unsafeWindow);
    }
  });
  require_main_001();

})(JSZip);
